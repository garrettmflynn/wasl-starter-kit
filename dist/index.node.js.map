{
  "version": 3,
  "sources": ["../../../node_modules/data-uri-to-buffer/src/index.ts", "../../../node_modules/web-streams-polyfill/src/stub/symbol.ts", "../../../node_modules/web-streams-polyfill/src/utils.ts", "../../../node_modules/web-streams-polyfill/src/lib/helpers/miscellaneous.ts", "../../../node_modules/web-streams-polyfill/src/lib/helpers/webidl.ts", "../../../node_modules/web-streams-polyfill/src/lib/simple-queue.ts", "../../../node_modules/web-streams-polyfill/src/lib/readable-stream/generic-reader.ts", "../../../node_modules/web-streams-polyfill/src/lib/abstract-ops/internal-methods.ts", "../../../node_modules/web-streams-polyfill/src/stub/number-isfinite.ts", "../../../node_modules/web-streams-polyfill/src/stub/math-trunc.ts", "../../../node_modules/web-streams-polyfill/src/lib/validators/basic.ts", "../../../node_modules/web-streams-polyfill/src/lib/validators/readable-stream.ts", "../../../node_modules/web-streams-polyfill/src/lib/readable-stream/default-reader.ts", "../../../node_modules/web-streams-polyfill/src/target/es2018/stub/async-iterator-prototype.ts", "../../../node_modules/web-streams-polyfill/src/lib/readable-stream/async-iterator.ts", "../../../node_modules/web-streams-polyfill/src/stub/number-isnan.ts", "../../../node_modules/web-streams-polyfill/src/lib/abstract-ops/ecmascript.ts", "../../../node_modules/web-streams-polyfill/src/lib/abstract-ops/miscellaneous.ts", "../../../node_modules/web-streams-polyfill/src/lib/abstract-ops/queue-with-sizes.ts", "../../../node_modules/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.ts", "../../../node_modules/web-streams-polyfill/src/lib/readable-stream/byob-reader.ts", "../../../node_modules/web-streams-polyfill/src/lib/abstract-ops/queuing-strategy.ts", "../../../node_modules/web-streams-polyfill/src/lib/validators/queuing-strategy.ts", "../../../node_modules/web-streams-polyfill/src/lib/validators/underlying-sink.ts", "../../../node_modules/web-streams-polyfill/src/lib/validators/writable-stream.ts", "../../../node_modules/web-streams-polyfill/src/lib/abort-signal.ts", "../../../node_modules/web-streams-polyfill/src/lib/writable-stream.ts", "../../../node_modules/web-streams-polyfill/src/stub/native.ts", "../../../node_modules/web-streams-polyfill/src/stub/dom-exception.ts", "../../../node_modules/web-streams-polyfill/src/lib/readable-stream/pipe.ts", "../../../node_modules/web-streams-polyfill/src/lib/readable-stream/default-controller.ts", "../../../node_modules/web-streams-polyfill/src/lib/readable-stream/tee.ts", "../../../node_modules/web-streams-polyfill/src/lib/validators/underlying-source.ts", "../../../node_modules/web-streams-polyfill/src/lib/validators/reader-options.ts", "../../../node_modules/web-streams-polyfill/src/lib/validators/iterator-options.ts", "../../../node_modules/web-streams-polyfill/src/lib/validators/pipe-options.ts", "../../../node_modules/web-streams-polyfill/src/lib/validators/readable-writable-pair.ts", "../../../node_modules/web-streams-polyfill/src/lib/readable-stream.ts", "../../../node_modules/web-streams-polyfill/src/lib/validators/queuing-strategy-init.ts", "../../../node_modules/web-streams-polyfill/src/lib/byte-length-queuing-strategy.ts", "../../../node_modules/web-streams-polyfill/src/lib/count-queuing-strategy.ts", "../../../node_modules/web-streams-polyfill/src/lib/validators/transformer.ts", "../../../node_modules/web-streams-polyfill/src/lib/transform-stream.ts", "../../../node_modules/fetch-blob/streams.cjs", "../../../node_modules/fetch-blob/index.js", "../../../node_modules/fetch-blob/file.js", "../../../node_modules/formdata-polyfill/esm.min.js", "../../../node_modules/node-fetch/src/errors/base.js", "../../../node_modules/node-fetch/src/errors/fetch-error.js", "../../../node_modules/node-fetch/src/utils/is.js", "../../../node_modules/node-domexception/index.js", "../../../node_modules/fetch-blob/from.js", "../../../node_modules/node-fetch/src/utils/multipart-parser.js", "../../../node_modules/node-fetch/src/body.js", "../../../node_modules/node-fetch/src/headers.js", "../../../node_modules/node-fetch/src/utils/is-redirect.js", "../../../node_modules/node-fetch/src/response.js", "../../../node_modules/node-fetch/src/utils/get-search.js", "../../../node_modules/node-fetch/src/utils/referrer.js", "../../../node_modules/node-fetch/src/request.js", "../../../node_modules/node-fetch/src/errors/abort-error.js", "../../../node_modules/node-fetch/src/index.js", "../../../node_modules/cross-blob/index.js", "../node_modules/data-uri-to-buffer/src/index.ts", "../node_modules/web-streams-polyfill/src/stub/symbol.ts", "../node_modules/web-streams-polyfill/src/utils.ts", "../node_modules/web-streams-polyfill/src/lib/helpers/miscellaneous.ts", "../node_modules/web-streams-polyfill/src/lib/helpers/webidl.ts", "../node_modules/web-streams-polyfill/src/lib/simple-queue.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream/generic-reader.ts", "../node_modules/web-streams-polyfill/src/lib/abstract-ops/internal-methods.ts", "../node_modules/web-streams-polyfill/src/stub/number-isfinite.ts", "../node_modules/web-streams-polyfill/src/stub/math-trunc.ts", "../node_modules/web-streams-polyfill/src/lib/validators/basic.ts", "../node_modules/web-streams-polyfill/src/lib/validators/readable-stream.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream/default-reader.ts", "../node_modules/web-streams-polyfill/src/target/es2018/stub/async-iterator-prototype.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream/async-iterator.ts", "../node_modules/web-streams-polyfill/src/stub/number-isnan.ts", "../node_modules/web-streams-polyfill/src/lib/abstract-ops/ecmascript.ts", "../node_modules/web-streams-polyfill/src/lib/abstract-ops/miscellaneous.ts", "../node_modules/web-streams-polyfill/src/lib/abstract-ops/queue-with-sizes.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream/byob-reader.ts", "../node_modules/web-streams-polyfill/src/lib/abstract-ops/queuing-strategy.ts", "../node_modules/web-streams-polyfill/src/lib/validators/queuing-strategy.ts", "../node_modules/web-streams-polyfill/src/lib/validators/underlying-sink.ts", "../node_modules/web-streams-polyfill/src/lib/validators/writable-stream.ts", "../node_modules/web-streams-polyfill/src/lib/abort-signal.ts", "../node_modules/web-streams-polyfill/src/lib/writable-stream.ts", "../node_modules/web-streams-polyfill/src/stub/native.ts", "../node_modules/web-streams-polyfill/src/stub/dom-exception.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream/pipe.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream/default-controller.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream/tee.ts", "../node_modules/web-streams-polyfill/src/lib/validators/underlying-source.ts", "../node_modules/web-streams-polyfill/src/lib/validators/reader-options.ts", "../node_modules/web-streams-polyfill/src/lib/validators/iterator-options.ts", "../node_modules/web-streams-polyfill/src/lib/validators/pipe-options.ts", "../node_modules/web-streams-polyfill/src/lib/validators/readable-writable-pair.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream.ts", "../node_modules/web-streams-polyfill/src/lib/validators/queuing-strategy-init.ts", "../node_modules/web-streams-polyfill/src/lib/byte-length-queuing-strategy.ts", "../node_modules/web-streams-polyfill/src/lib/count-queuing-strategy.ts", "../node_modules/web-streams-polyfill/src/lib/validators/transformer.ts", "../node_modules/web-streams-polyfill/src/lib/transform-stream.ts", "../node_modules/fetch-blob/streams.cjs", "../node_modules/fetch-blob/index.js", "../node_modules/fetch-blob/file.js", "../node_modules/formdata-polyfill/esm.min.js", "../node_modules/node-fetch/src/errors/base.js", "../node_modules/node-fetch/src/errors/fetch-error.js", "../node_modules/node-fetch/src/utils/is.js", "../node_modules/node-domexception/index.js", "../node_modules/fetch-blob/from.js", "../node_modules/node-fetch/src/utils/multipart-parser.js", "../node_modules/node-fetch/src/body.js", "../node_modules/node-fetch/src/headers.js", "../node_modules/node-fetch/src/utils/is-redirect.js", "../node_modules/node-fetch/src/response.js", "../node_modules/node-fetch/src/utils/get-search.js", "../node_modules/node-fetch/src/utils/referrer.js", "../node_modules/node-fetch/src/request.js", "../node_modules/node-fetch/src/errors/abort-error.js", "../node_modules/node-fetch/src/index.js", "../node_modules/cross-blob/index.js", "../index.ts", "../../common/utils/languages.ts", "../../common/utils/path.ts", "../../../node_modules/remote-esm/utils/path.js", "../../../node_modules/remote-esm/utils/request.js", "../../../node_modules/remote-esm/index.js", "../../common/get.ts", "../../common/utils/check.ts", "../utils.ts", "../node_modules/remote-esm/utils/path.js", "../node_modules/remote-esm/index.js", "../node_modules/es-plugins/dist/index.esm.js"],
  "sourcesContent": [null, "/// <reference lib=\"es2015.symbol\" />\n\nconst SymbolPolyfill: (description?: string) => symbol =\n  typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n    Symbol :\n    description => `Symbol(${description})` as any as symbol;\n\nexport default SymbolPolyfill;\n", "/// <reference lib=\"dom\" />\n\nexport function noop(): undefined {\n  return undefined;\n}\n\nfunction getGlobals() {\n  if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n", "import { noop } from '../../utils';\nimport { AssertionError } from '../../stub/assert';\n\nexport function typeIsObject(x: any): x is object {\n  return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\n\nexport const rethrowAssertionErrorRejection: (e: any) => void =\n  DEBUG ? e => {\n    // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\n    // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\n    // expect any errors, but assertion errors are always problematic.\n    if (e && e instanceof AssertionError) {\n      setTimeout(() => {\n        throw e;\n      }, 0);\n    }\n  } : noop;\n", "import { globals } from '../../utils';\nimport { rethrowAssertionErrorRejection } from './miscellaneous';\nimport assert from '../../stub/assert';\n\nconst originalPromise = Promise;\nconst originalPromiseThen = Promise.prototype.then;\nconst originalPromiseResolve = Promise.resolve.bind(originalPromise);\nconst originalPromiseReject = Promise.reject.bind(originalPromise);\n\nexport function newPromise<T>(executor: (\n  resolve: (value: T | PromiseLike<T>) => void,\n  reject: (reason?: any) => void\n) => void): Promise<T> {\n  return new originalPromise(executor);\n}\n\nexport function promiseResolvedWith<T>(value: T | PromiseLike<T>): Promise<T> {\n  return originalPromiseResolve(value);\n}\n\nexport function promiseRejectedWith<T = never>(reason: any): Promise<T> {\n  return originalPromiseReject(reason);\n}\n\nexport function PerformPromiseThen<T, TResult1 = T, TResult2 = never>(\n  promise: Promise<T>,\n  onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,\n  onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\n  // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n  // approximation.\n  return originalPromiseThen.call(promise, onFulfilled, onRejected) as Promise<TResult1 | TResult2>;\n}\n\nexport function uponPromise<T>(\n  promise: Promise<T>,\n  onFulfilled?: (value: T) => void | PromiseLike<void>,\n  onRejected?: (reason: any) => void | PromiseLike<void>): void {\n  PerformPromiseThen(\n    PerformPromiseThen(promise, onFulfilled, onRejected),\n    undefined,\n    rethrowAssertionErrorRejection\n  );\n}\n\nexport function uponFulfillment<T>(promise: Promise<T>, onFulfilled: (value: T) => void | PromiseLike<void>): void {\n  uponPromise(promise, onFulfilled);\n}\n\nexport function uponRejection(promise: Promise<unknown>, onRejected: (reason: any) => void | PromiseLike<void>): void {\n  uponPromise(promise, undefined, onRejected);\n}\n\nexport function transformPromiseWith<T, TResult1 = T, TResult2 = never>(\n  promise: Promise<T>,\n  fulfillmentHandler?: (value: T) => TResult1 | PromiseLike<TResult1>,\n  rejectionHandler?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\n  return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n}\n\nexport function setPromiseIsHandledToTrue(promise: Promise<unknown>): void {\n  PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n}\n\nexport const queueMicrotask: (fn: () => void) => void = (() => {\n  const globalQueueMicrotask = globals && globals.queueMicrotask;\n  if (typeof globalQueueMicrotask === 'function') {\n    return globalQueueMicrotask;\n  }\n\n  const resolvedPromise = promiseResolvedWith(undefined);\n  return (fn: () => void) => PerformPromiseThen(resolvedPromise, fn);\n})();\n\nexport function reflectCall<T, A extends any[], R>(F: (this: T, ...fnArgs: A) => R, V: T, args: A): R {\n  if (typeof F !== 'function') {\n    throw new TypeError('Argument is not a function');\n  }\n  return Function.prototype.apply.call(F, V, args);\n}\n\nexport function promiseCall<T, A extends any[], R>(F: (this: T, ...fnArgs: A) => R | PromiseLike<R>,\n                                                   V: T,\n                                                   args: A): Promise<R> {\n  assert(typeof F === 'function');\n  assert(V !== undefined);\n  assert(Array.isArray(args));\n  try {\n    return promiseResolvedWith(reflectCall(F, V, args));\n  } catch (value) {\n    return promiseRejectedWith(value);\n  }\n}\n", "import assert from '../stub/assert';\n\n// Original from Chromium\n// https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n\nconst QUEUE_MAX_ARRAY_SIZE = 16384;\n\ninterface Node<T> {\n  _elements: T[];\n  _next: Node<T> | undefined;\n}\n\n/**\n * Simple queue structure.\n *\n * Avoids scalability issues with using a packed array directly by using\n * multiple arrays in a linked list and keeping the array size bounded.\n */\nexport class SimpleQueue<T> {\n  private _front: Node<T>;\n  private _back: Node<T>;\n  private _cursor = 0;\n  private _size = 0;\n\n  constructor() {\n    // _front and _back are always defined.\n    this._front = {\n      _elements: [],\n      _next: undefined\n    };\n    this._back = this._front;\n    // The cursor is used to avoid calling Array.shift().\n    // It contains the index of the front element of the array inside the\n    // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n    this._cursor = 0;\n    // When there is only one node, size === elements.length - cursor.\n    this._size = 0;\n  }\n\n  get length(): number {\n    return this._size;\n  }\n\n  // For exception safety, this method is structured in order:\n  // 1. Read state\n  // 2. Calculate required state mutations\n  // 3. Perform state mutations\n  push(element: T): void {\n    const oldBack = this._back;\n    let newBack = oldBack;\n    assert(oldBack._next === undefined);\n    if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n      newBack = {\n        _elements: [],\n        _next: undefined\n      };\n    }\n\n    // push() is the mutation most likely to throw an exception, so it\n    // goes first.\n    oldBack._elements.push(element);\n    if (newBack !== oldBack) {\n      this._back = newBack;\n      oldBack._next = newBack;\n    }\n    ++this._size;\n  }\n\n  // Like push(), shift() follows the read -> calculate -> mutate pattern for\n  // exception safety.\n  shift(): T {\n    assert(this._size > 0); // must not be called on an empty queue\n\n    const oldFront = this._front;\n    let newFront = oldFront;\n    const oldCursor = this._cursor;\n    let newCursor = oldCursor + 1;\n\n    const elements = oldFront._elements;\n    const element = elements[oldCursor];\n\n    if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n      assert(elements.length === QUEUE_MAX_ARRAY_SIZE);\n      assert(oldFront._next !== undefined);\n      newFront = oldFront._next!;\n      newCursor = 0;\n    }\n\n    // No mutations before this point.\n    --this._size;\n    this._cursor = newCursor;\n    if (oldFront !== newFront) {\n      this._front = newFront;\n    }\n\n    // Permit shifted element to be garbage collected.\n    elements[oldCursor] = undefined!;\n\n    return element;\n  }\n\n  // The tricky thing about forEach() is that it can be called\n  // re-entrantly. The queue may be mutated inside the callback. It is easy to\n  // see that push() within the callback has no negative effects since the end\n  // of the queue is checked for on every iteration. If shift() is called\n  // repeatedly within the callback then the next iteration may return an\n  // element that has been removed. In this case the callback will be called\n  // with undefined values until we either \"catch up\" with elements that still\n  // exist or reach the back of the queue.\n  forEach(callback: (element: T) => void): void {\n    let i = this._cursor;\n    let node = this._front;\n    let elements = node._elements;\n    while (i !== elements.length || node._next !== undefined) {\n      if (i === elements.length) {\n        assert(node._next !== undefined);\n        assert(i === QUEUE_MAX_ARRAY_SIZE);\n        node = node._next!;\n        elements = node._elements;\n        i = 0;\n        if (elements.length === 0) {\n          break;\n        }\n      }\n      callback(elements[i]);\n      ++i;\n    }\n  }\n\n  // Return the element that would be returned if shift() was called now,\n  // without modifying the queue.\n  peek(): T {\n    assert(this._size > 0); // must not be called on an empty queue\n\n    const front = this._front;\n    const cursor = this._cursor;\n    return front._elements[cursor];\n  }\n}\n", "import assert from '../../stub/assert';\nimport { ReadableStream, ReadableStreamCancel, ReadableStreamReader } from '../readable-stream';\nimport { newPromise, setPromiseIsHandledToTrue } from '../helpers/webidl';\n\nexport function ReadableStreamReaderGenericInitialize<R>(reader: ReadableStreamReader<R>, stream: ReadableStream<R>) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    assert(stream._state === 'errored');\n\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n  }\n}\n\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\nexport function ReadableStreamReaderGenericCancel(reader: ReadableStreamReader<any>, reason: any): Promise<undefined> {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  return ReadableStreamCancel(stream, reason);\n}\n\nexport function ReadableStreamReaderGenericRelease(reader: ReadableStreamReader<any>) {\n  assert(reader._ownerReadableStream !== undefined);\n  assert(reader._ownerReadableStream._reader === reader);\n\n  if (reader._ownerReadableStream._state === 'readable') {\n    defaultReaderClosedPromiseReject(\n      reader,\n      new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(\n      reader,\n      new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  }\n\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined!;\n}\n\n// Helper functions for the readers.\n\nexport function readerLockException(name: string): TypeError {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nexport function defaultReaderClosedPromiseInitialize(reader: ReadableStreamReader<any>) {\n  reader._closedPromise = newPromise((resolve, reject) => {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nexport function defaultReaderClosedPromiseInitializeAsRejected(reader: ReadableStreamReader<any>, reason: any) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseReject(reader, reason);\n}\n\nexport function defaultReaderClosedPromiseInitializeAsResolved(reader: ReadableStreamReader<any>) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseResolve(reader);\n}\n\nexport function defaultReaderClosedPromiseReject(reader: ReadableStreamReader<any>, reason: any) {\n  if (reader._closedPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(reader._closedPromise);\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nexport function defaultReaderClosedPromiseResetToRejected(reader: ReadableStreamReader<any>, reason: any) {\n  assert(reader._closedPromise_resolve === undefined);\n  assert(reader._closedPromise_reject === undefined);\n\n  defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n}\n\nexport function defaultReaderClosedPromiseResolve(reader: ReadableStreamReader<any>) {\n  if (reader._closedPromise_resolve === undefined) {\n    return;\n  }\n\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n", "export const AbortSteps = Symbol('[[AbortSteps]]');\nexport const ErrorSteps = Symbol('[[ErrorSteps]]');\nexport const CancelSteps = Symbol('[[CancelSteps]]');\nexport const PullSteps = Symbol('[[PullSteps]]');\n", "/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\nconst NumberIsFinite: typeof Number.isFinite = Number.isFinite || function (x) {\n  return typeof x === 'number' && isFinite(x);\n};\n\nexport default NumberIsFinite;\n", "/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\nconst MathTrunc: typeof Math.trunc = Math.trunc || function (v) {\n  return v < 0 ? Math.ceil(v) : Math.floor(v);\n};\n\nexport default MathTrunc;\n", "import NumberIsFinite from '../../stub/number-isfinite';\nimport MathTrunc from '../../stub/math-trunc';\n\n// https://heycam.github.io/webidl/#idl-dictionaries\nexport function isDictionary(x: any): x is object | null {\n  return typeof x === 'object' || typeof x === 'function';\n}\n\nexport function assertDictionary(obj: unknown,\n                                 context: string): asserts obj is object | null | undefined {\n  if (obj !== undefined && !isDictionary(obj)) {\n    throw new TypeError(`${context} is not an object.`);\n  }\n}\n\nexport type AnyFunction = (...args: any[]) => any;\n\n// https://heycam.github.io/webidl/#idl-callback-functions\nexport function assertFunction(x: unknown, context: string): asserts x is AnyFunction {\n  if (typeof x !== 'function') {\n    throw new TypeError(`${context} is not a function.`);\n  }\n}\n\n// https://heycam.github.io/webidl/#idl-object\nexport function isObject(x: any): x is object {\n  return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\n\nexport function assertObject(x: unknown,\n                             context: string): asserts x is object {\n  if (!isObject(x)) {\n    throw new TypeError(`${context} is not an object.`);\n  }\n}\n\nexport function assertRequiredArgument<T extends any>(x: T | undefined,\n                                                      position: number,\n                                                      context: string): asserts x is T {\n  if (x === undefined) {\n    throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n  }\n}\n\nexport function assertRequiredField<T extends any>(x: T | undefined,\n                                                   field: string,\n                                                   context: string): asserts x is T {\n  if (x === undefined) {\n    throw new TypeError(`${field} is required in '${context}'.`);\n  }\n}\n\n// https://heycam.github.io/webidl/#idl-unrestricted-double\nexport function convertUnrestrictedDouble(value: unknown): number {\n  return Number(value);\n}\n\nfunction censorNegativeZero(x: number): number {\n  return x === 0 ? 0 : x;\n}\n\nfunction integerPart(x: number): number {\n  return censorNegativeZero(MathTrunc(x));\n}\n\n// https://heycam.github.io/webidl/#idl-unsigned-long-long\nexport function convertUnsignedLongLongWithEnforceRange(value: unknown, context: string): number {\n  const lowerBound = 0;\n  const upperBound = Number.MAX_SAFE_INTEGER;\n\n  let x = Number(value);\n  x = censorNegativeZero(x);\n\n  if (!NumberIsFinite(x)) {\n    throw new TypeError(`${context} is not a finite number`);\n  }\n\n  x = integerPart(x);\n\n  if (x < lowerBound || x > upperBound) {\n    throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n  }\n\n  if (!NumberIsFinite(x) || x === 0) {\n    return 0;\n  }\n\n  // TODO Use BigInt if supported?\n  // let xBigInt = BigInt(integerPart(x));\n  // xBigInt = BigInt.asUintN(64, xBigInt);\n  // return Number(xBigInt);\n\n  return x;\n}\n", "import { IsReadableStream, ReadableStream } from '../readable-stream';\n\nexport function assertReadableStream(x: unknown, context: string): asserts x is ReadableStream {\n  if (!IsReadableStream(x)) {\n    throw new TypeError(`${context} is not a ReadableStream.`);\n  }\n}\n", "import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericInitialize,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport { IsReadableStreamLocked, ReadableStream } from '../readable-stream';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport { PullSteps } from '../abstract-ops/internal-methods';\nimport { newPromise, promiseRejectedWith } from '../helpers/webidl';\nimport { assertRequiredArgument } from '../validators/basic';\nimport { assertReadableStream } from '../validators/readable-stream';\n\n/**\n * A result returned by {@link ReadableStreamDefaultReader.read}.\n *\n * @public\n */\nexport type ReadableStreamDefaultReadResult<T> = {\n  done: false;\n  value: T;\n} | {\n  done: true;\n  value?: undefined;\n}\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamDefaultReader<R>(stream: ReadableStream): ReadableStreamDefaultReader<R> {\n  return new ReadableStreamDefaultReader(stream);\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamAddReadRequest<R>(stream: ReadableStream<R>,\n                                                readRequest: ReadRequest<R>): void {\n  assert(IsReadableStreamDefaultReader(stream._reader));\n  assert(stream._state === 'readable');\n\n  (stream._reader! as ReadableStreamDefaultReader<R>)._readRequests.push(readRequest);\n}\n\nexport function ReadableStreamFulfillReadRequest<R>(stream: ReadableStream<R>, chunk: R | undefined, done: boolean) {\n  const reader = stream._reader as ReadableStreamDefaultReader<R>;\n\n  assert(reader._readRequests.length > 0);\n\n  const readRequest = reader._readRequests.shift()!;\n  if (done) {\n    readRequest._closeSteps();\n  } else {\n    readRequest._chunkSteps(chunk!);\n  }\n}\n\nexport function ReadableStreamGetNumReadRequests<R>(stream: ReadableStream<R>): number {\n  return (stream._reader as ReadableStreamDefaultReader<R>)._readRequests.length;\n}\n\nexport function ReadableStreamHasDefaultReader(stream: ReadableStream): boolean {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (!IsReadableStreamDefaultReader(reader)) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nexport interface ReadRequest<R> {\n  _chunkSteps(chunk: R): void;\n\n  _closeSteps(): void;\n\n  _errorSteps(e: any): void;\n}\n\n/**\n * A default reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nexport class ReadableStreamDefaultReader<R = any> {\n  /** @internal */\n  _ownerReadableStream!: ReadableStream<R>;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readRequests: SimpleQueue<ReadRequest<R>>;\n\n  constructor(stream: ReadableStream<R>) {\n    assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n    assertReadableStream(stream, 'First parameter');\n\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readRequests = new SimpleQueue();\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed,\n   * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  /**\n   * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n   *\n   * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   */\n  read(): Promise<ReadableStreamDefaultReadResult<R>> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('read from'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamDefaultReadResult<R>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamDefaultReadResult<R>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n      _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n      _errorSteps: e => rejectPromise(e)\n    };\n    ReadableStreamDefaultReaderRead(this, readRequest);\n    return promise;\n  }\n\n  /**\n   * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n   * from now on; otherwise, the reader will appear closed.\n   *\n   * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n   * do so will throw a `TypeError` and leave the reader locked to the stream.\n   */\n  releaseLock(): void {\n    if (!IsReadableStreamDefaultReader(this)) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\nObject.defineProperties(ReadableStreamDefaultReader.prototype, {\n  cancel: { enumerable: true },\n  read: { enumerable: true },\n  releaseLock: { enumerable: true },\n  closed: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamDefaultReader',\n    configurable: true\n  });\n}\n\n// Abstract operations for the readers.\n\nexport function IsReadableStreamDefaultReader<R = any>(x: any): x is ReadableStreamDefaultReader<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamDefaultReader;\n}\n\nexport function ReadableStreamDefaultReaderRead<R>(reader: ReadableStreamDefaultReader<R>,\n                                                   readRequest: ReadRequest<R>): void {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    readRequest._closeSteps();\n  } else if (stream._state === 'errored') {\n    readRequest._errorSteps(stream._storedError);\n  } else {\n    assert(stream._state === 'readable');\n    stream._readableStreamController[PullSteps](readRequest as ReadRequest<any>);\n  }\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction defaultReaderBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n", "/// <reference lib=\"es2018.asynciterable\" />\n\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport const AsyncIteratorPrototype: AsyncIterable<any> | undefined =\n  Object.getPrototypeOf(Object.getPrototypeOf(async function* (): AsyncIterableIterator<any> {}).prototype);\n", "/// <reference lib=\"es2018.asynciterable\" />\n\nimport { ReadableStream } from '../readable-stream';\nimport {\n  AcquireReadableStreamDefaultReader,\n  ReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderRead,\n  ReadableStreamDefaultReadResult,\n  ReadRequest\n} from './default-reader';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport assert from '../../stub/assert';\nimport { AsyncIteratorPrototype } from '@@target/stub/async-iterator-prototype';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  queueMicrotask,\n  transformPromiseWith\n} from '../helpers/webidl';\n\n/**\n * An async iterator returned by {@link ReadableStream.values}.\n *\n * @public\n */\nexport interface ReadableStreamAsyncIterator<R> extends AsyncIterator<R> {\n  next(): Promise<IteratorResult<R, undefined>>;\n\n  return(value?: any): Promise<IteratorResult<any>>;\n}\n\nexport class ReadableStreamAsyncIteratorImpl<R> {\n  private readonly _reader: ReadableStreamDefaultReader<R>;\n  private readonly _preventCancel: boolean;\n  private _ongoingPromise: Promise<ReadableStreamDefaultReadResult<R>> | undefined = undefined;\n  private _isFinished = false;\n\n  constructor(reader: ReadableStreamDefaultReader<R>, preventCancel: boolean) {\n    this._reader = reader;\n    this._preventCancel = preventCancel;\n  }\n\n  next(): Promise<ReadableStreamDefaultReadResult<R>> {\n    const nextSteps = () => this._nextSteps();\n    this._ongoingPromise = this._ongoingPromise ?\n      transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :\n      nextSteps();\n    return this._ongoingPromise;\n  }\n\n  return(value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    const returnSteps = () => this._returnSteps(value);\n    return this._ongoingPromise ?\n      transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :\n      returnSteps();\n  }\n\n  private _nextSteps(): Promise<ReadableStreamDefaultReadResult<R>> {\n    if (this._isFinished) {\n      return Promise.resolve({ value: undefined, done: true });\n    }\n\n    const reader = this._reader;\n    if (reader._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('iterate'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamDefaultReadResult<R>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamDefaultReadResult<R>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => {\n        this._ongoingPromise = undefined;\n        // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n        // FIXME Is this a bug in the specification, or in the test?\n        queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n      },\n      _closeSteps: () => {\n        this._ongoingPromise = undefined;\n        this._isFinished = true;\n        ReadableStreamReaderGenericRelease(reader);\n        resolvePromise({ value: undefined, done: true });\n      },\n      _errorSteps: reason => {\n        this._ongoingPromise = undefined;\n        this._isFinished = true;\n        ReadableStreamReaderGenericRelease(reader);\n        rejectPromise(reason);\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n    return promise;\n  }\n\n  private _returnSteps(value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (this._isFinished) {\n      return Promise.resolve({ value, done: true });\n    }\n    this._isFinished = true;\n\n    const reader = this._reader;\n    if (reader._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('finish iterating'));\n    }\n\n    assert(reader._readRequests.length === 0);\n\n    if (!this._preventCancel) {\n      const result = ReadableStreamReaderGenericCancel(reader, value);\n      ReadableStreamReaderGenericRelease(reader);\n      return transformPromiseWith(result, () => ({ value, done: true }));\n    }\n\n    ReadableStreamReaderGenericRelease(reader);\n    return promiseResolvedWith({ value, done: true });\n  }\n}\n\ndeclare class ReadableStreamAsyncIteratorInstance<R> implements ReadableStreamAsyncIterator<R> {\n  /** @interal */\n  _asyncIteratorImpl: ReadableStreamAsyncIteratorImpl<R>;\n\n  next(): Promise<IteratorResult<R, undefined>>;\n\n  return(value?: any): Promise<IteratorResult<any>>;\n}\n\nconst ReadableStreamAsyncIteratorPrototype: ReadableStreamAsyncIteratorInstance<any> = {\n  next(this: ReadableStreamAsyncIteratorInstance<any>): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (!IsReadableStreamAsyncIterator(this)) {\n      return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n    }\n    return this._asyncIteratorImpl.next();\n  },\n\n  return(this: ReadableStreamAsyncIteratorInstance<any>, value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (!IsReadableStreamAsyncIterator(this)) {\n      return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n    }\n    return this._asyncIteratorImpl.return(value);\n  }\n} as any;\nif (AsyncIteratorPrototype !== undefined) {\n  Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n}\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamAsyncIterator<R>(stream: ReadableStream<R>,\n                                                      preventCancel: boolean): ReadableStreamAsyncIterator<R> {\n  const reader = AcquireReadableStreamDefaultReader<R>(stream);\n  const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n  const iterator: ReadableStreamAsyncIteratorInstance<R> = Object.create(ReadableStreamAsyncIteratorPrototype);\n  iterator._asyncIteratorImpl = impl;\n  return iterator;\n}\n\nfunction IsReadableStreamAsyncIterator<R = any>(x: any): x is ReadableStreamAsyncIterator<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n    return false;\n  }\n\n  try {\n    // noinspection SuspiciousTypeOfGuard\n    return (x as ReadableStreamAsyncIteratorInstance<any>)._asyncIteratorImpl instanceof\n      ReadableStreamAsyncIteratorImpl;\n  } catch {\n    return false;\n  }\n}\n\n// Helper functions for the ReadableStream.\n\nfunction streamAsyncIteratorBrandCheckException(name: string): TypeError {\n  return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n}\n", "/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN: typeof Number.isNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nexport default NumberIsNaN;\n", "export function CreateArrayFromList<T extends any[]>(elements: T): T {\n  // We use arrays to represent lists, so this is basically a no-op.\n  // Do a slice though just in case we happen to depend on the unique-ness.\n  return elements.slice() as T;\n}\n\nexport function CopyDataBlockBytes(dest: ArrayBuffer,\n                                   destOffset: number,\n                                   src: ArrayBuffer,\n                                   srcOffset: number,\n                                   n: number) {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n}\n\n// Not implemented correctly\nexport function TransferArrayBuffer<T extends ArrayBufferLike>(O: T): T {\n  return O;\n}\n\n// Not implemented correctly\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function CanTransferArrayBuffer(O: ArrayBufferLike): boolean {\n  return true;\n}\n\n// Not implemented correctly\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function IsDetachedBuffer(O: ArrayBufferLike): boolean {\n  return false;\n}\n\nexport function ArrayBufferSlice(buffer: ArrayBufferLike, begin: number, end: number): ArrayBufferLike {\n  // ArrayBuffer.prototype.slice is not available on IE10\n  // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n  if (buffer.slice) {\n    return buffer.slice(begin, end);\n  }\n  const length = end - begin;\n  const slice = new ArrayBuffer(length);\n  CopyDataBlockBytes(slice, 0, buffer, begin, length);\n  return slice;\n}\n", "import NumberIsNaN from '../../stub/number-isnan';\nimport { ArrayBufferSlice } from './ecmascript';\n\nexport function IsNonNegativeNumber(v: number): boolean {\n  if (typeof v !== 'number') {\n    return false;\n  }\n\n  if (NumberIsNaN(v)) {\n    return false;\n  }\n\n  if (v < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function CloneAsUint8Array(O: ArrayBufferView): Uint8Array {\n  const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n  return new Uint8Array(buffer);\n}\n", "import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport { IsNonNegativeNumber } from './miscellaneous';\n\nexport interface QueueContainer<T> {\n  _queue: SimpleQueue<T>;\n  _queueTotalSize: number;\n}\n\nexport interface QueuePair<T> {\n  value: T;\n  size: number;\n}\n\nexport function DequeueValue<T>(container: QueueContainer<QueuePair<T>>): T {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.shift()!;\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n\n  return pair.value;\n}\n\nexport function EnqueueValueWithSize<T>(container: QueueContainer<QueuePair<T>>, value: T, size: number) {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  if (!IsNonNegativeNumber(size) || size === Infinity) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  container._queue.push({ value, size });\n  container._queueTotalSize += size;\n}\n\nexport function PeekQueueValue<T>(container: QueueContainer<QueuePair<T>>): T {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.peek();\n  return pair.value;\n}\n\nexport function ResetQueue<T>(container: QueueContainer<T>) {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  container._queue = new SimpleQueue<T>();\n  container._queueTotalSize = 0;\n}\n", "import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport { ResetQueue } from '../abstract-ops/queue-with-sizes';\nimport {\n  ReadableStreamAddReadRequest,\n  ReadableStreamFulfillReadRequest,\n  ReadableStreamGetNumReadRequests,\n  ReadableStreamHasDefaultReader,\n  ReadRequest\n} from './default-reader';\nimport {\n  ReadableStreamAddReadIntoRequest,\n  ReadableStreamFulfillReadIntoRequest,\n  ReadableStreamGetNumReadIntoRequests,\n  ReadableStreamHasBYOBReader,\n  ReadIntoRequest\n} from './byob-reader';\nimport NumberIsInteger from '../../stub/number-isinteger';\nimport {\n  IsReadableStreamLocked,\n  ReadableByteStream,\n  ReadableStreamClose,\n  ReadableStreamError\n} from '../readable-stream';\nimport { ValidatedUnderlyingByteSource } from './underlying-source';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport {\n  ArrayBufferSlice,\n  CanTransferArrayBuffer,\n  CopyDataBlockBytes,\n  IsDetachedBuffer,\n  TransferArrayBuffer\n} from '../abstract-ops/ecmascript';\nimport { CancelSteps, PullSteps } from '../abstract-ops/internal-methods';\nimport { promiseResolvedWith, uponPromise } from '../helpers/webidl';\nimport { assertRequiredArgument, convertUnsignedLongLongWithEnforceRange } from '../validators/basic';\n\n/**\n * A pull-into request in a {@link ReadableByteStreamController}.\n *\n * @public\n */\nexport class ReadableStreamBYOBRequest {\n  /** @internal */\n  _associatedReadableByteStreamController!: ReadableByteStreamController;\n  /** @internal */\n  _view!: ArrayBufferView | null;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n   */\n  get view(): ArrayBufferView | null {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('view');\n    }\n\n    return this._view;\n  }\n\n  /**\n   * Indicates to the associated readable byte stream that `bytesWritten` bytes were written into\n   * {@link ReadableStreamBYOBRequest.view | view}, causing the result be surfaced to the consumer.\n   *\n   * After this method is called, {@link ReadableStreamBYOBRequest.view | view} will be transferred and no longer\n   * modifiable.\n   */\n  respond(bytesWritten: number): void;\n  respond(bytesWritten: number | undefined): void {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('respond');\n    }\n    assertRequiredArgument(bytesWritten, 1, 'respond');\n    bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(this._view!.buffer)) {\n      throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);\n    }\n\n    assert(this._view!.byteLength > 0);\n    assert(this._view!.buffer.byteLength > 0);\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  }\n\n  /**\n   * Indicates to the associated readable byte stream that instead of writing into\n   * {@link ReadableStreamBYOBRequest.view | view}, the underlying byte source is providing a new `ArrayBufferView`,\n   * which will be given to the consumer of the readable byte stream.\n   *\n   * After this method is called, `view` will be transferred and no longer modifiable.\n   */\n  respondWithNewView(view: ArrayBufferView): void;\n  respondWithNewView(view: ArrayBufferView | undefined): void {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('respondWithNewView');\n    }\n    assertRequiredArgument(view, 1, 'respondWithNewView');\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(view.buffer)) {\n      throw new TypeError('The given view\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  }\n}\n\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, {\n  respond: { enumerable: true },\n  respondWithNewView: { enumerable: true },\n  view: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamBYOBRequest',\n    configurable: true\n  });\n}\n\ninterface ArrayBufferViewConstructor<T extends ArrayBufferView = ArrayBufferView> {\n  new(buffer: ArrayBufferLike, byteOffset: number, length?: number): T;\n\n  readonly prototype: T;\n  readonly BYTES_PER_ELEMENT: number;\n}\n\ninterface ByteQueueElement {\n  buffer: ArrayBufferLike;\n  byteOffset: number;\n  byteLength: number;\n}\n\ntype PullIntoDescriptor<T extends ArrayBufferView = ArrayBufferView> =\n  DefaultPullIntoDescriptor\n  | BYOBPullIntoDescriptor<T>;\n\ninterface DefaultPullIntoDescriptor {\n  buffer: ArrayBufferLike;\n  bufferByteLength: number;\n  byteOffset: number;\n  byteLength: number;\n  bytesFilled: number;\n  elementSize: number;\n  viewConstructor: ArrayBufferViewConstructor<Uint8Array>;\n  readerType: 'default';\n}\n\ninterface BYOBPullIntoDescriptor<T extends ArrayBufferView = ArrayBufferView> {\n  buffer: ArrayBufferLike;\n  bufferByteLength: number;\n  byteOffset: number;\n  byteLength: number;\n  bytesFilled: number;\n  elementSize: number;\n  viewConstructor: ArrayBufferViewConstructor<T>;\n  readerType: 'byob';\n}\n\n/**\n * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n *\n * @public\n */\nexport class ReadableByteStreamController {\n  /** @internal */\n  _controlledReadableByteStream!: ReadableByteStream;\n  /** @internal */\n  _queue!: SimpleQueue<ByteQueueElement>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _closeRequested!: boolean;\n  /** @internal */\n  _pullAgain!: boolean;\n  /** @internal */\n  _pulling !: boolean;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _pullAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm!: (reason: any) => Promise<void>;\n  /** @internal */\n  _autoAllocateChunkSize: number | undefined;\n  /** @internal */\n  _byobRequest: ReadableStreamBYOBRequest | null;\n  /** @internal */\n  _pendingPullIntos!: SimpleQueue<PullIntoDescriptor>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the current BYOB pull request, or `null` if there isn't one.\n   */\n  get byobRequest(): ReadableStreamBYOBRequest | null {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n\n    return ReadableByteStreamControllerGetBYOBRequest(this);\n  }\n\n  /**\n   * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n   * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n   */\n  get desiredSize(): number | null {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n\n  /**\n   * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   * the stream, but once those are read, the stream will become closed.\n   */\n  close(): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableByteStreamControllerClose(this);\n  }\n\n  /**\n   * Enqueues the given chunk chunk in the controlled readable stream.\n   * The chunk has to be an `ArrayBufferView` instance, or else a `TypeError` will be thrown.\n   */\n  enqueue(chunk: ArrayBufferView): void;\n  enqueue(chunk: ArrayBufferView | undefined): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    assertRequiredArgument(chunk, 1, 'enqueue');\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('chunk must be an array buffer view');\n    }\n    if (chunk.byteLength === 0) {\n      throw new TypeError('chunk must have non-zero byteLength');\n    }\n    if (chunk.buffer.byteLength === 0) {\n      throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n    }\n\n    if (this._closeRequested) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   */\n  error(e: any = undefined): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  }\n\n  /** @internal */\n  [CancelSteps](reason: any): Promise<void> {\n    ReadableByteStreamControllerClearPendingPullIntos(this);\n\n    ResetQueue(this);\n\n    const result = this._cancelAlgorithm(reason);\n    ReadableByteStreamControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [PullSteps](readRequest: ReadRequest<Uint8Array>): void {\n    const stream = this._controlledReadableByteStream;\n    assert(ReadableStreamHasDefaultReader(stream));\n\n    if (this._queueTotalSize > 0) {\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\n\n      const entry = this._queue.shift()!;\n      this._queueTotalSize -= entry.byteLength;\n\n      ReadableByteStreamControllerHandleQueueDrain(this);\n\n      const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n\n      readRequest._chunkSteps(view);\n      return;\n    }\n\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n      let buffer: ArrayBuffer;\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        readRequest._errorSteps(bufferE);\n        return;\n      }\n\n      const pullIntoDescriptor: DefaultPullIntoDescriptor = {\n        buffer,\n        bufferByteLength: autoAllocateChunkSize,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        elementSize: 1,\n        viewConstructor: Uint8Array,\n        readerType: 'default'\n      };\n\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n\n    ReadableStreamAddReadRequest(stream, readRequest);\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n  }\n}\n\nObject.defineProperties(ReadableByteStreamController.prototype, {\n  close: { enumerable: true },\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  byobRequest: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {\n    value: 'ReadableByteStreamController',\n    configurable: true\n  });\n}\n\n// Abstract operations for the ReadableByteStreamController.\n\nexport function IsReadableByteStreamController(x: any): x is ReadableByteStreamController {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n    return false;\n  }\n\n  return x instanceof ReadableByteStreamController;\n}\n\nfunction IsReadableStreamBYOBRequest(x: any): x is ReadableStreamBYOBRequest {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamBYOBRequest;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller: ReadableByteStreamController): void {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (!shouldPull) {\n    return;\n  }\n\n  if (controller._pulling) {\n    controller._pullAgain = true;\n    return;\n  }\n\n  assert(!controller._pullAgain);\n\n  controller._pulling = true;\n\n  // TODO: Test controller argument\n  const pullPromise = controller._pullAlgorithm();\n  uponPromise(\n    pullPromise,\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    },\n    e => {\n      ReadableByteStreamControllerError(controller, e);\n    }\n  );\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller: ReadableByteStreamController) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = new SimpleQueue();\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor<T extends ArrayBufferView>(\n  stream: ReadableByteStream,\n  pullIntoDescriptor: PullIntoDescriptor<T>\n) {\n  assert(stream._state !== 'errored');\n\n  let done = false;\n  if (stream._state === 'closed') {\n    assert(pullIntoDescriptor.bytesFilled === 0);\n    done = true;\n  }\n\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor<T>(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView as unknown as Uint8Array, done);\n  } else {\n    assert(pullIntoDescriptor.readerType === 'byob');\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor<T extends ArrayBufferView>(\n  pullIntoDescriptor: PullIntoDescriptor<T>\n): T {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\n  assert(bytesFilled % elementSize === 0);\n\n  return new pullIntoDescriptor.viewConstructor(\n    pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize) as T;\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller: ReadableByteStreamController,\n                                                         buffer: ArrayBufferLike,\n                                                         byteOffset: number,\n                                                         byteLength: number) {\n  controller._queue.push({ buffer, byteOffset, byteLength });\n  controller._queueTotalSize += byteLength;\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller: ReadableByteStreamController,\n                                                                     pullIntoDescriptor: PullIntoDescriptor) {\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  const queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue.peek();\n\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._queueTotalSize -= bytesToCopy;\n\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (!ready) {\n    assert(controller._queueTotalSize === 0);\n    assert(pullIntoDescriptor.bytesFilled > 0);\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller: ReadableByteStreamController,\n                                                                size: number,\n                                                                pullIntoDescriptor: PullIntoDescriptor) {\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos.peek() === pullIntoDescriptor);\n  assert(controller._byobRequest === null);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller: ReadableByteStreamController) {\n  assert(controller._controlledReadableByteStream._state === 'readable');\n\n  if (controller._queueTotalSize === 0 && controller._closeRequested) {\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller: ReadableByteStreamController) {\n  if (controller._byobRequest === null) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined!;\n  controller._byobRequest._view = null!;\n  controller._byobRequest = null;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller: ReadableByteStreamController) {\n  assert(!controller._closeRequested);\n\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n\n    const pullIntoDescriptor = controller._pendingPullIntos.peek();\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\n        controller._controlledReadableByteStream,\n        pullIntoDescriptor\n      );\n    }\n  }\n}\n\nexport function ReadableByteStreamControllerPullInto<T extends ArrayBufferView>(\n  controller: ReadableByteStreamController,\n  view: T,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  const stream = controller._controlledReadableByteStream;\n\n  let elementSize = 1;\n  if (view.constructor !== DataView) {\n    elementSize = (view.constructor as ArrayBufferViewConstructor<T>).BYTES_PER_ELEMENT;\n  }\n\n  const ctor = view.constructor as ArrayBufferViewConstructor<T>;\n\n  // try {\n  const buffer = TransferArrayBuffer(view.buffer);\n  // } catch (e) {\n  //   readIntoRequest._errorSteps(e);\n  //   return;\n  // }\n\n  const pullIntoDescriptor: BYOBPullIntoDescriptor<T> = {\n    buffer,\n    bufferByteLength: buffer.byteLength,\n    byteOffset: view.byteOffset,\n    byteLength: view.byteLength,\n    bytesFilled: 0,\n    elementSize,\n    viewConstructor: ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n    return;\n  }\n\n  if (stream._state === 'closed') {\n    const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n    readIntoRequest._closeSteps(emptyView);\n    return;\n  }\n\n  if (controller._queueTotalSize > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor<T>(pullIntoDescriptor);\n\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n\n      readIntoRequest._chunkSteps(filledView);\n      return;\n    }\n\n    if (controller._closeRequested) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      readIntoRequest._errorSteps(e);\n      return;\n    }\n  }\n\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  ReadableStreamAddReadIntoRequest<T>(stream, readIntoRequest);\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller: ReadableByteStreamController,\n                                                          firstDescriptor: PullIntoDescriptor) {\n  assert(firstDescriptor.bytesFilled === 0);\n\n  const stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream)) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller: ReadableByteStreamController,\n                                                            bytesWritten: number,\n                                                            pullIntoDescriptor: PullIntoDescriptor) {\n  assert(pullIntoDescriptor.bytesFilled + bytesWritten <= pullIntoDescriptor.byteLength);\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n  }\n\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller: ReadableByteStreamController, bytesWritten: number) {\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  assert(CanTransferArrayBuffer(firstDescriptor.buffer));\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n\n  const state = controller._controlledReadableByteStream._state;\n  if (state === 'closed') {\n    assert(bytesWritten === 0);\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    assert(state === 'readable');\n    assert(bytesWritten > 0);\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(\n  controller: ReadableByteStreamController\n): PullIntoDescriptor {\n  assert(controller._byobRequest === null);\n  const descriptor = controller._pendingPullIntos.shift()!;\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller: ReadableByteStreamController): boolean {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested) {\n    return false;\n  }\n\n  if (!controller._started) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize! > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableByteStreamControllerClearAlgorithms(controller: ReadableByteStreamController) {\n  controller._pullAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n}\n\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\nexport function ReadableByteStreamControllerClose(controller: ReadableByteStreamController) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (controller._closeRequested || stream._state !== 'readable') {\n    return;\n  }\n\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos.peek();\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamClose(stream);\n}\n\nexport function ReadableByteStreamControllerEnqueue(controller: ReadableByteStreamController, chunk: ArrayBufferView) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (controller._closeRequested || stream._state !== 'readable') {\n    return;\n  }\n\n  const buffer = chunk.buffer;\n  const byteOffset = chunk.byteOffset;\n  const byteLength = chunk.byteLength;\n  if (IsDetachedBuffer(buffer)) {\n    throw new TypeError('chunk\\'s buffer is detached and so cannot be enqueued');\n  }\n  const transferredBuffer = TransferArrayBuffer(buffer);\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos.peek();\n    if (IsDetachedBuffer(firstPendingPullInto.buffer)) {\n      throw new TypeError(\n        'The BYOB request\\'s buffer has been detached and so cannot be filled with an enqueued chunk'\n      );\n    }\n    firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n  }\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n\n  if (ReadableStreamHasDefaultReader(stream)) {\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      assert(controller._pendingPullIntos.length === 0);\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(controller._queue.length === 0);\n      if (controller._pendingPullIntos.length > 0) {\n        assert(controller._pendingPullIntos.peek().readerType === 'default');\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\n      }\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream)) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(!IsReadableStreamLocked(stream));\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nexport function ReadableByteStreamControllerError(controller: ReadableByteStreamController, e: any) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  ResetQueue(controller);\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nexport function ReadableByteStreamControllerGetBYOBRequest(\n  controller: ReadableByteStreamController\n): ReadableStreamBYOBRequest | null {\n  if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const view = new Uint8Array(firstDescriptor.buffer,\n                                firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n                                firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n\n    const byobRequest: ReadableStreamBYOBRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n    SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n    controller._byobRequest = byobRequest;\n  }\n  return controller._byobRequest;\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller: ReadableByteStreamController): number | null {\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nexport function ReadableByteStreamControllerRespond(controller: ReadableByteStreamController, bytesWritten: number) {\n  assert(controller._pendingPullIntos.length > 0);\n\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n  } else {\n    assert(state === 'readable');\n    if (bytesWritten === 0) {\n      throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n    }\n    if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n      throw new RangeError('bytesWritten out of range');\n    }\n  }\n\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nexport function ReadableByteStreamControllerRespondWithNewView(controller: ReadableByteStreamController,\n                                                               view: ArrayBufferView) {\n  assert(controller._pendingPullIntos.length > 0);\n  assert(!IsDetachedBuffer(view.buffer));\n\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'closed') {\n    if (view.byteLength !== 0) {\n      throw new TypeError('The view\\'s length must be 0 when calling respondWithNewView() on a closed stream');\n    }\n  } else {\n    assert(state === 'readable');\n    if (view.byteLength === 0) {\n      throw new TypeError(\n        'The view\\'s length must be greater than 0 when calling respondWithNewView() on a readable stream'\n      );\n    }\n  }\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n  if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n    throw new RangeError('The region specified by view is larger than byobRequest');\n  }\n\n  const viewByteLength = view.byteLength;\n  firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n  ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n}\n\nexport function SetUpReadableByteStreamController(stream: ReadableByteStream,\n                                                  controller: ReadableByteStreamController,\n                                                  startAlgorithm: () => void | PromiseLike<void>,\n                                                  pullAlgorithm: () => Promise<void>,\n                                                  cancelAlgorithm: (reason: any) => Promise<void>,\n                                                  highWaterMark: number,\n                                                  autoAllocateChunkSize: number | undefined) {\n  assert(stream._readableStreamController === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(NumberIsInteger(autoAllocateChunkSize));\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  controller._controlledReadableByteStream = stream;\n\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._byobRequest = null;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._closeRequested = false;\n  controller._started = false;\n\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n\n  controller._pendingPullIntos = new SimpleQueue();\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  uponPromise(\n    promiseResolvedWith(startResult),\n    () => {\n      controller._started = true;\n\n      assert(!controller._pulling);\n      assert(!controller._pullAgain);\n\n      ReadableByteStreamControllerCallPullIfNeeded(controller);\n    },\n    r => {\n      ReadableByteStreamControllerError(controller, r);\n    }\n  );\n}\n\nexport function SetUpReadableByteStreamControllerFromUnderlyingSource(\n  stream: ReadableByteStream,\n  underlyingByteSource: ValidatedUnderlyingByteSource,\n  highWaterMark: number\n) {\n  const controller: ReadableByteStreamController = Object.create(ReadableByteStreamController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void> = () => undefined;\n  let pullAlgorithm: () => Promise<void> = () => promiseResolvedWith(undefined);\n  let cancelAlgorithm: (reason: any) => Promise<void> = () => promiseResolvedWith(undefined);\n\n  if (underlyingByteSource.start !== undefined) {\n    startAlgorithm = () => underlyingByteSource.start!(controller);\n  }\n  if (underlyingByteSource.pull !== undefined) {\n    pullAlgorithm = () => underlyingByteSource.pull!(controller);\n  }\n  if (underlyingByteSource.cancel !== undefined) {\n    cancelAlgorithm = reason => underlyingByteSource.cancel!(reason);\n  }\n\n  const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize === 0) {\n    throw new TypeError('autoAllocateChunkSize must be greater than 0');\n  }\n\n  SetUpReadableByteStreamController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize\n  );\n}\n\nfunction SetUpReadableStreamBYOBRequest(request: ReadableStreamBYOBRequest,\n                                        controller: ReadableByteStreamController,\n                                        view: ArrayBufferView) {\n  assert(IsReadableByteStreamController(controller));\n  assert(typeof view === 'object');\n  assert(ArrayBuffer.isView(view));\n  assert(!IsDetachedBuffer(view.buffer));\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n}\n\n// Helper functions for the ReadableStreamBYOBRequest.\n\nfunction byobRequestBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n\n// Helper functions for the ReadableByteStreamController.\n\nfunction byteStreamControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n", "import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericInitialize,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport { IsReadableStreamLocked, ReadableByteStream, ReadableStream } from '../readable-stream';\nimport {\n  IsReadableByteStreamController,\n  ReadableByteStreamController,\n  ReadableByteStreamControllerPullInto\n} from './byte-stream-controller';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport { newPromise, promiseRejectedWith } from '../helpers/webidl';\nimport { assertRequiredArgument } from '../validators/basic';\nimport { assertReadableStream } from '../validators/readable-stream';\nimport { IsDetachedBuffer } from '../abstract-ops/ecmascript';\n\n/**\n * A result returned by {@link ReadableStreamBYOBReader.read}.\n *\n * @public\n */\nexport type ReadableStreamBYOBReadResult<T extends ArrayBufferView> = {\n  done: false;\n  value: T;\n} | {\n  done: true;\n  value: T | undefined;\n};\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamBYOBReader(stream: ReadableByteStream): ReadableStreamBYOBReader {\n  return new ReadableStreamBYOBReader(stream);\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamAddReadIntoRequest<T extends ArrayBufferView>(stream: ReadableByteStream,\n                                                                            readIntoRequest: ReadIntoRequest<T>): void {\n  assert(IsReadableStreamBYOBReader(stream._reader));\n  assert(stream._state === 'readable' || stream._state === 'closed');\n\n  (stream._reader! as ReadableStreamBYOBReader)._readIntoRequests.push(readIntoRequest);\n}\n\nexport function ReadableStreamFulfillReadIntoRequest(stream: ReadableByteStream,\n                                                     chunk: ArrayBufferView,\n                                                     done: boolean) {\n  const reader = stream._reader as ReadableStreamBYOBReader;\n\n  assert(reader._readIntoRequests.length > 0);\n\n  const readIntoRequest = reader._readIntoRequests.shift()!;\n  if (done) {\n    readIntoRequest._closeSteps(chunk);\n  } else {\n    readIntoRequest._chunkSteps(chunk);\n  }\n}\n\nexport function ReadableStreamGetNumReadIntoRequests(stream: ReadableByteStream): number {\n  return (stream._reader as ReadableStreamBYOBReader)._readIntoRequests.length;\n}\n\nexport function ReadableStreamHasBYOBReader(stream: ReadableByteStream): boolean {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (!IsReadableStreamBYOBReader(reader)) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nexport interface ReadIntoRequest<T extends ArrayBufferView> {\n  _chunkSteps(chunk: T): void;\n\n  _closeSteps(chunk: T | undefined): void;\n\n  _errorSteps(e: any): void;\n}\n\n/**\n * A BYOB reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nexport class ReadableStreamBYOBReader {\n  /** @internal */\n  _ownerReadableStream!: ReadableByteStream;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readIntoRequests: SimpleQueue<ReadIntoRequest<any>>;\n\n  constructor(stream: ReadableByteStream) {\n    assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n    assertReadableStream(stream, 'First parameter');\n\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    if (!IsReadableByteStreamController(stream._readableStreamController)) {\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n        'source');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readIntoRequests = new SimpleQueue();\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   * the reader's lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  /**\n   * Attempts to reads bytes into view, and returns a promise resolved with the result.\n   *\n   * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   */\n  read<T extends ArrayBufferView>(view: T): Promise<ReadableStreamBYOBReadResult<T>> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('read'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n    }\n    if (view.byteLength === 0) {\n      return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n    }\n    if (view.buffer.byteLength === 0) {\n      return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n    }\n    if (IsDetachedBuffer(view.buffer)) {\n      return promiseRejectedWith(new TypeError('view\\'s buffer has been detached'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('read from'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamBYOBReadResult<T>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamBYOBReadResult<T>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readIntoRequest: ReadIntoRequest<T> = {\n      _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n      _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n      _errorSteps: e => rejectPromise(e)\n    };\n    ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n    return promise;\n  }\n\n  /**\n   * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n   * from now on; otherwise, the reader will appear closed.\n   *\n   * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n   * do so will throw a `TypeError` and leave the reader locked to the stream.\n   */\n  releaseLock(): void {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readIntoRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\nObject.defineProperties(ReadableStreamBYOBReader.prototype, {\n  cancel: { enumerable: true },\n  read: { enumerable: true },\n  releaseLock: { enumerable: true },\n  closed: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamBYOBReader',\n    configurable: true\n  });\n}\n\n// Abstract operations for the readers.\n\nexport function IsReadableStreamBYOBReader(x: any): x is ReadableStreamBYOBReader {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamBYOBReader;\n}\n\nexport function ReadableStreamBYOBReaderRead<T extends ArrayBufferView>(\n  reader: ReadableStreamBYOBReader,\n  view: T,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    readIntoRequest._errorSteps(stream._storedError);\n  } else {\n    ReadableByteStreamControllerPullInto(\n      stream._readableStreamController as ReadableByteStreamController,\n      view,\n      readIntoRequest\n    );\n  }\n}\n\n// Helper functions for the ReadableStreamBYOBReader.\n\nfunction byobReaderBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n", "import { QueuingStrategy, QueuingStrategySizeCallback } from '../queuing-strategy';\nimport NumberIsNaN from '../../stub/number-isnan';\n\nexport function ExtractHighWaterMark(strategy: QueuingStrategy, defaultHWM: number): number {\n  const { highWaterMark } = strategy;\n\n  if (highWaterMark === undefined) {\n    return defaultHWM;\n  }\n\n  if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n    throw new RangeError('Invalid highWaterMark');\n  }\n\n  return highWaterMark;\n}\n\nexport function ExtractSizeAlgorithm<T>(strategy: QueuingStrategy<T>): QueuingStrategySizeCallback<T> {\n  const { size } = strategy;\n\n  if (!size) {\n    return () => 1;\n  }\n\n  return size;\n}\n", "import { QueuingStrategy, QueuingStrategySizeCallback } from '../queuing-strategy';\nimport { assertDictionary, assertFunction, convertUnrestrictedDouble } from './basic';\n\nexport function convertQueuingStrategy<T>(init: QueuingStrategy<T> | null | undefined,\n                                          context: string): QueuingStrategy<T> {\n  assertDictionary(init, context);\n  const highWaterMark = init?.highWaterMark;\n  const size = init?.size;\n  return {\n    highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n    size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n  };\n}\n\nfunction convertQueuingStrategySize<T>(fn: QueuingStrategySizeCallback<T>,\n                                       context: string): QueuingStrategySizeCallback<T> {\n  assertFunction(fn, context);\n  return chunk => convertUnrestrictedDouble(fn(chunk));\n}\n", "import { assertDictionary, assertFunction } from './basic';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\nimport {\n  UnderlyingSink,\n  UnderlyingSinkAbortCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  ValidatedUnderlyingSink\n} from '../writable-stream/underlying-sink';\nimport { WritableStreamDefaultController } from '../writable-stream';\n\nexport function convertUnderlyingSink<W>(original: UnderlyingSink<W> | null,\n                                         context: string): ValidatedUnderlyingSink<W> {\n  assertDictionary(original, context);\n  const abort = original?.abort;\n  const close = original?.close;\n  const start = original?.start;\n  const type = original?.type;\n  const write = original?.write;\n  return {\n    abort: abort === undefined ?\n      undefined :\n      convertUnderlyingSinkAbortCallback(abort, original!, `${context} has member 'abort' that`),\n    close: close === undefined ?\n      undefined :\n      convertUnderlyingSinkCloseCallback(close, original!, `${context} has member 'close' that`),\n    start: start === undefined ?\n      undefined :\n      convertUnderlyingSinkStartCallback(start, original!, `${context} has member 'start' that`),\n    write: write === undefined ?\n      undefined :\n      convertUnderlyingSinkWriteCallback(write, original!, `${context} has member 'write' that`),\n    type\n  };\n}\n\nfunction convertUnderlyingSinkAbortCallback(\n  fn: UnderlyingSinkAbortCallback,\n  original: UnderlyingSink,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n\nfunction convertUnderlyingSinkCloseCallback(\n  fn: UnderlyingSinkCloseCallback,\n  original: UnderlyingSink,\n  context: string\n): () => Promise<void> {\n  assertFunction(fn, context);\n  return () => promiseCall(fn, original, []);\n}\n\nfunction convertUnderlyingSinkStartCallback(\n  fn: UnderlyingSinkStartCallback,\n  original: UnderlyingSink,\n  context: string\n): UnderlyingSinkStartCallback {\n  assertFunction(fn, context);\n  return (controller: WritableStreamDefaultController) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertUnderlyingSinkWriteCallback<W>(\n  fn: UnderlyingSinkWriteCallback<W>,\n  original: UnderlyingSink<W>,\n  context: string\n): (chunk: W, controller: WritableStreamDefaultController) => Promise<void> {\n  assertFunction(fn, context);\n  return (chunk: W, controller: WritableStreamDefaultController) => promiseCall(fn, original, [chunk, controller]);\n}\n", "import { IsWritableStream, WritableStream } from '../writable-stream';\n\nexport function assertWritableStream(x: unknown, context: string): asserts x is WritableStream {\n  if (!IsWritableStream(x)) {\n    throw new TypeError(`${context} is not a WritableStream.`);\n  }\n}\n", "/**\n * A signal object that allows you to communicate with a request and abort it if required\n * via its associated `AbortController` object.\n *\n * @remarks\n *   This interface is compatible with the `AbortSignal` interface defined in TypeScript's DOM types.\n *   It is redefined here, so it can be polyfilled without a DOM, for example with\n *   {@link https://www.npmjs.com/package/abortcontroller-polyfill | abortcontroller-polyfill} in a Node environment.\n *\n * @public\n */\nexport interface AbortSignal {\n  /**\n   * Whether the request is aborted.\n   */\n  readonly aborted: boolean;\n\n  /**\n   * Add an event listener to be triggered when this signal becomes aborted.\n   */\n  addEventListener(type: 'abort', listener: () => void): void;\n\n  /**\n   * Remove an event listener that was previously added with {@link AbortSignal.addEventListener}.\n   */\n  removeEventListener(type: 'abort', listener: () => void): void;\n}\n\nexport function isAbortSignal(value: unknown): value is AbortSignal {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n  try {\n    return typeof (value as AbortSignal).aborted === 'boolean';\n  } catch {\n    // AbortSignal.prototype.aborted throws if its brand check fails\n    return false;\n  }\n}\n\n/**\n * A controller object that allows you to abort an `AbortSignal` when desired.\n *\n * @remarks\n *   This interface is compatible with the `AbortController` interface defined in TypeScript's DOM types.\n *   It is redefined here, so it can be polyfilled without a DOM, for example with\n *   {@link https://www.npmjs.com/package/abortcontroller-polyfill | abortcontroller-polyfill} in a Node environment.\n *\n * @internal\n */\nexport interface AbortController {\n  readonly signal: AbortSignal;\n\n  abort(): void;\n}\n\ninterface AbortControllerConstructor {\n  new(): AbortController;\n}\n\nconst supportsAbortController = typeof (AbortController as any) === 'function';\n\n/**\n * Construct a new AbortController, if supported by the platform.\n *\n * @internal\n */\nexport function createAbortController(): AbortController | undefined {\n  if (supportsAbortController) {\n    return new (AbortController as AbortControllerConstructor)();\n  }\n  return undefined;\n}\n", "import assert from '../stub/assert';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  uponPromise\n} from './helpers/webidl';\nimport {\n  DequeueValue,\n  EnqueueValueWithSize,\n  PeekQueueValue,\n  QueuePair,\n  ResetQueue\n} from './abstract-ops/queue-with-sizes';\nimport { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { SimpleQueue } from './simple-queue';\nimport { typeIsObject } from './helpers/miscellaneous';\nimport { AbortSteps, ErrorSteps } from './abstract-ops/internal-methods';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport {\n  UnderlyingSink,\n  UnderlyingSinkAbortCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  ValidatedUnderlyingSink\n} from './writable-stream/underlying-sink';\nimport { assertObject, assertRequiredArgument } from './validators/basic';\nimport { convertUnderlyingSink } from './validators/underlying-sink';\nimport { assertWritableStream } from './validators/writable-stream';\nimport { AbortController, AbortSignal, createAbortController } from './abort-signal';\n\ntype WritableStreamState = 'writable' | 'closed' | 'erroring' | 'errored';\n\ninterface WriteOrCloseRequest {\n  _resolve: (value?: undefined) => void;\n  _reject: (reason: any) => void;\n}\n\ntype WriteRequest = WriteOrCloseRequest;\ntype CloseRequest = WriteOrCloseRequest;\n\ninterface PendingAbortRequest {\n  _promise: Promise<undefined>;\n  _resolve: (value?: undefined) => void;\n  _reject: (reason: any) => void;\n  _reason: any;\n  _wasAlreadyErroring: boolean;\n}\n\n/**\n * A writable stream represents a destination for data, into which you can write.\n *\n * @public\n */\nclass WritableStream<W = any> {\n  /** @internal */\n  _state!: WritableStreamState;\n  /** @internal */\n  _storedError: any;\n  /** @internal */\n  _writer: WritableStreamDefaultWriter<W> | undefined;\n  /** @internal */\n  _writableStreamController!: WritableStreamDefaultController<W>;\n  /** @internal */\n  _writeRequests!: SimpleQueue<WriteRequest>;\n  /** @internal */\n  _inFlightWriteRequest: WriteRequest | undefined;\n  /** @internal */\n  _closeRequest: CloseRequest | undefined;\n  /** @internal */\n  _inFlightCloseRequest: CloseRequest | undefined;\n  /** @internal */\n  _pendingAbortRequest: PendingAbortRequest | undefined;\n  /** @internal */\n  _backpressure!: boolean;\n\n  constructor(underlyingSink?: UnderlyingSink<W>, strategy?: QueuingStrategy<W>);\n  constructor(rawUnderlyingSink: UnderlyingSink<W> | null | undefined = {},\n              rawStrategy: QueuingStrategy<W> | null | undefined = {}) {\n    if (rawUnderlyingSink === undefined) {\n      rawUnderlyingSink = null;\n    } else {\n      assertObject(rawUnderlyingSink, 'First parameter');\n    }\n\n    const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n    const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n\n    InitializeWritableStream(this);\n\n    const type = underlyingSink.type;\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n    const highWaterMark = ExtractHighWaterMark(strategy, 1);\n\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n\n  /**\n   * Returns whether or not the writable stream is locked to a writer.\n   */\n  get locked(): boolean {\n    if (!IsWritableStream(this)) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsWritableStreamLocked(this);\n  }\n\n  /**\n   * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n   * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n   * mechanism of the underlying sink.\n   *\n   * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n   * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n   * the stream) if the stream is currently locked.\n   */\n  abort(reason: any = undefined): Promise<void> {\n    if (!IsWritableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  }\n\n  /**\n   * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n   * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n   *\n   * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n   * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n   * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n   */\n  close() {\n    if (!IsWritableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('close'));\n    }\n\n    if (IsWritableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(this)) {\n      return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n    }\n\n    return WritableStreamClose(this);\n  }\n\n  /**\n   * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n   * is locked, no other writer can be acquired until this one is released.\n   *\n   * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n   * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n   * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n   */\n  getWriter(): WritableStreamDefaultWriter<W> {\n    if (!IsWritableStream(this)) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  }\n}\n\nObject.defineProperties(WritableStream.prototype, {\n  abort: { enumerable: true },\n  close: { enumerable: true },\n  getWriter: { enumerable: true },\n  locked: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {\n    value: 'WritableStream',\n    configurable: true\n  });\n}\n\nexport {\n  AcquireWritableStreamDefaultWriter,\n  CreateWritableStream,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamDefaultControllerErrorIfNeeded,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite,\n  WritableStreamCloseQueuedOrInFlight,\n  UnderlyingSink,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkAbortCallback\n};\n\n// Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter<W>(stream: WritableStream<W>): WritableStreamDefaultWriter<W> {\n  return new WritableStreamDefaultWriter(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream<W>(startAlgorithm: () => void | PromiseLike<void>,\n                                 writeAlgorithm: (chunk: W) => Promise<void>,\n                                 closeAlgorithm: () => Promise<void>,\n                                 abortAlgorithm: (reason: any) => Promise<void>,\n                                 highWaterMark = 1,\n                                 sizeAlgorithm: QueuingStrategySizeCallback<W> = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark));\n\n  const stream: WritableStream<W> = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n\n  const controller: WritableStreamDefaultController<W> = Object.create(WritableStreamDefaultController.prototype);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n}\n\nfunction InitializeWritableStream<W>(stream: WritableStream<W>) {\n  stream._state = 'writable';\n\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n  stream._storedError = undefined;\n\n  stream._writer = undefined;\n\n  // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n  stream._writableStreamController = undefined!;\n\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n  stream._writeRequests = new SimpleQueue();\n\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  stream._inFlightWriteRequest = undefined;\n\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n  stream._closeRequest = undefined;\n\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  stream._inFlightCloseRequest = undefined;\n\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  stream._pendingAbortRequest = undefined;\n\n  // The backpressure signal set by the controller.\n  stream._backpressure = false;\n}\n\nfunction IsWritableStream(x: unknown): x is WritableStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return x instanceof WritableStream;\n}\n\nfunction IsWritableStreamLocked(stream: WritableStream): boolean {\n  assert(IsWritableStream(stream));\n\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream: WritableStream, reason: any): Promise<undefined> {\n  if (stream._state === 'closed' || stream._state === 'errored') {\n    return promiseResolvedWith(undefined);\n  }\n  stream._writableStreamController._abortReason = reason;\n  stream._writableStreamController._abortController?.abort();\n\n  // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n  // but it doesn't know that signaling abort runs author code that might have changed the state.\n  // Widen the type again by casting to WritableStreamState.\n  const state = stream._state as WritableStreamState;\n\n  if (state === 'closed' || state === 'errored') {\n    return promiseResolvedWith(undefined);\n  }\n  if (stream._pendingAbortRequest !== undefined) {\n    return stream._pendingAbortRequest._promise;\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    // reason will not be used, so don't keep a reference to it.\n    reason = undefined;\n  }\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    stream._pendingAbortRequest = {\n      _promise: undefined!,\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring\n    };\n  });\n  stream._pendingAbortRequest!._promise = promise;\n\n  if (!wasAlreadyErroring) {\n    WritableStreamStartErroring(stream, reason);\n  }\n\n  return promise;\n}\n\nfunction WritableStreamClose(stream: WritableStream<any>): Promise<undefined> {\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return promiseRejectedWith(new TypeError(\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n  assert(!WritableStreamCloseQueuedOrInFlight(stream));\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    const closeRequest: CloseRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._closeRequest = closeRequest;\n  });\n\n  const writer = stream._writer;\n  if (writer !== undefined && stream._backpressure && state === 'writable') {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n\n  return promise;\n}\n\n// WritableStream API exposed for controllers.\n\nfunction WritableStreamAddWriteRequest(stream: WritableStream): Promise<undefined> {\n  assert(IsWritableStreamLocked(stream));\n  assert(stream._state === 'writable');\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    const writeRequest: WriteRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n\n  return promise;\n}\n\nfunction WritableStreamDealWithRejection(stream: WritableStream, error: any) {\n  const state = stream._state;\n\n  if (state === 'writable') {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  WritableStreamFinishErroring(stream);\n}\n\nfunction WritableStreamStartErroring(stream: WritableStream, reason: any) {\n  assert(stream._storedError === undefined);\n  assert(stream._state === 'writable');\n\n  const controller = stream._writableStreamController;\n  assert(controller !== undefined);\n\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n\n  if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n    WritableStreamFinishErroring(stream);\n  }\n}\n\nfunction WritableStreamFinishErroring(stream: WritableStream) {\n  assert(stream._state === 'erroring');\n  assert(!WritableStreamHasOperationMarkedInFlight(stream));\n  stream._state = 'errored';\n  stream._writableStreamController[ErrorSteps]();\n\n  const storedError = stream._storedError;\n  stream._writeRequests.forEach(writeRequest => {\n    writeRequest._reject(storedError);\n  });\n  stream._writeRequests = new SimpleQueue();\n\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n\n  if (abortRequest._wasAlreadyErroring) {\n    abortRequest._reject(storedError);\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n  uponPromise(\n    promise,\n    () => {\n      abortRequest._resolve();\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    },\n    (reason: any) => {\n      abortRequest._reject(reason);\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    });\n}\n\nfunction WritableStreamFinishInFlightWrite(stream: WritableStream) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest!._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n}\n\nfunction WritableStreamFinishInFlightWriteWithError(stream: WritableStream, error: any) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest!._reject(error);\n  stream._inFlightWriteRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  WritableStreamDealWithRejection(stream, error);\n}\n\nfunction WritableStreamFinishInFlightClose(stream: WritableStream) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest!._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n\n  const state = stream._state;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  if (state === 'erroring') {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n\n  stream._state = 'closed';\n\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n\n  assert(stream._pendingAbortRequest === undefined);\n  assert(stream._storedError === undefined);\n}\n\nfunction WritableStreamFinishInFlightCloseWithError(stream: WritableStream, error: any) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest!._reject(error);\n  stream._inFlightCloseRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  // Never execute sink abort() after sink close().\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n    stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n}\n\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream: WritableStream): boolean {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamHasOperationMarkedInFlight(stream: WritableStream): boolean {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamMarkCloseRequestInFlight(stream: WritableStream) {\n  assert(stream._inFlightCloseRequest === undefined);\n  assert(stream._closeRequest !== undefined);\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\n\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream: WritableStream) {\n  assert(stream._inFlightWriteRequest === undefined);\n  assert(stream._writeRequests.length !== 0);\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\n\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream: WritableStream) {\n  assert(stream._state === 'errored');\n  if (stream._closeRequest !== undefined) {\n    assert(stream._inFlightCloseRequest === undefined);\n\n    stream._closeRequest._reject(stream._storedError);\n    stream._closeRequest = undefined;\n  }\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream: WritableStream, backpressure: boolean) {\n  assert(stream._state === 'writable');\n  assert(!WritableStreamCloseQueuedOrInFlight(stream));\n\n  const writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      assert(!backpressure);\n\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n\n  stream._backpressure = backpressure;\n}\n\n/**\n * A default writer vended by a {@link WritableStream}.\n *\n * @public\n */\nexport class WritableStreamDefaultWriter<W = any> {\n  /** @internal */\n  _ownerWritableStream: WritableStream<W>;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _closedPromiseState!: 'pending' | 'resolved' | 'rejected';\n  /** @internal */\n  _readyPromise!: Promise<undefined>;\n  /** @internal */\n  _readyPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _readyPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readyPromiseState!: 'pending' | 'fulfilled' | 'rejected';\n\n  constructor(stream: WritableStream<W>) {\n    assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n    assertWritableStream(stream, 'First parameter');\n\n    if (IsWritableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n\n    const state = stream._state;\n\n    if (state === 'writable') {\n      if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'erroring') {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      assert(state === 'errored');\n\n      const storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n    }\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   * the writer\u2019s lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * Returns the desired size to fill the stream\u2019s internal queue. It can be negative, if the queue is over-full.\n   * A producer can use this information to determine the right amount of data to write.\n   *\n   * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n   * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n   * the writer\u2019s lock is released.\n   */\n  get desiredSize(): number | null {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      throw defaultWriterBrandCheckException('desiredSize');\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      throw defaultWriterLockException('desiredSize');\n    }\n\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the desired size to fill the stream\u2019s internal queue transitions\n   * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n   * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n   *\n   * If the stream becomes errored or aborted, or the writer\u2019s lock is released, the returned promise will become\n   * rejected.\n   */\n  get ready(): Promise<undefined> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n    }\n\n    return this._readyPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n   */\n  abort(reason: any = undefined): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n   */\n  close(): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('close'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream)) {\n      return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  }\n\n  /**\n   * Releases the writer\u2019s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n   * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n   * now on; otherwise, the writer will appear closed.\n   *\n   * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n   * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n   * It\u2019s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n   * other producers from writing in an interleaved manner.\n   */\n  releaseLock(): void {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    assert(stream._writer !== undefined);\n\n    WritableStreamDefaultWriterRelease(this);\n  }\n\n  /**\n   * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n   * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n   * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n   * errored before the writing process is initiated.\n   *\n   * Note that what \"success\" means is up to the underlying sink; it might indicate simply that the chunk has been\n   * accepted, and not necessarily that it is safely saved to its ultimate destination.\n   */\n  write(chunk: W): Promise<void>;\n  write(chunk: W = undefined!): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('write to'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  }\n}\n\nObject.defineProperties(WritableStreamDefaultWriter.prototype, {\n  abort: { enumerable: true },\n  close: { enumerable: true },\n  releaseLock: { enumerable: true },\n  write: { enumerable: true },\n  closed: { enumerable: true },\n  desiredSize: { enumerable: true },\n  ready: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {\n    value: 'WritableStreamDefaultWriter',\n    configurable: true\n  });\n}\n\n// Abstract operations for the WritableStreamDefaultWriter.\n\nfunction IsWritableStreamDefaultWriter<W = any>(x: any): x is WritableStreamDefaultWriter<W> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return x instanceof WritableStreamDefaultWriter;\n}\n\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultWriterAbort(writer: WritableStreamDefaultWriter, reason: any) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer: WritableStreamDefaultWriter): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamClose(stream);\n}\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer: WritableStreamDefaultWriter): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return promiseResolvedWith(undefined);\n  }\n\n  if (state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer: WritableStreamDefaultWriter, error: any) {\n  if (writer._closedPromiseState === 'pending') {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n}\n\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer: WritableStreamDefaultWriter, error: any) {\n  if (writer._readyPromiseState === 'pending') {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer: WritableStreamDefaultWriter): number | null {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n\n  if (state === 'errored' || state === 'erroring') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer: WritableStreamDefaultWriter) {\n  const stream = writer._ownerWritableStream;\n  assert(stream !== undefined);\n  assert(stream._writer === writer);\n\n  const releasedError = new TypeError(\n    `Writer was released and can no longer be used to monitor the stream's closedness`);\n\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined!;\n}\n\nfunction WritableStreamDefaultWriterWrite<W>(writer: WritableStreamDefaultWriter<W>, chunk: W): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const controller = stream._writableStreamController;\n\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n  if (stream !== writer._ownerWritableStream) {\n    return promiseRejectedWith(defaultWriterLockException('write to'));\n  }\n\n  const state = stream._state;\n  if (state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n  if (state === 'erroring') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  assert(state === 'writable');\n\n  const promise = WritableStreamAddWriteRequest(stream);\n\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n\n  return promise;\n}\n\nconst closeSentinel: unique symbol = {} as any;\n\ntype QueueRecord<W> = W | typeof closeSentinel;\n\n/**\n * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n *\n * @public\n */\nexport class WritableStreamDefaultController<W = any> {\n  /** @internal */\n  _controlledWritableStream!: WritableStream<W>;\n  /** @internal */\n  _queue!: SimpleQueue<QueuePair<QueueRecord<W>>>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _abortReason: any;\n  /** @internal */\n  _abortController: AbortController | undefined;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _strategySizeAlgorithm!: QueuingStrategySizeCallback<W>;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _writeAlgorithm!: (chunk: W) => Promise<void>;\n  /** @internal */\n  _closeAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _abortAlgorithm!: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n   *\n   * @deprecated\n   *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n   *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n   */\n  get abortReason(): any {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('abortReason');\n    }\n    return this._abortReason;\n  }\n\n  /**\n   * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n   */\n  get signal(): AbortSignal {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('signal');\n    }\n    if (this._abortController === undefined) {\n      // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n      // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n      // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n      throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');\n    }\n    return this._abortController.signal;\n  }\n\n  /**\n   * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n   *\n   * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n   * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n   * normal lifecycle of interactions with the underlying sink.\n   */\n  error(e: any = undefined): void {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n    const state = this._controlledWritableStream._state;\n    if (state !== 'writable') {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  }\n\n  /** @internal */\n  [AbortSteps](reason: any): Promise<void> {\n    const result = this._abortAlgorithm(reason);\n    WritableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [ErrorSteps]() {\n    ResetQueue(this);\n  }\n}\n\nObject.defineProperties(WritableStreamDefaultController.prototype, {\n  abortReason: { enumerable: true },\n  signal: { enumerable: true },\n  error: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'WritableStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Abstract operations implementing interface required by the WritableStream.\n\nfunction IsWritableStreamDefaultController(x: any): x is WritableStreamDefaultController<any> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n    return false;\n  }\n\n  return x instanceof WritableStreamDefaultController;\n}\n\nfunction SetUpWritableStreamDefaultController<W>(stream: WritableStream<W>,\n                                                 controller: WritableStreamDefaultController<W>,\n                                                 startAlgorithm: () => void | PromiseLike<void>,\n                                                 writeAlgorithm: (chunk: W) => Promise<void>,\n                                                 closeAlgorithm: () => Promise<void>,\n                                                 abortAlgorithm: (reason: any) => Promise<void>,\n                                                 highWaterMark: number,\n                                                 sizeAlgorithm: QueuingStrategySizeCallback<W>) {\n  assert(IsWritableStream(stream));\n  assert(stream._writableStreamController === undefined);\n\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = undefined!;\n  controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._abortReason = undefined;\n  controller._abortController = createAbortController();\n  controller._started = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n\n  const startResult = startAlgorithm();\n  const startPromise = promiseResolvedWith(startResult);\n  uponPromise(\n    startPromise,\n    () => {\n      assert(stream._state === 'writable' || stream._state === 'erroring');\n      controller._started = true;\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    },\n    r => {\n      assert(stream._state === 'writable' || stream._state === 'erroring');\n      controller._started = true;\n      WritableStreamDealWithRejection(stream, r);\n    }\n  );\n}\n\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink<W>(stream: WritableStream<W>,\n                                                                   underlyingSink: ValidatedUnderlyingSink<W>,\n                                                                   highWaterMark: number,\n                                                                   sizeAlgorithm: QueuingStrategySizeCallback<W>) {\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void> = () => undefined;\n  let writeAlgorithm: (chunk: W) => Promise<void> = () => promiseResolvedWith(undefined);\n  let closeAlgorithm: () => Promise<void> = () => promiseResolvedWith(undefined);\n  let abortAlgorithm: (reason: any) => Promise<void> = () => promiseResolvedWith(undefined);\n\n  if (underlyingSink.start !== undefined) {\n    startAlgorithm = () => underlyingSink.start!(controller);\n  }\n  if (underlyingSink.write !== undefined) {\n    writeAlgorithm = chunk => underlyingSink.write!(chunk, controller);\n  }\n  if (underlyingSink.close !== undefined) {\n    closeAlgorithm = () => underlyingSink.close!();\n  }\n  if (underlyingSink.abort !== undefined) {\n    abortAlgorithm = reason => underlyingSink.abort!(reason);\n  }\n\n  SetUpWritableStreamDefaultController(\n    stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm\n  );\n}\n\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller: WritableStreamDefaultController<any>) {\n  controller._writeAlgorithm = undefined!;\n  controller._closeAlgorithm = undefined!;\n  controller._abortAlgorithm = undefined!;\n  controller._strategySizeAlgorithm = undefined!;\n}\n\nfunction WritableStreamDefaultControllerClose<W>(controller: WritableStreamDefaultController<W>) {\n  EnqueueValueWithSize(controller, closeSentinel, 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetChunkSize<W>(controller: WritableStreamDefaultController<W>,\n                                                        chunk: W): number {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller: WritableStreamDefaultController<any>): number {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction WritableStreamDefaultControllerWrite<W>(controller: WritableStreamDefaultController<W>,\n                                                 chunk: W,\n                                                 chunkSize: number) {\n  try {\n    EnqueueValueWithSize(controller, chunk, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  const stream = controller._controlledWritableStream;\n  if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\n// Abstract operations for the WritableStreamDefaultController.\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded<W>(controller: WritableStreamDefaultController<W>) {\n  const stream = controller._controlledWritableStream;\n\n  if (!controller._started) {\n    return;\n  }\n\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n\n  const state = stream._state;\n  assert(state !== 'closed' && state !== 'errored');\n  if (state === 'erroring') {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  const value = PeekQueueValue(controller);\n  if (value === closeSentinel) {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, value);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller: WritableStreamDefaultController<any>, error: any) {\n  if (controller._controlledWritableStream._state === 'writable') {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller: WritableStreamDefaultController<any>) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkCloseRequestInFlight(stream);\n\n  DequeueValue(controller);\n  assert(controller._queue.length === 0);\n\n  const sinkClosePromise = controller._closeAlgorithm();\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  uponPromise(\n    sinkClosePromise,\n    () => {\n      WritableStreamFinishInFlightClose(stream);\n    },\n    reason => {\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\n    }\n  );\n}\n\nfunction WritableStreamDefaultControllerProcessWrite<W>(controller: WritableStreamDefaultController<W>, chunk: W) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\n  uponPromise(\n    sinkWritePromise,\n    () => {\n      WritableStreamFinishInFlightWrite(stream);\n\n      const state = stream._state;\n      assert(state === 'writable' || state === 'erroring');\n\n      DequeueValue(controller);\n\n      if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n      }\n\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    },\n    reason => {\n      if (stream._state === 'writable') {\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n      }\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\n    }\n  );\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller: WritableStreamDefaultController<any>): boolean {\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n}\n\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultControllerError(controller: WritableStreamDefaultController<any>, error: any) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'writable');\n\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  WritableStreamStartErroring(stream, error);\n}\n\n// Helper functions for the WritableStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n\n// Helper functions for the WritableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n}\n\n\n// Helper functions for the WritableStreamDefaultWriter.\n\nfunction defaultWriterBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\n\nfunction defaultWriterLockException(name: string): TypeError {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer: WritableStreamDefaultWriter) {\n  writer._closedPromise = newPromise((resolve, reject) => {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = 'pending';\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseReject(writer, reason);\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer: WritableStreamDefaultWriter) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseResolve(writer);\n}\n\nfunction defaultWriterClosedPromiseReject(writer: WritableStreamDefaultWriter, reason: any) {\n  if (writer._closedPromise_reject === undefined) {\n    return;\n  }\n  assert(writer._closedPromiseState === 'pending');\n\n  setPromiseIsHandledToTrue(writer._closedPromise);\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  assert(writer._closedPromise_resolve === undefined);\n  assert(writer._closedPromise_reject === undefined);\n  assert(writer._closedPromiseState !== 'pending');\n\n  defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n}\n\nfunction defaultWriterClosedPromiseResolve(writer: WritableStreamDefaultWriter) {\n  if (writer._closedPromise_resolve === undefined) {\n    return;\n  }\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer: WritableStreamDefaultWriter) {\n  writer._readyPromise = newPromise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseReject(writer, reason);\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer: WritableStreamDefaultWriter) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseResolve(writer);\n}\n\nfunction defaultWriterReadyPromiseReject(writer: WritableStreamDefaultWriter, reason: any) {\n  if (writer._readyPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(writer._readyPromise);\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseReset(writer: WritableStreamDefaultWriter) {\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  defaultWriterReadyPromiseInitialize(writer);\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n}\n\nfunction defaultWriterReadyPromiseResolve(writer: WritableStreamDefaultWriter) {\n  if (writer._readyPromise_resolve === undefined) {\n    return;\n  }\n\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n", "/// <reference lib=\"dom\" />\nexport const NativeDOMException: typeof DOMException | undefined =\n  typeof DOMException !== 'undefined' ? DOMException : undefined;\n", "/// <reference types=\"node\" />\nimport { NativeDOMException } from './native';\n\ndeclare class DOMExceptionClass extends Error {\n  constructor(message?: string, name?: string);\n\n  name: string;\n  message: string;\n}\n\ntype DOMException = DOMExceptionClass;\ntype DOMExceptionConstructor = typeof DOMExceptionClass;\n\nfunction isDOMExceptionConstructor(ctor: unknown): ctor is DOMExceptionConstructor {\n  if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n    return false;\n  }\n  try {\n    new (ctor as DOMExceptionConstructor)();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction createDOMExceptionPolyfill(): DOMExceptionConstructor {\n  // eslint-disable-next-line no-shadow\n  const ctor = function DOMException(this: DOMException, message?: string, name?: string) {\n    this.message = message || '';\n    this.name = name || 'Error';\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  } as any;\n  ctor.prototype = Object.create(Error.prototype);\n  Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n  return ctor;\n}\n\n// eslint-disable-next-line no-redeclare\nconst DOMException: DOMExceptionConstructor =\n  isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n\nexport { DOMException };\n", "import { IsReadableStream, IsReadableStreamLocked, ReadableStream, ReadableStreamCancel } from '../readable-stream';\nimport { AcquireReadableStreamDefaultReader, ReadableStreamDefaultReaderRead } from './default-reader';\nimport { ReadableStreamReaderGenericRelease } from './generic-reader';\nimport {\n  AcquireWritableStreamDefaultWriter,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamCloseQueuedOrInFlight,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite\n} from '../writable-stream';\nimport assert from '../../stub/assert';\nimport {\n  newPromise,\n  PerformPromiseThen,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  uponFulfillment,\n  uponPromise,\n  uponRejection\n} from '../helpers/webidl';\nimport { noop } from '../../utils';\nimport { AbortSignal, isAbortSignal } from '../abort-signal';\nimport { DOMException } from '../../stub/dom-exception';\n\nexport function ReadableStreamPipeTo<T>(source: ReadableStream<T>,\n                                        dest: WritableStream<T>,\n                                        preventClose: boolean,\n                                        preventAbort: boolean,\n                                        preventCancel: boolean,\n                                        signal: AbortSignal | undefined): Promise<undefined> {\n  assert(IsReadableStream(source));\n  assert(IsWritableStream(dest));\n  assert(typeof preventClose === 'boolean');\n  assert(typeof preventAbort === 'boolean');\n  assert(typeof preventCancel === 'boolean');\n  assert(signal === undefined || isAbortSignal(signal));\n  assert(!IsReadableStreamLocked(source));\n  assert(!IsWritableStreamLocked(dest));\n\n  const reader = AcquireReadableStreamDefaultReader<T>(source);\n  const writer = AcquireWritableStreamDefaultWriter<T>(dest);\n\n  source._disturbed = true;\n\n  let shuttingDown = false;\n\n  // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n  let currentWrite = promiseResolvedWith<void>(undefined);\n\n  return newPromise((resolve, reject) => {\n    let abortAlgorithm: () => void;\n    if (signal !== undefined) {\n      abortAlgorithm = () => {\n        const error = new DOMException('Aborted', 'AbortError');\n        const actions: Array<() => Promise<void>> = [];\n        if (!preventAbort) {\n          actions.push(() => {\n            if (dest._state === 'writable') {\n              return WritableStreamAbort(dest, error);\n            }\n            return promiseResolvedWith(undefined);\n          });\n        }\n        if (!preventCancel) {\n          actions.push(() => {\n            if (source._state === 'readable') {\n              return ReadableStreamCancel(source, error);\n            }\n            return promiseResolvedWith(undefined);\n          });\n        }\n        shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n      };\n\n      if (signal.aborted) {\n        abortAlgorithm();\n        return;\n      }\n\n      signal.addEventListener('abort', abortAlgorithm);\n    }\n\n    // Using reader and writer, read all chunks from this and write them to dest\n    // - Backpressure must be enforced\n    // - Shutdown must stop all activity\n    function pipeLoop() {\n      return newPromise<void>((resolveLoop, rejectLoop) => {\n        function next(done: boolean) {\n          if (done) {\n            resolveLoop();\n          } else {\n            // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n            PerformPromiseThen(pipeStep(), next, rejectLoop);\n          }\n        }\n\n        next(false);\n      });\n    }\n\n    function pipeStep(): Promise<boolean> {\n      if (shuttingDown) {\n        return promiseResolvedWith(true);\n      }\n\n      return PerformPromiseThen(writer._readyPromise, () => {\n        return newPromise<boolean>((resolveRead, rejectRead) => {\n          ReadableStreamDefaultReaderRead(\n            reader,\n            {\n              _chunkSteps: chunk => {\n                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                resolveRead(false);\n              },\n              _closeSteps: () => resolveRead(true),\n              _errorSteps: rejectRead\n            }\n          );\n        });\n      });\n    }\n\n    // Errors must be propagated forward\n    isOrBecomesErrored(source, reader._closedPromise, storedError => {\n      if (!preventAbort) {\n        shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n    });\n\n    // Errors must be propagated backward\n    isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n      if (!preventCancel) {\n        shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n    });\n\n    // Closing must be propagated forward\n    isOrBecomesClosed(source, reader._closedPromise, () => {\n      if (!preventClose) {\n        shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n      } else {\n        shutdown();\n      }\n    });\n\n    // Closing must be propagated backward\n    if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n      const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n      if (!preventCancel) {\n        shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n      } else {\n        shutdown(true, destClosed);\n      }\n    }\n\n    setPromiseIsHandledToTrue(pipeLoop());\n\n    function waitForWritesToFinish(): Promise<void> {\n      // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n      // for that too.\n      const oldCurrentWrite = currentWrite;\n      return PerformPromiseThen(\n        currentWrite,\n        () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined\n      );\n    }\n\n    function isOrBecomesErrored(stream: ReadableStream | WritableStream,\n                                promise: Promise<void>,\n                                action: (reason: any) => void) {\n      if (stream._state === 'errored') {\n        action(stream._storedError);\n      } else {\n        uponRejection(promise, action);\n      }\n    }\n\n    function isOrBecomesClosed(stream: ReadableStream | WritableStream, promise: Promise<void>, action: () => void) {\n      if (stream._state === 'closed') {\n        action();\n      } else {\n        uponFulfillment(promise, action);\n      }\n    }\n\n    function shutdownWithAction(action: () => Promise<unknown>, originalIsError?: boolean, originalError?: any) {\n      if (shuttingDown) {\n        return;\n      }\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n        uponFulfillment(waitForWritesToFinish(), doTheRest);\n      } else {\n        doTheRest();\n      }\n\n      function doTheRest() {\n        uponPromise(\n          action(),\n          () => finalize(originalIsError, originalError),\n          newError => finalize(true, newError)\n        );\n      }\n    }\n\n    function shutdown(isError?: boolean, error?: any) {\n      if (shuttingDown) {\n        return;\n      }\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n        uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n      } else {\n        finalize(isError, error);\n      }\n    }\n\n    function finalize(isError?: boolean, error?: any) {\n      WritableStreamDefaultWriterRelease(writer);\n      ReadableStreamReaderGenericRelease(reader);\n\n      if (signal !== undefined) {\n        signal.removeEventListener('abort', abortAlgorithm);\n      }\n      if (isError) {\n        reject(error);\n      } else {\n        resolve(undefined);\n      }\n    }\n  });\n}\n", "import { QueuingStrategySizeCallback } from '../queuing-strategy';\nimport assert from '../../stub/assert';\nimport { DequeueValue, EnqueueValueWithSize, QueuePair, ResetQueue } from '../abstract-ops/queue-with-sizes';\nimport {\n  ReadableStreamAddReadRequest,\n  ReadableStreamFulfillReadRequest,\n  ReadableStreamGetNumReadRequests,\n  ReadRequest\n} from './default-reader';\nimport { SimpleQueue } from '../simple-queue';\nimport { IsReadableStreamLocked, ReadableStream, ReadableStreamClose, ReadableStreamError } from '../readable-stream';\nimport { ValidatedUnderlyingSource } from './underlying-source';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport { CancelSteps, PullSteps } from '../abstract-ops/internal-methods';\nimport { promiseResolvedWith, uponPromise } from '../helpers/webidl';\n\n/**\n * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n *\n * @public\n */\nexport class ReadableStreamDefaultController<R> {\n  /** @internal */\n  _controlledReadableStream!: ReadableStream<R>;\n  /** @internal */\n  _queue!: SimpleQueue<QueuePair<R>>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _closeRequested!: boolean;\n  /** @internal */\n  _pullAgain!: boolean;\n  /** @internal */\n  _pulling !: boolean;\n  /** @internal */\n  _strategySizeAlgorithm!: QueuingStrategySizeCallback<R>;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _pullAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm!: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n   * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n   */\n  get desiredSize(): number | null {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  /**\n   * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   * the stream, but once those are read, the stream will become closed.\n   */\n  close(): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n      throw new TypeError('The stream is not in a state that permits close');\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  }\n\n  /**\n   * Enqueues the given chunk `chunk` in the controlled readable stream.\n   */\n  enqueue(chunk: R): void;\n  enqueue(chunk: R = undefined!): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n      throw new TypeError('The stream is not in a state that permits enqueue');\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   */\n  error(e: any = undefined): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  }\n\n  /** @internal */\n  [CancelSteps](reason: any): Promise<void> {\n    ResetQueue(this);\n    const result = this._cancelAlgorithm(reason);\n    ReadableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [PullSteps](readRequest: ReadRequest<R>): void {\n    const stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this);\n\n      if (this._closeRequested && this._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      readRequest._chunkSteps(chunk);\n    } else {\n      ReadableStreamAddReadRequest(stream, readRequest);\n      ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    }\n  }\n}\n\nObject.defineProperties(ReadableStreamDefaultController.prototype, {\n  close: { enumerable: true },\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Abstract operations for the ReadableStreamDefaultController.\n\nfunction IsReadableStreamDefaultController<R = any>(x: any): x is ReadableStreamDefaultController<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamDefaultController;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller: ReadableStreamDefaultController<any>): void {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (!shouldPull) {\n    return;\n  }\n\n  if (controller._pulling) {\n    controller._pullAgain = true;\n    return;\n  }\n\n  assert(!controller._pullAgain);\n\n  controller._pulling = true;\n\n  const pullPromise = controller._pullAlgorithm();\n  uponPromise(\n    pullPromise,\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain) {\n        controller._pullAgain = false;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n    },\n    e => {\n      ReadableStreamDefaultControllerError(controller, e);\n    }\n  );\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller: ReadableStreamDefaultController<any>): boolean {\n  const stream = controller._controlledReadableStream;\n\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return false;\n  }\n\n  if (!controller._started) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize! > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller: ReadableStreamDefaultController<any>) {\n  controller._pullAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n  controller._strategySizeAlgorithm = undefined!;\n}\n\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\nexport function ReadableStreamDefaultControllerClose(controller: ReadableStreamDefaultController<any>) {\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return;\n  }\n\n  const stream = controller._controlledReadableStream;\n\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n  }\n}\n\nexport function ReadableStreamDefaultControllerEnqueue<R>(\n  controller: ReadableStreamDefaultController<R>,\n  chunk: R\n): void {\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return;\n  }\n\n  const stream = controller._controlledReadableStream;\n\n  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize;\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n\n    try {\n      EnqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerError(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n}\n\nexport function ReadableStreamDefaultControllerError(controller: ReadableStreamDefaultController<any>, e: any) {\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ResetQueue(controller);\n\n  ReadableStreamDefaultControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nexport function ReadableStreamDefaultControllerGetDesiredSize(\n  controller: ReadableStreamDefaultController<any>\n): number | null {\n  const state = controller._controlledReadableStream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\n// This is used in the implementation of TransformStream.\nexport function ReadableStreamDefaultControllerHasBackpressure(\n  controller: ReadableStreamDefaultController<any>\n): boolean {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function ReadableStreamDefaultControllerCanCloseOrEnqueue(\n  controller: ReadableStreamDefaultController<any>\n): boolean {\n  const state = controller._controlledReadableStream._state;\n\n  if (!controller._closeRequested && state === 'readable') {\n    return true;\n  }\n\n  return false;\n}\n\nexport function SetUpReadableStreamDefaultController<R>(stream: ReadableStream<R>,\n                                                        controller: ReadableStreamDefaultController<R>,\n                                                        startAlgorithm: () => void | PromiseLike<void>,\n                                                        pullAlgorithm: () => Promise<void>,\n                                                        cancelAlgorithm: (reason: any) => Promise<void>,\n                                                        highWaterMark: number,\n                                                        sizeAlgorithm: QueuingStrategySizeCallback<R>) {\n  assert(stream._readableStreamController === undefined);\n\n  controller._controlledReadableStream = stream;\n\n  controller._queue = undefined!;\n  controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  uponPromise(\n    promiseResolvedWith(startResult),\n    () => {\n      controller._started = true;\n\n      assert(!controller._pulling);\n      assert(!controller._pullAgain);\n\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    },\n    r => {\n      ReadableStreamDefaultControllerError(controller, r);\n    }\n  );\n}\n\nexport function SetUpReadableStreamDefaultControllerFromUnderlyingSource<R>(\n  stream: ReadableStream<R>,\n  underlyingSource: ValidatedUnderlyingSource<R>,\n  highWaterMark: number,\n  sizeAlgorithm: QueuingStrategySizeCallback<R>\n) {\n  const controller: ReadableStreamDefaultController<R> = Object.create(ReadableStreamDefaultController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void> = () => undefined;\n  let pullAlgorithm: () => Promise<void> = () => promiseResolvedWith(undefined);\n  let cancelAlgorithm: (reason: any) => Promise<void> = () => promiseResolvedWith(undefined);\n\n  if (underlyingSource.start !== undefined) {\n    startAlgorithm = () => underlyingSource.start!(controller);\n  }\n  if (underlyingSource.pull !== undefined) {\n    pullAlgorithm = () => underlyingSource.pull!(controller);\n  }\n  if (underlyingSource.cancel !== undefined) {\n    cancelAlgorithm = reason => underlyingSource.cancel!(reason);\n  }\n\n  SetUpReadableStreamDefaultController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n}\n\n// Helper functions for the ReadableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n", "import {\n  CreateReadableByteStream,\n  CreateReadableStream,\n  IsReadableStream,\n  ReadableByteStream,\n  ReadableStream,\n  ReadableStreamCancel,\n  ReadableStreamReader\n} from '../readable-stream';\nimport { ReadableStreamReaderGenericRelease } from './generic-reader';\nimport {\n  AcquireReadableStreamDefaultReader,\n  IsReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderRead,\n  ReadRequest\n} from './default-reader';\nimport {\n  AcquireReadableStreamBYOBReader,\n  IsReadableStreamBYOBReader,\n  ReadableStreamBYOBReaderRead,\n  ReadIntoRequest\n} from './byob-reader';\nimport assert from '../../stub/assert';\nimport { newPromise, promiseResolvedWith, queueMicrotask, uponRejection } from '../helpers/webidl';\nimport {\n  ReadableStreamDefaultController,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError\n} from './default-controller';\nimport {\n  IsReadableByteStreamController,\n  ReadableByteStreamControllerClose,\n  ReadableByteStreamControllerEnqueue,\n  ReadableByteStreamControllerError,\n  ReadableByteStreamControllerGetBYOBRequest,\n  ReadableByteStreamControllerRespond,\n  ReadableByteStreamControllerRespondWithNewView\n} from './byte-stream-controller';\nimport { CreateArrayFromList } from '../abstract-ops/ecmascript';\nimport { CloneAsUint8Array } from '../abstract-ops/miscellaneous';\n\nexport function ReadableStreamTee<R>(stream: ReadableStream<R>,\n                                     cloneForBranch2: boolean): [ReadableStream<R>, ReadableStream<R>] {\n  assert(IsReadableStream(stream));\n  assert(typeof cloneForBranch2 === 'boolean');\n  if (IsReadableByteStreamController(stream._readableStreamController)) {\n    return ReadableByteStreamTee(stream as unknown as ReadableByteStream) as\n      unknown as [ReadableStream<R>, ReadableStream<R>];\n  }\n  return ReadableStreamDefaultTee(stream, cloneForBranch2);\n}\n\nexport function ReadableStreamDefaultTee<R>(stream: ReadableStream<R>,\n                                            cloneForBranch2: boolean): [ReadableStream<R>, ReadableStream<R>] {\n  assert(IsReadableStream(stream));\n  assert(typeof cloneForBranch2 === 'boolean');\n\n  const reader = AcquireReadableStreamDefaultReader<R>(stream);\n\n  let reading = false;\n  let readAgain = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1: any;\n  let reason2: any;\n  let branch1: ReadableStream<R>;\n  let branch2: ReadableStream<R>;\n\n  let resolveCancelPromise: (value: undefined | Promise<undefined>) => void;\n  const cancelPromise = newPromise<undefined>(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function pullAlgorithm(): Promise<void> {\n    if (reading) {\n      readAgain = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgain = false;\n          const chunk1 = chunk;\n          const chunk2 = chunk;\n\n          // There is no way to access the cloning code right now in the reference implementation.\n          // If we add one then we'll need an implementation for serializable objects.\n          // if (!canceled2 && cloneForBranch2) {\n          //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n          // }\n\n          if (!canceled1) {\n            ReadableStreamDefaultControllerEnqueue(\n              branch1._readableStreamController as ReadableStreamDefaultController<R>,\n              chunk1\n            );\n          }\n          if (!canceled2) {\n            ReadableStreamDefaultControllerEnqueue(\n              branch2._readableStreamController as ReadableStreamDefaultController<R>,\n              chunk2\n            );\n          }\n\n          reading = false;\n          if (readAgain) {\n            pullAlgorithm();\n          }\n        });\n      },\n      _closeSteps: () => {\n        reading = false;\n        if (!canceled1) {\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController as ReadableStreamDefaultController<R>);\n        }\n        if (!canceled2) {\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController as ReadableStreamDefaultController<R>);\n        }\n\n        if (!canceled1 || !canceled2) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function cancel1Algorithm(reason: any): Promise<void> {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason: any): Promise<void> {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm() {\n    // do nothing\n  }\n\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n\n  uponRejection(reader._closedPromise, (r: any) => {\n    ReadableStreamDefaultControllerError(branch1._readableStreamController as ReadableStreamDefaultController<R>, r);\n    ReadableStreamDefaultControllerError(branch2._readableStreamController as ReadableStreamDefaultController<R>, r);\n    if (!canceled1 || !canceled2) {\n      resolveCancelPromise(undefined);\n    }\n  });\n\n  return [branch1, branch2];\n}\n\nexport function ReadableByteStreamTee(stream: ReadableByteStream): [ReadableByteStream, ReadableByteStream] {\n  assert(IsReadableStream(stream));\n  assert(IsReadableByteStreamController(stream._readableStreamController));\n\n  let reader: ReadableStreamReader<Uint8Array> = AcquireReadableStreamDefaultReader(stream);\n  let reading = false;\n  let readAgainForBranch1 = false;\n  let readAgainForBranch2 = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1: any;\n  let reason2: any;\n  let branch1: ReadableByteStream;\n  let branch2: ReadableByteStream;\n\n  let resolveCancelPromise: (value: undefined | Promise<undefined>) => void;\n  const cancelPromise = newPromise<void>(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function forwardReaderError(thisReader: ReadableStreamReader<Uint8Array>) {\n    uponRejection(thisReader._closedPromise, r => {\n      if (thisReader !== reader) {\n        return;\n      }\n      ReadableByteStreamControllerError(branch1._readableStreamController, r);\n      ReadableByteStreamControllerError(branch2._readableStreamController, r);\n      if (!canceled1 || !canceled2) {\n        resolveCancelPromise(undefined);\n      }\n    });\n  }\n\n  function pullWithDefaultReader() {\n    if (IsReadableStreamBYOBReader(reader)) {\n      assert(reader._readIntoRequests.length === 0);\n      ReadableStreamReaderGenericRelease(reader);\n\n      reader = AcquireReadableStreamDefaultReader(stream);\n      forwardReaderError(reader);\n    }\n\n    const readRequest: ReadRequest<Uint8Array> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgainForBranch1 = false;\n          readAgainForBranch2 = false;\n\n          const chunk1 = chunk;\n          let chunk2 = chunk;\n          if (!canceled1 && !canceled2) {\n            try {\n              chunk2 = CloneAsUint8Array(chunk);\n            } catch (cloneE) {\n              ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n              ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n              return;\n            }\n          }\n\n          if (!canceled1) {\n            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n          }\n          if (!canceled2) {\n            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n          }\n\n          reading = false;\n          if (readAgainForBranch1) {\n            pull1Algorithm();\n          } else if (readAgainForBranch2) {\n            pull2Algorithm();\n          }\n        });\n      },\n      _closeSteps: () => {\n        reading = false;\n        if (!canceled1) {\n          ReadableByteStreamControllerClose(branch1._readableStreamController);\n        }\n        if (!canceled2) {\n          ReadableByteStreamControllerClose(branch2._readableStreamController);\n        }\n        if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n          ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n        }\n        if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n          ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n        }\n        if (!canceled1 || !canceled2) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n  }\n\n  function pullWithBYOBReader(view: ArrayBufferView, forBranch2: boolean) {\n    if (IsReadableStreamDefaultReader<Uint8Array>(reader)) {\n      assert(reader._readRequests.length === 0);\n      ReadableStreamReaderGenericRelease(reader);\n\n      reader = AcquireReadableStreamBYOBReader(stream);\n      forwardReaderError(reader);\n    }\n\n    const byobBranch = forBranch2 ? branch2 : branch1;\n    const otherBranch = forBranch2 ? branch1 : branch2;\n\n    const readIntoRequest: ReadIntoRequest<ArrayBufferView> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgainForBranch1 = false;\n          readAgainForBranch2 = false;\n\n          const byobCanceled = forBranch2 ? canceled2 : canceled1;\n          const otherCanceled = forBranch2 ? canceled1 : canceled2;\n\n          if (!otherCanceled) {\n            let clonedChunk;\n            try {\n              clonedChunk = CloneAsUint8Array(chunk);\n            } catch (cloneE) {\n              ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n              ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n              return;\n            }\n            if (!byobCanceled) {\n              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n            }\n            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n          } else if (!byobCanceled) {\n            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n          }\n\n          reading = false;\n          if (readAgainForBranch1) {\n            pull1Algorithm();\n          } else if (readAgainForBranch2) {\n            pull2Algorithm();\n          }\n        });\n      },\n      _closeSteps: chunk => {\n        reading = false;\n\n        const byobCanceled = forBranch2 ? canceled2 : canceled1;\n        const otherCanceled = forBranch2 ? canceled1 : canceled2;\n\n        if (!byobCanceled) {\n          ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n        }\n        if (!otherCanceled) {\n          ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n        }\n\n        if (chunk !== undefined) {\n          assert(chunk.byteLength === 0);\n\n          if (!byobCanceled) {\n            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n          }\n          if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n          }\n        }\n\n        if (!byobCanceled || !otherCanceled) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);\n  }\n\n  function pull1Algorithm(): Promise<void> {\n    if (reading) {\n      readAgainForBranch1 = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n    if (byobRequest === null) {\n      pullWithDefaultReader();\n    } else {\n      pullWithBYOBReader(byobRequest._view!, false);\n    }\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function pull2Algorithm(): Promise<void> {\n    if (reading) {\n      readAgainForBranch2 = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n    if (byobRequest === null) {\n      pullWithDefaultReader();\n    } else {\n      pullWithBYOBReader(byobRequest._view!, true);\n    }\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function cancel1Algorithm(reason: any): Promise<void> {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason: any): Promise<void> {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm(): void {\n    return;\n  }\n\n  branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n  branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n\n  forwardReaderError(reader);\n\n  return [branch1, branch2];\n}\n", "import { assertDictionary, assertFunction, convertUnsignedLongLongWithEnforceRange } from './basic';\nimport {\n  ReadableStreamController,\n  UnderlyingByteSource,\n  UnderlyingDefaultOrByteSource,\n  UnderlyingDefaultOrByteSourcePullCallback,\n  UnderlyingDefaultOrByteSourceStartCallback,\n  UnderlyingSource,\n  UnderlyingSourceCancelCallback,\n  ValidatedUnderlyingDefaultOrByteSource\n} from '../readable-stream/underlying-source';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\n\nexport function convertUnderlyingDefaultOrByteSource<R>(\n  source: UnderlyingSource<R> | UnderlyingByteSource | null,\n  context: string\n): ValidatedUnderlyingDefaultOrByteSource<R> {\n  assertDictionary(source, context);\n  const original = source as (UnderlyingDefaultOrByteSource<R> | null);\n  const autoAllocateChunkSize = original?.autoAllocateChunkSize;\n  const cancel = original?.cancel;\n  const pull = original?.pull;\n  const start = original?.start;\n  const type = original?.type;\n  return {\n    autoAllocateChunkSize: autoAllocateChunkSize === undefined ?\n      undefined :\n      convertUnsignedLongLongWithEnforceRange(\n        autoAllocateChunkSize,\n        `${context} has member 'autoAllocateChunkSize' that`\n      ),\n    cancel: cancel === undefined ?\n      undefined :\n      convertUnderlyingSourceCancelCallback(cancel, original!, `${context} has member 'cancel' that`),\n    pull: pull === undefined ?\n      undefined :\n      convertUnderlyingSourcePullCallback(pull, original!, `${context} has member 'pull' that`),\n    start: start === undefined ?\n      undefined :\n      convertUnderlyingSourceStartCallback(start, original!, `${context} has member 'start' that`),\n    type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n  };\n}\n\nfunction convertUnderlyingSourceCancelCallback(\n  fn: UnderlyingSourceCancelCallback,\n  original: UnderlyingDefaultOrByteSource,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n\nfunction convertUnderlyingSourcePullCallback<R>(\n  fn: UnderlyingDefaultOrByteSourcePullCallback<R>,\n  original: UnderlyingDefaultOrByteSource<R>,\n  context: string\n): (controller: ReadableStreamController<R>) => Promise<void> {\n  assertFunction(fn, context);\n  return (controller: ReadableStreamController<R>) => promiseCall(fn, original, [controller]);\n}\n\nfunction convertUnderlyingSourceStartCallback<R>(\n  fn: UnderlyingDefaultOrByteSourceStartCallback<R>,\n  original: UnderlyingDefaultOrByteSource<R>,\n  context: string\n): UnderlyingDefaultOrByteSourceStartCallback<R> {\n  assertFunction(fn, context);\n  return (controller: ReadableStreamController<R>) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertReadableStreamType(type: string, context: string): 'bytes' {\n  type = `${type}`;\n  if (type !== 'bytes') {\n    throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n  }\n  return type;\n}\n", "import { assertDictionary } from './basic';\nimport { ReadableStreamGetReaderOptions } from '../readable-stream/reader-options';\n\nexport function convertReaderOptions(options: ReadableStreamGetReaderOptions | null | undefined,\n                                     context: string): ReadableStreamGetReaderOptions {\n  assertDictionary(options, context);\n  const mode = options?.mode;\n  return {\n    mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n  };\n}\n\nfunction convertReadableStreamReaderMode(mode: string, context: string): 'byob' {\n  mode = `${mode}`;\n  if (mode !== 'byob') {\n    throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n  }\n  return mode;\n}\n", "import { assertDictionary } from './basic';\nimport {\n  ReadableStreamIteratorOptions,\n  ValidatedReadableStreamIteratorOptions\n} from '../readable-stream/iterator-options';\n\nexport function convertIteratorOptions(options: ReadableStreamIteratorOptions | null | undefined,\n                                       context: string): ValidatedReadableStreamIteratorOptions {\n  assertDictionary(options, context);\n  const preventCancel = options?.preventCancel;\n  return { preventCancel: Boolean(preventCancel) };\n}\n", "import { assertDictionary } from './basic';\nimport { StreamPipeOptions, ValidatedStreamPipeOptions } from '../readable-stream/pipe-options';\nimport { AbortSignal, isAbortSignal } from '../abort-signal';\n\nexport function convertPipeOptions(options: StreamPipeOptions | null | undefined,\n                                   context: string): ValidatedStreamPipeOptions {\n  assertDictionary(options, context);\n  const preventAbort = options?.preventAbort;\n  const preventCancel = options?.preventCancel;\n  const preventClose = options?.preventClose;\n  const signal = options?.signal;\n  if (signal !== undefined) {\n    assertAbortSignal(signal, `${context} has member 'signal' that`);\n  }\n  return {\n    preventAbort: Boolean(preventAbort),\n    preventCancel: Boolean(preventCancel),\n    preventClose: Boolean(preventClose),\n    signal\n  };\n}\n\nfunction assertAbortSignal(signal: unknown, context: string): asserts signal is AbortSignal {\n  if (!isAbortSignal(signal)) {\n    throw new TypeError(`${context} is not an AbortSignal.`);\n  }\n}\n", "import { assertDictionary, assertRequiredField } from './basic';\nimport { ReadableStream } from '../readable-stream';\nimport { WritableStream } from '../writable-stream';\nimport { assertReadableStream } from './readable-stream';\nimport { assertWritableStream } from './writable-stream';\n\nexport function convertReadableWritablePair<RS extends ReadableStream, WS extends WritableStream>(\n  pair: { readable: RS; writable: WS } | null | undefined,\n  context: string\n): { readable: RS; writable: WS } {\n  assertDictionary(pair, context);\n\n  const readable = pair?.readable;\n  assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n  assertReadableStream(readable, `${context} has member 'readable' that`);\n\n  const writable = pair?.writable;\n  assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n  assertWritableStream(writable, `${context} has member 'writable' that`);\n\n  return { readable, writable };\n}\n", "import assert from '../stub/assert';\nimport {\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  transformPromiseWith\n} from './helpers/webidl';\nimport { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { AcquireReadableStreamAsyncIterator, ReadableStreamAsyncIterator } from './readable-stream/async-iterator';\nimport { defaultReaderClosedPromiseReject, defaultReaderClosedPromiseResolve } from './readable-stream/generic-reader';\nimport {\n  AcquireReadableStreamDefaultReader,\n  IsReadableStreamDefaultReader,\n  ReadableStreamDefaultReader,\n  ReadableStreamDefaultReadResult\n} from './readable-stream/default-reader';\nimport {\n  AcquireReadableStreamBYOBReader,\n  IsReadableStreamBYOBReader,\n  ReadableStreamBYOBReader,\n  ReadableStreamBYOBReadResult\n} from './readable-stream/byob-reader';\nimport { ReadableStreamPipeTo } from './readable-stream/pipe';\nimport { ReadableStreamTee } from './readable-stream/tee';\nimport { IsWritableStream, IsWritableStreamLocked, WritableStream } from './writable-stream';\nimport { SimpleQueue } from './simple-queue';\nimport {\n  ReadableByteStreamController,\n  ReadableStreamBYOBRequest,\n  SetUpReadableByteStreamController,\n  SetUpReadableByteStreamControllerFromUnderlyingSource\n} from './readable-stream/byte-stream-controller';\nimport {\n  ReadableStreamDefaultController,\n  SetUpReadableStreamDefaultController,\n  SetUpReadableStreamDefaultControllerFromUnderlyingSource\n} from './readable-stream/default-controller';\nimport {\n  UnderlyingByteSource,\n  UnderlyingByteSourcePullCallback,\n  UnderlyingByteSourceStartCallback,\n  UnderlyingSource,\n  UnderlyingSourceCancelCallback,\n  UnderlyingSourcePullCallback,\n  UnderlyingSourceStartCallback\n} from './readable-stream/underlying-source';\nimport { noop } from '../utils';\nimport { typeIsObject } from './helpers/miscellaneous';\nimport { CreateArrayFromList } from './abstract-ops/ecmascript';\nimport { CancelSteps } from './abstract-ops/internal-methods';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { assertObject, assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport { convertUnderlyingDefaultOrByteSource } from './validators/underlying-source';\nimport { ReadableStreamGetReaderOptions } from './readable-stream/reader-options';\nimport { convertReaderOptions } from './validators/reader-options';\nimport { StreamPipeOptions, ValidatedStreamPipeOptions } from './readable-stream/pipe-options';\nimport { ReadableStreamIteratorOptions } from './readable-stream/iterator-options';\nimport { convertIteratorOptions } from './validators/iterator-options';\nimport { convertPipeOptions } from './validators/pipe-options';\nimport { ReadableWritablePair } from './readable-stream/readable-writable-pair';\nimport { convertReadableWritablePair } from './validators/readable-writable-pair';\n\nexport type ReadableByteStream = ReadableStream<Uint8Array> & {\n  _readableStreamController: ReadableByteStreamController\n};\n\ntype ReadableStreamState = 'readable' | 'closed' | 'errored';\n\n/**\n * A readable stream represents a source of data, from which you can read.\n *\n * @public\n */\nexport class ReadableStream<R = any> {\n  /** @internal */\n  _state!: ReadableStreamState;\n  /** @internal */\n  _reader: ReadableStreamReader<R> | undefined;\n  /** @internal */\n  _storedError: any;\n  /** @internal */\n  _disturbed!: boolean;\n  /** @internal */\n  _readableStreamController!: ReadableStreamDefaultController<R> | ReadableByteStreamController;\n\n  constructor(underlyingSource: UnderlyingByteSource, strategy?: { highWaterMark?: number; size?: undefined });\n  constructor(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>);\n  constructor(rawUnderlyingSource: UnderlyingSource<R> | UnderlyingByteSource | null | undefined = {},\n              rawStrategy: QueuingStrategy<R> | null | undefined = {}) {\n    if (rawUnderlyingSource === undefined) {\n      rawUnderlyingSource = null;\n    } else {\n      assertObject(rawUnderlyingSource, 'First parameter');\n    }\n\n    const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n    const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n\n    InitializeReadableStream(this);\n\n    if (underlyingSource.type === 'bytes') {\n      if (strategy.size !== undefined) {\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\n      }\n      const highWaterMark = ExtractHighWaterMark(strategy, 0);\n      SetUpReadableByteStreamControllerFromUnderlyingSource(\n        this as unknown as ReadableByteStream,\n        underlyingSource,\n        highWaterMark\n      );\n    } else {\n      assert(underlyingSource.type === undefined);\n      const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n      const highWaterMark = ExtractHighWaterMark(strategy, 1);\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(\n        this,\n        underlyingSource,\n        highWaterMark,\n        sizeAlgorithm\n      );\n    }\n  }\n\n  /**\n   * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n   */\n  get locked(): boolean {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsReadableStreamLocked(this);\n  }\n\n  /**\n   * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n   *\n   * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n   * method, which might or might not use it.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  }\n\n  /**\n   * Creates a {@link ReadableStreamBYOBReader} and locks the stream to the new reader.\n   *\n   * This call behaves the same way as the no-argument variant, except that it only works on readable byte streams,\n   * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n   * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n   * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n   * control over allocation.\n   */\n  getReader({ mode }: { mode: 'byob' }): ReadableStreamBYOBReader;\n  /**\n   * Creates a {@link ReadableStreamDefaultReader} and locks the stream to the new reader.\n   * While the stream is locked, no other reader can be acquired until this one is released.\n   *\n   * This functionality is especially useful for creating abstractions that desire the ability to consume a stream\n   * in its entirety. By getting a reader for the stream, you can ensure nobody else can interleave reads with yours\n   * or cancel the stream, which would interfere with your abstraction.\n   */\n  getReader(): ReadableStreamDefaultReader<R>;\n  getReader(\n    rawOptions: ReadableStreamGetReaderOptions | null | undefined = undefined\n  ): ReadableStreamDefaultReader<R> | ReadableStreamBYOBReader {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('getReader');\n    }\n\n    const options = convertReaderOptions(rawOptions, 'First parameter');\n\n    if (options.mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    assert(options.mode === 'byob');\n    return AcquireReadableStreamBYOBReader(this as unknown as ReadableByteStream);\n  }\n\n  /**\n   * Provides a convenient, chainable way of piping this readable stream through a transform stream\n   * (or any other `{ writable, readable }` pair). It simply {@link ReadableStream.pipeTo | pipes} the stream\n   * into the writable side of the supplied pair, and returns the readable side for further use.\n   *\n   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   */\n  pipeThrough<RS extends ReadableStream>(\n    transform: { readable: RS; writable: WritableStream<R> },\n    options?: StreamPipeOptions\n  ): RS;\n  pipeThrough<RS extends ReadableStream>(\n    rawTransform: { readable: RS; writable: WritableStream<R> } | null | undefined,\n    rawOptions: StreamPipeOptions | null | undefined = {}\n  ): RS {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('pipeThrough');\n    }\n    assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n\n    const transform = convertReadableWritablePair(rawTransform, 'First parameter');\n    const options = convertPipeOptions(rawOptions, 'Second parameter');\n\n    if (IsReadableStreamLocked(this)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n    }\n    if (IsWritableStreamLocked(transform.writable)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n    }\n\n    const promise = ReadableStreamPipeTo(\n      this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal\n    );\n\n    setPromiseIsHandledToTrue(promise);\n\n    return transform.readable;\n  }\n\n  /**\n   * Pipes this readable stream to a given writable stream. The way in which the piping process behaves under\n   * various error conditions can be customized with a number of passed options. It returns a promise that fulfills\n   * when the piping process completes successfully, or rejects if any errors were encountered.\n   *\n   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   */\n  pipeTo(destination: WritableStream<R>, options?: StreamPipeOptions): Promise<void>;\n  pipeTo(destination: WritableStream<R> | null | undefined,\n         rawOptions: StreamPipeOptions | null | undefined = {}): Promise<void> {\n    if (!IsReadableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('pipeTo'));\n    }\n\n    if (destination === undefined) {\n      return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n    }\n    if (!IsWritableStream(destination)) {\n      return promiseRejectedWith(\n        new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`)\n      );\n    }\n\n    let options: ValidatedStreamPipeOptions;\n    try {\n      options = convertPipeOptions(rawOptions, 'Second parameter');\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n\n    if (IsReadableStreamLocked(this)) {\n      return promiseRejectedWith(\n        new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream')\n      );\n    }\n    if (IsWritableStreamLocked(destination)) {\n      return promiseRejectedWith(\n        new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream')\n      );\n    }\n\n    return ReadableStreamPipeTo<R>(\n      this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal\n    );\n  }\n\n  /**\n   * Tees this readable stream, returning a two-element array containing the two resulting branches as\n   * new {@link ReadableStream} instances.\n   *\n   * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n   * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n   * propagated to the stream's underlying source.\n   *\n   * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n   * this could allow interference between the two branches.\n   */\n  tee(): [ReadableStream<R>, ReadableStream<R>] {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('tee');\n    }\n\n    const branches = ReadableStreamTee(this, false);\n    return CreateArrayFromList(branches);\n  }\n\n  /**\n   * Asynchronously iterates over the chunks in the stream's internal queue.\n   *\n   * Asynchronously iterating over the stream will lock it, preventing any other consumer from acquiring a reader.\n   * The lock will be released if the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method\n   * is called, e.g. by breaking out of the loop.\n   *\n   * By default, calling the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method will also\n   * cancel the stream. To prevent this, use the stream's {@link ReadableStream.values | values()} method, passing\n   * `true` for the `preventCancel` option.\n   */\n  values(options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n  values(rawOptions: ReadableStreamIteratorOptions | null | undefined = undefined): ReadableStreamAsyncIterator<R> {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('values');\n    }\n\n    const options = convertIteratorOptions(rawOptions, 'First parameter');\n    return AcquireReadableStreamAsyncIterator<R>(this, options.preventCancel);\n  }\n\n  /**\n   * {@inheritDoc ReadableStream.values}\n   */\n  [Symbol.asyncIterator]: (options?: ReadableStreamIteratorOptions) => ReadableStreamAsyncIterator<R>;\n}\n\nObject.defineProperties(ReadableStream.prototype, {\n  cancel: { enumerable: true },\n  getReader: { enumerable: true },\n  pipeThrough: { enumerable: true },\n  pipeTo: { enumerable: true },\n  tee: { enumerable: true },\n  values: { enumerable: true },\n  locked: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, {\n    value: 'ReadableStream',\n    configurable: true\n  });\n}\nif (typeof Symbol.asyncIterator === 'symbol') {\n  Object.defineProperty(ReadableStream.prototype, Symbol.asyncIterator, {\n    value: ReadableStream.prototype.values,\n    writable: true,\n    configurable: true\n  });\n}\n\nexport {\n  ReadableStreamAsyncIterator,\n  ReadableStreamDefaultReadResult,\n  ReadableStreamBYOBReadResult,\n  UnderlyingByteSource,\n  UnderlyingSource,\n  UnderlyingSourceStartCallback,\n  UnderlyingSourcePullCallback,\n  UnderlyingSourceCancelCallback,\n  UnderlyingByteSourceStartCallback,\n  UnderlyingByteSourcePullCallback,\n  StreamPipeOptions,\n  ReadableWritablePair,\n  ReadableStreamIteratorOptions\n};\n\n// Abstract operations for the ReadableStream.\n\n// Throws if and only if startAlgorithm throws.\nexport function CreateReadableStream<R>(startAlgorithm: () => void | PromiseLike<void>,\n                                        pullAlgorithm: () => Promise<void>,\n                                        cancelAlgorithm: (reason: any) => Promise<void>,\n                                        highWaterMark = 1,\n                                        sizeAlgorithm: QueuingStrategySizeCallback<R> = () => 1): ReadableStream<R> {\n  assert(IsNonNegativeNumber(highWaterMark));\n\n  const stream: ReadableStream<R> = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller: ReadableStreamDefaultController<R> = Object.create(ReadableStreamDefaultController.prototype);\n  SetUpReadableStreamDefaultController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n\n  return stream;\n}\n\n// Throws if and only if startAlgorithm throws.\nexport function CreateReadableByteStream(\n  startAlgorithm: () => void | PromiseLike<void>,\n  pullAlgorithm: () => Promise<void>,\n  cancelAlgorithm: (reason: any) => Promise<void>\n): ReadableByteStream {\n  const stream: ReadableByteStream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller: ReadableByteStreamController = Object.create(ReadableByteStreamController.prototype);\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n\n  return stream;\n}\n\nfunction InitializeReadableStream(stream: ReadableStream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\n\nexport function IsReadableStream(x: unknown): x is ReadableStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return x instanceof ReadableStream;\n}\n\nexport function IsReadableStreamDisturbed(stream: ReadableStream): boolean {\n  assert(IsReadableStream(stream));\n\n  return stream._disturbed;\n}\n\nexport function IsReadableStreamLocked(stream: ReadableStream): boolean {\n  assert(IsReadableStream(stream));\n\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamCancel<R>(stream: ReadableStream<R>, reason: any): Promise<undefined> {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return promiseResolvedWith(undefined);\n  }\n  if (stream._state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  const reader = stream._reader;\n  if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n    reader._readIntoRequests.forEach(readIntoRequest => {\n      readIntoRequest._closeSteps(undefined);\n    });\n    reader._readIntoRequests = new SimpleQueue();\n  }\n\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n  return transformPromiseWith(sourceCancelPromise, noop);\n}\n\nexport function ReadableStreamClose<R>(stream: ReadableStream<R>): void {\n  assert(stream._state === 'readable');\n\n  stream._state = 'closed';\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return;\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n\n  if (IsReadableStreamDefaultReader<R>(reader)) {\n    reader._readRequests.forEach(readRequest => {\n      readRequest._closeSteps();\n    });\n    reader._readRequests = new SimpleQueue();\n  }\n}\n\nexport function ReadableStreamError<R>(stream: ReadableStream<R>, e: any): void {\n  assert(IsReadableStream(stream));\n  assert(stream._state === 'readable');\n\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return;\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n\n  if (IsReadableStreamDefaultReader<R>(reader)) {\n    reader._readRequests.forEach(readRequest => {\n      readRequest._errorSteps(e);\n    });\n\n    reader._readRequests = new SimpleQueue();\n  } else {\n    assert(IsReadableStreamBYOBReader(reader));\n\n    reader._readIntoRequests.forEach(readIntoRequest => {\n      readIntoRequest._errorSteps(e);\n    });\n\n    reader._readIntoRequests = new SimpleQueue();\n  }\n}\n\n// Readers\n\nexport type ReadableStreamReader<R> = ReadableStreamDefaultReader<R> | ReadableStreamBYOBReader;\n\nexport {\n  ReadableStreamDefaultReader,\n  ReadableStreamBYOBReader\n};\n\n// Controllers\n\nexport {\n  ReadableStreamDefaultController,\n  ReadableStreamBYOBRequest,\n  ReadableByteStreamController\n};\n\n// Helper functions for the ReadableStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n", "import { QueuingStrategyInit } from '../queuing-strategy';\nimport { assertDictionary, assertRequiredField, convertUnrestrictedDouble } from './basic';\n\nexport function convertQueuingStrategyInit(init: QueuingStrategyInit | null | undefined,\n                                           context: string): QueuingStrategyInit {\n  assertDictionary(init, context);\n  const highWaterMark = init?.highWaterMark;\n  assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n  return {\n    highWaterMark: convertUnrestrictedDouble(highWaterMark)\n  };\n}\n", "import { QueuingStrategy, QueuingStrategyInit } from './queuing-strategy';\nimport { typeIsObject } from './helpers/miscellaneous';\nimport { assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategyInit } from './validators/queuing-strategy-init';\n\n// The size function must not have a prototype property nor be a constructor\nconst byteLengthSizeFunction = (chunk: ArrayBufferView): number => {\n  return chunk.byteLength;\n};\ntry {\n  Object.defineProperty(byteLengthSizeFunction, 'name', {\n    value: 'size',\n    configurable: true\n  });\n} catch {\n  // This property is non-configurable in older browsers, so ignore if this throws.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n}\n\n/**\n * A queuing strategy that counts the number of bytes in each chunk.\n *\n * @public\n */\nexport default class ByteLengthQueuingStrategy implements QueuingStrategy<ArrayBufferView> {\n  /** @internal */\n  readonly _byteLengthQueuingStrategyHighWaterMark: number;\n\n  constructor(options: QueuingStrategyInit) {\n    assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n    options = convertQueuingStrategyInit(options, 'First parameter');\n    this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n  }\n\n  /**\n   * Returns the high water mark provided to the constructor.\n   */\n  get highWaterMark(): number {\n    if (!IsByteLengthQueuingStrategy(this)) {\n      throw byteLengthBrandCheckException('highWaterMark');\n    }\n    return this._byteLengthQueuingStrategyHighWaterMark;\n  }\n\n  /**\n   * Measures the size of `chunk` by returning the value of its `byteLength` property.\n   */\n  get size(): (chunk: ArrayBufferView) => number {\n    if (!IsByteLengthQueuingStrategy(this)) {\n      throw byteLengthBrandCheckException('size');\n    }\n    return byteLengthSizeFunction;\n  }\n}\n\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, {\n  highWaterMark: { enumerable: true },\n  size: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {\n    value: 'ByteLengthQueuingStrategy',\n    configurable: true\n  });\n}\n\n// Helper functions for the ByteLengthQueuingStrategy.\n\nfunction byteLengthBrandCheckException(name: string): TypeError {\n  return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n}\n\nexport function IsByteLengthQueuingStrategy(x: any): x is ByteLengthQueuingStrategy {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n    return false;\n  }\n\n  return x instanceof ByteLengthQueuingStrategy;\n}\n", "import { QueuingStrategy, QueuingStrategyInit } from './queuing-strategy';\nimport { typeIsObject } from './helpers/miscellaneous';\nimport { assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategyInit } from './validators/queuing-strategy-init';\n\n// The size function must not have a prototype property nor be a constructor\nconst countSizeFunction = (): 1 => {\n  return 1;\n};\ntry {\n  Object.defineProperty(countSizeFunction, 'name', {\n    value: 'size',\n    configurable: true\n  });\n} catch {\n  // This property is non-configurable in older browsers, so ignore if this throws.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n}\n\n/**\n * A queuing strategy that counts the number of chunks.\n *\n * @public\n */\nexport default class CountQueuingStrategy implements QueuingStrategy<any> {\n  /** @internal */\n  readonly _countQueuingStrategyHighWaterMark!: number;\n\n  constructor(options: QueuingStrategyInit) {\n    assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n    options = convertQueuingStrategyInit(options, 'First parameter');\n    this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n  }\n\n  /**\n   * Returns the high water mark provided to the constructor.\n   */\n  get highWaterMark(): number {\n    if (!IsCountQueuingStrategy(this)) {\n      throw countBrandCheckException('highWaterMark');\n    }\n    return this._countQueuingStrategyHighWaterMark;\n  }\n\n  /**\n   * Measures the size of `chunk` by always returning 1.\n   * This ensures that the total queue size is a count of the number of chunks in the queue.\n   */\n  get size(): (chunk: any) => 1 {\n    if (!IsCountQueuingStrategy(this)) {\n      throw countBrandCheckException('size');\n    }\n    return countSizeFunction;\n  }\n}\n\nObject.defineProperties(CountQueuingStrategy.prototype, {\n  highWaterMark: { enumerable: true },\n  size: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {\n    value: 'CountQueuingStrategy',\n    configurable: true\n  });\n}\n\n// Helper functions for the CountQueuingStrategy.\n\nfunction countBrandCheckException(name: string): TypeError {\n  return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n}\n\nexport function IsCountQueuingStrategy(x: any): x is CountQueuingStrategy {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n    return false;\n  }\n\n  return x instanceof CountQueuingStrategy;\n}\n", "import { assertDictionary, assertFunction } from './basic';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\nimport {\n  Transformer,\n  TransformerFlushCallback,\n  TransformerStartCallback,\n  TransformerTransformCallback,\n  ValidatedTransformer\n} from '../transform-stream/transformer';\nimport { TransformStreamDefaultController } from '../transform-stream';\n\nexport function convertTransformer<I, O>(original: Transformer<I, O> | null,\n                                         context: string): ValidatedTransformer<I, O> {\n  assertDictionary(original, context);\n  const flush = original?.flush;\n  const readableType = original?.readableType;\n  const start = original?.start;\n  const transform = original?.transform;\n  const writableType = original?.writableType;\n  return {\n    flush: flush === undefined ?\n      undefined :\n      convertTransformerFlushCallback(flush, original!, `${context} has member 'flush' that`),\n    readableType,\n    start: start === undefined ?\n      undefined :\n      convertTransformerStartCallback(start, original!, `${context} has member 'start' that`),\n    transform: transform === undefined ?\n      undefined :\n      convertTransformerTransformCallback(transform, original!, `${context} has member 'transform' that`),\n    writableType\n  };\n}\n\nfunction convertTransformerFlushCallback<I, O>(\n  fn: TransformerFlushCallback<O>,\n  original: Transformer<I, O>,\n  context: string\n): (controller: TransformStreamDefaultController<O>) => Promise<void> {\n  assertFunction(fn, context);\n  return (controller: TransformStreamDefaultController<O>) => promiseCall(fn, original, [controller]);\n}\n\nfunction convertTransformerStartCallback<I, O>(\n  fn: TransformerStartCallback<O>,\n  original: Transformer<I, O>,\n  context: string\n): TransformerStartCallback<O> {\n  assertFunction(fn, context);\n  return (controller: TransformStreamDefaultController<O>) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertTransformerTransformCallback<I, O>(\n  fn: TransformerTransformCallback<I, O>,\n  original: Transformer<I, O>,\n  context: string\n): (chunk: I, controller: TransformStreamDefaultController<O>) => Promise<void> {\n  assertFunction(fn, context);\n  return (chunk: I, controller: TransformStreamDefaultController<O>) => promiseCall(fn, original, [chunk, controller]);\n}\n", "import assert from '../stub/assert';\nimport { newPromise, promiseRejectedWith, promiseResolvedWith, transformPromiseWith } from './helpers/webidl';\nimport { CreateReadableStream, ReadableStream, ReadableStreamDefaultController } from './readable-stream';\nimport {\n  ReadableStreamDefaultControllerCanCloseOrEnqueue,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize,\n  ReadableStreamDefaultControllerHasBackpressure\n} from './readable-stream/default-controller';\nimport { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { CreateWritableStream, WritableStream, WritableStreamDefaultControllerErrorIfNeeded } from './writable-stream';\nimport { typeIsObject } from './helpers/miscellaneous';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport {\n  Transformer,\n  TransformerFlushCallback,\n  TransformerStartCallback,\n  TransformerTransformCallback,\n  ValidatedTransformer\n} from './transform-stream/transformer';\nimport { convertTransformer } from './validators/transformer';\n\n// Class TransformStream\n\n/**\n * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n * made available for reading from the readable side.\n *\n * @public\n */\nexport class TransformStream<I = any, O = any> {\n  /** @internal */\n  _writable!: WritableStream<I>;\n  /** @internal */\n  _readable!: ReadableStream<O>;\n  /** @internal */\n  _backpressure!: boolean;\n  /** @internal */\n  _backpressureChangePromise!: Promise<void>;\n  /** @internal */\n  _backpressureChangePromise_resolve!: () => void;\n  /** @internal */\n  _transformStreamController!: TransformStreamDefaultController<O>;\n\n  constructor(\n    transformer?: Transformer<I, O>,\n    writableStrategy?: QueuingStrategy<I>,\n    readableStrategy?: QueuingStrategy<O>\n  );\n  constructor(rawTransformer: Transformer<I, O> | null | undefined = {},\n              rawWritableStrategy: QueuingStrategy<I> | null | undefined = {},\n              rawReadableStrategy: QueuingStrategy<O> | null | undefined = {}) {\n    if (rawTransformer === undefined) {\n      rawTransformer = null;\n    }\n\n    const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n    const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n\n    const transformer = convertTransformer(rawTransformer, 'First parameter');\n    if (transformer.readableType !== undefined) {\n      throw new RangeError('Invalid readableType specified');\n    }\n    if (transformer.writableType !== undefined) {\n      throw new RangeError('Invalid writableType specified');\n    }\n\n    const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n    const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n    const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n    const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n\n    let startPromise_resolve!: (value: void | PromiseLike<void>) => void;\n    const startPromise = newPromise<void>(resolve => {\n      startPromise_resolve = resolve;\n    });\n\n    InitializeTransformStream(\n      this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm\n    );\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n\n    if (transformer.start !== undefined) {\n      startPromise_resolve(transformer.start(this._transformStreamController));\n    } else {\n      startPromise_resolve(undefined);\n    }\n  }\n\n  /**\n   * The readable side of the transform stream.\n   */\n  get readable(): ReadableStream<O> {\n    if (!IsTransformStream(this)) {\n      throw streamBrandCheckException('readable');\n    }\n\n    return this._readable;\n  }\n\n  /**\n   * The writable side of the transform stream.\n   */\n  get writable(): WritableStream<I> {\n    if (!IsTransformStream(this)) {\n      throw streamBrandCheckException('writable');\n    }\n\n    return this._writable;\n  }\n}\n\nObject.defineProperties(TransformStream.prototype, {\n  readable: { enumerable: true },\n  writable: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {\n    value: 'TransformStream',\n    configurable: true\n  });\n}\n\nexport {\n  Transformer,\n  TransformerStartCallback,\n  TransformerFlushCallback,\n  TransformerTransformCallback\n};\n\n// Transform Stream Abstract Operations\n\nexport function CreateTransformStream<I, O>(startAlgorithm: () => void | PromiseLike<void>,\n                                            transformAlgorithm: (chunk: I) => Promise<void>,\n                                            flushAlgorithm: () => Promise<void>,\n                                            writableHighWaterMark = 1,\n                                            writableSizeAlgorithm: QueuingStrategySizeCallback<I> = () => 1,\n                                            readableHighWaterMark = 0,\n                                            readableSizeAlgorithm: QueuingStrategySizeCallback<O> = () => 1) {\n  assert(IsNonNegativeNumber(writableHighWaterMark));\n  assert(IsNonNegativeNumber(readableHighWaterMark));\n\n  const stream: TransformStream<I, O> = Object.create(TransformStream.prototype);\n\n  let startPromise_resolve!: (value: void | PromiseLike<void>) => void;\n  const startPromise = newPromise<void>(resolve => {\n    startPromise_resolve = resolve;\n  });\n\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                            readableSizeAlgorithm);\n\n  const controller: TransformStreamDefaultController<O> = Object.create(TransformStreamDefaultController.prototype);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n\n  const startResult = startAlgorithm();\n  startPromise_resolve(startResult);\n  return stream;\n}\n\nfunction InitializeTransformStream<I, O>(stream: TransformStream<I, O>,\n                                         startPromise: Promise<void>,\n                                         writableHighWaterMark: number,\n                                         writableSizeAlgorithm: QueuingStrategySizeCallback<I>,\n                                         readableHighWaterMark: number,\n                                         readableSizeAlgorithm: QueuingStrategySizeCallback<O>) {\n  function startAlgorithm(): Promise<void> {\n    return startPromise;\n  }\n\n  function writeAlgorithm(chunk: I): Promise<void> {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n\n  function abortAlgorithm(reason: any): Promise<void> {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n\n  function closeAlgorithm(): Promise<void> {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\n                                          writableHighWaterMark, writableSizeAlgorithm);\n\n  function pullAlgorithm(): Promise<void> {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n\n  function cancelAlgorithm(reason: any): Promise<void> {\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n    return promiseResolvedWith(undefined);\n  }\n\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\n                                          readableSizeAlgorithm);\n\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  stream._backpressure = undefined!;\n  stream._backpressureChangePromise = undefined!;\n  stream._backpressureChangePromise_resolve = undefined!;\n  TransformStreamSetBackpressure(stream, true);\n\n  stream._transformStreamController = undefined!;\n}\n\nfunction IsTransformStream(x: unknown): x is TransformStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return x instanceof TransformStream;\n}\n\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream: TransformStream, e: any) {\n  ReadableStreamDefaultControllerError(\n    stream._readable._readableStreamController as ReadableStreamDefaultController<any>,\n    e\n  );\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\n\nfunction TransformStreamErrorWritableAndUnblockWrite(stream: TransformStream, e: any) {\n  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n  if (stream._backpressure) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\n\nfunction TransformStreamSetBackpressure(stream: TransformStream, backpressure: boolean) {\n  // Passes also when called during construction.\n  assert(stream._backpressure !== backpressure);\n\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n\n  stream._backpressureChangePromise = newPromise(resolve => {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n\n  stream._backpressure = backpressure;\n}\n\n// Class TransformStreamDefaultController\n\n/**\n * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n *\n * @public\n */\nexport class TransformStreamDefaultController<O> {\n  /** @internal */\n  _controlledTransformStream: TransformStream<any, O>;\n  /** @internal */\n  _transformAlgorithm: (chunk: any) => Promise<void>;\n  /** @internal */\n  _flushAlgorithm: () => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the desired size to fill the readable side\u2019s internal queue. It can be negative, if the queue is over-full.\n   */\n  get desiredSize(): number | null {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController as ReadableStreamDefaultController<O>);\n  }\n\n  /**\n   * Enqueues the given chunk `chunk` in the readable side of the controlled transform stream.\n   */\n  enqueue(chunk: O): void;\n  enqueue(chunk: O = undefined!): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors both the readable side and the writable side of the controlled transform stream, making all future\n   * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n   */\n  error(reason: any = undefined): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    TransformStreamDefaultControllerError(this, reason);\n  }\n\n  /**\n   * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n   * transformer only needs to consume a portion of the chunks written to the writable side.\n   */\n  terminate(): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('terminate');\n    }\n\n    TransformStreamDefaultControllerTerminate(this);\n  }\n}\n\nObject.defineProperties(TransformStreamDefaultController.prototype, {\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  terminate: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'TransformStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Transform Stream Default Controller Abstract Operations\n\nfunction IsTransformStreamDefaultController<O = any>(x: any): x is TransformStreamDefaultController<O> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return x instanceof TransformStreamDefaultController;\n}\n\nfunction SetUpTransformStreamDefaultController<I, O>(stream: TransformStream<I, O>,\n                                                     controller: TransformStreamDefaultController<O>,\n                                                     transformAlgorithm: (chunk: I) => Promise<void>,\n                                                     flushAlgorithm: () => Promise<void>) {\n  assert(IsTransformStream(stream));\n  assert(stream._transformStreamController === undefined);\n\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n}\n\nfunction SetUpTransformStreamDefaultControllerFromTransformer<I, O>(stream: TransformStream<I, O>,\n                                                                    transformer: ValidatedTransformer<I, O>) {\n  const controller: TransformStreamDefaultController<O> = Object.create(TransformStreamDefaultController.prototype);\n\n  let transformAlgorithm = (chunk: I): Promise<void> => {\n    try {\n      TransformStreamDefaultControllerEnqueue(controller, chunk as unknown as O);\n      return promiseResolvedWith(undefined);\n    } catch (transformResultE) {\n      return promiseRejectedWith(transformResultE);\n    }\n  };\n\n  let flushAlgorithm: () => Promise<void> = () => promiseResolvedWith(undefined);\n\n  if (transformer.transform !== undefined) {\n    transformAlgorithm = chunk => transformer.transform!(chunk, controller);\n  }\n  if (transformer.flush !== undefined) {\n    flushAlgorithm = () => transformer.flush!(controller);\n  }\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\n\nfunction TransformStreamDefaultControllerClearAlgorithms(controller: TransformStreamDefaultController<any>) {\n  controller._transformAlgorithm = undefined!;\n  controller._flushAlgorithm = undefined!;\n}\n\nfunction TransformStreamDefaultControllerEnqueue<O>(controller: TransformStreamDefaultController<O>, chunk: O) {\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController as ReadableStreamDefaultController<O>;\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n    throw new TypeError('Readable side is not in a state that permits enqueue');\n  }\n\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n\n  try {\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n\n    throw stream._readable._storedError;\n  }\n\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream._backpressure) {\n    assert(backpressure);\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\n\nfunction TransformStreamDefaultControllerError(controller: TransformStreamDefaultController<any>, e: any) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\n\nfunction TransformStreamDefaultControllerPerformTransform<I, O>(controller: TransformStreamDefaultController<O>,\n                                                                chunk: I) {\n  const transformPromise = controller._transformAlgorithm(chunk);\n  return transformPromiseWith(transformPromise, undefined, r => {\n    TransformStreamError(controller._controlledTransformStream, r);\n    throw r;\n  });\n}\n\nfunction TransformStreamDefaultControllerTerminate<O>(controller: TransformStreamDefaultController<O>) {\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController as ReadableStreamDefaultController<O>;\n\n  ReadableStreamDefaultControllerClose(readableController);\n\n  const error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n\n// TransformStreamDefaultSink Algorithms\n\nfunction TransformStreamDefaultSinkWriteAlgorithm<I, O>(stream: TransformStream<I, O>, chunk: I): Promise<void> {\n  assert(stream._writable._state === 'writable');\n\n  const controller = stream._transformStreamController;\n\n  if (stream._backpressure) {\n    const backpressureChangePromise = stream._backpressureChangePromise;\n    assert(backpressureChangePromise !== undefined);\n    return transformPromiseWith(backpressureChangePromise, () => {\n      const writable = stream._writable;\n      const state = writable._state;\n      if (state === 'erroring') {\n        throw writable._storedError;\n      }\n      assert(state === 'writable');\n      return TransformStreamDefaultControllerPerformTransform<I, O>(controller, chunk);\n    });\n  }\n\n  return TransformStreamDefaultControllerPerformTransform<I, O>(controller, chunk);\n}\n\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream: TransformStream, reason: any): Promise<void> {\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n  // errored.\n  TransformStreamError(stream, reason);\n  return promiseResolvedWith(undefined);\n}\n\nfunction TransformStreamDefaultSinkCloseAlgorithm<I, O>(stream: TransformStream<I, O>): Promise<void> {\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  const controller = stream._transformStreamController;\n  const flushPromise = controller._flushAlgorithm();\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  // Return a promise that is fulfilled with undefined on success.\n  return transformPromiseWith(flushPromise, () => {\n    if (readable._state === 'errored') {\n      throw readable._storedError;\n    }\n    ReadableStreamDefaultControllerClose(readable._readableStreamController as ReadableStreamDefaultController<O>);\n  }, r => {\n    TransformStreamError(stream, r);\n    throw readable._storedError;\n  });\n}\n\n// TransformStreamDefaultSource Algorithms\n\nfunction TransformStreamDefaultSourcePullAlgorithm(stream: TransformStream): Promise<void> {\n  // Invariant. Enforced by the promises returned by start() and pull().\n  assert(stream._backpressure);\n\n  assert(stream._backpressureChangePromise !== undefined);\n\n  TransformStreamSetBackpressure(stream, false);\n\n  // Prevent the next pull() call until there is backpressure.\n  return stream._backpressureChangePromise;\n}\n\n// Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n\n// Helper functions for the TransformStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n", "/* c8 ignore start */\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\nif (!globalThis.ReadableStream) {\n  // `node:stream/web` got introduced in v16.5.0 as experimental\n  // and it's preferred over the polyfilled version. So we also\n  // suppress the warning that gets emitted by NodeJS for using it.\n  try {\n    const process = require('node:process')\n    const { emitWarning } = process\n    try {\n      process.emitWarning = () => {}\n      Object.assign(globalThis, require('node:stream/web'))\n      process.emitWarning = emitWarning\n    } catch (error) {\n      process.emitWarning = emitWarning\n      throw error\n    }\n  } catch (error) {\n    // fallback to polyfill implementation\n    Object.assign(globalThis, require('web-streams-polyfill/dist/ponyfill.es2018.js'))\n  }\n}\n\ntry {\n  // Don't use node: prefix for this, require+node: is not supported until node v14.14\n  // Only `import()` can use prefix in 12.20 and later\n  const { Blob } = require('buffer')\n  if (Blob && !Blob.prototype.stream) {\n    Blob.prototype.stream = function name (params) {\n      let position = 0\n      const blob = this\n\n      return new ReadableStream({\n        type: 'bytes',\n        async pull (ctrl) {\n          const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE))\n          const buffer = await chunk.arrayBuffer()\n          position += buffer.byteLength\n          ctrl.enqueue(new Uint8Array(buffer))\n\n          if (position === blob.size) {\n            ctrl.close()\n          }\n        }\n      })\n    }\n  }\n} catch (error) {}\n/* c8 ignore end */\n", "/*! fetch-blob. MIT License. Jimmy W\u00E4rting <https://jimmy.warting.se/opensource> */\n\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs'\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\n/** @param {(Blob | Uint8Array)[]} parts */\nasync function * toIterator (parts, clone = true) {\n  for (const part of parts) {\n    if ('stream' in part) {\n      yield * (/** @type {AsyncIterableIterator<Uint8Array>} */ (part.stream()))\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        let position = part.byteOffset\n        const end = part.byteOffset + part.byteLength\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE)\n          const chunk = part.buffer.slice(position, position + size)\n          position += chunk.byteLength\n          yield new Uint8Array(chunk)\n        }\n      } else {\n        yield part\n      }\n    /* c8 ignore next 10 */\n    } else {\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n      let position = 0, b = (/** @type {Blob} */ (part))\n      while (position !== b.size) {\n        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE))\n        const buffer = await chunk.arrayBuffer()\n        position += buffer.byteLength\n        yield new Uint8Array(buffer)\n      }\n    }\n  }\n}\n\nconst _Blob = class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n  #parts = []\n  #type = ''\n  #size = 0\n  #endings = 'transparent'\n\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */\n  constructor (blobParts = [], options = {}) {\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.')\n    }\n\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.')\n    }\n\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.')\n    }\n\n    if (options === null) options = {}\n\n    const encoder = new TextEncoder()\n    for (const element of blobParts) {\n      let part\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength))\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0))\n      } else if (element instanceof Blob) {\n        part = element\n      } else {\n        part = encoder.encode(`${element}`)\n      }\n\n      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size\n      this.#parts.push(part)\n    }\n\n    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`\n    const type = options.type === undefined ? '' : String(options.type)\n    this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : ''\n  }\n\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n  get size () {\n    return this.#size\n  }\n\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n  get type () {\n    return this.#type\n  }\n\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n  async text () {\n    // More optimized than using this.arrayBuffer()\n    // that requires twice as much ram\n    const decoder = new TextDecoder()\n    let str = ''\n    for await (const part of toIterator(this.#parts, false)) {\n      str += decoder.decode(part, { stream: true })\n    }\n    // Remaining\n    str += decoder.decode()\n    return str\n  }\n\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n  async arrayBuffer () {\n    // Easier way... Just a unnecessary overhead\n    // const view = new Uint8Array(this.size);\n    // await this.stream().getReader({mode: 'byob'}).read(view);\n    // return view.buffer;\n\n    const data = new Uint8Array(this.size)\n    let offset = 0\n    for await (const chunk of toIterator(this.#parts, false)) {\n      data.set(chunk, offset)\n      offset += chunk.length\n    }\n\n    return data.buffer\n  }\n\n  stream () {\n    const it = toIterator(this.#parts, true)\n\n    return new globalThis.ReadableStream({\n      // @ts-ignore\n      type: 'bytes',\n      async pull (ctrl) {\n        const chunk = await it.next()\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value)\n      },\n\n      async cancel () {\n        await it.return()\n      }\n    })\n  }\n\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n  slice (start = 0, end = this.size, type = '') {\n    const { size } = this\n\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size)\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size)\n\n    const span = Math.max(relativeEnd - relativeStart, 0)\n    const parts = this.#parts\n    const blobParts = []\n    let added = 0\n\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break\n      }\n\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size\n        relativeEnd -= size\n      } else {\n        let chunk\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.byteLength\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.size\n        }\n        relativeEnd -= size\n        blobParts.push(chunk)\n        relativeStart = 0 // All next sequential parts should start at 0\n      }\n    }\n\n    const blob = new Blob([], { type: String(type).toLowerCase() })\n    blob.#size = span\n    blob.#parts = blobParts\n\n    return blob\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return (\n      object &&\n      typeof object === 'object' &&\n      typeof object.constructor === 'function' &&\n      (\n        typeof object.stream === 'function' ||\n        typeof object.arrayBuffer === 'function'\n      ) &&\n      /^(Blob|File)$/.test(object[Symbol.toStringTag])\n    )\n  }\n}\n\nObject.defineProperties(_Blob.prototype, {\n  size: { enumerable: true },\n  type: { enumerable: true },\n  slice: { enumerable: true }\n})\n\n/** @type {typeof globalThis.Blob} */\nexport const Blob = _Blob\nexport default Blob\n", "import Blob from './index.js'\n\nconst _File = class File extends Blob {\n  #lastModified = 0\n  #name = ''\n\n  /**\n   * @param {*[]} fileBits\n   * @param {string} fileName\n   * @param {{lastModified?: number, type?: string}} options\n   */// @ts-ignore\n  constructor (fileBits, fileName, options = {}) {\n    if (arguments.length < 2) {\n      throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`)\n    }\n    super(fileBits, options)\n\n    if (options === null) options = {}\n\n    // Simulate WebIDL type casting for NaN value in lastModified option.\n    const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified)\n    if (!Number.isNaN(lastModified)) {\n      this.#lastModified = lastModified\n    }\n\n    this.#name = String(fileName)\n  }\n\n  get name () {\n    return this.#name\n  }\n\n  get lastModified () {\n    return this.#lastModified\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'File'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return !!object && object instanceof Blob &&\n      /^(File)$/.test(object[Symbol.toStringTag])\n  }\n}\n\n/** @type {typeof globalThis.File} */// @ts-ignore\nexport const File = _File\nexport default File\n", "/*! formdata-polyfill. MIT License. Jimmy W\u00E4rting <https://jimmy.warting.se/opensource> */\n\nimport C from 'fetch-blob'\nimport F from 'fetch-blob/file.js'\n\nvar {toStringTag:t,iterator:i,hasInstance:h}=Symbol,\nr=Math.random,\nm='append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(','),\nf=(a,b,c)=>(a+='',/^(Blob|File)$/.test(b && b[t])?[(c=c!==void 0?c+'':b[t]=='File'?b.name:'blob',a),b.name!==c||b[t]=='blob'?new F([b],c,b):b]:[a,b+'']),\ne=(c,f)=>(f?c:c.replace(/\\r?\\n|\\r/g,'\\r\\n')).replace(/\\n/g,'%0A').replace(/\\r/g,'%0D').replace(/\"/g,'%22'),\nx=(n, a, e)=>{if(a.length<e){throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`)}}\n\nexport const File = F\n\n/** @type {typeof globalThis.FormData} */\nexport const FormData = class FormData {\n#d=[];\nconstructor(...a){if(a.length)throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`)}\nget [t]() {return 'FormData'}\n[i](){return this.entries()}\nstatic [h](o) {return o&&typeof o==='object'&&o[t]==='FormData'&&!m.some(m=>typeof o[m]!='function')}\nappend(...a){x('append',arguments,2);this.#d.push(f(...a))}\ndelete(a){x('delete',arguments,1);a+='';this.#d=this.#d.filter(([b])=>b!==a)}\nget(a){x('get',arguments,1);a+='';for(var b=this.#d,l=b.length,c=0;c<l;c++)if(b[c][0]===a)return b[c][1];return null}\ngetAll(a,b){x('getAll',arguments,1);b=[];a+='';this.#d.forEach(c=>c[0]===a&&b.push(c[1]));return b}\nhas(a){x('has',arguments,1);a+='';return this.#d.some(b=>b[0]===a)}\nforEach(a,b){x('forEach',arguments,1);for(var [c,d]of this)a.call(b,d,c,this)}\nset(...a){x('set',arguments,2);var b=[],c=!0;a=f(...a);this.#d.forEach(d=>{d[0]===a[0]?c&&(c=!b.push(a)):b.push(d)});c&&b.push(a);this.#d=b}\n*entries(){yield*this.#d}\n*keys(){for(var[a]of this)yield a}\n*values(){for(var[,a]of this)yield a}}\n\n/** @param {FormData} F */\nexport function formDataToBlob (F,B=C){\nvar b=`${r()}${r()}`.replace(/\\./g, '').slice(-28).padStart(32, '-'),c=[],p=`--${b}\\r\\nContent-Disposition: form-data; name=\"`\nF.forEach((v,n)=>typeof v=='string'\n?c.push(p+e(n)+`\"\\r\\n\\r\\n${v.replace(/\\r(?!\\n)|(?<!\\r)\\n/g, '\\r\\n')}\\r\\n`)\n:c.push(p+e(n)+`\"; filename=\"${e(v.name, 1)}\"\\r\\nContent-Type: ${v.type||\"application/octet-stream\"}\\r\\n\\r\\n`, v, '\\r\\n'))\nc.push(`--${b}--`)\nreturn new B(c,{type:\"multipart/form-data; boundary=\"+b})}\n", "export class FetchBaseError extends Error {\n\tconstructor(message, type) {\n\t\tsuper(message);\n\t\t// Hide custom error implementation details from end-users\n\t\tError.captureStackTrace(this, this.constructor);\n\n\t\tthis.type = type;\n\t}\n\n\tget name() {\n\t\treturn this.constructor.name;\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn this.constructor.name;\n\t}\n}\n", "\nimport {FetchBaseError} from './base.js';\n\n/**\n * @typedef {{ address?: string, code: string, dest?: string, errno: number, info?: object, message: string, path?: string, port?: number, syscall: string}} SystemError\n*/\n\n/**\n * FetchError interface for operational errors\n */\nexport class FetchError extends FetchBaseError {\n\t/**\n\t * @param  {string} message -      Error message for human\n\t * @param  {string} [type] -        Error type for machine\n\t * @param  {SystemError} [systemError] - For Node.js system error\n\t */\n\tconstructor(message, type, systemError) {\n\t\tsuper(message, type);\n\t\t// When err.type is `system`, err.erroredSysCall contains system error and err.code contains system error code\n\t\tif (systemError) {\n\t\t\t// eslint-disable-next-line no-multi-assign\n\t\t\tthis.code = this.errno = systemError.code;\n\t\t\tthis.erroredSysCall = systemError.syscall;\n\t\t}\n\t}\n}\n", "/**\n * Is.js\n *\n * Object type checks.\n */\n\nconst NAME = Symbol.toStringTag;\n\n/**\n * Check if `obj` is a URLSearchParams object\n * ref: https://github.com/node-fetch/node-fetch/issues/296#issuecomment-307598143\n * @param {*} object - Object to check for\n * @return {boolean}\n */\nexport const isURLSearchParameters = object => {\n\treturn (\n\t\ttypeof object === 'object' &&\n\t\ttypeof object.append === 'function' &&\n\t\ttypeof object.delete === 'function' &&\n\t\ttypeof object.get === 'function' &&\n\t\ttypeof object.getAll === 'function' &&\n\t\ttypeof object.has === 'function' &&\n\t\ttypeof object.set === 'function' &&\n\t\ttypeof object.sort === 'function' &&\n\t\tobject[NAME] === 'URLSearchParams'\n\t);\n};\n\n/**\n * Check if `object` is a W3C `Blob` object (which `File` inherits from)\n * @param {*} object - Object to check for\n * @return {boolean}\n */\nexport const isBlob = object => {\n\treturn (\n\t\tobject &&\n\t\ttypeof object === 'object' &&\n\t\ttypeof object.arrayBuffer === 'function' &&\n\t\ttypeof object.type === 'string' &&\n\t\ttypeof object.stream === 'function' &&\n\t\ttypeof object.constructor === 'function' &&\n\t\t/^(Blob|File)$/.test(object[NAME])\n\t);\n};\n\n/**\n * Check if `obj` is an instance of AbortSignal.\n * @param {*} object - Object to check for\n * @return {boolean}\n */\nexport const isAbortSignal = object => {\n\treturn (\n\t\ttypeof object === 'object' && (\n\t\t\tobject[NAME] === 'AbortSignal' ||\n\t\t\tobject[NAME] === 'EventTarget'\n\t\t)\n\t);\n};\n\n/**\n * isDomainOrSubdomain reports whether sub is a subdomain (or exact match) of\n * the parent domain.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */\nexport const isDomainOrSubdomain = (destination, original) => {\n\tconst orig = new URL(original).hostname;\n\tconst dest = new URL(destination).hostname;\n\n\treturn orig === dest || orig.endsWith(`.${dest}`);\n};\n\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */\nexport const isSameProtocol = (destination, original) => {\n\tconst orig = new URL(original).protocol;\n\tconst dest = new URL(destination).protocol;\n\n\treturn orig === dest;\n};\n", "/*! node-domexception. MIT License. Jimmy W\u00E4rting <https://jimmy.warting.se/opensource> */\n\nif (!globalThis.DOMException) {\n  try {\n    const { MessageChannel } = require('worker_threads'),\n    port = new MessageChannel().port1,\n    ab = new ArrayBuffer()\n    port.postMessage(ab, [ab, ab])\n  } catch (err) {\n    err.constructor.name === 'DOMException' && (\n      globalThis.DOMException = err.constructor\n    )\n  }\n}\n\nmodule.exports = globalThis.DOMException\n", "import { statSync, createReadStream, promises as fs } from 'node:fs'\nimport { basename } from 'node:path'\nimport DOMException from 'node-domexception'\n\nimport File from './file.js'\nimport Blob from './index.js'\n\nconst { stat } = fs\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst blobFromSync = (path, type) => fromBlob(statSync(path), path, type)\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */\nconst blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */\nconst fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst fileFromSync = (path, type) => fromFile(statSync(path), path, type)\n\n// @ts-ignore\nconst fromBlob = (stat, path, type = '') => new Blob([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], { type })\n\n// @ts-ignore\nconst fromFile = (stat, path, type = '') => new File([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], basename(path), { type, lastModified: stat.mtimeMs })\n\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */\nclass BlobDataItem {\n  #path\n  #start\n\n  constructor (options) {\n    this.#path = options.path\n    this.#start = options.start\n    this.size = options.size\n    this.lastModified = options.lastModified\n  }\n\n  /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */\n  slice (start, end) {\n    return new BlobDataItem({\n      path: this.#path,\n      lastModified: this.lastModified,\n      size: end - start,\n      start: this.#start + start\n    })\n  }\n\n  async * stream () {\n    const { mtimeMs } = await stat(this.#path)\n    if (mtimeMs > this.lastModified) {\n      throw new DOMException('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError')\n    }\n    yield * createReadStream(this.#path, {\n      start: this.#start,\n      end: this.#start + this.size - 1\n    })\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n}\n\nexport default blobFromSync\nexport { File, Blob, blobFrom, blobFromSync, fileFrom, fileFromSync }\n", "import {File} from 'fetch-blob/from.js';\nimport {FormData} from 'formdata-polyfill/esm.min.js';\n\nlet s = 0;\nconst S = {\n\tSTART_BOUNDARY: s++,\n\tHEADER_FIELD_START: s++,\n\tHEADER_FIELD: s++,\n\tHEADER_VALUE_START: s++,\n\tHEADER_VALUE: s++,\n\tHEADER_VALUE_ALMOST_DONE: s++,\n\tHEADERS_ALMOST_DONE: s++,\n\tPART_DATA_START: s++,\n\tPART_DATA: s++,\n\tEND: s++\n};\n\nlet f = 1;\nconst F = {\n\tPART_BOUNDARY: f,\n\tLAST_BOUNDARY: f *= 2\n};\n\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nconst lower = c => c | 0x20;\n\nconst noop = () => {};\n\nclass MultipartParser {\n\t/**\n\t * @param {string} boundary\n\t */\n\tconstructor(boundary) {\n\t\tthis.index = 0;\n\t\tthis.flags = 0;\n\n\t\tthis.onHeaderEnd = noop;\n\t\tthis.onHeaderField = noop;\n\t\tthis.onHeadersEnd = noop;\n\t\tthis.onHeaderValue = noop;\n\t\tthis.onPartBegin = noop;\n\t\tthis.onPartData = noop;\n\t\tthis.onPartEnd = noop;\n\n\t\tthis.boundaryChars = {};\n\n\t\tboundary = '\\r\\n--' + boundary;\n\t\tconst ui8a = new Uint8Array(boundary.length);\n\t\tfor (let i = 0; i < boundary.length; i++) {\n\t\t\tui8a[i] = boundary.charCodeAt(i);\n\t\t\tthis.boundaryChars[ui8a[i]] = true;\n\t\t}\n\n\t\tthis.boundary = ui8a;\n\t\tthis.lookbehind = new Uint8Array(this.boundary.length + 8);\n\t\tthis.state = S.START_BOUNDARY;\n\t}\n\n\t/**\n\t * @param {Uint8Array} data\n\t */\n\twrite(data) {\n\t\tlet i = 0;\n\t\tconst length_ = data.length;\n\t\tlet previousIndex = this.index;\n\t\tlet {lookbehind, boundary, boundaryChars, index, state, flags} = this;\n\t\tconst boundaryLength = this.boundary.length;\n\t\tconst boundaryEnd = boundaryLength - 1;\n\t\tconst bufferLength = data.length;\n\t\tlet c;\n\t\tlet cl;\n\n\t\tconst mark = name => {\n\t\t\tthis[name + 'Mark'] = i;\n\t\t};\n\n\t\tconst clear = name => {\n\t\t\tdelete this[name + 'Mark'];\n\t\t};\n\n\t\tconst callback = (callbackSymbol, start, end, ui8a) => {\n\t\t\tif (start === undefined || start !== end) {\n\t\t\t\tthis[callbackSymbol](ui8a && ui8a.subarray(start, end));\n\t\t\t}\n\t\t};\n\n\t\tconst dataCallback = (name, clear) => {\n\t\t\tconst markSymbol = name + 'Mark';\n\t\t\tif (!(markSymbol in this)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (clear) {\n\t\t\t\tcallback(name, this[markSymbol], i, data);\n\t\t\t\tdelete this[markSymbol];\n\t\t\t} else {\n\t\t\t\tcallback(name, this[markSymbol], data.length, data);\n\t\t\t\tthis[markSymbol] = 0;\n\t\t\t}\n\t\t};\n\n\t\tfor (i = 0; i < length_; i++) {\n\t\t\tc = data[i];\n\n\t\t\tswitch (state) {\n\t\t\t\tcase S.START_BOUNDARY:\n\t\t\t\t\tif (index === boundary.length - 2) {\n\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else if (c !== CR) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (index - 1 === boundary.length - 2) {\n\t\t\t\t\t\tif (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t} else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c !== boundary[index + 2]) {\n\t\t\t\t\t\tindex = -2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === boundary[index + 2]) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_FIELD_START:\n\t\t\t\t\tstate = S.HEADER_FIELD;\n\t\t\t\t\tmark('onHeaderField');\n\t\t\t\t\tindex = 0;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_FIELD:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tclear('onHeaderField');\n\t\t\t\t\t\tstate = S.HEADERS_ALMOST_DONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === COLON) {\n\t\t\t\t\t\tif (index === 1) {\n\t\t\t\t\t\t\t// empty header field\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdataCallback('onHeaderField', true);\n\t\t\t\t\t\tstate = S.HEADER_VALUE_START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcl = lower(c);\n\t\t\t\t\tif (cl < A || cl > Z) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_START:\n\t\t\t\t\tif (c === SPACE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tmark('onHeaderValue');\n\t\t\t\t\tstate = S.HEADER_VALUE;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_VALUE:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tdataCallback('onHeaderValue', true);\n\t\t\t\t\t\tcallback('onHeaderEnd');\n\t\t\t\t\t\tstate = S.HEADER_VALUE_ALMOST_DONE;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADERS_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback('onHeadersEnd');\n\t\t\t\t\tstate = S.PART_DATA_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.PART_DATA_START:\n\t\t\t\t\tstate = S.PART_DATA;\n\t\t\t\t\tmark('onPartData');\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.PART_DATA:\n\t\t\t\t\tpreviousIndex = index;\n\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t// boyer-moore derrived algorithm to safely skip non-boundary data\n\t\t\t\t\t\ti += boundaryEnd;\n\t\t\t\t\t\twhile (i < bufferLength && !(data[i] in boundaryChars)) {\n\t\t\t\t\t\t\ti += boundaryLength;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti -= boundaryEnd;\n\t\t\t\t\t\tc = data[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index < boundary.length) {\n\t\t\t\t\t\tif (boundary[index] === c) {\n\t\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\t\tdataCallback('onPartData', true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index === boundary.length) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\t\t// CR = part boundary\n\t\t\t\t\t\t\tflags |= F.PART_BOUNDARY;\n\t\t\t\t\t\t} else if (c === HYPHEN) {\n\t\t\t\t\t\t\t// HYPHEN = end boundary\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index - 1 === boundary.length) {\n\t\t\t\t\t\tif (flags & F.PART_BOUNDARY) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tif (c === LF) {\n\t\t\t\t\t\t\t\t// unset the PART_BOUNDARY flag\n\t\t\t\t\t\t\t\tflags &= ~F.PART_BOUNDARY;\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (flags & F.LAST_BOUNDARY) {\n\t\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\t// when matching a possible boundary, keep a lookbehind reference\n\t\t\t\t\t\t// in case it turns out to be a false lead\n\t\t\t\t\t\tlookbehind[index - 1] = c;\n\t\t\t\t\t} else if (previousIndex > 0) {\n\t\t\t\t\t\t// if our boundary turned out to be rubbish, the captured lookbehind\n\t\t\t\t\t\t// belongs to partData\n\t\t\t\t\t\tconst _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n\t\t\t\t\t\tcallback('onPartData', 0, previousIndex, _lookbehind);\n\t\t\t\t\t\tpreviousIndex = 0;\n\t\t\t\t\t\tmark('onPartData');\n\n\t\t\t\t\t\t// reconsider the current character even so it interrupted the sequence\n\t\t\t\t\t\t// it could be the beginning of a new sequence\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.END:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected state entered: ${state}`);\n\t\t\t}\n\t\t}\n\n\t\tdataCallback('onHeaderField');\n\t\tdataCallback('onHeaderValue');\n\t\tdataCallback('onPartData');\n\n\t\t// Update properties for the next call\n\t\tthis.index = index;\n\t\tthis.state = state;\n\t\tthis.flags = flags;\n\t}\n\n\tend() {\n\t\tif ((this.state === S.HEADER_FIELD_START && this.index === 0) ||\n\t\t\t(this.state === S.PART_DATA && this.index === this.boundary.length)) {\n\t\t\tthis.onPartEnd();\n\t\t} else if (this.state !== S.END) {\n\t\t\tthrow new Error('MultipartParser.end(): stream ended unexpectedly');\n\t\t}\n\t}\n}\n\nfunction _fileName(headerValue) {\n\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\tconst m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n\tif (!m) {\n\t\treturn;\n\t}\n\n\tconst match = m[2] || m[3] || '';\n\tlet filename = match.slice(match.lastIndexOf('\\\\') + 1);\n\tfilename = filename.replace(/%22/g, '\"');\n\tfilename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n\t\treturn String.fromCharCode(code);\n\t});\n\treturn filename;\n}\n\nexport async function toFormData(Body, ct) {\n\tif (!/multipart/i.test(ct)) {\n\t\tthrow new TypeError('Failed to fetch');\n\t}\n\n\tconst m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n\tif (!m) {\n\t\tthrow new TypeError('no or bad content-type header, no multipart boundary');\n\t}\n\n\tconst parser = new MultipartParser(m[1] || m[2]);\n\n\tlet headerField;\n\tlet headerValue;\n\tlet entryValue;\n\tlet entryName;\n\tlet contentType;\n\tlet filename;\n\tconst entryChunks = [];\n\tconst formData = new FormData();\n\n\tconst onPartData = ui8a => {\n\t\tentryValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tconst appendToFile = ui8a => {\n\t\tentryChunks.push(ui8a);\n\t};\n\n\tconst appendFileToFormData = () => {\n\t\tconst file = new File(entryChunks, filename, {type: contentType});\n\t\tformData.append(entryName, file);\n\t};\n\n\tconst appendEntryToFormData = () => {\n\t\tformData.append(entryName, entryValue);\n\t};\n\n\tconst decoder = new TextDecoder('utf-8');\n\tdecoder.decode();\n\n\tparser.onPartBegin = function () {\n\t\tparser.onPartData = onPartData;\n\t\tparser.onPartEnd = appendEntryToFormData;\n\n\t\theaderField = '';\n\t\theaderValue = '';\n\t\tentryValue = '';\n\t\tentryName = '';\n\t\tcontentType = '';\n\t\tfilename = null;\n\t\tentryChunks.length = 0;\n\t};\n\n\tparser.onHeaderField = function (ui8a) {\n\t\theaderField += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderValue = function (ui8a) {\n\t\theaderValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderEnd = function () {\n\t\theaderValue += decoder.decode();\n\t\theaderField = headerField.toLowerCase();\n\n\t\tif (headerField === 'content-disposition') {\n\t\t\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\t\t\tconst m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n\n\t\t\tif (m) {\n\t\t\t\tentryName = m[2] || m[3] || '';\n\t\t\t}\n\n\t\t\tfilename = _fileName(headerValue);\n\n\t\t\tif (filename) {\n\t\t\t\tparser.onPartData = appendToFile;\n\t\t\t\tparser.onPartEnd = appendFileToFormData;\n\t\t\t}\n\t\t} else if (headerField === 'content-type') {\n\t\t\tcontentType = headerValue;\n\t\t}\n\n\t\theaderValue = '';\n\t\theaderField = '';\n\t};\n\n\tfor await (const chunk of Body) {\n\t\tparser.write(chunk);\n\t}\n\n\tparser.end();\n\n\treturn formData;\n}\n", "\n/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\n\nimport Stream, {PassThrough} from 'node:stream';\nimport {types, deprecate, promisify} from 'node:util';\nimport {Buffer} from 'node:buffer';\n\nimport Blob from 'fetch-blob';\nimport {FormData, formDataToBlob} from 'formdata-polyfill/esm.min.js';\n\nimport {FetchError} from './errors/fetch-error.js';\nimport {FetchBaseError} from './errors/base.js';\nimport {isBlob, isURLSearchParameters} from './utils/is.js';\n\nconst pipeline = promisify(Stream.pipeline);\nconst INTERNALS = Symbol('Body internals');\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Body {\n\tconstructor(body, {\n\t\tsize = 0\n\t} = {}) {\n\t\tlet boundary = null;\n\n\t\tif (body === null) {\n\t\t\t// Body is undefined or null\n\t\t\tbody = null;\n\t\t} else if (isURLSearchParameters(body)) {\n\t\t\t// Body is a URLSearchParams\n\t\t\tbody = Buffer.from(body.toString());\n\t\t} else if (isBlob(body)) {\n\t\t\t// Body is blob\n\t\t} else if (Buffer.isBuffer(body)) {\n\t\t\t// Body is Buffer\n\t\t} else if (types.isAnyArrayBuffer(body)) {\n\t\t\t// Body is ArrayBuffer\n\t\t\tbody = Buffer.from(body);\n\t\t} else if (ArrayBuffer.isView(body)) {\n\t\t\t// Body is ArrayBufferView\n\t\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t\t} else if (body instanceof Stream) {\n\t\t\t// Body is stream\n\t\t} else if (body instanceof FormData) {\n\t\t\t// Body is FormData\n\t\t\tbody = formDataToBlob(body);\n\t\t\tboundary = body.type.split('=')[1];\n\t\t} else {\n\t\t\t// None of the above\n\t\t\t// coerce to string then buffer\n\t\t\tbody = Buffer.from(String(body));\n\t\t}\n\n\t\tlet stream = body;\n\n\t\tif (Buffer.isBuffer(body)) {\n\t\t\tstream = Stream.Readable.from(body);\n\t\t} else if (isBlob(body)) {\n\t\t\tstream = Stream.Readable.from(body.stream());\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\tbody,\n\t\t\tstream,\n\t\t\tboundary,\n\t\t\tdisturbed: false,\n\t\t\terror: null\n\t\t};\n\t\tthis.size = size;\n\n\t\tif (body instanceof Stream) {\n\t\t\tbody.on('error', error_ => {\n\t\t\t\tconst error = error_ instanceof FetchBaseError ?\n\t\t\t\t\terror_ :\n\t\t\t\t\tnew FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n\t\t\t\tthis[INTERNALS].error = error;\n\t\t\t});\n\t\t}\n\t}\n\n\tget body() {\n\t\treturn this[INTERNALS].stream;\n\t}\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t}\n\n\t/**\n\t * Decode response as ArrayBuffer\n\t *\n\t * @return  Promise\n\t */\n\tasync arrayBuffer() {\n\t\tconst {buffer, byteOffset, byteLength} = await consumeBody(this);\n\t\treturn buffer.slice(byteOffset, byteOffset + byteLength);\n\t}\n\n\tasync formData() {\n\t\tconst ct = this.headers.get('content-type');\n\n\t\tif (ct.startsWith('application/x-www-form-urlencoded')) {\n\t\t\tconst formData = new FormData();\n\t\t\tconst parameters = new URLSearchParams(await this.text());\n\n\t\t\tfor (const [name, value] of parameters) {\n\t\t\t\tformData.append(name, value);\n\t\t\t}\n\n\t\t\treturn formData;\n\t\t}\n\n\t\tconst {toFormData} = await import('./utils/multipart-parser.js');\n\t\treturn toFormData(this.body, ct);\n\t}\n\n\t/**\n\t * Return raw response as Blob\n\t *\n\t * @return Promise\n\t */\n\tasync blob() {\n\t\tconst ct = (this.headers && this.headers.get('content-type')) || (this[INTERNALS].body && this[INTERNALS].body.type) || '';\n\t\tconst buf = await this.arrayBuffer();\n\n\t\treturn new Blob([buf], {\n\t\t\ttype: ct\n\t\t});\n\t}\n\n\t/**\n\t * Decode response as json\n\t *\n\t * @return  Promise\n\t */\n\tasync json() {\n\t\tconst text = await this.text();\n\t\treturn JSON.parse(text);\n\t}\n\n\t/**\n\t * Decode response as text\n\t *\n\t * @return  Promise\n\t */\n\tasync text() {\n\t\tconst buffer = await consumeBody(this);\n\t\treturn new TextDecoder().decode(buffer);\n\t}\n\n\t/**\n\t * Decode response as buffer (non-spec api)\n\t *\n\t * @return  Promise\n\t */\n\tbuffer() {\n\t\treturn consumeBody(this);\n\t}\n}\n\nBody.prototype.buffer = deprecate(Body.prototype.buffer, 'Please use \\'response.arrayBuffer()\\' instead of \\'response.buffer()\\'', 'node-fetch#buffer');\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: {enumerable: true},\n\tbodyUsed: {enumerable: true},\n\tarrayBuffer: {enumerable: true},\n\tblob: {enumerable: true},\n\tjson: {enumerable: true},\n\ttext: {enumerable: true},\n\tdata: {get: deprecate(() => {},\n\t\t'data doesn\\'t exist, use json(), text(), arrayBuffer(), or body instead',\n\t\t'https://github.com/node-fetch/node-fetch/issues/1000 (response)')}\n});\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\nasync function consumeBody(data) {\n\tif (data[INTERNALS].disturbed) {\n\t\tthrow new TypeError(`body used already for: ${data.url}`);\n\t}\n\n\tdata[INTERNALS].disturbed = true;\n\n\tif (data[INTERNALS].error) {\n\t\tthrow data[INTERNALS].error;\n\t}\n\n\tconst {body} = data;\n\n\t// Body is null\n\tif (body === null) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t/* c8 ignore next 3 */\n\tif (!(body instanceof Stream)) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t// Body is stream\n\t// get ready to actually consume the body\n\tconst accum = [];\n\tlet accumBytes = 0;\n\n\ttry {\n\t\tfor await (const chunk of body) {\n\t\t\tif (data.size > 0 && accumBytes + chunk.length > data.size) {\n\t\t\t\tconst error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n\t\t\t\tbody.destroy(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t}\n\t} catch (error) {\n\t\tconst error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n\t\tthrow error_;\n\t}\n\n\tif (body.readableEnded === true || body._readableState.ended === true) {\n\t\ttry {\n\t\t\tif (accum.every(c => typeof c === 'string')) {\n\t\t\t\treturn Buffer.from(accum.join(''));\n\t\t\t}\n\n\t\t\treturn Buffer.concat(accum, accumBytes);\n\t\t} catch (error) {\n\t\t\tthrow new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n\t\t}\n\t} else {\n\t\tthrow new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n\t}\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\nexport const clone = (instance, highWaterMark) => {\n\tlet p1;\n\tlet p2;\n\tlet {body} = instance[INTERNALS];\n\n\t// Don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// Check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif ((body instanceof Stream) && (typeof body.getBoundary !== 'function')) {\n\t\t// Tee instance body\n\t\tp1 = new PassThrough({highWaterMark});\n\t\tp2 = new PassThrough({highWaterMark});\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// Set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].stream = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n};\n\nconst getNonSpecFormDataBoundary = deprecate(\n\tbody => body.getBoundary(),\n\t'form-data doesn\\'t follow the spec and requires special treatment. Use alternative package',\n\t'https://github.com/node-fetch/node-fetch/issues/1167'\n);\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\nexport const extractContentType = (body, request) => {\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn null;\n\t}\n\n\t// Body is string\n\tif (typeof body === 'string') {\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n\n\t// Body is a URLSearchParams\n\tif (isURLSearchParameters(body)) {\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t}\n\n\t// Body is blob\n\tif (isBlob(body)) {\n\t\treturn body.type || null;\n\t}\n\n\t// Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\tif (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n\t\treturn null;\n\t}\n\n\tif (body instanceof FormData) {\n\t\treturn `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getBoundary === 'function') {\n\t\treturn `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n\t}\n\n\t// Body is stream - can't really do much about this\n\tif (body instanceof Stream) {\n\t\treturn null;\n\t}\n\n\t// Body constructor defaults other things to string\n\treturn 'text/plain;charset=UTF-8';\n};\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\nexport const getTotalBytes = request => {\n\tconst {body} = request[INTERNALS];\n\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn 0;\n\t}\n\n\t// Body is Blob\n\tif (isBlob(body)) {\n\t\treturn body.size;\n\t}\n\n\t// Body is Buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn body.length;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getLengthSync === 'function') {\n\t\treturn body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n\t}\n\n\t// Body is stream\n\treturn null;\n};\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {Promise<void>}\n */\nexport const writeToStream = async (dest, {body}) => {\n\tif (body === null) {\n\t\t// Body is null\n\t\tdest.end();\n\t} else {\n\t\t// Body is stream\n\t\tawait pipeline(body, dest);\n\t}\n};\n", "/**\n * Headers.js\n *\n * Headers class offers convenient helpers\n */\n\nimport {types} from 'node:util';\nimport http from 'node:http';\n\n/* c8 ignore next 9 */\nconst validateHeaderName = typeof http.validateHeaderName === 'function' ?\n\thttp.validateHeaderName :\n\tname => {\n\t\tif (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(name)) {\n\t\t\tconst error = new TypeError(`Header name must be a valid HTTP token [${name}]`);\n\t\t\tObject.defineProperty(error, 'code', {value: 'ERR_INVALID_HTTP_TOKEN'});\n\t\t\tthrow error;\n\t\t}\n\t};\n\n/* c8 ignore next 9 */\nconst validateHeaderValue = typeof http.validateHeaderValue === 'function' ?\n\thttp.validateHeaderValue :\n\t(name, value) => {\n\t\tif (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(value)) {\n\t\t\tconst error = new TypeError(`Invalid character in header content [\"${name}\"]`);\n\t\t\tObject.defineProperty(error, 'code', {value: 'ERR_INVALID_CHAR'});\n\t\t\tthrow error;\n\t\t}\n\t};\n\n/**\n * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit\n */\n\n/**\n * This Fetch API interface allows you to perform various actions on HTTP request and response headers.\n * These actions include retrieving, setting, adding to, and removing.\n * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.\n * You can add to this using methods like append() (see Examples.)\n * In all methods of this interface, header names are matched by case-insensitive byte sequence.\n *\n */\nexport default class Headers extends URLSearchParams {\n\t/**\n\t * Headers class\n\t *\n\t * @constructor\n\t * @param {HeadersInit} [init] - Response headers\n\t */\n\tconstructor(init) {\n\t\t// Validate and normalize init object in [name, value(s)][]\n\t\t/** @type {string[][]} */\n\t\tlet result = [];\n\t\tif (init instanceof Headers) {\n\t\t\tconst raw = init.raw();\n\t\t\tfor (const [name, values] of Object.entries(raw)) {\n\t\t\t\tresult.push(...values.map(value => [name, value]));\n\t\t\t}\n\t\t} else if (init == null) { // eslint-disable-line no-eq-null, eqeqeq\n\t\t\t// No op\n\t\t} else if (typeof init === 'object' && !types.isBoxedPrimitive(init)) {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\t\tif (method == null) {\n\t\t\t\t// Record<ByteString, ByteString>\n\t\t\t\tresult.push(...Object.entries(init));\n\t\t\t} else {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// Sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tresult = [...init]\n\t\t\t\t\t.map(pair => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttypeof pair !== 'object' || types.isBoxedPrimitive(pair)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new TypeError('Each header pair must be an iterable object');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [...pair];\n\t\t\t\t\t}).map(pair => {\n\t\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [...pair];\n\t\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Failed to construct \\'Headers\\': The provided value is not of type \\'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');\n\t\t}\n\n\t\t// Validate and lowercase\n\t\tresult =\n\t\t\tresult.length > 0 ?\n\t\t\t\tresult.map(([name, value]) => {\n\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\treturn [String(name).toLowerCase(), String(value)];\n\t\t\t\t}) :\n\t\t\t\tundefined;\n\n\t\tsuper(result);\n\n\t\t// Returning a Proxy that will lowercase key names, validate parameters and sort keys\n\t\t// eslint-disable-next-line no-constructor-return\n\t\treturn new Proxy(this, {\n\t\t\tget(target, p, receiver) {\n\t\t\t\tswitch (p) {\n\t\t\t\t\tcase 'append':\n\t\t\t\t\tcase 'set':\n\t\t\t\t\t\treturn (name, value) => {\n\t\t\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\t\t\treturn URLSearchParams.prototype[p].call(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tString(name).toLowerCase(),\n\t\t\t\t\t\t\t\tString(value)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\n\t\t\t\t\tcase 'delete':\n\t\t\t\t\tcase 'has':\n\t\t\t\t\tcase 'getAll':\n\t\t\t\t\t\treturn name => {\n\t\t\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\t\t\treturn URLSearchParams.prototype[p].call(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tString(name).toLowerCase()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\n\t\t\t\t\tcase 'keys':\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\ttarget.sort();\n\t\t\t\t\t\t\treturn new Set(URLSearchParams.prototype.keys.call(target)).keys();\n\t\t\t\t\t\t};\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn Reflect.get(target, p, receiver);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t/* c8 ignore next */\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn this.constructor.name;\n\t}\n\n\ttoString() {\n\t\treturn Object.prototype.toString.call(this);\n\t}\n\n\tget(name) {\n\t\tconst values = this.getAll(name);\n\t\tif (values.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet value = values.join(', ');\n\t\tif (/^content-encoding$/i.test(name)) {\n\t\t\tvalue = value.toLowerCase();\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tforEach(callback, thisArg = undefined) {\n\t\tfor (const name of this.keys()) {\n\t\t\tReflect.apply(callback, thisArg, [this.get(name), name, this]);\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const name of this.keys()) {\n\t\t\tyield this.get(name);\n\t\t}\n\t}\n\n\t/**\n\t * @type {() => IterableIterator<[string, string]>}\n\t */\n\t* entries() {\n\t\tfor (const name of this.keys()) {\n\t\t\tyield [name, this.get(name)];\n\t\t}\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this.entries();\n\t}\n\n\t/**\n\t * Node-fetch non-spec method\n\t * returning all headers and their values as array\n\t * @returns {Record<string, string[]>}\n\t */\n\traw() {\n\t\treturn [...this.keys()].reduce((result, key) => {\n\t\t\tresult[key] = this.getAll(key);\n\t\t\treturn result;\n\t\t}, {});\n\t}\n\n\t/**\n\t * For better console.log(headers) and also to convert Headers into Node.js Request compatible format\n\t */\n\t[Symbol.for('nodejs.util.inspect.custom')]() {\n\t\treturn [...this.keys()].reduce((result, key) => {\n\t\t\tconst values = this.getAll(key);\n\t\t\t// Http.request() only supports string as Host header.\n\t\t\t// This hack makes specifying custom Host header possible.\n\t\t\tif (key === 'host') {\n\t\t\t\tresult[key] = values[0];\n\t\t\t} else {\n\t\t\t\tresult[key] = values.length > 1 ? values : values[0];\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}, {});\n\t}\n}\n\n/**\n * Re-shaping object for Web IDL tests\n * Only need to do it for overridden methods\n */\nObject.defineProperties(\n\tHeaders.prototype,\n\t['get', 'entries', 'forEach', 'values'].reduce((result, property) => {\n\t\tresult[property] = {enumerable: true};\n\t\treturn result;\n\t}, {})\n);\n\n/**\n * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do\n * not conform to HTTP grammar productions.\n * @param {import('http').IncomingMessage['rawHeaders']} headers\n */\nexport function fromRawHeaders(headers = []) {\n\treturn new Headers(\n\t\theaders\n\t\t\t// Split into pairs\n\t\t\t.reduce((result, value, index, array) => {\n\t\t\t\tif (index % 2 === 0) {\n\t\t\t\t\tresult.push(array.slice(index, index + 2));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, [])\n\t\t\t.filter(([name, value]) => {\n\t\t\t\ttry {\n\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\treturn true;\n\t\t\t\t} catch {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t})\n\n\t);\n}\n", "const redirectStatus = new Set([301, 302, 303, 307, 308]);\n\n/**\n * Redirect code matching\n *\n * @param {number} code - Status code\n * @return {boolean}\n */\nexport const isRedirect = code => {\n\treturn redirectStatus.has(code);\n};\n", "/**\n * Response.js\n *\n * Response class provides content decoding\n */\n\nimport Headers from './headers.js';\nimport Body, {clone, extractContentType} from './body.js';\nimport {isRedirect} from './utils/is-redirect.js';\n\nconst INTERNALS = Symbol('Response internals');\n\n/**\n * Response class\n *\n * Ref: https://fetch.spec.whatwg.org/#response-class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Response extends Body {\n\tconstructor(body = null, options = {}) {\n\t\tsuper(body, options);\n\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition\n\t\tconst status = options.status != null ? options.status : 200;\n\n\t\tconst headers = new Headers(options.headers);\n\n\t\tif (body !== null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body, this);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\ttype: 'default',\n\t\t\turl: options.url,\n\t\t\tstatus,\n\t\t\tstatusText: options.statusText || '',\n\t\t\theaders,\n\t\t\tcounter: options.counter,\n\t\t\thighWaterMark: options.highWaterMark\n\t\t};\n\t}\n\n\tget type() {\n\t\treturn this[INTERNALS].type;\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS].status;\n\t}\n\n\t/**\n\t * Convenience property representing if the request ended normally\n\t */\n\tget ok() {\n\t\treturn this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS].headers;\n\t}\n\n\tget highWaterMark() {\n\t\treturn this[INTERNALS].highWaterMark;\n\t}\n\n\t/**\n\t * Clone this response\n\t *\n\t * @return  Response\n\t */\n\tclone() {\n\t\treturn new Response(clone(this, this.highWaterMark), {\n\t\t\ttype: this.type,\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected,\n\t\t\tsize: this.size,\n\t\t\thighWaterMark: this.highWaterMark\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} url    The URL that the new response is to originate from.\n\t * @param {number} status An optional status code for the response (e.g., 302.)\n\t * @returns {Response}    A Response object.\n\t */\n\tstatic redirect(url, status = 302) {\n\t\tif (!isRedirect(status)) {\n\t\t\tthrow new RangeError('Failed to execute \"redirect\" on \"response\": Invalid status code');\n\t\t}\n\n\t\treturn new Response(null, {\n\t\t\theaders: {\n\t\t\t\tlocation: new URL(url).toString()\n\t\t\t},\n\t\t\tstatus\n\t\t});\n\t}\n\n\tstatic error() {\n\t\tconst response = new Response(null, {status: 0, statusText: ''});\n\t\tresponse[INTERNALS].type = 'error';\n\t\treturn response;\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn 'Response';\n\t}\n}\n\nObject.defineProperties(Response.prototype, {\n\ttype: {enumerable: true},\n\turl: {enumerable: true},\n\tstatus: {enumerable: true},\n\tok: {enumerable: true},\n\tredirected: {enumerable: true},\n\tstatusText: {enumerable: true},\n\theaders: {enumerable: true},\n\tclone: {enumerable: true}\n});\n", "export const getSearch = parsedURL => {\n\tif (parsedURL.search) {\n\t\treturn parsedURL.search;\n\t}\n\n\tconst lastOffset = parsedURL.href.length - 1;\n\tconst hash = parsedURL.hash || (parsedURL.href[lastOffset] === '#' ? '#' : '');\n\treturn parsedURL.href[lastOffset - hash.length] === '?' ? '?' : '';\n};\n", "import {isIP} from 'node:net';\n\n/**\n * @external URL\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}\n */\n\n/**\n * @module utils/referrer\n * @private\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy \u00A78.4. Strip url for use as a referrer}\n * @param {string} URL\n * @param {boolean} [originOnly=false]\n */\nexport function stripURLForUseAsAReferrer(url, originOnly = false) {\n\t// 1. If url is null, return no referrer.\n\tif (url == null) { // eslint-disable-line no-eq-null, eqeqeq\n\t\treturn 'no-referrer';\n\t}\n\n\turl = new URL(url);\n\n\t// 2. If url's scheme is a local scheme, then return no referrer.\n\tif (/^(about|blob|data):$/.test(url.protocol)) {\n\t\treturn 'no-referrer';\n\t}\n\n\t// 3. Set url's username to the empty string.\n\turl.username = '';\n\n\t// 4. Set url's password to null.\n\t// Note: `null` appears to be a mistake as this actually results in the password being `\"null\"`.\n\turl.password = '';\n\n\t// 5. Set url's fragment to null.\n\t// Note: `null` appears to be a mistake as this actually results in the fragment being `\"#null\"`.\n\turl.hash = '';\n\n\t// 6. If the origin-only flag is true, then:\n\tif (originOnly) {\n\t\t// 6.1. Set url's path to null.\n\t\t// Note: `null` appears to be a mistake as this actually results in the path being `\"/null\"`.\n\t\turl.pathname = '';\n\n\t\t// 6.2. Set url's query to null.\n\t\t// Note: `null` appears to be a mistake as this actually results in the query being `\"?null\"`.\n\t\turl.search = '';\n\t}\n\n\t// 7. Return url.\n\treturn url;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}\n */\nexport const ReferrerPolicy = new Set([\n\t'',\n\t'no-referrer',\n\t'no-referrer-when-downgrade',\n\t'same-origin',\n\t'origin',\n\t'strict-origin',\n\t'origin-when-cross-origin',\n\t'strict-origin-when-cross-origin',\n\t'unsafe-url'\n]);\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}\n */\nexport const DEFAULT_REFERRER_POLICY = 'strict-origin-when-cross-origin';\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy \u00A73. Referrer Policies}\n * @param {string} referrerPolicy\n * @returns {string} referrerPolicy\n */\nexport function validateReferrerPolicy(referrerPolicy) {\n\tif (!ReferrerPolicy.has(referrerPolicy)) {\n\t\tthrow new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);\n\t}\n\n\treturn referrerPolicy;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy \u00A73.2. Is origin potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\nexport function isOriginPotentiallyTrustworthy(url) {\n\t// 1. If origin is an opaque origin, return \"Not Trustworthy\".\n\t// Not applicable\n\n\t// 2. Assert: origin is a tuple origin.\n\t// Not for implementations\n\n\t// 3. If origin's scheme is either \"https\" or \"wss\", return \"Potentially Trustworthy\".\n\tif (/^(http|ws)s:$/.test(url.protocol)) {\n\t\treturn true;\n\t}\n\n\t// 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return \"Potentially Trustworthy\".\n\tconst hostIp = url.host.replace(/(^\\[)|(]$)/g, '');\n\tconst hostIPVersion = isIP(hostIp);\n\n\tif (hostIPVersion === 4 && /^127\\./.test(hostIp)) {\n\t\treturn true;\n\t}\n\n\tif (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {\n\t\treturn true;\n\t}\n\n\t// 5. If origin's host component is \"localhost\" or falls within \".localhost\", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return \"Potentially Trustworthy\".\n\t// We are returning FALSE here because we cannot ensure conformance to\n\t// let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)\n\tif (url.host === 'localhost' || url.host.endsWith('.localhost')) {\n\t\treturn false;\n\t}\n\n\t// 6. If origin's scheme component is file, return \"Potentially Trustworthy\".\n\tif (url.protocol === 'file:') {\n\t\treturn true;\n\t}\n\n\t// 7. If origin's scheme component is one which the user agent considers to be authenticated, return \"Potentially Trustworthy\".\n\t// Not supported\n\n\t// 8. If origin has been configured as a trustworthy origin, return \"Potentially Trustworthy\".\n\t// Not supported\n\n\t// 9. Return \"Not Trustworthy\".\n\treturn false;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy \u00A73.3. Is url potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\nexport function isUrlPotentiallyTrustworthy(url) {\n\t// 1. If url is \"about:blank\" or \"about:srcdoc\", return \"Potentially Trustworthy\".\n\tif (/^about:(blank|srcdoc)$/.test(url)) {\n\t\treturn true;\n\t}\n\n\t// 2. If url's scheme is \"data\", return \"Potentially Trustworthy\".\n\tif (url.protocol === 'data:') {\n\t\treturn true;\n\t}\n\n\t// Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were\n\t// created. Therefore, blobs created in a trustworthy origin will themselves be potentially\n\t// trustworthy.\n\tif (/^(blob|filesystem):$/.test(url.protocol)) {\n\t\treturn true;\n\t}\n\n\t// 3. Return the result of executing \u00A73.2 Is origin potentially trustworthy? on url's origin.\n\treturn isOriginPotentiallyTrustworthy(url);\n}\n\n/**\n * Modifies the referrerURL to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy \u00A78.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerURLCallback\n * @param {external:URL} referrerURL\n * @returns {external:URL} modified referrerURL\n */\n\n/**\n * Modifies the referrerOrigin to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy \u00A78.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerOriginCallback\n * @param {external:URL} referrerOrigin\n * @returns {external:URL} modified referrerOrigin\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy \u00A78.3. Determine request's Referrer}\n * @param {Request} request\n * @param {object} o\n * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback\n * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback\n * @returns {external:URL} Request's referrer\n */\nexport function determineRequestsReferrer(request, {referrerURLCallback, referrerOriginCallback} = {}) {\n\t// There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for\n\t// these cases:\n\t// > Note: If request's referrer is \"no-referrer\", Fetch will not call into this algorithm.\n\t// > Note: If request's referrer policy is the empty string, Fetch will not call into this\n\t// > algorithm.\n\tif (request.referrer === 'no-referrer' || request.referrerPolicy === '') {\n\t\treturn null;\n\t}\n\n\t// 1. Let policy be request's associated referrer policy.\n\tconst policy = request.referrerPolicy;\n\n\t// 2. Let environment be request's client.\n\t// not applicable to node.js\n\n\t// 3. Switch on request's referrer:\n\tif (request.referrer === 'about:client') {\n\t\treturn 'no-referrer';\n\t}\n\n\t// \"a URL\": Let referrerSource be request's referrer.\n\tconst referrerSource = request.referrer;\n\n\t// 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.\n\tlet referrerURL = stripURLForUseAsAReferrer(referrerSource);\n\n\t// 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the\n\t//    origin-only flag set to true.\n\tlet referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);\n\n\t// 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set\n\t//    referrerURL to referrerOrigin.\n\tif (referrerURL.toString().length > 4096) {\n\t\treferrerURL = referrerOrigin;\n\t}\n\n\t// 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary\n\t//    policy considerations in the interests of minimizing data leakage. For example, the user\n\t//    agent could strip the URL down to an origin, modify its host, replace it with an empty\n\t//    string, etc.\n\tif (referrerURLCallback) {\n\t\treferrerURL = referrerURLCallback(referrerURL);\n\t}\n\n\tif (referrerOriginCallback) {\n\t\treferrerOrigin = referrerOriginCallback(referrerOrigin);\n\t}\n\n\t// 8.Execute the statements corresponding to the value of policy:\n\tconst currentURL = new URL(request.url);\n\n\tswitch (policy) {\n\t\tcase 'no-referrer':\n\t\t\treturn 'no-referrer';\n\n\t\tcase 'origin':\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'unsafe-url':\n\t\t\treturn referrerURL;\n\n\t\tcase 'strict-origin':\n\t\t\t// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 2. Return referrerOrigin.\n\t\t\treturn referrerOrigin.toString();\n\n\t\tcase 'strict-origin-when-cross-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 3. Return referrerOrigin.\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'same-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// 2. Return no referrer.\n\t\t\treturn 'no-referrer';\n\n\t\tcase 'origin-when-cross-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// Return referrerOrigin.\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'no-referrer-when-downgrade':\n\t\t\t// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 2. Return referrerURL.\n\t\t\treturn referrerURL;\n\n\t\tdefault:\n\t\t\tthrow new TypeError(`Invalid referrerPolicy: ${policy}`);\n\t}\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy \u00A78.1. Parse a referrer policy from a Referrer-Policy header}\n * @param {Headers} headers Response headers\n * @returns {string} policy\n */\nexport function parseReferrerPolicyFromHeader(headers) {\n\t// 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`\n\t//    and response\u2019s header list.\n\tconst policyTokens = (headers.get('referrer-policy') || '').split(/[,\\s]+/);\n\n\t// 2. Let policy be the empty string.\n\tlet policy = '';\n\n\t// 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty\n\t//    string, then set policy to token.\n\t// Note: This algorithm loops over multiple policy values to allow deployment of new policy\n\t// values with fallbacks for older user agents, as described in \u00A7 11.1 Unknown Policy Values.\n\tfor (const token of policyTokens) {\n\t\tif (token && ReferrerPolicy.has(token)) {\n\t\t\tpolicy = token;\n\t\t}\n\t}\n\n\t// 4. Return policy.\n\treturn policy;\n}\n", "/**\n * Request.js\n *\n * Request class contains server only options\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */\n\nimport {format as formatUrl} from 'node:url';\nimport {deprecate} from 'node:util';\nimport Headers from './headers.js';\nimport Body, {clone, extractContentType, getTotalBytes} from './body.js';\nimport {isAbortSignal} from './utils/is.js';\nimport {getSearch} from './utils/get-search.js';\nimport {\n\tvalidateReferrerPolicy, determineRequestsReferrer, DEFAULT_REFERRER_POLICY\n} from './utils/referrer.js';\n\nconst INTERNALS = Symbol('Request internals');\n\n/**\n * Check if `obj` is an instance of Request.\n *\n * @param  {*} object\n * @return {boolean}\n */\nconst isRequest = object => {\n\treturn (\n\t\ttypeof object === 'object' &&\n\t\ttypeof object[INTERNALS] === 'object'\n\t);\n};\n\nconst doBadDataWarn = deprecate(() => {},\n\t'.data is not a valid RequestInit property, use .body instead',\n\t'https://github.com/node-fetch/node-fetch/issues/1000 (request)');\n\n/**\n * Request class\n *\n * Ref: https://fetch.spec.whatwg.org/#request-class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nexport default class Request extends Body {\n\tconstructor(input, init = {}) {\n\t\tlet parsedURL;\n\n\t\t// Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)\n\t\tif (isRequest(input)) {\n\t\t\tparsedURL = new URL(input.url);\n\t\t} else {\n\t\t\tparsedURL = new URL(input);\n\t\t\tinput = {};\n\t\t}\n\n\t\tif (parsedURL.username !== '' || parsedURL.password !== '') {\n\t\t\tthrow new TypeError(`${parsedURL} is an url with embedded credentials.`);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tif (/^(delete|get|head|options|post|put)$/i.test(method)) {\n\t\t\tmethod = method.toUpperCase();\n\t\t}\n\n\t\tif (!isRequest(init) && 'data' in init) {\n\t\t\tdoBadDataWarn();\n\t\t}\n\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\tif ((init.body != null || (isRequest(input) && input.body !== null)) &&\n\t\t\t(method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tconst inputBody = init.body ?\n\t\t\tinit.body :\n\t\t\t(isRequest(input) && input.body !== null ?\n\t\t\t\tclone(input) :\n\t\t\t\tnull);\n\n\t\tsuper(inputBody, {\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody !== null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody, this);\n\t\t\tif (contentType) {\n\t\t\t\theaders.set('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ?\n\t\t\tinput.signal :\n\t\t\tnull;\n\t\tif ('signal' in init) {\n\t\t\tsignal = init.signal;\n\t\t}\n\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal or EventTarget');\n\t\t}\n\n\t\t// \u00A75.4, Request constructor steps, step 15.1\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\tlet referrer = init.referrer == null ? input.referrer : init.referrer;\n\t\tif (referrer === '') {\n\t\t\t// \u00A75.4, Request constructor steps, step 15.2\n\t\t\treferrer = 'no-referrer';\n\t\t} else if (referrer) {\n\t\t\t// \u00A75.4, Request constructor steps, step 15.3.1, 15.3.2\n\t\t\tconst parsedReferrer = new URL(referrer);\n\t\t\t// \u00A75.4, Request constructor steps, step 15.3.3, 15.3.4\n\t\t\treferrer = /^about:(\\/\\/)?client$/.test(parsedReferrer) ? 'client' : parsedReferrer;\n\t\t} else {\n\t\t\treferrer = undefined;\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal,\n\t\t\treferrer\n\t\t};\n\n\t\t// Node-fetch-only options\n\t\tthis.follow = init.follow === undefined ? (input.follow === undefined ? 20 : input.follow) : init.follow;\n\t\tthis.compress = init.compress === undefined ? (input.compress === undefined ? true : input.compress) : init.compress;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t\tthis.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;\n\t\tthis.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;\n\n\t\t// \u00A75.4, Request constructor steps, step 16.\n\t\t// Default is empty string per https://fetch.spec.whatwg.org/#concept-request-referrer-policy\n\t\tthis.referrerPolicy = init.referrerPolicy || input.referrerPolicy || '';\n\t}\n\n\t/** @returns {string} */\n\tget method() {\n\t\treturn this[INTERNALS].method;\n\t}\n\n\t/** @returns {string} */\n\tget url() {\n\t\treturn formatUrl(this[INTERNALS].parsedURL);\n\t}\n\n\t/** @returns {Headers} */\n\tget headers() {\n\t\treturn this[INTERNALS].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS].redirect;\n\t}\n\n\t/** @returns {AbortSignal} */\n\tget signal() {\n\t\treturn this[INTERNALS].signal;\n\t}\n\n\t// https://fetch.spec.whatwg.org/#dom-request-referrer\n\tget referrer() {\n\t\tif (this[INTERNALS].referrer === 'no-referrer') {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (this[INTERNALS].referrer === 'client') {\n\t\t\treturn 'about:client';\n\t\t}\n\n\t\tif (this[INTERNALS].referrer) {\n\t\t\treturn this[INTERNALS].referrer.toString();\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tget referrerPolicy() {\n\t\treturn this[INTERNALS].referrerPolicy;\n\t}\n\n\tset referrerPolicy(referrerPolicy) {\n\t\tthis[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);\n\t}\n\n\t/**\n\t * Clone this request\n\t *\n\t * @return  Request\n\t */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn 'Request';\n\t}\n}\n\nObject.defineProperties(Request.prototype, {\n\tmethod: {enumerable: true},\n\turl: {enumerable: true},\n\theaders: {enumerable: true},\n\tredirect: {enumerable: true},\n\tclone: {enumerable: true},\n\tsignal: {enumerable: true},\n\treferrer: {enumerable: true},\n\treferrerPolicy: {enumerable: true}\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param {Request} request - A Request instance\n * @return The options object to be passed to http.request\n */\nexport const getNodeRequestOptions = request => {\n\tconst {parsedURL} = request[INTERNALS];\n\tconst headers = new Headers(request[INTERNALS].headers);\n\n\t// Fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body === null && /^(post|put)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\n\tif (request.body !== null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\t// Set Content-Length if totalBytes is a number (that is not NaN)\n\t\tif (typeof totalBytes === 'number' && !Number.isNaN(totalBytes)) {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// 4.1. Main fetch, step 2.6\n\t// > If request's referrer policy is the empty string, then set request's referrer policy to the\n\t// > default referrer policy.\n\tif (request.referrerPolicy === '') {\n\t\trequest.referrerPolicy = DEFAULT_REFERRER_POLICY;\n\t}\n\n\t// 4.1. Main fetch, step 2.7\n\t// > If request's referrer is not \"no-referrer\", set request's referrer to the result of invoking\n\t// > determine request's referrer.\n\tif (request.referrer && request.referrer !== 'no-referrer') {\n\t\trequest[INTERNALS].referrer = determineRequestsReferrer(request);\n\t} else {\n\t\trequest[INTERNALS].referrer = 'no-referrer';\n\t}\n\n\t// 4.5. HTTP-network-or-cache fetch, step 6.9\n\t// > If httpRequest's referrer is a URL, then append `Referer`/httpRequest's referrer, serialized\n\t// >  and isomorphic encoded, to httpRequest's header list.\n\tif (request[INTERNALS].referrer instanceof URL) {\n\t\theaders.set('Referer', request.referrer);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip, deflate, br');\n\t}\n\n\tlet {agent} = request;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\tconst search = getSearch(parsedURL);\n\n\t// Pass the full URL directly to request(), but overwrite the following\n\t// options:\n\tconst options = {\n\t\t// Overwrite search to retain trailing ? (issue #776)\n\t\tpath: parsedURL.pathname + search,\n\t\t// The following options are not expressed in the URL\n\t\tmethod: request.method,\n\t\theaders: headers[Symbol.for('nodejs.util.inspect.custom')](),\n\t\tinsecureHTTPParser: request.insecureHTTPParser,\n\t\tagent\n\t};\n\n\treturn {\n\t\t/** @type {URL} */\n\t\tparsedURL,\n\t\toptions\n\t};\n};\n", "import {FetchBaseError} from './base.js';\n\n/**\n * AbortError interface for cancelled requests\n */\nexport class AbortError extends FetchBaseError {\n\tconstructor(message, type = 'aborted') {\n\t\tsuper(message, type);\n\t}\n}\n", "/**\n * Index.js\n *\n * a request API compatible with window.fetch\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */\n\nimport http from 'node:http';\nimport https from 'node:https';\nimport zlib from 'node:zlib';\nimport Stream, {PassThrough, pipeline as pump} from 'node:stream';\nimport {Buffer} from 'node:buffer';\n\nimport dataUriToBuffer from 'data-uri-to-buffer';\n\nimport {writeToStream, clone} from './body.js';\nimport Response from './response.js';\nimport Headers, {fromRawHeaders} from './headers.js';\nimport Request, {getNodeRequestOptions} from './request.js';\nimport {FetchError} from './errors/fetch-error.js';\nimport {AbortError} from './errors/abort-error.js';\nimport {isRedirect} from './utils/is-redirect.js';\nimport {FormData} from 'formdata-polyfill/esm.min.js';\nimport {isDomainOrSubdomain, isSameProtocol} from './utils/is.js';\nimport {parseReferrerPolicyFromHeader} from './utils/referrer.js';\nimport {\n\tBlob,\n\tFile,\n\tfileFromSync,\n\tfileFrom,\n\tblobFromSync,\n\tblobFrom\n} from 'fetch-blob/from.js';\n\nexport {FormData, Headers, Request, Response, FetchError, AbortError, isRedirect};\nexport {Blob, File, fileFromSync, fileFrom, blobFromSync, blobFrom};\n\nconst supportedSchemas = new Set(['data:', 'http:', 'https:']);\n\n/**\n * Fetch function\n *\n * @param   {string | URL | import('./request').default} url - Absolute url or Request instance\n * @param   {*} [options_] - Fetch options\n * @return  {Promise<import('./response').default>}\n */\nexport default async function fetch(url, options_) {\n\treturn new Promise((resolve, reject) => {\n\t\t// Build request object\n\t\tconst request = new Request(url, options_);\n\t\tconst {parsedURL, options} = getNodeRequestOptions(request);\n\t\tif (!supportedSchemas.has(parsedURL.protocol)) {\n\t\t\tthrow new TypeError(`node-fetch cannot load ${url}. URL scheme \"${parsedURL.protocol.replace(/:$/, '')}\" is not supported.`);\n\t\t}\n\n\t\tif (parsedURL.protocol === 'data:') {\n\t\t\tconst data = dataUriToBuffer(request.url);\n\t\t\tconst response = new Response(data, {headers: {'Content-Type': data.typeFull}});\n\t\t\tresolve(response);\n\t\t\treturn;\n\t\t}\n\n\t\t// Wrap http.request into fetch\n\t\tconst send = (parsedURL.protocol === 'https:' ? https : http).request;\n\t\tconst {signal} = request;\n\t\tlet response = null;\n\n\t\tconst abort = () => {\n\t\t\tconst error = new AbortError('The operation was aborted.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\trequest.body.destroy(error);\n\t\t\t}\n\n\t\t\tif (!response || !response.body) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = () => {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// Send request\n\t\tconst request_ = send(parsedURL.toString(), options);\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tconst finalize = () => {\n\t\t\trequest_.abort();\n\t\t\tif (signal) {\n\t\t\t\tsignal.removeEventListener('abort', abortAndFinalize);\n\t\t\t}\n\t\t};\n\n\t\trequest_.on('error', error => {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, 'system', error));\n\t\t\tfinalize();\n\t\t});\n\n\t\tfixResponseChunkedTransferBadEnding(request_, error => {\n\t\t\tif (response && response.body) {\n\t\t\t\tresponse.body.destroy(error);\n\t\t\t}\n\t\t});\n\n\t\t/* c8 ignore next 18 */\n\t\tif (process.version < 'v14') {\n\t\t\t// Before Node.js 14, pipeline() does not fully support async iterators and does not always\n\t\t\t// properly handle when the socket close/end events are out of order.\n\t\t\trequest_.on('socket', s => {\n\t\t\t\tlet endedWithEventsCount;\n\t\t\t\ts.prependListener('end', () => {\n\t\t\t\t\tendedWithEventsCount = s._eventsCount;\n\t\t\t\t});\n\t\t\t\ts.prependListener('close', hadError => {\n\t\t\t\t\t// if end happened before close but the socket didn't emit an error, do it now\n\t\t\t\t\tif (response && endedWithEventsCount < s._eventsCount && !hadError) {\n\t\t\t\t\t\tconst error = new Error('Premature close');\n\t\t\t\t\t\terror.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\t\tresponse.body.emit('error', error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\trequest_.on('response', response_ => {\n\t\t\trequest_.setTimeout(0);\n\t\t\tconst headers = fromRawHeaders(response_.rawHeaders);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (isRedirect(response_.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tlet locationURL = null;\n\t\t\t\ttry {\n\t\t\t\t\tlocationURL = location === null ? null : new URL(location, request.url);\n\t\t\t\t} catch {\n\t\t\t\t\t// error here can only be invalid URL in Location: header\n\t\t\t\t\t// do not throw when options.redirect == manual\n\t\t\t\t\t// let the user extract the errorneous redirect URL\n\t\t\t\t\tif (request.redirect !== 'manual') {\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// Nothing to do\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow': {\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOptions = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: clone(request),\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\tsize: request.size,\n\t\t\t\t\t\t\treferrer: request.referrer,\n\t\t\t\t\t\t\treferrerPolicy: request.referrerPolicy\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// when forwarding sensitive headers like \"Authorization\",\n\t\t\t\t\t\t// \"WWW-Authenticate\", and \"Cookie\" to untrusted targets,\n\t\t\t\t\t\t// headers will be ignored when following a redirect to a domain\n\t\t\t\t\t\t// that is not a subdomain match or exact match of the initial domain.\n\t\t\t\t\t\t// For example, a redirect from \"foo.com\" to either \"foo.com\" or \"sub.foo.com\"\n\t\t\t\t\t\t// will forward the sensitive headers, but a redirect to \"bar.com\" will not.\n\t\t\t\t\t\t// headers will also be ignored when following a redirect to a domain using\n\t\t\t\t\t\t// a different protocol. For example, a redirect from \"https://foo.com\" to \"http://foo.com\"\n\t\t\t\t\t\t// will not forward the sensitive headers\n\t\t\t\t\t\tif (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n\t\t\t\t\t\t\tfor (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {\n\t\t\t\t\t\t\t\trequestOptions.headers.delete(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (response_.statusCode !== 303 && request.body && options_.body instanceof Stream.Readable) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (response_.statusCode === 303 || ((response_.statusCode === 301 || response_.statusCode === 302) && request.method === 'POST')) {\n\t\t\t\t\t\t\trequestOptions.method = 'GET';\n\t\t\t\t\t\t\trequestOptions.body = undefined;\n\t\t\t\t\t\t\trequestOptions.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 14\n\t\t\t\t\t\tconst responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);\n\t\t\t\t\t\tif (responseReferrerPolicy) {\n\t\t\t\t\t\t\trequestOptions.referrerPolicy = responseReferrerPolicy;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOptions)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Prepare response\n\t\t\tif (signal) {\n\t\t\t\tresponse_.once('end', () => {\n\t\t\t\t\tsignal.removeEventListener('abort', abortAndFinalize);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet body = pump(response_, new PassThrough(), error => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t});\n\t\t\t// see https://github.com/nodejs/node/pull/29376\n\t\t\t/* c8 ignore next 3 */\n\t\t\tif (process.version < 'v12.10') {\n\t\t\t\tresponse_.on('aborted', abortAndFinalize);\n\t\t\t}\n\n\t\t\tconst responseOptions = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: response_.statusCode,\n\t\t\t\tstatusText: response_.statusMessage,\n\t\t\t\theaders,\n\t\t\t\tsize: request.size,\n\t\t\t\tcounter: request.counter,\n\t\t\t\thighWaterMark: request.highWaterMark\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// For gzip\n\t\t\tif (codings === 'gzip' || codings === 'x-gzip') {\n\t\t\t\tbody = pump(body, zlib.createGunzip(zlibOptions), error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For deflate\n\t\t\tif (codings === 'deflate' || codings === 'x-deflate') {\n\t\t\t\t// Handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = pump(response_, new PassThrough(), error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\traw.once('data', chunk => {\n\t\t\t\t\t// See http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = pump(body, zlib.createInflate(), error => {\n\t\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = pump(body, zlib.createInflateRaw(), error => {\n\t\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\traw.once('end', () => {\n\t\t\t\t\t// Some old IIS servers return zero-length OK deflate responses, so\n\t\t\t\t\t// 'data' is never emitted. See https://github.com/node-fetch/node-fetch/pull/903\n\t\t\t\t\tif (!response) {\n\t\t\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For br\n\t\t\tif (codings === 'br') {\n\t\t\t\tbody = pump(body, zlib.createBrotliDecompress(), error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise, use response as-is\n\t\t\tresponse = new Response(body, responseOptions);\n\t\t\tresolve(response);\n\t\t});\n\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\twriteToStream(request_, request).catch(reject);\n\t});\n}\n\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n\tconst LAST_CHUNK = Buffer.from('0\\r\\n\\r\\n');\n\n\tlet isChunkedTransfer = false;\n\tlet properLastChunkReceived = false;\n\tlet previousChunk;\n\n\trequest.on('response', response => {\n\t\tconst {headers} = response;\n\t\tisChunkedTransfer = headers['transfer-encoding'] === 'chunked' && !headers['content-length'];\n\t});\n\n\trequest.on('socket', socket => {\n\t\tconst onSocketClose = () => {\n\t\t\tif (isChunkedTransfer && !properLastChunkReceived) {\n\t\t\t\tconst error = new Error('Premature close');\n\t\t\t\terror.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\terrorCallback(error);\n\t\t\t}\n\t\t};\n\n\t\tconst onData = buf => {\n\t\t\tproperLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;\n\n\t\t\t// Sometimes final 0-length chunk and end of message code are in separate packets\n\t\t\tif (!properLastChunkReceived && previousChunk) {\n\t\t\t\tproperLastChunkReceived = (\n\t\t\t\t\tBuffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 &&\n\t\t\t\t\tBuffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpreviousChunk = buf;\n\t\t};\n\n\t\tsocket.prependListener('close', onSocketClose);\n\t\tsocket.on('data', onData);\n\n\t\trequest.on('close', () => {\n\t\t\tsocket.removeListener('close', onSocketClose);\n\t\t\tsocket.removeListener('data', onData);\n\t\t});\n\t});\n}\n", "import { Blob } from \"fetch-blob\"\n\nexport default Blob\n", null, "/// <reference lib=\"es2015.symbol\" />\n\nconst SymbolPolyfill: (description?: string) => symbol =\n  typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n    Symbol :\n    description => `Symbol(${description})` as any as symbol;\n\nexport default SymbolPolyfill;\n", "/// <reference lib=\"dom\" />\n\nexport function noop(): undefined {\n  return undefined;\n}\n\nfunction getGlobals() {\n  if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n", "import { noop } from '../../utils';\nimport { AssertionError } from '../../stub/assert';\n\nexport function typeIsObject(x: any): x is object {\n  return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\n\nexport const rethrowAssertionErrorRejection: (e: any) => void =\n  DEBUG ? e => {\n    // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\n    // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\n    // expect any errors, but assertion errors are always problematic.\n    if (e && e instanceof AssertionError) {\n      setTimeout(() => {\n        throw e;\n      }, 0);\n    }\n  } : noop;\n", "import { globals } from '../../utils';\nimport { rethrowAssertionErrorRejection } from './miscellaneous';\nimport assert from '../../stub/assert';\n\nconst originalPromise = Promise;\nconst originalPromiseThen = Promise.prototype.then;\nconst originalPromiseResolve = Promise.resolve.bind(originalPromise);\nconst originalPromiseReject = Promise.reject.bind(originalPromise);\n\nexport function newPromise<T>(executor: (\n  resolve: (value: T | PromiseLike<T>) => void,\n  reject: (reason?: any) => void\n) => void): Promise<T> {\n  return new originalPromise(executor);\n}\n\nexport function promiseResolvedWith<T>(value: T | PromiseLike<T>): Promise<T> {\n  return originalPromiseResolve(value);\n}\n\nexport function promiseRejectedWith<T = never>(reason: any): Promise<T> {\n  return originalPromiseReject(reason);\n}\n\nexport function PerformPromiseThen<T, TResult1 = T, TResult2 = never>(\n  promise: Promise<T>,\n  onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,\n  onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\n  // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n  // approximation.\n  return originalPromiseThen.call(promise, onFulfilled, onRejected) as Promise<TResult1 | TResult2>;\n}\n\nexport function uponPromise<T>(\n  promise: Promise<T>,\n  onFulfilled?: (value: T) => void | PromiseLike<void>,\n  onRejected?: (reason: any) => void | PromiseLike<void>): void {\n  PerformPromiseThen(\n    PerformPromiseThen(promise, onFulfilled, onRejected),\n    undefined,\n    rethrowAssertionErrorRejection\n  );\n}\n\nexport function uponFulfillment<T>(promise: Promise<T>, onFulfilled: (value: T) => void | PromiseLike<void>): void {\n  uponPromise(promise, onFulfilled);\n}\n\nexport function uponRejection(promise: Promise<unknown>, onRejected: (reason: any) => void | PromiseLike<void>): void {\n  uponPromise(promise, undefined, onRejected);\n}\n\nexport function transformPromiseWith<T, TResult1 = T, TResult2 = never>(\n  promise: Promise<T>,\n  fulfillmentHandler?: (value: T) => TResult1 | PromiseLike<TResult1>,\n  rejectionHandler?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\n  return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n}\n\nexport function setPromiseIsHandledToTrue(promise: Promise<unknown>): void {\n  PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n}\n\nexport const queueMicrotask: (fn: () => void) => void = (() => {\n  const globalQueueMicrotask = globals && globals.queueMicrotask;\n  if (typeof globalQueueMicrotask === 'function') {\n    return globalQueueMicrotask;\n  }\n\n  const resolvedPromise = promiseResolvedWith(undefined);\n  return (fn: () => void) => PerformPromiseThen(resolvedPromise, fn);\n})();\n\nexport function reflectCall<T, A extends any[], R>(F: (this: T, ...fnArgs: A) => R, V: T, args: A): R {\n  if (typeof F !== 'function') {\n    throw new TypeError('Argument is not a function');\n  }\n  return Function.prototype.apply.call(F, V, args);\n}\n\nexport function promiseCall<T, A extends any[], R>(F: (this: T, ...fnArgs: A) => R | PromiseLike<R>,\n                                                   V: T,\n                                                   args: A): Promise<R> {\n  assert(typeof F === 'function');\n  assert(V !== undefined);\n  assert(Array.isArray(args));\n  try {\n    return promiseResolvedWith(reflectCall(F, V, args));\n  } catch (value) {\n    return promiseRejectedWith(value);\n  }\n}\n", "import assert from '../stub/assert';\n\n// Original from Chromium\n// https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n\nconst QUEUE_MAX_ARRAY_SIZE = 16384;\n\ninterface Node<T> {\n  _elements: T[];\n  _next: Node<T> | undefined;\n}\n\n/**\n * Simple queue structure.\n *\n * Avoids scalability issues with using a packed array directly by using\n * multiple arrays in a linked list and keeping the array size bounded.\n */\nexport class SimpleQueue<T> {\n  private _front: Node<T>;\n  private _back: Node<T>;\n  private _cursor = 0;\n  private _size = 0;\n\n  constructor() {\n    // _front and _back are always defined.\n    this._front = {\n      _elements: [],\n      _next: undefined\n    };\n    this._back = this._front;\n    // The cursor is used to avoid calling Array.shift().\n    // It contains the index of the front element of the array inside the\n    // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n    this._cursor = 0;\n    // When there is only one node, size === elements.length - cursor.\n    this._size = 0;\n  }\n\n  get length(): number {\n    return this._size;\n  }\n\n  // For exception safety, this method is structured in order:\n  // 1. Read state\n  // 2. Calculate required state mutations\n  // 3. Perform state mutations\n  push(element: T): void {\n    const oldBack = this._back;\n    let newBack = oldBack;\n    assert(oldBack._next === undefined);\n    if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n      newBack = {\n        _elements: [],\n        _next: undefined\n      };\n    }\n\n    // push() is the mutation most likely to throw an exception, so it\n    // goes first.\n    oldBack._elements.push(element);\n    if (newBack !== oldBack) {\n      this._back = newBack;\n      oldBack._next = newBack;\n    }\n    ++this._size;\n  }\n\n  // Like push(), shift() follows the read -> calculate -> mutate pattern for\n  // exception safety.\n  shift(): T {\n    assert(this._size > 0); // must not be called on an empty queue\n\n    const oldFront = this._front;\n    let newFront = oldFront;\n    const oldCursor = this._cursor;\n    let newCursor = oldCursor + 1;\n\n    const elements = oldFront._elements;\n    const element = elements[oldCursor];\n\n    if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n      assert(elements.length === QUEUE_MAX_ARRAY_SIZE);\n      assert(oldFront._next !== undefined);\n      newFront = oldFront._next!;\n      newCursor = 0;\n    }\n\n    // No mutations before this point.\n    --this._size;\n    this._cursor = newCursor;\n    if (oldFront !== newFront) {\n      this._front = newFront;\n    }\n\n    // Permit shifted element to be garbage collected.\n    elements[oldCursor] = undefined!;\n\n    return element;\n  }\n\n  // The tricky thing about forEach() is that it can be called\n  // re-entrantly. The queue may be mutated inside the callback. It is easy to\n  // see that push() within the callback has no negative effects since the end\n  // of the queue is checked for on every iteration. If shift() is called\n  // repeatedly within the callback then the next iteration may return an\n  // element that has been removed. In this case the callback will be called\n  // with undefined values until we either \"catch up\" with elements that still\n  // exist or reach the back of the queue.\n  forEach(callback: (element: T) => void): void {\n    let i = this._cursor;\n    let node = this._front;\n    let elements = node._elements;\n    while (i !== elements.length || node._next !== undefined) {\n      if (i === elements.length) {\n        assert(node._next !== undefined);\n        assert(i === QUEUE_MAX_ARRAY_SIZE);\n        node = node._next!;\n        elements = node._elements;\n        i = 0;\n        if (elements.length === 0) {\n          break;\n        }\n      }\n      callback(elements[i]);\n      ++i;\n    }\n  }\n\n  // Return the element that would be returned if shift() was called now,\n  // without modifying the queue.\n  peek(): T {\n    assert(this._size > 0); // must not be called on an empty queue\n\n    const front = this._front;\n    const cursor = this._cursor;\n    return front._elements[cursor];\n  }\n}\n", "import assert from '../../stub/assert';\nimport { ReadableStream, ReadableStreamCancel, ReadableStreamReader } from '../readable-stream';\nimport { newPromise, setPromiseIsHandledToTrue } from '../helpers/webidl';\n\nexport function ReadableStreamReaderGenericInitialize<R>(reader: ReadableStreamReader<R>, stream: ReadableStream<R>) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    assert(stream._state === 'errored');\n\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n  }\n}\n\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\nexport function ReadableStreamReaderGenericCancel(reader: ReadableStreamReader<any>, reason: any): Promise<undefined> {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  return ReadableStreamCancel(stream, reason);\n}\n\nexport function ReadableStreamReaderGenericRelease(reader: ReadableStreamReader<any>) {\n  assert(reader._ownerReadableStream !== undefined);\n  assert(reader._ownerReadableStream._reader === reader);\n\n  if (reader._ownerReadableStream._state === 'readable') {\n    defaultReaderClosedPromiseReject(\n      reader,\n      new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(\n      reader,\n      new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  }\n\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined!;\n}\n\n// Helper functions for the readers.\n\nexport function readerLockException(name: string): TypeError {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nexport function defaultReaderClosedPromiseInitialize(reader: ReadableStreamReader<any>) {\n  reader._closedPromise = newPromise((resolve, reject) => {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nexport function defaultReaderClosedPromiseInitializeAsRejected(reader: ReadableStreamReader<any>, reason: any) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseReject(reader, reason);\n}\n\nexport function defaultReaderClosedPromiseInitializeAsResolved(reader: ReadableStreamReader<any>) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseResolve(reader);\n}\n\nexport function defaultReaderClosedPromiseReject(reader: ReadableStreamReader<any>, reason: any) {\n  if (reader._closedPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(reader._closedPromise);\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nexport function defaultReaderClosedPromiseResetToRejected(reader: ReadableStreamReader<any>, reason: any) {\n  assert(reader._closedPromise_resolve === undefined);\n  assert(reader._closedPromise_reject === undefined);\n\n  defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n}\n\nexport function defaultReaderClosedPromiseResolve(reader: ReadableStreamReader<any>) {\n  if (reader._closedPromise_resolve === undefined) {\n    return;\n  }\n\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n", "export const AbortSteps = Symbol('[[AbortSteps]]');\nexport const ErrorSteps = Symbol('[[ErrorSteps]]');\nexport const CancelSteps = Symbol('[[CancelSteps]]');\nexport const PullSteps = Symbol('[[PullSteps]]');\n", "/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\nconst NumberIsFinite: typeof Number.isFinite = Number.isFinite || function (x) {\n  return typeof x === 'number' && isFinite(x);\n};\n\nexport default NumberIsFinite;\n", "/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\nconst MathTrunc: typeof Math.trunc = Math.trunc || function (v) {\n  return v < 0 ? Math.ceil(v) : Math.floor(v);\n};\n\nexport default MathTrunc;\n", "import NumberIsFinite from '../../stub/number-isfinite';\nimport MathTrunc from '../../stub/math-trunc';\n\n// https://heycam.github.io/webidl/#idl-dictionaries\nexport function isDictionary(x: any): x is object | null {\n  return typeof x === 'object' || typeof x === 'function';\n}\n\nexport function assertDictionary(obj: unknown,\n                                 context: string): asserts obj is object | null | undefined {\n  if (obj !== undefined && !isDictionary(obj)) {\n    throw new TypeError(`${context} is not an object.`);\n  }\n}\n\nexport type AnyFunction = (...args: any[]) => any;\n\n// https://heycam.github.io/webidl/#idl-callback-functions\nexport function assertFunction(x: unknown, context: string): asserts x is AnyFunction {\n  if (typeof x !== 'function') {\n    throw new TypeError(`${context} is not a function.`);\n  }\n}\n\n// https://heycam.github.io/webidl/#idl-object\nexport function isObject(x: any): x is object {\n  return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\n\nexport function assertObject(x: unknown,\n                             context: string): asserts x is object {\n  if (!isObject(x)) {\n    throw new TypeError(`${context} is not an object.`);\n  }\n}\n\nexport function assertRequiredArgument<T extends any>(x: T | undefined,\n                                                      position: number,\n                                                      context: string): asserts x is T {\n  if (x === undefined) {\n    throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n  }\n}\n\nexport function assertRequiredField<T extends any>(x: T | undefined,\n                                                   field: string,\n                                                   context: string): asserts x is T {\n  if (x === undefined) {\n    throw new TypeError(`${field} is required in '${context}'.`);\n  }\n}\n\n// https://heycam.github.io/webidl/#idl-unrestricted-double\nexport function convertUnrestrictedDouble(value: unknown): number {\n  return Number(value);\n}\n\nfunction censorNegativeZero(x: number): number {\n  return x === 0 ? 0 : x;\n}\n\nfunction integerPart(x: number): number {\n  return censorNegativeZero(MathTrunc(x));\n}\n\n// https://heycam.github.io/webidl/#idl-unsigned-long-long\nexport function convertUnsignedLongLongWithEnforceRange(value: unknown, context: string): number {\n  const lowerBound = 0;\n  const upperBound = Number.MAX_SAFE_INTEGER;\n\n  let x = Number(value);\n  x = censorNegativeZero(x);\n\n  if (!NumberIsFinite(x)) {\n    throw new TypeError(`${context} is not a finite number`);\n  }\n\n  x = integerPart(x);\n\n  if (x < lowerBound || x > upperBound) {\n    throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n  }\n\n  if (!NumberIsFinite(x) || x === 0) {\n    return 0;\n  }\n\n  // TODO Use BigInt if supported?\n  // let xBigInt = BigInt(integerPart(x));\n  // xBigInt = BigInt.asUintN(64, xBigInt);\n  // return Number(xBigInt);\n\n  return x;\n}\n", "import { IsReadableStream, ReadableStream } from '../readable-stream';\n\nexport function assertReadableStream(x: unknown, context: string): asserts x is ReadableStream {\n  if (!IsReadableStream(x)) {\n    throw new TypeError(`${context} is not a ReadableStream.`);\n  }\n}\n", "import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericInitialize,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport { IsReadableStreamLocked, ReadableStream } from '../readable-stream';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport { PullSteps } from '../abstract-ops/internal-methods';\nimport { newPromise, promiseRejectedWith } from '../helpers/webidl';\nimport { assertRequiredArgument } from '../validators/basic';\nimport { assertReadableStream } from '../validators/readable-stream';\n\n/**\n * A result returned by {@link ReadableStreamDefaultReader.read}.\n *\n * @public\n */\nexport type ReadableStreamDefaultReadResult<T> = {\n  done: false;\n  value: T;\n} | {\n  done: true;\n  value?: undefined;\n}\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamDefaultReader<R>(stream: ReadableStream): ReadableStreamDefaultReader<R> {\n  return new ReadableStreamDefaultReader(stream);\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamAddReadRequest<R>(stream: ReadableStream<R>,\n                                                readRequest: ReadRequest<R>): void {\n  assert(IsReadableStreamDefaultReader(stream._reader));\n  assert(stream._state === 'readable');\n\n  (stream._reader! as ReadableStreamDefaultReader<R>)._readRequests.push(readRequest);\n}\n\nexport function ReadableStreamFulfillReadRequest<R>(stream: ReadableStream<R>, chunk: R | undefined, done: boolean) {\n  const reader = stream._reader as ReadableStreamDefaultReader<R>;\n\n  assert(reader._readRequests.length > 0);\n\n  const readRequest = reader._readRequests.shift()!;\n  if (done) {\n    readRequest._closeSteps();\n  } else {\n    readRequest._chunkSteps(chunk!);\n  }\n}\n\nexport function ReadableStreamGetNumReadRequests<R>(stream: ReadableStream<R>): number {\n  return (stream._reader as ReadableStreamDefaultReader<R>)._readRequests.length;\n}\n\nexport function ReadableStreamHasDefaultReader(stream: ReadableStream): boolean {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (!IsReadableStreamDefaultReader(reader)) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nexport interface ReadRequest<R> {\n  _chunkSteps(chunk: R): void;\n\n  _closeSteps(): void;\n\n  _errorSteps(e: any): void;\n}\n\n/**\n * A default reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nexport class ReadableStreamDefaultReader<R = any> {\n  /** @internal */\n  _ownerReadableStream!: ReadableStream<R>;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readRequests: SimpleQueue<ReadRequest<R>>;\n\n  constructor(stream: ReadableStream<R>) {\n    assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n    assertReadableStream(stream, 'First parameter');\n\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readRequests = new SimpleQueue();\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed,\n   * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  /**\n   * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n   *\n   * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   */\n  read(): Promise<ReadableStreamDefaultReadResult<R>> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('read from'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamDefaultReadResult<R>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamDefaultReadResult<R>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n      _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n      _errorSteps: e => rejectPromise(e)\n    };\n    ReadableStreamDefaultReaderRead(this, readRequest);\n    return promise;\n  }\n\n  /**\n   * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n   * from now on; otherwise, the reader will appear closed.\n   *\n   * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n   * do so will throw a `TypeError` and leave the reader locked to the stream.\n   */\n  releaseLock(): void {\n    if (!IsReadableStreamDefaultReader(this)) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\nObject.defineProperties(ReadableStreamDefaultReader.prototype, {\n  cancel: { enumerable: true },\n  read: { enumerable: true },\n  releaseLock: { enumerable: true },\n  closed: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamDefaultReader',\n    configurable: true\n  });\n}\n\n// Abstract operations for the readers.\n\nexport function IsReadableStreamDefaultReader<R = any>(x: any): x is ReadableStreamDefaultReader<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamDefaultReader;\n}\n\nexport function ReadableStreamDefaultReaderRead<R>(reader: ReadableStreamDefaultReader<R>,\n                                                   readRequest: ReadRequest<R>): void {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    readRequest._closeSteps();\n  } else if (stream._state === 'errored') {\n    readRequest._errorSteps(stream._storedError);\n  } else {\n    assert(stream._state === 'readable');\n    stream._readableStreamController[PullSteps](readRequest as ReadRequest<any>);\n  }\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction defaultReaderBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n", "/// <reference lib=\"es2018.asynciterable\" />\n\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport const AsyncIteratorPrototype: AsyncIterable<any> | undefined =\n  Object.getPrototypeOf(Object.getPrototypeOf(async function* (): AsyncIterableIterator<any> {}).prototype);\n", "/// <reference lib=\"es2018.asynciterable\" />\n\nimport { ReadableStream } from '../readable-stream';\nimport {\n  AcquireReadableStreamDefaultReader,\n  ReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderRead,\n  ReadableStreamDefaultReadResult,\n  ReadRequest\n} from './default-reader';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport assert from '../../stub/assert';\nimport { AsyncIteratorPrototype } from '@@target/stub/async-iterator-prototype';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  queueMicrotask,\n  transformPromiseWith\n} from '../helpers/webidl';\n\n/**\n * An async iterator returned by {@link ReadableStream.values}.\n *\n * @public\n */\nexport interface ReadableStreamAsyncIterator<R> extends AsyncIterator<R> {\n  next(): Promise<IteratorResult<R, undefined>>;\n\n  return(value?: any): Promise<IteratorResult<any>>;\n}\n\nexport class ReadableStreamAsyncIteratorImpl<R> {\n  private readonly _reader: ReadableStreamDefaultReader<R>;\n  private readonly _preventCancel: boolean;\n  private _ongoingPromise: Promise<ReadableStreamDefaultReadResult<R>> | undefined = undefined;\n  private _isFinished = false;\n\n  constructor(reader: ReadableStreamDefaultReader<R>, preventCancel: boolean) {\n    this._reader = reader;\n    this._preventCancel = preventCancel;\n  }\n\n  next(): Promise<ReadableStreamDefaultReadResult<R>> {\n    const nextSteps = () => this._nextSteps();\n    this._ongoingPromise = this._ongoingPromise ?\n      transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :\n      nextSteps();\n    return this._ongoingPromise;\n  }\n\n  return(value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    const returnSteps = () => this._returnSteps(value);\n    return this._ongoingPromise ?\n      transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :\n      returnSteps();\n  }\n\n  private _nextSteps(): Promise<ReadableStreamDefaultReadResult<R>> {\n    if (this._isFinished) {\n      return Promise.resolve({ value: undefined, done: true });\n    }\n\n    const reader = this._reader;\n    if (reader._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('iterate'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamDefaultReadResult<R>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamDefaultReadResult<R>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => {\n        this._ongoingPromise = undefined;\n        // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n        // FIXME Is this a bug in the specification, or in the test?\n        queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n      },\n      _closeSteps: () => {\n        this._ongoingPromise = undefined;\n        this._isFinished = true;\n        ReadableStreamReaderGenericRelease(reader);\n        resolvePromise({ value: undefined, done: true });\n      },\n      _errorSteps: reason => {\n        this._ongoingPromise = undefined;\n        this._isFinished = true;\n        ReadableStreamReaderGenericRelease(reader);\n        rejectPromise(reason);\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n    return promise;\n  }\n\n  private _returnSteps(value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (this._isFinished) {\n      return Promise.resolve({ value, done: true });\n    }\n    this._isFinished = true;\n\n    const reader = this._reader;\n    if (reader._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('finish iterating'));\n    }\n\n    assert(reader._readRequests.length === 0);\n\n    if (!this._preventCancel) {\n      const result = ReadableStreamReaderGenericCancel(reader, value);\n      ReadableStreamReaderGenericRelease(reader);\n      return transformPromiseWith(result, () => ({ value, done: true }));\n    }\n\n    ReadableStreamReaderGenericRelease(reader);\n    return promiseResolvedWith({ value, done: true });\n  }\n}\n\ndeclare class ReadableStreamAsyncIteratorInstance<R> implements ReadableStreamAsyncIterator<R> {\n  /** @interal */\n  _asyncIteratorImpl: ReadableStreamAsyncIteratorImpl<R>;\n\n  next(): Promise<IteratorResult<R, undefined>>;\n\n  return(value?: any): Promise<IteratorResult<any>>;\n}\n\nconst ReadableStreamAsyncIteratorPrototype: ReadableStreamAsyncIteratorInstance<any> = {\n  next(this: ReadableStreamAsyncIteratorInstance<any>): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (!IsReadableStreamAsyncIterator(this)) {\n      return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n    }\n    return this._asyncIteratorImpl.next();\n  },\n\n  return(this: ReadableStreamAsyncIteratorInstance<any>, value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (!IsReadableStreamAsyncIterator(this)) {\n      return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n    }\n    return this._asyncIteratorImpl.return(value);\n  }\n} as any;\nif (AsyncIteratorPrototype !== undefined) {\n  Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n}\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamAsyncIterator<R>(stream: ReadableStream<R>,\n                                                      preventCancel: boolean): ReadableStreamAsyncIterator<R> {\n  const reader = AcquireReadableStreamDefaultReader<R>(stream);\n  const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n  const iterator: ReadableStreamAsyncIteratorInstance<R> = Object.create(ReadableStreamAsyncIteratorPrototype);\n  iterator._asyncIteratorImpl = impl;\n  return iterator;\n}\n\nfunction IsReadableStreamAsyncIterator<R = any>(x: any): x is ReadableStreamAsyncIterator<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n    return false;\n  }\n\n  try {\n    // noinspection SuspiciousTypeOfGuard\n    return (x as ReadableStreamAsyncIteratorInstance<any>)._asyncIteratorImpl instanceof\n      ReadableStreamAsyncIteratorImpl;\n  } catch {\n    return false;\n  }\n}\n\n// Helper functions for the ReadableStream.\n\nfunction streamAsyncIteratorBrandCheckException(name: string): TypeError {\n  return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n}\n", "/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN: typeof Number.isNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nexport default NumberIsNaN;\n", "export function CreateArrayFromList<T extends any[]>(elements: T): T {\n  // We use arrays to represent lists, so this is basically a no-op.\n  // Do a slice though just in case we happen to depend on the unique-ness.\n  return elements.slice() as T;\n}\n\nexport function CopyDataBlockBytes(dest: ArrayBuffer,\n                                   destOffset: number,\n                                   src: ArrayBuffer,\n                                   srcOffset: number,\n                                   n: number) {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n}\n\n// Not implemented correctly\nexport function TransferArrayBuffer<T extends ArrayBufferLike>(O: T): T {\n  return O;\n}\n\n// Not implemented correctly\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function CanTransferArrayBuffer(O: ArrayBufferLike): boolean {\n  return true;\n}\n\n// Not implemented correctly\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function IsDetachedBuffer(O: ArrayBufferLike): boolean {\n  return false;\n}\n\nexport function ArrayBufferSlice(buffer: ArrayBufferLike, begin: number, end: number): ArrayBufferLike {\n  // ArrayBuffer.prototype.slice is not available on IE10\n  // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n  if (buffer.slice) {\n    return buffer.slice(begin, end);\n  }\n  const length = end - begin;\n  const slice = new ArrayBuffer(length);\n  CopyDataBlockBytes(slice, 0, buffer, begin, length);\n  return slice;\n}\n", "import NumberIsNaN from '../../stub/number-isnan';\nimport { ArrayBufferSlice } from './ecmascript';\n\nexport function IsNonNegativeNumber(v: number): boolean {\n  if (typeof v !== 'number') {\n    return false;\n  }\n\n  if (NumberIsNaN(v)) {\n    return false;\n  }\n\n  if (v < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function CloneAsUint8Array(O: ArrayBufferView): Uint8Array {\n  const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n  return new Uint8Array(buffer);\n}\n", "import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport { IsNonNegativeNumber } from './miscellaneous';\n\nexport interface QueueContainer<T> {\n  _queue: SimpleQueue<T>;\n  _queueTotalSize: number;\n}\n\nexport interface QueuePair<T> {\n  value: T;\n  size: number;\n}\n\nexport function DequeueValue<T>(container: QueueContainer<QueuePair<T>>): T {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.shift()!;\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n\n  return pair.value;\n}\n\nexport function EnqueueValueWithSize<T>(container: QueueContainer<QueuePair<T>>, value: T, size: number) {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  if (!IsNonNegativeNumber(size) || size === Infinity) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  container._queue.push({ value, size });\n  container._queueTotalSize += size;\n}\n\nexport function PeekQueueValue<T>(container: QueueContainer<QueuePair<T>>): T {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.peek();\n  return pair.value;\n}\n\nexport function ResetQueue<T>(container: QueueContainer<T>) {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  container._queue = new SimpleQueue<T>();\n  container._queueTotalSize = 0;\n}\n", "import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport { ResetQueue } from '../abstract-ops/queue-with-sizes';\nimport {\n  ReadableStreamAddReadRequest,\n  ReadableStreamFulfillReadRequest,\n  ReadableStreamGetNumReadRequests,\n  ReadableStreamHasDefaultReader,\n  ReadRequest\n} from './default-reader';\nimport {\n  ReadableStreamAddReadIntoRequest,\n  ReadableStreamFulfillReadIntoRequest,\n  ReadableStreamGetNumReadIntoRequests,\n  ReadableStreamHasBYOBReader,\n  ReadIntoRequest\n} from './byob-reader';\nimport NumberIsInteger from '../../stub/number-isinteger';\nimport {\n  IsReadableStreamLocked,\n  ReadableByteStream,\n  ReadableStreamClose,\n  ReadableStreamError\n} from '../readable-stream';\nimport { ValidatedUnderlyingByteSource } from './underlying-source';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport {\n  ArrayBufferSlice,\n  CanTransferArrayBuffer,\n  CopyDataBlockBytes,\n  IsDetachedBuffer,\n  TransferArrayBuffer\n} from '../abstract-ops/ecmascript';\nimport { CancelSteps, PullSteps } from '../abstract-ops/internal-methods';\nimport { promiseResolvedWith, uponPromise } from '../helpers/webidl';\nimport { assertRequiredArgument, convertUnsignedLongLongWithEnforceRange } from '../validators/basic';\n\n/**\n * A pull-into request in a {@link ReadableByteStreamController}.\n *\n * @public\n */\nexport class ReadableStreamBYOBRequest {\n  /** @internal */\n  _associatedReadableByteStreamController!: ReadableByteStreamController;\n  /** @internal */\n  _view!: ArrayBufferView | null;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n   */\n  get view(): ArrayBufferView | null {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('view');\n    }\n\n    return this._view;\n  }\n\n  /**\n   * Indicates to the associated readable byte stream that `bytesWritten` bytes were written into\n   * {@link ReadableStreamBYOBRequest.view | view}, causing the result be surfaced to the consumer.\n   *\n   * After this method is called, {@link ReadableStreamBYOBRequest.view | view} will be transferred and no longer\n   * modifiable.\n   */\n  respond(bytesWritten: number): void;\n  respond(bytesWritten: number | undefined): void {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('respond');\n    }\n    assertRequiredArgument(bytesWritten, 1, 'respond');\n    bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(this._view!.buffer)) {\n      throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);\n    }\n\n    assert(this._view!.byteLength > 0);\n    assert(this._view!.buffer.byteLength > 0);\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  }\n\n  /**\n   * Indicates to the associated readable byte stream that instead of writing into\n   * {@link ReadableStreamBYOBRequest.view | view}, the underlying byte source is providing a new `ArrayBufferView`,\n   * which will be given to the consumer of the readable byte stream.\n   *\n   * After this method is called, `view` will be transferred and no longer modifiable.\n   */\n  respondWithNewView(view: ArrayBufferView): void;\n  respondWithNewView(view: ArrayBufferView | undefined): void {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('respondWithNewView');\n    }\n    assertRequiredArgument(view, 1, 'respondWithNewView');\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(view.buffer)) {\n      throw new TypeError('The given view\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  }\n}\n\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, {\n  respond: { enumerable: true },\n  respondWithNewView: { enumerable: true },\n  view: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamBYOBRequest',\n    configurable: true\n  });\n}\n\ninterface ArrayBufferViewConstructor<T extends ArrayBufferView = ArrayBufferView> {\n  new(buffer: ArrayBufferLike, byteOffset: number, length?: number): T;\n\n  readonly prototype: T;\n  readonly BYTES_PER_ELEMENT: number;\n}\n\ninterface ByteQueueElement {\n  buffer: ArrayBufferLike;\n  byteOffset: number;\n  byteLength: number;\n}\n\ntype PullIntoDescriptor<T extends ArrayBufferView = ArrayBufferView> =\n  DefaultPullIntoDescriptor\n  | BYOBPullIntoDescriptor<T>;\n\ninterface DefaultPullIntoDescriptor {\n  buffer: ArrayBufferLike;\n  bufferByteLength: number;\n  byteOffset: number;\n  byteLength: number;\n  bytesFilled: number;\n  elementSize: number;\n  viewConstructor: ArrayBufferViewConstructor<Uint8Array>;\n  readerType: 'default';\n}\n\ninterface BYOBPullIntoDescriptor<T extends ArrayBufferView = ArrayBufferView> {\n  buffer: ArrayBufferLike;\n  bufferByteLength: number;\n  byteOffset: number;\n  byteLength: number;\n  bytesFilled: number;\n  elementSize: number;\n  viewConstructor: ArrayBufferViewConstructor<T>;\n  readerType: 'byob';\n}\n\n/**\n * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n *\n * @public\n */\nexport class ReadableByteStreamController {\n  /** @internal */\n  _controlledReadableByteStream!: ReadableByteStream;\n  /** @internal */\n  _queue!: SimpleQueue<ByteQueueElement>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _closeRequested!: boolean;\n  /** @internal */\n  _pullAgain!: boolean;\n  /** @internal */\n  _pulling !: boolean;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _pullAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm!: (reason: any) => Promise<void>;\n  /** @internal */\n  _autoAllocateChunkSize: number | undefined;\n  /** @internal */\n  _byobRequest: ReadableStreamBYOBRequest | null;\n  /** @internal */\n  _pendingPullIntos!: SimpleQueue<PullIntoDescriptor>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the current BYOB pull request, or `null` if there isn't one.\n   */\n  get byobRequest(): ReadableStreamBYOBRequest | null {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n\n    return ReadableByteStreamControllerGetBYOBRequest(this);\n  }\n\n  /**\n   * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n   * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n   */\n  get desiredSize(): number | null {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n\n  /**\n   * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   * the stream, but once those are read, the stream will become closed.\n   */\n  close(): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableByteStreamControllerClose(this);\n  }\n\n  /**\n   * Enqueues the given chunk chunk in the controlled readable stream.\n   * The chunk has to be an `ArrayBufferView` instance, or else a `TypeError` will be thrown.\n   */\n  enqueue(chunk: ArrayBufferView): void;\n  enqueue(chunk: ArrayBufferView | undefined): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    assertRequiredArgument(chunk, 1, 'enqueue');\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('chunk must be an array buffer view');\n    }\n    if (chunk.byteLength === 0) {\n      throw new TypeError('chunk must have non-zero byteLength');\n    }\n    if (chunk.buffer.byteLength === 0) {\n      throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n    }\n\n    if (this._closeRequested) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   */\n  error(e: any = undefined): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  }\n\n  /** @internal */\n  [CancelSteps](reason: any): Promise<void> {\n    ReadableByteStreamControllerClearPendingPullIntos(this);\n\n    ResetQueue(this);\n\n    const result = this._cancelAlgorithm(reason);\n    ReadableByteStreamControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [PullSteps](readRequest: ReadRequest<Uint8Array>): void {\n    const stream = this._controlledReadableByteStream;\n    assert(ReadableStreamHasDefaultReader(stream));\n\n    if (this._queueTotalSize > 0) {\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\n\n      const entry = this._queue.shift()!;\n      this._queueTotalSize -= entry.byteLength;\n\n      ReadableByteStreamControllerHandleQueueDrain(this);\n\n      const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n\n      readRequest._chunkSteps(view);\n      return;\n    }\n\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n      let buffer: ArrayBuffer;\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        readRequest._errorSteps(bufferE);\n        return;\n      }\n\n      const pullIntoDescriptor: DefaultPullIntoDescriptor = {\n        buffer,\n        bufferByteLength: autoAllocateChunkSize,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        elementSize: 1,\n        viewConstructor: Uint8Array,\n        readerType: 'default'\n      };\n\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n\n    ReadableStreamAddReadRequest(stream, readRequest);\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n  }\n}\n\nObject.defineProperties(ReadableByteStreamController.prototype, {\n  close: { enumerable: true },\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  byobRequest: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {\n    value: 'ReadableByteStreamController',\n    configurable: true\n  });\n}\n\n// Abstract operations for the ReadableByteStreamController.\n\nexport function IsReadableByteStreamController(x: any): x is ReadableByteStreamController {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n    return false;\n  }\n\n  return x instanceof ReadableByteStreamController;\n}\n\nfunction IsReadableStreamBYOBRequest(x: any): x is ReadableStreamBYOBRequest {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamBYOBRequest;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller: ReadableByteStreamController): void {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (!shouldPull) {\n    return;\n  }\n\n  if (controller._pulling) {\n    controller._pullAgain = true;\n    return;\n  }\n\n  assert(!controller._pullAgain);\n\n  controller._pulling = true;\n\n  // TODO: Test controller argument\n  const pullPromise = controller._pullAlgorithm();\n  uponPromise(\n    pullPromise,\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    },\n    e => {\n      ReadableByteStreamControllerError(controller, e);\n    }\n  );\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller: ReadableByteStreamController) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = new SimpleQueue();\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor<T extends ArrayBufferView>(\n  stream: ReadableByteStream,\n  pullIntoDescriptor: PullIntoDescriptor<T>\n) {\n  assert(stream._state !== 'errored');\n\n  let done = false;\n  if (stream._state === 'closed') {\n    assert(pullIntoDescriptor.bytesFilled === 0);\n    done = true;\n  }\n\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor<T>(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView as unknown as Uint8Array, done);\n  } else {\n    assert(pullIntoDescriptor.readerType === 'byob');\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor<T extends ArrayBufferView>(\n  pullIntoDescriptor: PullIntoDescriptor<T>\n): T {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\n  assert(bytesFilled % elementSize === 0);\n\n  return new pullIntoDescriptor.viewConstructor(\n    pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize) as T;\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller: ReadableByteStreamController,\n                                                         buffer: ArrayBufferLike,\n                                                         byteOffset: number,\n                                                         byteLength: number) {\n  controller._queue.push({ buffer, byteOffset, byteLength });\n  controller._queueTotalSize += byteLength;\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller: ReadableByteStreamController,\n                                                                     pullIntoDescriptor: PullIntoDescriptor) {\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  const queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue.peek();\n\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._queueTotalSize -= bytesToCopy;\n\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (!ready) {\n    assert(controller._queueTotalSize === 0);\n    assert(pullIntoDescriptor.bytesFilled > 0);\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller: ReadableByteStreamController,\n                                                                size: number,\n                                                                pullIntoDescriptor: PullIntoDescriptor) {\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos.peek() === pullIntoDescriptor);\n  assert(controller._byobRequest === null);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller: ReadableByteStreamController) {\n  assert(controller._controlledReadableByteStream._state === 'readable');\n\n  if (controller._queueTotalSize === 0 && controller._closeRequested) {\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller: ReadableByteStreamController) {\n  if (controller._byobRequest === null) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined!;\n  controller._byobRequest._view = null!;\n  controller._byobRequest = null;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller: ReadableByteStreamController) {\n  assert(!controller._closeRequested);\n\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n\n    const pullIntoDescriptor = controller._pendingPullIntos.peek();\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\n        controller._controlledReadableByteStream,\n        pullIntoDescriptor\n      );\n    }\n  }\n}\n\nexport function ReadableByteStreamControllerPullInto<T extends ArrayBufferView>(\n  controller: ReadableByteStreamController,\n  view: T,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  const stream = controller._controlledReadableByteStream;\n\n  let elementSize = 1;\n  if (view.constructor !== DataView) {\n    elementSize = (view.constructor as ArrayBufferViewConstructor<T>).BYTES_PER_ELEMENT;\n  }\n\n  const ctor = view.constructor as ArrayBufferViewConstructor<T>;\n\n  // try {\n  const buffer = TransferArrayBuffer(view.buffer);\n  // } catch (e) {\n  //   readIntoRequest._errorSteps(e);\n  //   return;\n  // }\n\n  const pullIntoDescriptor: BYOBPullIntoDescriptor<T> = {\n    buffer,\n    bufferByteLength: buffer.byteLength,\n    byteOffset: view.byteOffset,\n    byteLength: view.byteLength,\n    bytesFilled: 0,\n    elementSize,\n    viewConstructor: ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n    return;\n  }\n\n  if (stream._state === 'closed') {\n    const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n    readIntoRequest._closeSteps(emptyView);\n    return;\n  }\n\n  if (controller._queueTotalSize > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor<T>(pullIntoDescriptor);\n\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n\n      readIntoRequest._chunkSteps(filledView);\n      return;\n    }\n\n    if (controller._closeRequested) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      readIntoRequest._errorSteps(e);\n      return;\n    }\n  }\n\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  ReadableStreamAddReadIntoRequest<T>(stream, readIntoRequest);\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller: ReadableByteStreamController,\n                                                          firstDescriptor: PullIntoDescriptor) {\n  assert(firstDescriptor.bytesFilled === 0);\n\n  const stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream)) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller: ReadableByteStreamController,\n                                                            bytesWritten: number,\n                                                            pullIntoDescriptor: PullIntoDescriptor) {\n  assert(pullIntoDescriptor.bytesFilled + bytesWritten <= pullIntoDescriptor.byteLength);\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n  }\n\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller: ReadableByteStreamController, bytesWritten: number) {\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  assert(CanTransferArrayBuffer(firstDescriptor.buffer));\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n\n  const state = controller._controlledReadableByteStream._state;\n  if (state === 'closed') {\n    assert(bytesWritten === 0);\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    assert(state === 'readable');\n    assert(bytesWritten > 0);\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(\n  controller: ReadableByteStreamController\n): PullIntoDescriptor {\n  assert(controller._byobRequest === null);\n  const descriptor = controller._pendingPullIntos.shift()!;\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller: ReadableByteStreamController): boolean {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested) {\n    return false;\n  }\n\n  if (!controller._started) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize! > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableByteStreamControllerClearAlgorithms(controller: ReadableByteStreamController) {\n  controller._pullAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n}\n\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\nexport function ReadableByteStreamControllerClose(controller: ReadableByteStreamController) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (controller._closeRequested || stream._state !== 'readable') {\n    return;\n  }\n\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos.peek();\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamClose(stream);\n}\n\nexport function ReadableByteStreamControllerEnqueue(controller: ReadableByteStreamController, chunk: ArrayBufferView) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (controller._closeRequested || stream._state !== 'readable') {\n    return;\n  }\n\n  const buffer = chunk.buffer;\n  const byteOffset = chunk.byteOffset;\n  const byteLength = chunk.byteLength;\n  if (IsDetachedBuffer(buffer)) {\n    throw new TypeError('chunk\\'s buffer is detached and so cannot be enqueued');\n  }\n  const transferredBuffer = TransferArrayBuffer(buffer);\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos.peek();\n    if (IsDetachedBuffer(firstPendingPullInto.buffer)) {\n      throw new TypeError(\n        'The BYOB request\\'s buffer has been detached and so cannot be filled with an enqueued chunk'\n      );\n    }\n    firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n  }\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n\n  if (ReadableStreamHasDefaultReader(stream)) {\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      assert(controller._pendingPullIntos.length === 0);\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(controller._queue.length === 0);\n      if (controller._pendingPullIntos.length > 0) {\n        assert(controller._pendingPullIntos.peek().readerType === 'default');\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\n      }\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream)) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(!IsReadableStreamLocked(stream));\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nexport function ReadableByteStreamControllerError(controller: ReadableByteStreamController, e: any) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  ResetQueue(controller);\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nexport function ReadableByteStreamControllerGetBYOBRequest(\n  controller: ReadableByteStreamController\n): ReadableStreamBYOBRequest | null {\n  if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const view = new Uint8Array(firstDescriptor.buffer,\n                                firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n                                firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n\n    const byobRequest: ReadableStreamBYOBRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n    SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n    controller._byobRequest = byobRequest;\n  }\n  return controller._byobRequest;\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller: ReadableByteStreamController): number | null {\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nexport function ReadableByteStreamControllerRespond(controller: ReadableByteStreamController, bytesWritten: number) {\n  assert(controller._pendingPullIntos.length > 0);\n\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n  } else {\n    assert(state === 'readable');\n    if (bytesWritten === 0) {\n      throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n    }\n    if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n      throw new RangeError('bytesWritten out of range');\n    }\n  }\n\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nexport function ReadableByteStreamControllerRespondWithNewView(controller: ReadableByteStreamController,\n                                                               view: ArrayBufferView) {\n  assert(controller._pendingPullIntos.length > 0);\n  assert(!IsDetachedBuffer(view.buffer));\n\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'closed') {\n    if (view.byteLength !== 0) {\n      throw new TypeError('The view\\'s length must be 0 when calling respondWithNewView() on a closed stream');\n    }\n  } else {\n    assert(state === 'readable');\n    if (view.byteLength === 0) {\n      throw new TypeError(\n        'The view\\'s length must be greater than 0 when calling respondWithNewView() on a readable stream'\n      );\n    }\n  }\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n  if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n    throw new RangeError('The region specified by view is larger than byobRequest');\n  }\n\n  const viewByteLength = view.byteLength;\n  firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n  ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n}\n\nexport function SetUpReadableByteStreamController(stream: ReadableByteStream,\n                                                  controller: ReadableByteStreamController,\n                                                  startAlgorithm: () => void | PromiseLike<void>,\n                                                  pullAlgorithm: () => Promise<void>,\n                                                  cancelAlgorithm: (reason: any) => Promise<void>,\n                                                  highWaterMark: number,\n                                                  autoAllocateChunkSize: number | undefined) {\n  assert(stream._readableStreamController === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(NumberIsInteger(autoAllocateChunkSize));\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  controller._controlledReadableByteStream = stream;\n\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._byobRequest = null;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._closeRequested = false;\n  controller._started = false;\n\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n\n  controller._pendingPullIntos = new SimpleQueue();\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  uponPromise(\n    promiseResolvedWith(startResult),\n    () => {\n      controller._started = true;\n\n      assert(!controller._pulling);\n      assert(!controller._pullAgain);\n\n      ReadableByteStreamControllerCallPullIfNeeded(controller);\n    },\n    r => {\n      ReadableByteStreamControllerError(controller, r);\n    }\n  );\n}\n\nexport function SetUpReadableByteStreamControllerFromUnderlyingSource(\n  stream: ReadableByteStream,\n  underlyingByteSource: ValidatedUnderlyingByteSource,\n  highWaterMark: number\n) {\n  const controller: ReadableByteStreamController = Object.create(ReadableByteStreamController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void> = () => undefined;\n  let pullAlgorithm: () => Promise<void> = () => promiseResolvedWith(undefined);\n  let cancelAlgorithm: (reason: any) => Promise<void> = () => promiseResolvedWith(undefined);\n\n  if (underlyingByteSource.start !== undefined) {\n    startAlgorithm = () => underlyingByteSource.start!(controller);\n  }\n  if (underlyingByteSource.pull !== undefined) {\n    pullAlgorithm = () => underlyingByteSource.pull!(controller);\n  }\n  if (underlyingByteSource.cancel !== undefined) {\n    cancelAlgorithm = reason => underlyingByteSource.cancel!(reason);\n  }\n\n  const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize === 0) {\n    throw new TypeError('autoAllocateChunkSize must be greater than 0');\n  }\n\n  SetUpReadableByteStreamController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize\n  );\n}\n\nfunction SetUpReadableStreamBYOBRequest(request: ReadableStreamBYOBRequest,\n                                        controller: ReadableByteStreamController,\n                                        view: ArrayBufferView) {\n  assert(IsReadableByteStreamController(controller));\n  assert(typeof view === 'object');\n  assert(ArrayBuffer.isView(view));\n  assert(!IsDetachedBuffer(view.buffer));\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n}\n\n// Helper functions for the ReadableStreamBYOBRequest.\n\nfunction byobRequestBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n\n// Helper functions for the ReadableByteStreamController.\n\nfunction byteStreamControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n", "import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericInitialize,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport { IsReadableStreamLocked, ReadableByteStream, ReadableStream } from '../readable-stream';\nimport {\n  IsReadableByteStreamController,\n  ReadableByteStreamController,\n  ReadableByteStreamControllerPullInto\n} from './byte-stream-controller';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport { newPromise, promiseRejectedWith } from '../helpers/webidl';\nimport { assertRequiredArgument } from '../validators/basic';\nimport { assertReadableStream } from '../validators/readable-stream';\nimport { IsDetachedBuffer } from '../abstract-ops/ecmascript';\n\n/**\n * A result returned by {@link ReadableStreamBYOBReader.read}.\n *\n * @public\n */\nexport type ReadableStreamBYOBReadResult<T extends ArrayBufferView> = {\n  done: false;\n  value: T;\n} | {\n  done: true;\n  value: T | undefined;\n};\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamBYOBReader(stream: ReadableByteStream): ReadableStreamBYOBReader {\n  return new ReadableStreamBYOBReader(stream);\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamAddReadIntoRequest<T extends ArrayBufferView>(stream: ReadableByteStream,\n                                                                            readIntoRequest: ReadIntoRequest<T>): void {\n  assert(IsReadableStreamBYOBReader(stream._reader));\n  assert(stream._state === 'readable' || stream._state === 'closed');\n\n  (stream._reader! as ReadableStreamBYOBReader)._readIntoRequests.push(readIntoRequest);\n}\n\nexport function ReadableStreamFulfillReadIntoRequest(stream: ReadableByteStream,\n                                                     chunk: ArrayBufferView,\n                                                     done: boolean) {\n  const reader = stream._reader as ReadableStreamBYOBReader;\n\n  assert(reader._readIntoRequests.length > 0);\n\n  const readIntoRequest = reader._readIntoRequests.shift()!;\n  if (done) {\n    readIntoRequest._closeSteps(chunk);\n  } else {\n    readIntoRequest._chunkSteps(chunk);\n  }\n}\n\nexport function ReadableStreamGetNumReadIntoRequests(stream: ReadableByteStream): number {\n  return (stream._reader as ReadableStreamBYOBReader)._readIntoRequests.length;\n}\n\nexport function ReadableStreamHasBYOBReader(stream: ReadableByteStream): boolean {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (!IsReadableStreamBYOBReader(reader)) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nexport interface ReadIntoRequest<T extends ArrayBufferView> {\n  _chunkSteps(chunk: T): void;\n\n  _closeSteps(chunk: T | undefined): void;\n\n  _errorSteps(e: any): void;\n}\n\n/**\n * A BYOB reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nexport class ReadableStreamBYOBReader {\n  /** @internal */\n  _ownerReadableStream!: ReadableByteStream;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readIntoRequests: SimpleQueue<ReadIntoRequest<any>>;\n\n  constructor(stream: ReadableByteStream) {\n    assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n    assertReadableStream(stream, 'First parameter');\n\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    if (!IsReadableByteStreamController(stream._readableStreamController)) {\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n        'source');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readIntoRequests = new SimpleQueue();\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   * the reader's lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  /**\n   * Attempts to reads bytes into view, and returns a promise resolved with the result.\n   *\n   * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   */\n  read<T extends ArrayBufferView>(view: T): Promise<ReadableStreamBYOBReadResult<T>> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('read'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n    }\n    if (view.byteLength === 0) {\n      return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n    }\n    if (view.buffer.byteLength === 0) {\n      return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n    }\n    if (IsDetachedBuffer(view.buffer)) {\n      return promiseRejectedWith(new TypeError('view\\'s buffer has been detached'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('read from'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamBYOBReadResult<T>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamBYOBReadResult<T>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readIntoRequest: ReadIntoRequest<T> = {\n      _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n      _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n      _errorSteps: e => rejectPromise(e)\n    };\n    ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n    return promise;\n  }\n\n  /**\n   * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n   * from now on; otherwise, the reader will appear closed.\n   *\n   * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n   * do so will throw a `TypeError` and leave the reader locked to the stream.\n   */\n  releaseLock(): void {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readIntoRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\nObject.defineProperties(ReadableStreamBYOBReader.prototype, {\n  cancel: { enumerable: true },\n  read: { enumerable: true },\n  releaseLock: { enumerable: true },\n  closed: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamBYOBReader',\n    configurable: true\n  });\n}\n\n// Abstract operations for the readers.\n\nexport function IsReadableStreamBYOBReader(x: any): x is ReadableStreamBYOBReader {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamBYOBReader;\n}\n\nexport function ReadableStreamBYOBReaderRead<T extends ArrayBufferView>(\n  reader: ReadableStreamBYOBReader,\n  view: T,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    readIntoRequest._errorSteps(stream._storedError);\n  } else {\n    ReadableByteStreamControllerPullInto(\n      stream._readableStreamController as ReadableByteStreamController,\n      view,\n      readIntoRequest\n    );\n  }\n}\n\n// Helper functions for the ReadableStreamBYOBReader.\n\nfunction byobReaderBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n", "import { QueuingStrategy, QueuingStrategySizeCallback } from '../queuing-strategy';\nimport NumberIsNaN from '../../stub/number-isnan';\n\nexport function ExtractHighWaterMark(strategy: QueuingStrategy, defaultHWM: number): number {\n  const { highWaterMark } = strategy;\n\n  if (highWaterMark === undefined) {\n    return defaultHWM;\n  }\n\n  if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n    throw new RangeError('Invalid highWaterMark');\n  }\n\n  return highWaterMark;\n}\n\nexport function ExtractSizeAlgorithm<T>(strategy: QueuingStrategy<T>): QueuingStrategySizeCallback<T> {\n  const { size } = strategy;\n\n  if (!size) {\n    return () => 1;\n  }\n\n  return size;\n}\n", "import { QueuingStrategy, QueuingStrategySizeCallback } from '../queuing-strategy';\nimport { assertDictionary, assertFunction, convertUnrestrictedDouble } from './basic';\n\nexport function convertQueuingStrategy<T>(init: QueuingStrategy<T> | null | undefined,\n                                          context: string): QueuingStrategy<T> {\n  assertDictionary(init, context);\n  const highWaterMark = init?.highWaterMark;\n  const size = init?.size;\n  return {\n    highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n    size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n  };\n}\n\nfunction convertQueuingStrategySize<T>(fn: QueuingStrategySizeCallback<T>,\n                                       context: string): QueuingStrategySizeCallback<T> {\n  assertFunction(fn, context);\n  return chunk => convertUnrestrictedDouble(fn(chunk));\n}\n", "import { assertDictionary, assertFunction } from './basic';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\nimport {\n  UnderlyingSink,\n  UnderlyingSinkAbortCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  ValidatedUnderlyingSink\n} from '../writable-stream/underlying-sink';\nimport { WritableStreamDefaultController } from '../writable-stream';\n\nexport function convertUnderlyingSink<W>(original: UnderlyingSink<W> | null,\n                                         context: string): ValidatedUnderlyingSink<W> {\n  assertDictionary(original, context);\n  const abort = original?.abort;\n  const close = original?.close;\n  const start = original?.start;\n  const type = original?.type;\n  const write = original?.write;\n  return {\n    abort: abort === undefined ?\n      undefined :\n      convertUnderlyingSinkAbortCallback(abort, original!, `${context} has member 'abort' that`),\n    close: close === undefined ?\n      undefined :\n      convertUnderlyingSinkCloseCallback(close, original!, `${context} has member 'close' that`),\n    start: start === undefined ?\n      undefined :\n      convertUnderlyingSinkStartCallback(start, original!, `${context} has member 'start' that`),\n    write: write === undefined ?\n      undefined :\n      convertUnderlyingSinkWriteCallback(write, original!, `${context} has member 'write' that`),\n    type\n  };\n}\n\nfunction convertUnderlyingSinkAbortCallback(\n  fn: UnderlyingSinkAbortCallback,\n  original: UnderlyingSink,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n\nfunction convertUnderlyingSinkCloseCallback(\n  fn: UnderlyingSinkCloseCallback,\n  original: UnderlyingSink,\n  context: string\n): () => Promise<void> {\n  assertFunction(fn, context);\n  return () => promiseCall(fn, original, []);\n}\n\nfunction convertUnderlyingSinkStartCallback(\n  fn: UnderlyingSinkStartCallback,\n  original: UnderlyingSink,\n  context: string\n): UnderlyingSinkStartCallback {\n  assertFunction(fn, context);\n  return (controller: WritableStreamDefaultController) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertUnderlyingSinkWriteCallback<W>(\n  fn: UnderlyingSinkWriteCallback<W>,\n  original: UnderlyingSink<W>,\n  context: string\n): (chunk: W, controller: WritableStreamDefaultController) => Promise<void> {\n  assertFunction(fn, context);\n  return (chunk: W, controller: WritableStreamDefaultController) => promiseCall(fn, original, [chunk, controller]);\n}\n", "import { IsWritableStream, WritableStream } from '../writable-stream';\n\nexport function assertWritableStream(x: unknown, context: string): asserts x is WritableStream {\n  if (!IsWritableStream(x)) {\n    throw new TypeError(`${context} is not a WritableStream.`);\n  }\n}\n", "/**\n * A signal object that allows you to communicate with a request and abort it if required\n * via its associated `AbortController` object.\n *\n * @remarks\n *   This interface is compatible with the `AbortSignal` interface defined in TypeScript's DOM types.\n *   It is redefined here, so it can be polyfilled without a DOM, for example with\n *   {@link https://www.npmjs.com/package/abortcontroller-polyfill | abortcontroller-polyfill} in a Node environment.\n *\n * @public\n */\nexport interface AbortSignal {\n  /**\n   * Whether the request is aborted.\n   */\n  readonly aborted: boolean;\n\n  /**\n   * Add an event listener to be triggered when this signal becomes aborted.\n   */\n  addEventListener(type: 'abort', listener: () => void): void;\n\n  /**\n   * Remove an event listener that was previously added with {@link AbortSignal.addEventListener}.\n   */\n  removeEventListener(type: 'abort', listener: () => void): void;\n}\n\nexport function isAbortSignal(value: unknown): value is AbortSignal {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n  try {\n    return typeof (value as AbortSignal).aborted === 'boolean';\n  } catch {\n    // AbortSignal.prototype.aborted throws if its brand check fails\n    return false;\n  }\n}\n\n/**\n * A controller object that allows you to abort an `AbortSignal` when desired.\n *\n * @remarks\n *   This interface is compatible with the `AbortController` interface defined in TypeScript's DOM types.\n *   It is redefined here, so it can be polyfilled without a DOM, for example with\n *   {@link https://www.npmjs.com/package/abortcontroller-polyfill | abortcontroller-polyfill} in a Node environment.\n *\n * @internal\n */\nexport interface AbortController {\n  readonly signal: AbortSignal;\n\n  abort(): void;\n}\n\ninterface AbortControllerConstructor {\n  new(): AbortController;\n}\n\nconst supportsAbortController = typeof (AbortController as any) === 'function';\n\n/**\n * Construct a new AbortController, if supported by the platform.\n *\n * @internal\n */\nexport function createAbortController(): AbortController | undefined {\n  if (supportsAbortController) {\n    return new (AbortController as AbortControllerConstructor)();\n  }\n  return undefined;\n}\n", "import assert from '../stub/assert';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  uponPromise\n} from './helpers/webidl';\nimport {\n  DequeueValue,\n  EnqueueValueWithSize,\n  PeekQueueValue,\n  QueuePair,\n  ResetQueue\n} from './abstract-ops/queue-with-sizes';\nimport { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { SimpleQueue } from './simple-queue';\nimport { typeIsObject } from './helpers/miscellaneous';\nimport { AbortSteps, ErrorSteps } from './abstract-ops/internal-methods';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport {\n  UnderlyingSink,\n  UnderlyingSinkAbortCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  ValidatedUnderlyingSink\n} from './writable-stream/underlying-sink';\nimport { assertObject, assertRequiredArgument } from './validators/basic';\nimport { convertUnderlyingSink } from './validators/underlying-sink';\nimport { assertWritableStream } from './validators/writable-stream';\nimport { AbortController, AbortSignal, createAbortController } from './abort-signal';\n\ntype WritableStreamState = 'writable' | 'closed' | 'erroring' | 'errored';\n\ninterface WriteOrCloseRequest {\n  _resolve: (value?: undefined) => void;\n  _reject: (reason: any) => void;\n}\n\ntype WriteRequest = WriteOrCloseRequest;\ntype CloseRequest = WriteOrCloseRequest;\n\ninterface PendingAbortRequest {\n  _promise: Promise<undefined>;\n  _resolve: (value?: undefined) => void;\n  _reject: (reason: any) => void;\n  _reason: any;\n  _wasAlreadyErroring: boolean;\n}\n\n/**\n * A writable stream represents a destination for data, into which you can write.\n *\n * @public\n */\nclass WritableStream<W = any> {\n  /** @internal */\n  _state!: WritableStreamState;\n  /** @internal */\n  _storedError: any;\n  /** @internal */\n  _writer: WritableStreamDefaultWriter<W> | undefined;\n  /** @internal */\n  _writableStreamController!: WritableStreamDefaultController<W>;\n  /** @internal */\n  _writeRequests!: SimpleQueue<WriteRequest>;\n  /** @internal */\n  _inFlightWriteRequest: WriteRequest | undefined;\n  /** @internal */\n  _closeRequest: CloseRequest | undefined;\n  /** @internal */\n  _inFlightCloseRequest: CloseRequest | undefined;\n  /** @internal */\n  _pendingAbortRequest: PendingAbortRequest | undefined;\n  /** @internal */\n  _backpressure!: boolean;\n\n  constructor(underlyingSink?: UnderlyingSink<W>, strategy?: QueuingStrategy<W>);\n  constructor(rawUnderlyingSink: UnderlyingSink<W> | null | undefined = {},\n              rawStrategy: QueuingStrategy<W> | null | undefined = {}) {\n    if (rawUnderlyingSink === undefined) {\n      rawUnderlyingSink = null;\n    } else {\n      assertObject(rawUnderlyingSink, 'First parameter');\n    }\n\n    const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n    const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n\n    InitializeWritableStream(this);\n\n    const type = underlyingSink.type;\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n    const highWaterMark = ExtractHighWaterMark(strategy, 1);\n\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n\n  /**\n   * Returns whether or not the writable stream is locked to a writer.\n   */\n  get locked(): boolean {\n    if (!IsWritableStream(this)) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsWritableStreamLocked(this);\n  }\n\n  /**\n   * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n   * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n   * mechanism of the underlying sink.\n   *\n   * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n   * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n   * the stream) if the stream is currently locked.\n   */\n  abort(reason: any = undefined): Promise<void> {\n    if (!IsWritableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  }\n\n  /**\n   * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n   * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n   *\n   * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n   * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n   * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n   */\n  close() {\n    if (!IsWritableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('close'));\n    }\n\n    if (IsWritableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(this)) {\n      return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n    }\n\n    return WritableStreamClose(this);\n  }\n\n  /**\n   * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n   * is locked, no other writer can be acquired until this one is released.\n   *\n   * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n   * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n   * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n   */\n  getWriter(): WritableStreamDefaultWriter<W> {\n    if (!IsWritableStream(this)) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  }\n}\n\nObject.defineProperties(WritableStream.prototype, {\n  abort: { enumerable: true },\n  close: { enumerable: true },\n  getWriter: { enumerable: true },\n  locked: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {\n    value: 'WritableStream',\n    configurable: true\n  });\n}\n\nexport {\n  AcquireWritableStreamDefaultWriter,\n  CreateWritableStream,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamDefaultControllerErrorIfNeeded,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite,\n  WritableStreamCloseQueuedOrInFlight,\n  UnderlyingSink,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkAbortCallback\n};\n\n// Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter<W>(stream: WritableStream<W>): WritableStreamDefaultWriter<W> {\n  return new WritableStreamDefaultWriter(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream<W>(startAlgorithm: () => void | PromiseLike<void>,\n                                 writeAlgorithm: (chunk: W) => Promise<void>,\n                                 closeAlgorithm: () => Promise<void>,\n                                 abortAlgorithm: (reason: any) => Promise<void>,\n                                 highWaterMark = 1,\n                                 sizeAlgorithm: QueuingStrategySizeCallback<W> = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark));\n\n  const stream: WritableStream<W> = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n\n  const controller: WritableStreamDefaultController<W> = Object.create(WritableStreamDefaultController.prototype);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n}\n\nfunction InitializeWritableStream<W>(stream: WritableStream<W>) {\n  stream._state = 'writable';\n\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n  stream._storedError = undefined;\n\n  stream._writer = undefined;\n\n  // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n  stream._writableStreamController = undefined!;\n\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n  stream._writeRequests = new SimpleQueue();\n\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  stream._inFlightWriteRequest = undefined;\n\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n  stream._closeRequest = undefined;\n\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  stream._inFlightCloseRequest = undefined;\n\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  stream._pendingAbortRequest = undefined;\n\n  // The backpressure signal set by the controller.\n  stream._backpressure = false;\n}\n\nfunction IsWritableStream(x: unknown): x is WritableStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return x instanceof WritableStream;\n}\n\nfunction IsWritableStreamLocked(stream: WritableStream): boolean {\n  assert(IsWritableStream(stream));\n\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream: WritableStream, reason: any): Promise<undefined> {\n  if (stream._state === 'closed' || stream._state === 'errored') {\n    return promiseResolvedWith(undefined);\n  }\n  stream._writableStreamController._abortReason = reason;\n  stream._writableStreamController._abortController?.abort();\n\n  // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n  // but it doesn't know that signaling abort runs author code that might have changed the state.\n  // Widen the type again by casting to WritableStreamState.\n  const state = stream._state as WritableStreamState;\n\n  if (state === 'closed' || state === 'errored') {\n    return promiseResolvedWith(undefined);\n  }\n  if (stream._pendingAbortRequest !== undefined) {\n    return stream._pendingAbortRequest._promise;\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    // reason will not be used, so don't keep a reference to it.\n    reason = undefined;\n  }\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    stream._pendingAbortRequest = {\n      _promise: undefined!,\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring\n    };\n  });\n  stream._pendingAbortRequest!._promise = promise;\n\n  if (!wasAlreadyErroring) {\n    WritableStreamStartErroring(stream, reason);\n  }\n\n  return promise;\n}\n\nfunction WritableStreamClose(stream: WritableStream<any>): Promise<undefined> {\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return promiseRejectedWith(new TypeError(\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n  assert(!WritableStreamCloseQueuedOrInFlight(stream));\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    const closeRequest: CloseRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._closeRequest = closeRequest;\n  });\n\n  const writer = stream._writer;\n  if (writer !== undefined && stream._backpressure && state === 'writable') {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n\n  return promise;\n}\n\n// WritableStream API exposed for controllers.\n\nfunction WritableStreamAddWriteRequest(stream: WritableStream): Promise<undefined> {\n  assert(IsWritableStreamLocked(stream));\n  assert(stream._state === 'writable');\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    const writeRequest: WriteRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n\n  return promise;\n}\n\nfunction WritableStreamDealWithRejection(stream: WritableStream, error: any) {\n  const state = stream._state;\n\n  if (state === 'writable') {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  WritableStreamFinishErroring(stream);\n}\n\nfunction WritableStreamStartErroring(stream: WritableStream, reason: any) {\n  assert(stream._storedError === undefined);\n  assert(stream._state === 'writable');\n\n  const controller = stream._writableStreamController;\n  assert(controller !== undefined);\n\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n\n  if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n    WritableStreamFinishErroring(stream);\n  }\n}\n\nfunction WritableStreamFinishErroring(stream: WritableStream) {\n  assert(stream._state === 'erroring');\n  assert(!WritableStreamHasOperationMarkedInFlight(stream));\n  stream._state = 'errored';\n  stream._writableStreamController[ErrorSteps]();\n\n  const storedError = stream._storedError;\n  stream._writeRequests.forEach(writeRequest => {\n    writeRequest._reject(storedError);\n  });\n  stream._writeRequests = new SimpleQueue();\n\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n\n  if (abortRequest._wasAlreadyErroring) {\n    abortRequest._reject(storedError);\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n  uponPromise(\n    promise,\n    () => {\n      abortRequest._resolve();\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    },\n    (reason: any) => {\n      abortRequest._reject(reason);\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    });\n}\n\nfunction WritableStreamFinishInFlightWrite(stream: WritableStream) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest!._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n}\n\nfunction WritableStreamFinishInFlightWriteWithError(stream: WritableStream, error: any) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest!._reject(error);\n  stream._inFlightWriteRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  WritableStreamDealWithRejection(stream, error);\n}\n\nfunction WritableStreamFinishInFlightClose(stream: WritableStream) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest!._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n\n  const state = stream._state;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  if (state === 'erroring') {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n\n  stream._state = 'closed';\n\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n\n  assert(stream._pendingAbortRequest === undefined);\n  assert(stream._storedError === undefined);\n}\n\nfunction WritableStreamFinishInFlightCloseWithError(stream: WritableStream, error: any) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest!._reject(error);\n  stream._inFlightCloseRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  // Never execute sink abort() after sink close().\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n    stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n}\n\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream: WritableStream): boolean {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamHasOperationMarkedInFlight(stream: WritableStream): boolean {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamMarkCloseRequestInFlight(stream: WritableStream) {\n  assert(stream._inFlightCloseRequest === undefined);\n  assert(stream._closeRequest !== undefined);\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\n\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream: WritableStream) {\n  assert(stream._inFlightWriteRequest === undefined);\n  assert(stream._writeRequests.length !== 0);\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\n\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream: WritableStream) {\n  assert(stream._state === 'errored');\n  if (stream._closeRequest !== undefined) {\n    assert(stream._inFlightCloseRequest === undefined);\n\n    stream._closeRequest._reject(stream._storedError);\n    stream._closeRequest = undefined;\n  }\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream: WritableStream, backpressure: boolean) {\n  assert(stream._state === 'writable');\n  assert(!WritableStreamCloseQueuedOrInFlight(stream));\n\n  const writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      assert(!backpressure);\n\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n\n  stream._backpressure = backpressure;\n}\n\n/**\n * A default writer vended by a {@link WritableStream}.\n *\n * @public\n */\nexport class WritableStreamDefaultWriter<W = any> {\n  /** @internal */\n  _ownerWritableStream: WritableStream<W>;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _closedPromiseState!: 'pending' | 'resolved' | 'rejected';\n  /** @internal */\n  _readyPromise!: Promise<undefined>;\n  /** @internal */\n  _readyPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _readyPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readyPromiseState!: 'pending' | 'fulfilled' | 'rejected';\n\n  constructor(stream: WritableStream<W>) {\n    assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n    assertWritableStream(stream, 'First parameter');\n\n    if (IsWritableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n\n    const state = stream._state;\n\n    if (state === 'writable') {\n      if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'erroring') {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      assert(state === 'errored');\n\n      const storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n    }\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   * the writer\u2019s lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * Returns the desired size to fill the stream\u2019s internal queue. It can be negative, if the queue is over-full.\n   * A producer can use this information to determine the right amount of data to write.\n   *\n   * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n   * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n   * the writer\u2019s lock is released.\n   */\n  get desiredSize(): number | null {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      throw defaultWriterBrandCheckException('desiredSize');\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      throw defaultWriterLockException('desiredSize');\n    }\n\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the desired size to fill the stream\u2019s internal queue transitions\n   * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n   * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n   *\n   * If the stream becomes errored or aborted, or the writer\u2019s lock is released, the returned promise will become\n   * rejected.\n   */\n  get ready(): Promise<undefined> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n    }\n\n    return this._readyPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n   */\n  abort(reason: any = undefined): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n   */\n  close(): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('close'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream)) {\n      return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  }\n\n  /**\n   * Releases the writer\u2019s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n   * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n   * now on; otherwise, the writer will appear closed.\n   *\n   * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n   * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n   * It\u2019s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n   * other producers from writing in an interleaved manner.\n   */\n  releaseLock(): void {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    assert(stream._writer !== undefined);\n\n    WritableStreamDefaultWriterRelease(this);\n  }\n\n  /**\n   * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n   * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n   * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n   * errored before the writing process is initiated.\n   *\n   * Note that what \"success\" means is up to the underlying sink; it might indicate simply that the chunk has been\n   * accepted, and not necessarily that it is safely saved to its ultimate destination.\n   */\n  write(chunk: W): Promise<void>;\n  write(chunk: W = undefined!): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('write to'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  }\n}\n\nObject.defineProperties(WritableStreamDefaultWriter.prototype, {\n  abort: { enumerable: true },\n  close: { enumerable: true },\n  releaseLock: { enumerable: true },\n  write: { enumerable: true },\n  closed: { enumerable: true },\n  desiredSize: { enumerable: true },\n  ready: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {\n    value: 'WritableStreamDefaultWriter',\n    configurable: true\n  });\n}\n\n// Abstract operations for the WritableStreamDefaultWriter.\n\nfunction IsWritableStreamDefaultWriter<W = any>(x: any): x is WritableStreamDefaultWriter<W> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return x instanceof WritableStreamDefaultWriter;\n}\n\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultWriterAbort(writer: WritableStreamDefaultWriter, reason: any) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer: WritableStreamDefaultWriter): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamClose(stream);\n}\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer: WritableStreamDefaultWriter): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return promiseResolvedWith(undefined);\n  }\n\n  if (state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer: WritableStreamDefaultWriter, error: any) {\n  if (writer._closedPromiseState === 'pending') {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n}\n\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer: WritableStreamDefaultWriter, error: any) {\n  if (writer._readyPromiseState === 'pending') {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer: WritableStreamDefaultWriter): number | null {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n\n  if (state === 'errored' || state === 'erroring') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer: WritableStreamDefaultWriter) {\n  const stream = writer._ownerWritableStream;\n  assert(stream !== undefined);\n  assert(stream._writer === writer);\n\n  const releasedError = new TypeError(\n    `Writer was released and can no longer be used to monitor the stream's closedness`);\n\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined!;\n}\n\nfunction WritableStreamDefaultWriterWrite<W>(writer: WritableStreamDefaultWriter<W>, chunk: W): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const controller = stream._writableStreamController;\n\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n  if (stream !== writer._ownerWritableStream) {\n    return promiseRejectedWith(defaultWriterLockException('write to'));\n  }\n\n  const state = stream._state;\n  if (state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n  if (state === 'erroring') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  assert(state === 'writable');\n\n  const promise = WritableStreamAddWriteRequest(stream);\n\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n\n  return promise;\n}\n\nconst closeSentinel: unique symbol = {} as any;\n\ntype QueueRecord<W> = W | typeof closeSentinel;\n\n/**\n * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n *\n * @public\n */\nexport class WritableStreamDefaultController<W = any> {\n  /** @internal */\n  _controlledWritableStream!: WritableStream<W>;\n  /** @internal */\n  _queue!: SimpleQueue<QueuePair<QueueRecord<W>>>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _abortReason: any;\n  /** @internal */\n  _abortController: AbortController | undefined;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _strategySizeAlgorithm!: QueuingStrategySizeCallback<W>;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _writeAlgorithm!: (chunk: W) => Promise<void>;\n  /** @internal */\n  _closeAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _abortAlgorithm!: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n   *\n   * @deprecated\n   *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n   *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n   */\n  get abortReason(): any {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('abortReason');\n    }\n    return this._abortReason;\n  }\n\n  /**\n   * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n   */\n  get signal(): AbortSignal {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('signal');\n    }\n    if (this._abortController === undefined) {\n      // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n      // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n      // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n      throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');\n    }\n    return this._abortController.signal;\n  }\n\n  /**\n   * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n   *\n   * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n   * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n   * normal lifecycle of interactions with the underlying sink.\n   */\n  error(e: any = undefined): void {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n    const state = this._controlledWritableStream._state;\n    if (state !== 'writable') {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  }\n\n  /** @internal */\n  [AbortSteps](reason: any): Promise<void> {\n    const result = this._abortAlgorithm(reason);\n    WritableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [ErrorSteps]() {\n    ResetQueue(this);\n  }\n}\n\nObject.defineProperties(WritableStreamDefaultController.prototype, {\n  abortReason: { enumerable: true },\n  signal: { enumerable: true },\n  error: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'WritableStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Abstract operations implementing interface required by the WritableStream.\n\nfunction IsWritableStreamDefaultController(x: any): x is WritableStreamDefaultController<any> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n    return false;\n  }\n\n  return x instanceof WritableStreamDefaultController;\n}\n\nfunction SetUpWritableStreamDefaultController<W>(stream: WritableStream<W>,\n                                                 controller: WritableStreamDefaultController<W>,\n                                                 startAlgorithm: () => void | PromiseLike<void>,\n                                                 writeAlgorithm: (chunk: W) => Promise<void>,\n                                                 closeAlgorithm: () => Promise<void>,\n                                                 abortAlgorithm: (reason: any) => Promise<void>,\n                                                 highWaterMark: number,\n                                                 sizeAlgorithm: QueuingStrategySizeCallback<W>) {\n  assert(IsWritableStream(stream));\n  assert(stream._writableStreamController === undefined);\n\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = undefined!;\n  controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._abortReason = undefined;\n  controller._abortController = createAbortController();\n  controller._started = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n\n  const startResult = startAlgorithm();\n  const startPromise = promiseResolvedWith(startResult);\n  uponPromise(\n    startPromise,\n    () => {\n      assert(stream._state === 'writable' || stream._state === 'erroring');\n      controller._started = true;\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    },\n    r => {\n      assert(stream._state === 'writable' || stream._state === 'erroring');\n      controller._started = true;\n      WritableStreamDealWithRejection(stream, r);\n    }\n  );\n}\n\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink<W>(stream: WritableStream<W>,\n                                                                   underlyingSink: ValidatedUnderlyingSink<W>,\n                                                                   highWaterMark: number,\n                                                                   sizeAlgorithm: QueuingStrategySizeCallback<W>) {\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void> = () => undefined;\n  let writeAlgorithm: (chunk: W) => Promise<void> = () => promiseResolvedWith(undefined);\n  let closeAlgorithm: () => Promise<void> = () => promiseResolvedWith(undefined);\n  let abortAlgorithm: (reason: any) => Promise<void> = () => promiseResolvedWith(undefined);\n\n  if (underlyingSink.start !== undefined) {\n    startAlgorithm = () => underlyingSink.start!(controller);\n  }\n  if (underlyingSink.write !== undefined) {\n    writeAlgorithm = chunk => underlyingSink.write!(chunk, controller);\n  }\n  if (underlyingSink.close !== undefined) {\n    closeAlgorithm = () => underlyingSink.close!();\n  }\n  if (underlyingSink.abort !== undefined) {\n    abortAlgorithm = reason => underlyingSink.abort!(reason);\n  }\n\n  SetUpWritableStreamDefaultController(\n    stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm\n  );\n}\n\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller: WritableStreamDefaultController<any>) {\n  controller._writeAlgorithm = undefined!;\n  controller._closeAlgorithm = undefined!;\n  controller._abortAlgorithm = undefined!;\n  controller._strategySizeAlgorithm = undefined!;\n}\n\nfunction WritableStreamDefaultControllerClose<W>(controller: WritableStreamDefaultController<W>) {\n  EnqueueValueWithSize(controller, closeSentinel, 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetChunkSize<W>(controller: WritableStreamDefaultController<W>,\n                                                        chunk: W): number {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller: WritableStreamDefaultController<any>): number {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction WritableStreamDefaultControllerWrite<W>(controller: WritableStreamDefaultController<W>,\n                                                 chunk: W,\n                                                 chunkSize: number) {\n  try {\n    EnqueueValueWithSize(controller, chunk, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  const stream = controller._controlledWritableStream;\n  if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\n// Abstract operations for the WritableStreamDefaultController.\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded<W>(controller: WritableStreamDefaultController<W>) {\n  const stream = controller._controlledWritableStream;\n\n  if (!controller._started) {\n    return;\n  }\n\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n\n  const state = stream._state;\n  assert(state !== 'closed' && state !== 'errored');\n  if (state === 'erroring') {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  const value = PeekQueueValue(controller);\n  if (value === closeSentinel) {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, value);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller: WritableStreamDefaultController<any>, error: any) {\n  if (controller._controlledWritableStream._state === 'writable') {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller: WritableStreamDefaultController<any>) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkCloseRequestInFlight(stream);\n\n  DequeueValue(controller);\n  assert(controller._queue.length === 0);\n\n  const sinkClosePromise = controller._closeAlgorithm();\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  uponPromise(\n    sinkClosePromise,\n    () => {\n      WritableStreamFinishInFlightClose(stream);\n    },\n    reason => {\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\n    }\n  );\n}\n\nfunction WritableStreamDefaultControllerProcessWrite<W>(controller: WritableStreamDefaultController<W>, chunk: W) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\n  uponPromise(\n    sinkWritePromise,\n    () => {\n      WritableStreamFinishInFlightWrite(stream);\n\n      const state = stream._state;\n      assert(state === 'writable' || state === 'erroring');\n\n      DequeueValue(controller);\n\n      if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n      }\n\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    },\n    reason => {\n      if (stream._state === 'writable') {\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n      }\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\n    }\n  );\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller: WritableStreamDefaultController<any>): boolean {\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n}\n\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultControllerError(controller: WritableStreamDefaultController<any>, error: any) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'writable');\n\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  WritableStreamStartErroring(stream, error);\n}\n\n// Helper functions for the WritableStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n\n// Helper functions for the WritableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n}\n\n\n// Helper functions for the WritableStreamDefaultWriter.\n\nfunction defaultWriterBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\n\nfunction defaultWriterLockException(name: string): TypeError {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer: WritableStreamDefaultWriter) {\n  writer._closedPromise = newPromise((resolve, reject) => {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = 'pending';\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseReject(writer, reason);\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer: WritableStreamDefaultWriter) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseResolve(writer);\n}\n\nfunction defaultWriterClosedPromiseReject(writer: WritableStreamDefaultWriter, reason: any) {\n  if (writer._closedPromise_reject === undefined) {\n    return;\n  }\n  assert(writer._closedPromiseState === 'pending');\n\n  setPromiseIsHandledToTrue(writer._closedPromise);\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  assert(writer._closedPromise_resolve === undefined);\n  assert(writer._closedPromise_reject === undefined);\n  assert(writer._closedPromiseState !== 'pending');\n\n  defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n}\n\nfunction defaultWriterClosedPromiseResolve(writer: WritableStreamDefaultWriter) {\n  if (writer._closedPromise_resolve === undefined) {\n    return;\n  }\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer: WritableStreamDefaultWriter) {\n  writer._readyPromise = newPromise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseReject(writer, reason);\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer: WritableStreamDefaultWriter) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseResolve(writer);\n}\n\nfunction defaultWriterReadyPromiseReject(writer: WritableStreamDefaultWriter, reason: any) {\n  if (writer._readyPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(writer._readyPromise);\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseReset(writer: WritableStreamDefaultWriter) {\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  defaultWriterReadyPromiseInitialize(writer);\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n}\n\nfunction defaultWriterReadyPromiseResolve(writer: WritableStreamDefaultWriter) {\n  if (writer._readyPromise_resolve === undefined) {\n    return;\n  }\n\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n", "/// <reference lib=\"dom\" />\nexport const NativeDOMException: typeof DOMException | undefined =\n  typeof DOMException !== 'undefined' ? DOMException : undefined;\n", "/// <reference types=\"node\" />\nimport { NativeDOMException } from './native';\n\ndeclare class DOMExceptionClass extends Error {\n  constructor(message?: string, name?: string);\n\n  name: string;\n  message: string;\n}\n\ntype DOMException = DOMExceptionClass;\ntype DOMExceptionConstructor = typeof DOMExceptionClass;\n\nfunction isDOMExceptionConstructor(ctor: unknown): ctor is DOMExceptionConstructor {\n  if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n    return false;\n  }\n  try {\n    new (ctor as DOMExceptionConstructor)();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction createDOMExceptionPolyfill(): DOMExceptionConstructor {\n  // eslint-disable-next-line no-shadow\n  const ctor = function DOMException(this: DOMException, message?: string, name?: string) {\n    this.message = message || '';\n    this.name = name || 'Error';\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  } as any;\n  ctor.prototype = Object.create(Error.prototype);\n  Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n  return ctor;\n}\n\n// eslint-disable-next-line no-redeclare\nconst DOMException: DOMExceptionConstructor =\n  isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n\nexport { DOMException };\n", "import { IsReadableStream, IsReadableStreamLocked, ReadableStream, ReadableStreamCancel } from '../readable-stream';\nimport { AcquireReadableStreamDefaultReader, ReadableStreamDefaultReaderRead } from './default-reader';\nimport { ReadableStreamReaderGenericRelease } from './generic-reader';\nimport {\n  AcquireWritableStreamDefaultWriter,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamCloseQueuedOrInFlight,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite\n} from '../writable-stream';\nimport assert from '../../stub/assert';\nimport {\n  newPromise,\n  PerformPromiseThen,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  uponFulfillment,\n  uponPromise,\n  uponRejection\n} from '../helpers/webidl';\nimport { noop } from '../../utils';\nimport { AbortSignal, isAbortSignal } from '../abort-signal';\nimport { DOMException } from '../../stub/dom-exception';\n\nexport function ReadableStreamPipeTo<T>(source: ReadableStream<T>,\n                                        dest: WritableStream<T>,\n                                        preventClose: boolean,\n                                        preventAbort: boolean,\n                                        preventCancel: boolean,\n                                        signal: AbortSignal | undefined): Promise<undefined> {\n  assert(IsReadableStream(source));\n  assert(IsWritableStream(dest));\n  assert(typeof preventClose === 'boolean');\n  assert(typeof preventAbort === 'boolean');\n  assert(typeof preventCancel === 'boolean');\n  assert(signal === undefined || isAbortSignal(signal));\n  assert(!IsReadableStreamLocked(source));\n  assert(!IsWritableStreamLocked(dest));\n\n  const reader = AcquireReadableStreamDefaultReader<T>(source);\n  const writer = AcquireWritableStreamDefaultWriter<T>(dest);\n\n  source._disturbed = true;\n\n  let shuttingDown = false;\n\n  // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n  let currentWrite = promiseResolvedWith<void>(undefined);\n\n  return newPromise((resolve, reject) => {\n    let abortAlgorithm: () => void;\n    if (signal !== undefined) {\n      abortAlgorithm = () => {\n        const error = new DOMException('Aborted', 'AbortError');\n        const actions: Array<() => Promise<void>> = [];\n        if (!preventAbort) {\n          actions.push(() => {\n            if (dest._state === 'writable') {\n              return WritableStreamAbort(dest, error);\n            }\n            return promiseResolvedWith(undefined);\n          });\n        }\n        if (!preventCancel) {\n          actions.push(() => {\n            if (source._state === 'readable') {\n              return ReadableStreamCancel(source, error);\n            }\n            return promiseResolvedWith(undefined);\n          });\n        }\n        shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n      };\n\n      if (signal.aborted) {\n        abortAlgorithm();\n        return;\n      }\n\n      signal.addEventListener('abort', abortAlgorithm);\n    }\n\n    // Using reader and writer, read all chunks from this and write them to dest\n    // - Backpressure must be enforced\n    // - Shutdown must stop all activity\n    function pipeLoop() {\n      return newPromise<void>((resolveLoop, rejectLoop) => {\n        function next(done: boolean) {\n          if (done) {\n            resolveLoop();\n          } else {\n            // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n            PerformPromiseThen(pipeStep(), next, rejectLoop);\n          }\n        }\n\n        next(false);\n      });\n    }\n\n    function pipeStep(): Promise<boolean> {\n      if (shuttingDown) {\n        return promiseResolvedWith(true);\n      }\n\n      return PerformPromiseThen(writer._readyPromise, () => {\n        return newPromise<boolean>((resolveRead, rejectRead) => {\n          ReadableStreamDefaultReaderRead(\n            reader,\n            {\n              _chunkSteps: chunk => {\n                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                resolveRead(false);\n              },\n              _closeSteps: () => resolveRead(true),\n              _errorSteps: rejectRead\n            }\n          );\n        });\n      });\n    }\n\n    // Errors must be propagated forward\n    isOrBecomesErrored(source, reader._closedPromise, storedError => {\n      if (!preventAbort) {\n        shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n    });\n\n    // Errors must be propagated backward\n    isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n      if (!preventCancel) {\n        shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n    });\n\n    // Closing must be propagated forward\n    isOrBecomesClosed(source, reader._closedPromise, () => {\n      if (!preventClose) {\n        shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n      } else {\n        shutdown();\n      }\n    });\n\n    // Closing must be propagated backward\n    if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n      const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n      if (!preventCancel) {\n        shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n      } else {\n        shutdown(true, destClosed);\n      }\n    }\n\n    setPromiseIsHandledToTrue(pipeLoop());\n\n    function waitForWritesToFinish(): Promise<void> {\n      // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n      // for that too.\n      const oldCurrentWrite = currentWrite;\n      return PerformPromiseThen(\n        currentWrite,\n        () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined\n      );\n    }\n\n    function isOrBecomesErrored(stream: ReadableStream | WritableStream,\n                                promise: Promise<void>,\n                                action: (reason: any) => void) {\n      if (stream._state === 'errored') {\n        action(stream._storedError);\n      } else {\n        uponRejection(promise, action);\n      }\n    }\n\n    function isOrBecomesClosed(stream: ReadableStream | WritableStream, promise: Promise<void>, action: () => void) {\n      if (stream._state === 'closed') {\n        action();\n      } else {\n        uponFulfillment(promise, action);\n      }\n    }\n\n    function shutdownWithAction(action: () => Promise<unknown>, originalIsError?: boolean, originalError?: any) {\n      if (shuttingDown) {\n        return;\n      }\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n        uponFulfillment(waitForWritesToFinish(), doTheRest);\n      } else {\n        doTheRest();\n      }\n\n      function doTheRest() {\n        uponPromise(\n          action(),\n          () => finalize(originalIsError, originalError),\n          newError => finalize(true, newError)\n        );\n      }\n    }\n\n    function shutdown(isError?: boolean, error?: any) {\n      if (shuttingDown) {\n        return;\n      }\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n        uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n      } else {\n        finalize(isError, error);\n      }\n    }\n\n    function finalize(isError?: boolean, error?: any) {\n      WritableStreamDefaultWriterRelease(writer);\n      ReadableStreamReaderGenericRelease(reader);\n\n      if (signal !== undefined) {\n        signal.removeEventListener('abort', abortAlgorithm);\n      }\n      if (isError) {\n        reject(error);\n      } else {\n        resolve(undefined);\n      }\n    }\n  });\n}\n", "import { QueuingStrategySizeCallback } from '../queuing-strategy';\nimport assert from '../../stub/assert';\nimport { DequeueValue, EnqueueValueWithSize, QueuePair, ResetQueue } from '../abstract-ops/queue-with-sizes';\nimport {\n  ReadableStreamAddReadRequest,\n  ReadableStreamFulfillReadRequest,\n  ReadableStreamGetNumReadRequests,\n  ReadRequest\n} from './default-reader';\nimport { SimpleQueue } from '../simple-queue';\nimport { IsReadableStreamLocked, ReadableStream, ReadableStreamClose, ReadableStreamError } from '../readable-stream';\nimport { ValidatedUnderlyingSource } from './underlying-source';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport { CancelSteps, PullSteps } from '../abstract-ops/internal-methods';\nimport { promiseResolvedWith, uponPromise } from '../helpers/webidl';\n\n/**\n * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n *\n * @public\n */\nexport class ReadableStreamDefaultController<R> {\n  /** @internal */\n  _controlledReadableStream!: ReadableStream<R>;\n  /** @internal */\n  _queue!: SimpleQueue<QueuePair<R>>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _closeRequested!: boolean;\n  /** @internal */\n  _pullAgain!: boolean;\n  /** @internal */\n  _pulling !: boolean;\n  /** @internal */\n  _strategySizeAlgorithm!: QueuingStrategySizeCallback<R>;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _pullAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm!: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n   * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n   */\n  get desiredSize(): number | null {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  /**\n   * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   * the stream, but once those are read, the stream will become closed.\n   */\n  close(): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n      throw new TypeError('The stream is not in a state that permits close');\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  }\n\n  /**\n   * Enqueues the given chunk `chunk` in the controlled readable stream.\n   */\n  enqueue(chunk: R): void;\n  enqueue(chunk: R = undefined!): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n      throw new TypeError('The stream is not in a state that permits enqueue');\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   */\n  error(e: any = undefined): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  }\n\n  /** @internal */\n  [CancelSteps](reason: any): Promise<void> {\n    ResetQueue(this);\n    const result = this._cancelAlgorithm(reason);\n    ReadableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [PullSteps](readRequest: ReadRequest<R>): void {\n    const stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this);\n\n      if (this._closeRequested && this._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      readRequest._chunkSteps(chunk);\n    } else {\n      ReadableStreamAddReadRequest(stream, readRequest);\n      ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    }\n  }\n}\n\nObject.defineProperties(ReadableStreamDefaultController.prototype, {\n  close: { enumerable: true },\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Abstract operations for the ReadableStreamDefaultController.\n\nfunction IsReadableStreamDefaultController<R = any>(x: any): x is ReadableStreamDefaultController<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamDefaultController;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller: ReadableStreamDefaultController<any>): void {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (!shouldPull) {\n    return;\n  }\n\n  if (controller._pulling) {\n    controller._pullAgain = true;\n    return;\n  }\n\n  assert(!controller._pullAgain);\n\n  controller._pulling = true;\n\n  const pullPromise = controller._pullAlgorithm();\n  uponPromise(\n    pullPromise,\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain) {\n        controller._pullAgain = false;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n    },\n    e => {\n      ReadableStreamDefaultControllerError(controller, e);\n    }\n  );\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller: ReadableStreamDefaultController<any>): boolean {\n  const stream = controller._controlledReadableStream;\n\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return false;\n  }\n\n  if (!controller._started) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize! > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller: ReadableStreamDefaultController<any>) {\n  controller._pullAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n  controller._strategySizeAlgorithm = undefined!;\n}\n\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\nexport function ReadableStreamDefaultControllerClose(controller: ReadableStreamDefaultController<any>) {\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return;\n  }\n\n  const stream = controller._controlledReadableStream;\n\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n  }\n}\n\nexport function ReadableStreamDefaultControllerEnqueue<R>(\n  controller: ReadableStreamDefaultController<R>,\n  chunk: R\n): void {\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return;\n  }\n\n  const stream = controller._controlledReadableStream;\n\n  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize;\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n\n    try {\n      EnqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerError(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n}\n\nexport function ReadableStreamDefaultControllerError(controller: ReadableStreamDefaultController<any>, e: any) {\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ResetQueue(controller);\n\n  ReadableStreamDefaultControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nexport function ReadableStreamDefaultControllerGetDesiredSize(\n  controller: ReadableStreamDefaultController<any>\n): number | null {\n  const state = controller._controlledReadableStream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\n// This is used in the implementation of TransformStream.\nexport function ReadableStreamDefaultControllerHasBackpressure(\n  controller: ReadableStreamDefaultController<any>\n): boolean {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function ReadableStreamDefaultControllerCanCloseOrEnqueue(\n  controller: ReadableStreamDefaultController<any>\n): boolean {\n  const state = controller._controlledReadableStream._state;\n\n  if (!controller._closeRequested && state === 'readable') {\n    return true;\n  }\n\n  return false;\n}\n\nexport function SetUpReadableStreamDefaultController<R>(stream: ReadableStream<R>,\n                                                        controller: ReadableStreamDefaultController<R>,\n                                                        startAlgorithm: () => void | PromiseLike<void>,\n                                                        pullAlgorithm: () => Promise<void>,\n                                                        cancelAlgorithm: (reason: any) => Promise<void>,\n                                                        highWaterMark: number,\n                                                        sizeAlgorithm: QueuingStrategySizeCallback<R>) {\n  assert(stream._readableStreamController === undefined);\n\n  controller._controlledReadableStream = stream;\n\n  controller._queue = undefined!;\n  controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  uponPromise(\n    promiseResolvedWith(startResult),\n    () => {\n      controller._started = true;\n\n      assert(!controller._pulling);\n      assert(!controller._pullAgain);\n\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    },\n    r => {\n      ReadableStreamDefaultControllerError(controller, r);\n    }\n  );\n}\n\nexport function SetUpReadableStreamDefaultControllerFromUnderlyingSource<R>(\n  stream: ReadableStream<R>,\n  underlyingSource: ValidatedUnderlyingSource<R>,\n  highWaterMark: number,\n  sizeAlgorithm: QueuingStrategySizeCallback<R>\n) {\n  const controller: ReadableStreamDefaultController<R> = Object.create(ReadableStreamDefaultController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void> = () => undefined;\n  let pullAlgorithm: () => Promise<void> = () => promiseResolvedWith(undefined);\n  let cancelAlgorithm: (reason: any) => Promise<void> = () => promiseResolvedWith(undefined);\n\n  if (underlyingSource.start !== undefined) {\n    startAlgorithm = () => underlyingSource.start!(controller);\n  }\n  if (underlyingSource.pull !== undefined) {\n    pullAlgorithm = () => underlyingSource.pull!(controller);\n  }\n  if (underlyingSource.cancel !== undefined) {\n    cancelAlgorithm = reason => underlyingSource.cancel!(reason);\n  }\n\n  SetUpReadableStreamDefaultController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n}\n\n// Helper functions for the ReadableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n", "import {\n  CreateReadableByteStream,\n  CreateReadableStream,\n  IsReadableStream,\n  ReadableByteStream,\n  ReadableStream,\n  ReadableStreamCancel,\n  ReadableStreamReader\n} from '../readable-stream';\nimport { ReadableStreamReaderGenericRelease } from './generic-reader';\nimport {\n  AcquireReadableStreamDefaultReader,\n  IsReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderRead,\n  ReadRequest\n} from './default-reader';\nimport {\n  AcquireReadableStreamBYOBReader,\n  IsReadableStreamBYOBReader,\n  ReadableStreamBYOBReaderRead,\n  ReadIntoRequest\n} from './byob-reader';\nimport assert from '../../stub/assert';\nimport { newPromise, promiseResolvedWith, queueMicrotask, uponRejection } from '../helpers/webidl';\nimport {\n  ReadableStreamDefaultController,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError\n} from './default-controller';\nimport {\n  IsReadableByteStreamController,\n  ReadableByteStreamControllerClose,\n  ReadableByteStreamControllerEnqueue,\n  ReadableByteStreamControllerError,\n  ReadableByteStreamControllerGetBYOBRequest,\n  ReadableByteStreamControllerRespond,\n  ReadableByteStreamControllerRespondWithNewView\n} from './byte-stream-controller';\nimport { CreateArrayFromList } from '../abstract-ops/ecmascript';\nimport { CloneAsUint8Array } from '../abstract-ops/miscellaneous';\n\nexport function ReadableStreamTee<R>(stream: ReadableStream<R>,\n                                     cloneForBranch2: boolean): [ReadableStream<R>, ReadableStream<R>] {\n  assert(IsReadableStream(stream));\n  assert(typeof cloneForBranch2 === 'boolean');\n  if (IsReadableByteStreamController(stream._readableStreamController)) {\n    return ReadableByteStreamTee(stream as unknown as ReadableByteStream) as\n      unknown as [ReadableStream<R>, ReadableStream<R>];\n  }\n  return ReadableStreamDefaultTee(stream, cloneForBranch2);\n}\n\nexport function ReadableStreamDefaultTee<R>(stream: ReadableStream<R>,\n                                            cloneForBranch2: boolean): [ReadableStream<R>, ReadableStream<R>] {\n  assert(IsReadableStream(stream));\n  assert(typeof cloneForBranch2 === 'boolean');\n\n  const reader = AcquireReadableStreamDefaultReader<R>(stream);\n\n  let reading = false;\n  let readAgain = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1: any;\n  let reason2: any;\n  let branch1: ReadableStream<R>;\n  let branch2: ReadableStream<R>;\n\n  let resolveCancelPromise: (value: undefined | Promise<undefined>) => void;\n  const cancelPromise = newPromise<undefined>(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function pullAlgorithm(): Promise<void> {\n    if (reading) {\n      readAgain = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgain = false;\n          const chunk1 = chunk;\n          const chunk2 = chunk;\n\n          // There is no way to access the cloning code right now in the reference implementation.\n          // If we add one then we'll need an implementation for serializable objects.\n          // if (!canceled2 && cloneForBranch2) {\n          //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n          // }\n\n          if (!canceled1) {\n            ReadableStreamDefaultControllerEnqueue(\n              branch1._readableStreamController as ReadableStreamDefaultController<R>,\n              chunk1\n            );\n          }\n          if (!canceled2) {\n            ReadableStreamDefaultControllerEnqueue(\n              branch2._readableStreamController as ReadableStreamDefaultController<R>,\n              chunk2\n            );\n          }\n\n          reading = false;\n          if (readAgain) {\n            pullAlgorithm();\n          }\n        });\n      },\n      _closeSteps: () => {\n        reading = false;\n        if (!canceled1) {\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController as ReadableStreamDefaultController<R>);\n        }\n        if (!canceled2) {\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController as ReadableStreamDefaultController<R>);\n        }\n\n        if (!canceled1 || !canceled2) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function cancel1Algorithm(reason: any): Promise<void> {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason: any): Promise<void> {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm() {\n    // do nothing\n  }\n\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n\n  uponRejection(reader._closedPromise, (r: any) => {\n    ReadableStreamDefaultControllerError(branch1._readableStreamController as ReadableStreamDefaultController<R>, r);\n    ReadableStreamDefaultControllerError(branch2._readableStreamController as ReadableStreamDefaultController<R>, r);\n    if (!canceled1 || !canceled2) {\n      resolveCancelPromise(undefined);\n    }\n  });\n\n  return [branch1, branch2];\n}\n\nexport function ReadableByteStreamTee(stream: ReadableByteStream): [ReadableByteStream, ReadableByteStream] {\n  assert(IsReadableStream(stream));\n  assert(IsReadableByteStreamController(stream._readableStreamController));\n\n  let reader: ReadableStreamReader<Uint8Array> = AcquireReadableStreamDefaultReader(stream);\n  let reading = false;\n  let readAgainForBranch1 = false;\n  let readAgainForBranch2 = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1: any;\n  let reason2: any;\n  let branch1: ReadableByteStream;\n  let branch2: ReadableByteStream;\n\n  let resolveCancelPromise: (value: undefined | Promise<undefined>) => void;\n  const cancelPromise = newPromise<void>(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function forwardReaderError(thisReader: ReadableStreamReader<Uint8Array>) {\n    uponRejection(thisReader._closedPromise, r => {\n      if (thisReader !== reader) {\n        return;\n      }\n      ReadableByteStreamControllerError(branch1._readableStreamController, r);\n      ReadableByteStreamControllerError(branch2._readableStreamController, r);\n      if (!canceled1 || !canceled2) {\n        resolveCancelPromise(undefined);\n      }\n    });\n  }\n\n  function pullWithDefaultReader() {\n    if (IsReadableStreamBYOBReader(reader)) {\n      assert(reader._readIntoRequests.length === 0);\n      ReadableStreamReaderGenericRelease(reader);\n\n      reader = AcquireReadableStreamDefaultReader(stream);\n      forwardReaderError(reader);\n    }\n\n    const readRequest: ReadRequest<Uint8Array> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgainForBranch1 = false;\n          readAgainForBranch2 = false;\n\n          const chunk1 = chunk;\n          let chunk2 = chunk;\n          if (!canceled1 && !canceled2) {\n            try {\n              chunk2 = CloneAsUint8Array(chunk);\n            } catch (cloneE) {\n              ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n              ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n              return;\n            }\n          }\n\n          if (!canceled1) {\n            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n          }\n          if (!canceled2) {\n            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n          }\n\n          reading = false;\n          if (readAgainForBranch1) {\n            pull1Algorithm();\n          } else if (readAgainForBranch2) {\n            pull2Algorithm();\n          }\n        });\n      },\n      _closeSteps: () => {\n        reading = false;\n        if (!canceled1) {\n          ReadableByteStreamControllerClose(branch1._readableStreamController);\n        }\n        if (!canceled2) {\n          ReadableByteStreamControllerClose(branch2._readableStreamController);\n        }\n        if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n          ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n        }\n        if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n          ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n        }\n        if (!canceled1 || !canceled2) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n  }\n\n  function pullWithBYOBReader(view: ArrayBufferView, forBranch2: boolean) {\n    if (IsReadableStreamDefaultReader<Uint8Array>(reader)) {\n      assert(reader._readRequests.length === 0);\n      ReadableStreamReaderGenericRelease(reader);\n\n      reader = AcquireReadableStreamBYOBReader(stream);\n      forwardReaderError(reader);\n    }\n\n    const byobBranch = forBranch2 ? branch2 : branch1;\n    const otherBranch = forBranch2 ? branch1 : branch2;\n\n    const readIntoRequest: ReadIntoRequest<ArrayBufferView> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgainForBranch1 = false;\n          readAgainForBranch2 = false;\n\n          const byobCanceled = forBranch2 ? canceled2 : canceled1;\n          const otherCanceled = forBranch2 ? canceled1 : canceled2;\n\n          if (!otherCanceled) {\n            let clonedChunk;\n            try {\n              clonedChunk = CloneAsUint8Array(chunk);\n            } catch (cloneE) {\n              ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n              ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n              return;\n            }\n            if (!byobCanceled) {\n              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n            }\n            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n          } else if (!byobCanceled) {\n            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n          }\n\n          reading = false;\n          if (readAgainForBranch1) {\n            pull1Algorithm();\n          } else if (readAgainForBranch2) {\n            pull2Algorithm();\n          }\n        });\n      },\n      _closeSteps: chunk => {\n        reading = false;\n\n        const byobCanceled = forBranch2 ? canceled2 : canceled1;\n        const otherCanceled = forBranch2 ? canceled1 : canceled2;\n\n        if (!byobCanceled) {\n          ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n        }\n        if (!otherCanceled) {\n          ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n        }\n\n        if (chunk !== undefined) {\n          assert(chunk.byteLength === 0);\n\n          if (!byobCanceled) {\n            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n          }\n          if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n          }\n        }\n\n        if (!byobCanceled || !otherCanceled) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);\n  }\n\n  function pull1Algorithm(): Promise<void> {\n    if (reading) {\n      readAgainForBranch1 = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n    if (byobRequest === null) {\n      pullWithDefaultReader();\n    } else {\n      pullWithBYOBReader(byobRequest._view!, false);\n    }\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function pull2Algorithm(): Promise<void> {\n    if (reading) {\n      readAgainForBranch2 = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n    if (byobRequest === null) {\n      pullWithDefaultReader();\n    } else {\n      pullWithBYOBReader(byobRequest._view!, true);\n    }\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function cancel1Algorithm(reason: any): Promise<void> {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason: any): Promise<void> {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm(): void {\n    return;\n  }\n\n  branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n  branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n\n  forwardReaderError(reader);\n\n  return [branch1, branch2];\n}\n", "import { assertDictionary, assertFunction, convertUnsignedLongLongWithEnforceRange } from './basic';\nimport {\n  ReadableStreamController,\n  UnderlyingByteSource,\n  UnderlyingDefaultOrByteSource,\n  UnderlyingDefaultOrByteSourcePullCallback,\n  UnderlyingDefaultOrByteSourceStartCallback,\n  UnderlyingSource,\n  UnderlyingSourceCancelCallback,\n  ValidatedUnderlyingDefaultOrByteSource\n} from '../readable-stream/underlying-source';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\n\nexport function convertUnderlyingDefaultOrByteSource<R>(\n  source: UnderlyingSource<R> | UnderlyingByteSource | null,\n  context: string\n): ValidatedUnderlyingDefaultOrByteSource<R> {\n  assertDictionary(source, context);\n  const original = source as (UnderlyingDefaultOrByteSource<R> | null);\n  const autoAllocateChunkSize = original?.autoAllocateChunkSize;\n  const cancel = original?.cancel;\n  const pull = original?.pull;\n  const start = original?.start;\n  const type = original?.type;\n  return {\n    autoAllocateChunkSize: autoAllocateChunkSize === undefined ?\n      undefined :\n      convertUnsignedLongLongWithEnforceRange(\n        autoAllocateChunkSize,\n        `${context} has member 'autoAllocateChunkSize' that`\n      ),\n    cancel: cancel === undefined ?\n      undefined :\n      convertUnderlyingSourceCancelCallback(cancel, original!, `${context} has member 'cancel' that`),\n    pull: pull === undefined ?\n      undefined :\n      convertUnderlyingSourcePullCallback(pull, original!, `${context} has member 'pull' that`),\n    start: start === undefined ?\n      undefined :\n      convertUnderlyingSourceStartCallback(start, original!, `${context} has member 'start' that`),\n    type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n  };\n}\n\nfunction convertUnderlyingSourceCancelCallback(\n  fn: UnderlyingSourceCancelCallback,\n  original: UnderlyingDefaultOrByteSource,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n\nfunction convertUnderlyingSourcePullCallback<R>(\n  fn: UnderlyingDefaultOrByteSourcePullCallback<R>,\n  original: UnderlyingDefaultOrByteSource<R>,\n  context: string\n): (controller: ReadableStreamController<R>) => Promise<void> {\n  assertFunction(fn, context);\n  return (controller: ReadableStreamController<R>) => promiseCall(fn, original, [controller]);\n}\n\nfunction convertUnderlyingSourceStartCallback<R>(\n  fn: UnderlyingDefaultOrByteSourceStartCallback<R>,\n  original: UnderlyingDefaultOrByteSource<R>,\n  context: string\n): UnderlyingDefaultOrByteSourceStartCallback<R> {\n  assertFunction(fn, context);\n  return (controller: ReadableStreamController<R>) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertReadableStreamType(type: string, context: string): 'bytes' {\n  type = `${type}`;\n  if (type !== 'bytes') {\n    throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n  }\n  return type;\n}\n", "import { assertDictionary } from './basic';\nimport { ReadableStreamGetReaderOptions } from '../readable-stream/reader-options';\n\nexport function convertReaderOptions(options: ReadableStreamGetReaderOptions | null | undefined,\n                                     context: string): ReadableStreamGetReaderOptions {\n  assertDictionary(options, context);\n  const mode = options?.mode;\n  return {\n    mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n  };\n}\n\nfunction convertReadableStreamReaderMode(mode: string, context: string): 'byob' {\n  mode = `${mode}`;\n  if (mode !== 'byob') {\n    throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n  }\n  return mode;\n}\n", "import { assertDictionary } from './basic';\nimport {\n  ReadableStreamIteratorOptions,\n  ValidatedReadableStreamIteratorOptions\n} from '../readable-stream/iterator-options';\n\nexport function convertIteratorOptions(options: ReadableStreamIteratorOptions | null | undefined,\n                                       context: string): ValidatedReadableStreamIteratorOptions {\n  assertDictionary(options, context);\n  const preventCancel = options?.preventCancel;\n  return { preventCancel: Boolean(preventCancel) };\n}\n", "import { assertDictionary } from './basic';\nimport { StreamPipeOptions, ValidatedStreamPipeOptions } from '../readable-stream/pipe-options';\nimport { AbortSignal, isAbortSignal } from '../abort-signal';\n\nexport function convertPipeOptions(options: StreamPipeOptions | null | undefined,\n                                   context: string): ValidatedStreamPipeOptions {\n  assertDictionary(options, context);\n  const preventAbort = options?.preventAbort;\n  const preventCancel = options?.preventCancel;\n  const preventClose = options?.preventClose;\n  const signal = options?.signal;\n  if (signal !== undefined) {\n    assertAbortSignal(signal, `${context} has member 'signal' that`);\n  }\n  return {\n    preventAbort: Boolean(preventAbort),\n    preventCancel: Boolean(preventCancel),\n    preventClose: Boolean(preventClose),\n    signal\n  };\n}\n\nfunction assertAbortSignal(signal: unknown, context: string): asserts signal is AbortSignal {\n  if (!isAbortSignal(signal)) {\n    throw new TypeError(`${context} is not an AbortSignal.`);\n  }\n}\n", "import { assertDictionary, assertRequiredField } from './basic';\nimport { ReadableStream } from '../readable-stream';\nimport { WritableStream } from '../writable-stream';\nimport { assertReadableStream } from './readable-stream';\nimport { assertWritableStream } from './writable-stream';\n\nexport function convertReadableWritablePair<RS extends ReadableStream, WS extends WritableStream>(\n  pair: { readable: RS; writable: WS } | null | undefined,\n  context: string\n): { readable: RS; writable: WS } {\n  assertDictionary(pair, context);\n\n  const readable = pair?.readable;\n  assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n  assertReadableStream(readable, `${context} has member 'readable' that`);\n\n  const writable = pair?.writable;\n  assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n  assertWritableStream(writable, `${context} has member 'writable' that`);\n\n  return { readable, writable };\n}\n", "import assert from '../stub/assert';\nimport {\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  transformPromiseWith\n} from './helpers/webidl';\nimport { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { AcquireReadableStreamAsyncIterator, ReadableStreamAsyncIterator } from './readable-stream/async-iterator';\nimport { defaultReaderClosedPromiseReject, defaultReaderClosedPromiseResolve } from './readable-stream/generic-reader';\nimport {\n  AcquireReadableStreamDefaultReader,\n  IsReadableStreamDefaultReader,\n  ReadableStreamDefaultReader,\n  ReadableStreamDefaultReadResult\n} from './readable-stream/default-reader';\nimport {\n  AcquireReadableStreamBYOBReader,\n  IsReadableStreamBYOBReader,\n  ReadableStreamBYOBReader,\n  ReadableStreamBYOBReadResult\n} from './readable-stream/byob-reader';\nimport { ReadableStreamPipeTo } from './readable-stream/pipe';\nimport { ReadableStreamTee } from './readable-stream/tee';\nimport { IsWritableStream, IsWritableStreamLocked, WritableStream } from './writable-stream';\nimport { SimpleQueue } from './simple-queue';\nimport {\n  ReadableByteStreamController,\n  ReadableStreamBYOBRequest,\n  SetUpReadableByteStreamController,\n  SetUpReadableByteStreamControllerFromUnderlyingSource\n} from './readable-stream/byte-stream-controller';\nimport {\n  ReadableStreamDefaultController,\n  SetUpReadableStreamDefaultController,\n  SetUpReadableStreamDefaultControllerFromUnderlyingSource\n} from './readable-stream/default-controller';\nimport {\n  UnderlyingByteSource,\n  UnderlyingByteSourcePullCallback,\n  UnderlyingByteSourceStartCallback,\n  UnderlyingSource,\n  UnderlyingSourceCancelCallback,\n  UnderlyingSourcePullCallback,\n  UnderlyingSourceStartCallback\n} from './readable-stream/underlying-source';\nimport { noop } from '../utils';\nimport { typeIsObject } from './helpers/miscellaneous';\nimport { CreateArrayFromList } from './abstract-ops/ecmascript';\nimport { CancelSteps } from './abstract-ops/internal-methods';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { assertObject, assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport { convertUnderlyingDefaultOrByteSource } from './validators/underlying-source';\nimport { ReadableStreamGetReaderOptions } from './readable-stream/reader-options';\nimport { convertReaderOptions } from './validators/reader-options';\nimport { StreamPipeOptions, ValidatedStreamPipeOptions } from './readable-stream/pipe-options';\nimport { ReadableStreamIteratorOptions } from './readable-stream/iterator-options';\nimport { convertIteratorOptions } from './validators/iterator-options';\nimport { convertPipeOptions } from './validators/pipe-options';\nimport { ReadableWritablePair } from './readable-stream/readable-writable-pair';\nimport { convertReadableWritablePair } from './validators/readable-writable-pair';\n\nexport type ReadableByteStream = ReadableStream<Uint8Array> & {\n  _readableStreamController: ReadableByteStreamController\n};\n\ntype ReadableStreamState = 'readable' | 'closed' | 'errored';\n\n/**\n * A readable stream represents a source of data, from which you can read.\n *\n * @public\n */\nexport class ReadableStream<R = any> {\n  /** @internal */\n  _state!: ReadableStreamState;\n  /** @internal */\n  _reader: ReadableStreamReader<R> | undefined;\n  /** @internal */\n  _storedError: any;\n  /** @internal */\n  _disturbed!: boolean;\n  /** @internal */\n  _readableStreamController!: ReadableStreamDefaultController<R> | ReadableByteStreamController;\n\n  constructor(underlyingSource: UnderlyingByteSource, strategy?: { highWaterMark?: number; size?: undefined });\n  constructor(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>);\n  constructor(rawUnderlyingSource: UnderlyingSource<R> | UnderlyingByteSource | null | undefined = {},\n              rawStrategy: QueuingStrategy<R> | null | undefined = {}) {\n    if (rawUnderlyingSource === undefined) {\n      rawUnderlyingSource = null;\n    } else {\n      assertObject(rawUnderlyingSource, 'First parameter');\n    }\n\n    const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n    const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n\n    InitializeReadableStream(this);\n\n    if (underlyingSource.type === 'bytes') {\n      if (strategy.size !== undefined) {\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\n      }\n      const highWaterMark = ExtractHighWaterMark(strategy, 0);\n      SetUpReadableByteStreamControllerFromUnderlyingSource(\n        this as unknown as ReadableByteStream,\n        underlyingSource,\n        highWaterMark\n      );\n    } else {\n      assert(underlyingSource.type === undefined);\n      const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n      const highWaterMark = ExtractHighWaterMark(strategy, 1);\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(\n        this,\n        underlyingSource,\n        highWaterMark,\n        sizeAlgorithm\n      );\n    }\n  }\n\n  /**\n   * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n   */\n  get locked(): boolean {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsReadableStreamLocked(this);\n  }\n\n  /**\n   * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n   *\n   * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n   * method, which might or might not use it.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  }\n\n  /**\n   * Creates a {@link ReadableStreamBYOBReader} and locks the stream to the new reader.\n   *\n   * This call behaves the same way as the no-argument variant, except that it only works on readable byte streams,\n   * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n   * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n   * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n   * control over allocation.\n   */\n  getReader({ mode }: { mode: 'byob' }): ReadableStreamBYOBReader;\n  /**\n   * Creates a {@link ReadableStreamDefaultReader} and locks the stream to the new reader.\n   * While the stream is locked, no other reader can be acquired until this one is released.\n   *\n   * This functionality is especially useful for creating abstractions that desire the ability to consume a stream\n   * in its entirety. By getting a reader for the stream, you can ensure nobody else can interleave reads with yours\n   * or cancel the stream, which would interfere with your abstraction.\n   */\n  getReader(): ReadableStreamDefaultReader<R>;\n  getReader(\n    rawOptions: ReadableStreamGetReaderOptions | null | undefined = undefined\n  ): ReadableStreamDefaultReader<R> | ReadableStreamBYOBReader {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('getReader');\n    }\n\n    const options = convertReaderOptions(rawOptions, 'First parameter');\n\n    if (options.mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    assert(options.mode === 'byob');\n    return AcquireReadableStreamBYOBReader(this as unknown as ReadableByteStream);\n  }\n\n  /**\n   * Provides a convenient, chainable way of piping this readable stream through a transform stream\n   * (or any other `{ writable, readable }` pair). It simply {@link ReadableStream.pipeTo | pipes} the stream\n   * into the writable side of the supplied pair, and returns the readable side for further use.\n   *\n   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   */\n  pipeThrough<RS extends ReadableStream>(\n    transform: { readable: RS; writable: WritableStream<R> },\n    options?: StreamPipeOptions\n  ): RS;\n  pipeThrough<RS extends ReadableStream>(\n    rawTransform: { readable: RS; writable: WritableStream<R> } | null | undefined,\n    rawOptions: StreamPipeOptions | null | undefined = {}\n  ): RS {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('pipeThrough');\n    }\n    assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n\n    const transform = convertReadableWritablePair(rawTransform, 'First parameter');\n    const options = convertPipeOptions(rawOptions, 'Second parameter');\n\n    if (IsReadableStreamLocked(this)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n    }\n    if (IsWritableStreamLocked(transform.writable)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n    }\n\n    const promise = ReadableStreamPipeTo(\n      this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal\n    );\n\n    setPromiseIsHandledToTrue(promise);\n\n    return transform.readable;\n  }\n\n  /**\n   * Pipes this readable stream to a given writable stream. The way in which the piping process behaves under\n   * various error conditions can be customized with a number of passed options. It returns a promise that fulfills\n   * when the piping process completes successfully, or rejects if any errors were encountered.\n   *\n   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   */\n  pipeTo(destination: WritableStream<R>, options?: StreamPipeOptions): Promise<void>;\n  pipeTo(destination: WritableStream<R> | null | undefined,\n         rawOptions: StreamPipeOptions | null | undefined = {}): Promise<void> {\n    if (!IsReadableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('pipeTo'));\n    }\n\n    if (destination === undefined) {\n      return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n    }\n    if (!IsWritableStream(destination)) {\n      return promiseRejectedWith(\n        new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`)\n      );\n    }\n\n    let options: ValidatedStreamPipeOptions;\n    try {\n      options = convertPipeOptions(rawOptions, 'Second parameter');\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n\n    if (IsReadableStreamLocked(this)) {\n      return promiseRejectedWith(\n        new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream')\n      );\n    }\n    if (IsWritableStreamLocked(destination)) {\n      return promiseRejectedWith(\n        new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream')\n      );\n    }\n\n    return ReadableStreamPipeTo<R>(\n      this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal\n    );\n  }\n\n  /**\n   * Tees this readable stream, returning a two-element array containing the two resulting branches as\n   * new {@link ReadableStream} instances.\n   *\n   * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n   * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n   * propagated to the stream's underlying source.\n   *\n   * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n   * this could allow interference between the two branches.\n   */\n  tee(): [ReadableStream<R>, ReadableStream<R>] {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('tee');\n    }\n\n    const branches = ReadableStreamTee(this, false);\n    return CreateArrayFromList(branches);\n  }\n\n  /**\n   * Asynchronously iterates over the chunks in the stream's internal queue.\n   *\n   * Asynchronously iterating over the stream will lock it, preventing any other consumer from acquiring a reader.\n   * The lock will be released if the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method\n   * is called, e.g. by breaking out of the loop.\n   *\n   * By default, calling the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method will also\n   * cancel the stream. To prevent this, use the stream's {@link ReadableStream.values | values()} method, passing\n   * `true` for the `preventCancel` option.\n   */\n  values(options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n  values(rawOptions: ReadableStreamIteratorOptions | null | undefined = undefined): ReadableStreamAsyncIterator<R> {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('values');\n    }\n\n    const options = convertIteratorOptions(rawOptions, 'First parameter');\n    return AcquireReadableStreamAsyncIterator<R>(this, options.preventCancel);\n  }\n\n  /**\n   * {@inheritDoc ReadableStream.values}\n   */\n  [Symbol.asyncIterator]: (options?: ReadableStreamIteratorOptions) => ReadableStreamAsyncIterator<R>;\n}\n\nObject.defineProperties(ReadableStream.prototype, {\n  cancel: { enumerable: true },\n  getReader: { enumerable: true },\n  pipeThrough: { enumerable: true },\n  pipeTo: { enumerable: true },\n  tee: { enumerable: true },\n  values: { enumerable: true },\n  locked: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, {\n    value: 'ReadableStream',\n    configurable: true\n  });\n}\nif (typeof Symbol.asyncIterator === 'symbol') {\n  Object.defineProperty(ReadableStream.prototype, Symbol.asyncIterator, {\n    value: ReadableStream.prototype.values,\n    writable: true,\n    configurable: true\n  });\n}\n\nexport {\n  ReadableStreamAsyncIterator,\n  ReadableStreamDefaultReadResult,\n  ReadableStreamBYOBReadResult,\n  UnderlyingByteSource,\n  UnderlyingSource,\n  UnderlyingSourceStartCallback,\n  UnderlyingSourcePullCallback,\n  UnderlyingSourceCancelCallback,\n  UnderlyingByteSourceStartCallback,\n  UnderlyingByteSourcePullCallback,\n  StreamPipeOptions,\n  ReadableWritablePair,\n  ReadableStreamIteratorOptions\n};\n\n// Abstract operations for the ReadableStream.\n\n// Throws if and only if startAlgorithm throws.\nexport function CreateReadableStream<R>(startAlgorithm: () => void | PromiseLike<void>,\n                                        pullAlgorithm: () => Promise<void>,\n                                        cancelAlgorithm: (reason: any) => Promise<void>,\n                                        highWaterMark = 1,\n                                        sizeAlgorithm: QueuingStrategySizeCallback<R> = () => 1): ReadableStream<R> {\n  assert(IsNonNegativeNumber(highWaterMark));\n\n  const stream: ReadableStream<R> = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller: ReadableStreamDefaultController<R> = Object.create(ReadableStreamDefaultController.prototype);\n  SetUpReadableStreamDefaultController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n\n  return stream;\n}\n\n// Throws if and only if startAlgorithm throws.\nexport function CreateReadableByteStream(\n  startAlgorithm: () => void | PromiseLike<void>,\n  pullAlgorithm: () => Promise<void>,\n  cancelAlgorithm: (reason: any) => Promise<void>\n): ReadableByteStream {\n  const stream: ReadableByteStream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller: ReadableByteStreamController = Object.create(ReadableByteStreamController.prototype);\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n\n  return stream;\n}\n\nfunction InitializeReadableStream(stream: ReadableStream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\n\nexport function IsReadableStream(x: unknown): x is ReadableStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return x instanceof ReadableStream;\n}\n\nexport function IsReadableStreamDisturbed(stream: ReadableStream): boolean {\n  assert(IsReadableStream(stream));\n\n  return stream._disturbed;\n}\n\nexport function IsReadableStreamLocked(stream: ReadableStream): boolean {\n  assert(IsReadableStream(stream));\n\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamCancel<R>(stream: ReadableStream<R>, reason: any): Promise<undefined> {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return promiseResolvedWith(undefined);\n  }\n  if (stream._state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  const reader = stream._reader;\n  if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n    reader._readIntoRequests.forEach(readIntoRequest => {\n      readIntoRequest._closeSteps(undefined);\n    });\n    reader._readIntoRequests = new SimpleQueue();\n  }\n\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n  return transformPromiseWith(sourceCancelPromise, noop);\n}\n\nexport function ReadableStreamClose<R>(stream: ReadableStream<R>): void {\n  assert(stream._state === 'readable');\n\n  stream._state = 'closed';\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return;\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n\n  if (IsReadableStreamDefaultReader<R>(reader)) {\n    reader._readRequests.forEach(readRequest => {\n      readRequest._closeSteps();\n    });\n    reader._readRequests = new SimpleQueue();\n  }\n}\n\nexport function ReadableStreamError<R>(stream: ReadableStream<R>, e: any): void {\n  assert(IsReadableStream(stream));\n  assert(stream._state === 'readable');\n\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return;\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n\n  if (IsReadableStreamDefaultReader<R>(reader)) {\n    reader._readRequests.forEach(readRequest => {\n      readRequest._errorSteps(e);\n    });\n\n    reader._readRequests = new SimpleQueue();\n  } else {\n    assert(IsReadableStreamBYOBReader(reader));\n\n    reader._readIntoRequests.forEach(readIntoRequest => {\n      readIntoRequest._errorSteps(e);\n    });\n\n    reader._readIntoRequests = new SimpleQueue();\n  }\n}\n\n// Readers\n\nexport type ReadableStreamReader<R> = ReadableStreamDefaultReader<R> | ReadableStreamBYOBReader;\n\nexport {\n  ReadableStreamDefaultReader,\n  ReadableStreamBYOBReader\n};\n\n// Controllers\n\nexport {\n  ReadableStreamDefaultController,\n  ReadableStreamBYOBRequest,\n  ReadableByteStreamController\n};\n\n// Helper functions for the ReadableStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n", "import { QueuingStrategyInit } from '../queuing-strategy';\nimport { assertDictionary, assertRequiredField, convertUnrestrictedDouble } from './basic';\n\nexport function convertQueuingStrategyInit(init: QueuingStrategyInit | null | undefined,\n                                           context: string): QueuingStrategyInit {\n  assertDictionary(init, context);\n  const highWaterMark = init?.highWaterMark;\n  assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n  return {\n    highWaterMark: convertUnrestrictedDouble(highWaterMark)\n  };\n}\n", "import { QueuingStrategy, QueuingStrategyInit } from './queuing-strategy';\nimport { typeIsObject } from './helpers/miscellaneous';\nimport { assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategyInit } from './validators/queuing-strategy-init';\n\n// The size function must not have a prototype property nor be a constructor\nconst byteLengthSizeFunction = (chunk: ArrayBufferView): number => {\n  return chunk.byteLength;\n};\ntry {\n  Object.defineProperty(byteLengthSizeFunction, 'name', {\n    value: 'size',\n    configurable: true\n  });\n} catch {\n  // This property is non-configurable in older browsers, so ignore if this throws.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n}\n\n/**\n * A queuing strategy that counts the number of bytes in each chunk.\n *\n * @public\n */\nexport default class ByteLengthQueuingStrategy implements QueuingStrategy<ArrayBufferView> {\n  /** @internal */\n  readonly _byteLengthQueuingStrategyHighWaterMark: number;\n\n  constructor(options: QueuingStrategyInit) {\n    assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n    options = convertQueuingStrategyInit(options, 'First parameter');\n    this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n  }\n\n  /**\n   * Returns the high water mark provided to the constructor.\n   */\n  get highWaterMark(): number {\n    if (!IsByteLengthQueuingStrategy(this)) {\n      throw byteLengthBrandCheckException('highWaterMark');\n    }\n    return this._byteLengthQueuingStrategyHighWaterMark;\n  }\n\n  /**\n   * Measures the size of `chunk` by returning the value of its `byteLength` property.\n   */\n  get size(): (chunk: ArrayBufferView) => number {\n    if (!IsByteLengthQueuingStrategy(this)) {\n      throw byteLengthBrandCheckException('size');\n    }\n    return byteLengthSizeFunction;\n  }\n}\n\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, {\n  highWaterMark: { enumerable: true },\n  size: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {\n    value: 'ByteLengthQueuingStrategy',\n    configurable: true\n  });\n}\n\n// Helper functions for the ByteLengthQueuingStrategy.\n\nfunction byteLengthBrandCheckException(name: string): TypeError {\n  return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n}\n\nexport function IsByteLengthQueuingStrategy(x: any): x is ByteLengthQueuingStrategy {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n    return false;\n  }\n\n  return x instanceof ByteLengthQueuingStrategy;\n}\n", "import { QueuingStrategy, QueuingStrategyInit } from './queuing-strategy';\nimport { typeIsObject } from './helpers/miscellaneous';\nimport { assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategyInit } from './validators/queuing-strategy-init';\n\n// The size function must not have a prototype property nor be a constructor\nconst countSizeFunction = (): 1 => {\n  return 1;\n};\ntry {\n  Object.defineProperty(countSizeFunction, 'name', {\n    value: 'size',\n    configurable: true\n  });\n} catch {\n  // This property is non-configurable in older browsers, so ignore if this throws.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n}\n\n/**\n * A queuing strategy that counts the number of chunks.\n *\n * @public\n */\nexport default class CountQueuingStrategy implements QueuingStrategy<any> {\n  /** @internal */\n  readonly _countQueuingStrategyHighWaterMark!: number;\n\n  constructor(options: QueuingStrategyInit) {\n    assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n    options = convertQueuingStrategyInit(options, 'First parameter');\n    this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n  }\n\n  /**\n   * Returns the high water mark provided to the constructor.\n   */\n  get highWaterMark(): number {\n    if (!IsCountQueuingStrategy(this)) {\n      throw countBrandCheckException('highWaterMark');\n    }\n    return this._countQueuingStrategyHighWaterMark;\n  }\n\n  /**\n   * Measures the size of `chunk` by always returning 1.\n   * This ensures that the total queue size is a count of the number of chunks in the queue.\n   */\n  get size(): (chunk: any) => 1 {\n    if (!IsCountQueuingStrategy(this)) {\n      throw countBrandCheckException('size');\n    }\n    return countSizeFunction;\n  }\n}\n\nObject.defineProperties(CountQueuingStrategy.prototype, {\n  highWaterMark: { enumerable: true },\n  size: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {\n    value: 'CountQueuingStrategy',\n    configurable: true\n  });\n}\n\n// Helper functions for the CountQueuingStrategy.\n\nfunction countBrandCheckException(name: string): TypeError {\n  return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n}\n\nexport function IsCountQueuingStrategy(x: any): x is CountQueuingStrategy {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n    return false;\n  }\n\n  return x instanceof CountQueuingStrategy;\n}\n", "import { assertDictionary, assertFunction } from './basic';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\nimport {\n  Transformer,\n  TransformerFlushCallback,\n  TransformerStartCallback,\n  TransformerTransformCallback,\n  ValidatedTransformer\n} from '../transform-stream/transformer';\nimport { TransformStreamDefaultController } from '../transform-stream';\n\nexport function convertTransformer<I, O>(original: Transformer<I, O> | null,\n                                         context: string): ValidatedTransformer<I, O> {\n  assertDictionary(original, context);\n  const flush = original?.flush;\n  const readableType = original?.readableType;\n  const start = original?.start;\n  const transform = original?.transform;\n  const writableType = original?.writableType;\n  return {\n    flush: flush === undefined ?\n      undefined :\n      convertTransformerFlushCallback(flush, original!, `${context} has member 'flush' that`),\n    readableType,\n    start: start === undefined ?\n      undefined :\n      convertTransformerStartCallback(start, original!, `${context} has member 'start' that`),\n    transform: transform === undefined ?\n      undefined :\n      convertTransformerTransformCallback(transform, original!, `${context} has member 'transform' that`),\n    writableType\n  };\n}\n\nfunction convertTransformerFlushCallback<I, O>(\n  fn: TransformerFlushCallback<O>,\n  original: Transformer<I, O>,\n  context: string\n): (controller: TransformStreamDefaultController<O>) => Promise<void> {\n  assertFunction(fn, context);\n  return (controller: TransformStreamDefaultController<O>) => promiseCall(fn, original, [controller]);\n}\n\nfunction convertTransformerStartCallback<I, O>(\n  fn: TransformerStartCallback<O>,\n  original: Transformer<I, O>,\n  context: string\n): TransformerStartCallback<O> {\n  assertFunction(fn, context);\n  return (controller: TransformStreamDefaultController<O>) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertTransformerTransformCallback<I, O>(\n  fn: TransformerTransformCallback<I, O>,\n  original: Transformer<I, O>,\n  context: string\n): (chunk: I, controller: TransformStreamDefaultController<O>) => Promise<void> {\n  assertFunction(fn, context);\n  return (chunk: I, controller: TransformStreamDefaultController<O>) => promiseCall(fn, original, [chunk, controller]);\n}\n", "import assert from '../stub/assert';\nimport { newPromise, promiseRejectedWith, promiseResolvedWith, transformPromiseWith } from './helpers/webidl';\nimport { CreateReadableStream, ReadableStream, ReadableStreamDefaultController } from './readable-stream';\nimport {\n  ReadableStreamDefaultControllerCanCloseOrEnqueue,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize,\n  ReadableStreamDefaultControllerHasBackpressure\n} from './readable-stream/default-controller';\nimport { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { CreateWritableStream, WritableStream, WritableStreamDefaultControllerErrorIfNeeded } from './writable-stream';\nimport { typeIsObject } from './helpers/miscellaneous';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport {\n  Transformer,\n  TransformerFlushCallback,\n  TransformerStartCallback,\n  TransformerTransformCallback,\n  ValidatedTransformer\n} from './transform-stream/transformer';\nimport { convertTransformer } from './validators/transformer';\n\n// Class TransformStream\n\n/**\n * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n * made available for reading from the readable side.\n *\n * @public\n */\nexport class TransformStream<I = any, O = any> {\n  /** @internal */\n  _writable!: WritableStream<I>;\n  /** @internal */\n  _readable!: ReadableStream<O>;\n  /** @internal */\n  _backpressure!: boolean;\n  /** @internal */\n  _backpressureChangePromise!: Promise<void>;\n  /** @internal */\n  _backpressureChangePromise_resolve!: () => void;\n  /** @internal */\n  _transformStreamController!: TransformStreamDefaultController<O>;\n\n  constructor(\n    transformer?: Transformer<I, O>,\n    writableStrategy?: QueuingStrategy<I>,\n    readableStrategy?: QueuingStrategy<O>\n  );\n  constructor(rawTransformer: Transformer<I, O> | null | undefined = {},\n              rawWritableStrategy: QueuingStrategy<I> | null | undefined = {},\n              rawReadableStrategy: QueuingStrategy<O> | null | undefined = {}) {\n    if (rawTransformer === undefined) {\n      rawTransformer = null;\n    }\n\n    const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n    const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n\n    const transformer = convertTransformer(rawTransformer, 'First parameter');\n    if (transformer.readableType !== undefined) {\n      throw new RangeError('Invalid readableType specified');\n    }\n    if (transformer.writableType !== undefined) {\n      throw new RangeError('Invalid writableType specified');\n    }\n\n    const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n    const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n    const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n    const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n\n    let startPromise_resolve!: (value: void | PromiseLike<void>) => void;\n    const startPromise = newPromise<void>(resolve => {\n      startPromise_resolve = resolve;\n    });\n\n    InitializeTransformStream(\n      this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm\n    );\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n\n    if (transformer.start !== undefined) {\n      startPromise_resolve(transformer.start(this._transformStreamController));\n    } else {\n      startPromise_resolve(undefined);\n    }\n  }\n\n  /**\n   * The readable side of the transform stream.\n   */\n  get readable(): ReadableStream<O> {\n    if (!IsTransformStream(this)) {\n      throw streamBrandCheckException('readable');\n    }\n\n    return this._readable;\n  }\n\n  /**\n   * The writable side of the transform stream.\n   */\n  get writable(): WritableStream<I> {\n    if (!IsTransformStream(this)) {\n      throw streamBrandCheckException('writable');\n    }\n\n    return this._writable;\n  }\n}\n\nObject.defineProperties(TransformStream.prototype, {\n  readable: { enumerable: true },\n  writable: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {\n    value: 'TransformStream',\n    configurable: true\n  });\n}\n\nexport {\n  Transformer,\n  TransformerStartCallback,\n  TransformerFlushCallback,\n  TransformerTransformCallback\n};\n\n// Transform Stream Abstract Operations\n\nexport function CreateTransformStream<I, O>(startAlgorithm: () => void | PromiseLike<void>,\n                                            transformAlgorithm: (chunk: I) => Promise<void>,\n                                            flushAlgorithm: () => Promise<void>,\n                                            writableHighWaterMark = 1,\n                                            writableSizeAlgorithm: QueuingStrategySizeCallback<I> = () => 1,\n                                            readableHighWaterMark = 0,\n                                            readableSizeAlgorithm: QueuingStrategySizeCallback<O> = () => 1) {\n  assert(IsNonNegativeNumber(writableHighWaterMark));\n  assert(IsNonNegativeNumber(readableHighWaterMark));\n\n  const stream: TransformStream<I, O> = Object.create(TransformStream.prototype);\n\n  let startPromise_resolve!: (value: void | PromiseLike<void>) => void;\n  const startPromise = newPromise<void>(resolve => {\n    startPromise_resolve = resolve;\n  });\n\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                            readableSizeAlgorithm);\n\n  const controller: TransformStreamDefaultController<O> = Object.create(TransformStreamDefaultController.prototype);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n\n  const startResult = startAlgorithm();\n  startPromise_resolve(startResult);\n  return stream;\n}\n\nfunction InitializeTransformStream<I, O>(stream: TransformStream<I, O>,\n                                         startPromise: Promise<void>,\n                                         writableHighWaterMark: number,\n                                         writableSizeAlgorithm: QueuingStrategySizeCallback<I>,\n                                         readableHighWaterMark: number,\n                                         readableSizeAlgorithm: QueuingStrategySizeCallback<O>) {\n  function startAlgorithm(): Promise<void> {\n    return startPromise;\n  }\n\n  function writeAlgorithm(chunk: I): Promise<void> {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n\n  function abortAlgorithm(reason: any): Promise<void> {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n\n  function closeAlgorithm(): Promise<void> {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\n                                          writableHighWaterMark, writableSizeAlgorithm);\n\n  function pullAlgorithm(): Promise<void> {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n\n  function cancelAlgorithm(reason: any): Promise<void> {\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n    return promiseResolvedWith(undefined);\n  }\n\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\n                                          readableSizeAlgorithm);\n\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  stream._backpressure = undefined!;\n  stream._backpressureChangePromise = undefined!;\n  stream._backpressureChangePromise_resolve = undefined!;\n  TransformStreamSetBackpressure(stream, true);\n\n  stream._transformStreamController = undefined!;\n}\n\nfunction IsTransformStream(x: unknown): x is TransformStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return x instanceof TransformStream;\n}\n\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream: TransformStream, e: any) {\n  ReadableStreamDefaultControllerError(\n    stream._readable._readableStreamController as ReadableStreamDefaultController<any>,\n    e\n  );\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\n\nfunction TransformStreamErrorWritableAndUnblockWrite(stream: TransformStream, e: any) {\n  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n  if (stream._backpressure) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\n\nfunction TransformStreamSetBackpressure(stream: TransformStream, backpressure: boolean) {\n  // Passes also when called during construction.\n  assert(stream._backpressure !== backpressure);\n\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n\n  stream._backpressureChangePromise = newPromise(resolve => {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n\n  stream._backpressure = backpressure;\n}\n\n// Class TransformStreamDefaultController\n\n/**\n * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n *\n * @public\n */\nexport class TransformStreamDefaultController<O> {\n  /** @internal */\n  _controlledTransformStream: TransformStream<any, O>;\n  /** @internal */\n  _transformAlgorithm: (chunk: any) => Promise<void>;\n  /** @internal */\n  _flushAlgorithm: () => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the desired size to fill the readable side\u2019s internal queue. It can be negative, if the queue is over-full.\n   */\n  get desiredSize(): number | null {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController as ReadableStreamDefaultController<O>);\n  }\n\n  /**\n   * Enqueues the given chunk `chunk` in the readable side of the controlled transform stream.\n   */\n  enqueue(chunk: O): void;\n  enqueue(chunk: O = undefined!): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors both the readable side and the writable side of the controlled transform stream, making all future\n   * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n   */\n  error(reason: any = undefined): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    TransformStreamDefaultControllerError(this, reason);\n  }\n\n  /**\n   * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n   * transformer only needs to consume a portion of the chunks written to the writable side.\n   */\n  terminate(): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('terminate');\n    }\n\n    TransformStreamDefaultControllerTerminate(this);\n  }\n}\n\nObject.defineProperties(TransformStreamDefaultController.prototype, {\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  terminate: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'TransformStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Transform Stream Default Controller Abstract Operations\n\nfunction IsTransformStreamDefaultController<O = any>(x: any): x is TransformStreamDefaultController<O> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return x instanceof TransformStreamDefaultController;\n}\n\nfunction SetUpTransformStreamDefaultController<I, O>(stream: TransformStream<I, O>,\n                                                     controller: TransformStreamDefaultController<O>,\n                                                     transformAlgorithm: (chunk: I) => Promise<void>,\n                                                     flushAlgorithm: () => Promise<void>) {\n  assert(IsTransformStream(stream));\n  assert(stream._transformStreamController === undefined);\n\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n}\n\nfunction SetUpTransformStreamDefaultControllerFromTransformer<I, O>(stream: TransformStream<I, O>,\n                                                                    transformer: ValidatedTransformer<I, O>) {\n  const controller: TransformStreamDefaultController<O> = Object.create(TransformStreamDefaultController.prototype);\n\n  let transformAlgorithm = (chunk: I): Promise<void> => {\n    try {\n      TransformStreamDefaultControllerEnqueue(controller, chunk as unknown as O);\n      return promiseResolvedWith(undefined);\n    } catch (transformResultE) {\n      return promiseRejectedWith(transformResultE);\n    }\n  };\n\n  let flushAlgorithm: () => Promise<void> = () => promiseResolvedWith(undefined);\n\n  if (transformer.transform !== undefined) {\n    transformAlgorithm = chunk => transformer.transform!(chunk, controller);\n  }\n  if (transformer.flush !== undefined) {\n    flushAlgorithm = () => transformer.flush!(controller);\n  }\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\n\nfunction TransformStreamDefaultControllerClearAlgorithms(controller: TransformStreamDefaultController<any>) {\n  controller._transformAlgorithm = undefined!;\n  controller._flushAlgorithm = undefined!;\n}\n\nfunction TransformStreamDefaultControllerEnqueue<O>(controller: TransformStreamDefaultController<O>, chunk: O) {\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController as ReadableStreamDefaultController<O>;\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n    throw new TypeError('Readable side is not in a state that permits enqueue');\n  }\n\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n\n  try {\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n\n    throw stream._readable._storedError;\n  }\n\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream._backpressure) {\n    assert(backpressure);\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\n\nfunction TransformStreamDefaultControllerError(controller: TransformStreamDefaultController<any>, e: any) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\n\nfunction TransformStreamDefaultControllerPerformTransform<I, O>(controller: TransformStreamDefaultController<O>,\n                                                                chunk: I) {\n  const transformPromise = controller._transformAlgorithm(chunk);\n  return transformPromiseWith(transformPromise, undefined, r => {\n    TransformStreamError(controller._controlledTransformStream, r);\n    throw r;\n  });\n}\n\nfunction TransformStreamDefaultControllerTerminate<O>(controller: TransformStreamDefaultController<O>) {\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController as ReadableStreamDefaultController<O>;\n\n  ReadableStreamDefaultControllerClose(readableController);\n\n  const error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n\n// TransformStreamDefaultSink Algorithms\n\nfunction TransformStreamDefaultSinkWriteAlgorithm<I, O>(stream: TransformStream<I, O>, chunk: I): Promise<void> {\n  assert(stream._writable._state === 'writable');\n\n  const controller = stream._transformStreamController;\n\n  if (stream._backpressure) {\n    const backpressureChangePromise = stream._backpressureChangePromise;\n    assert(backpressureChangePromise !== undefined);\n    return transformPromiseWith(backpressureChangePromise, () => {\n      const writable = stream._writable;\n      const state = writable._state;\n      if (state === 'erroring') {\n        throw writable._storedError;\n      }\n      assert(state === 'writable');\n      return TransformStreamDefaultControllerPerformTransform<I, O>(controller, chunk);\n    });\n  }\n\n  return TransformStreamDefaultControllerPerformTransform<I, O>(controller, chunk);\n}\n\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream: TransformStream, reason: any): Promise<void> {\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n  // errored.\n  TransformStreamError(stream, reason);\n  return promiseResolvedWith(undefined);\n}\n\nfunction TransformStreamDefaultSinkCloseAlgorithm<I, O>(stream: TransformStream<I, O>): Promise<void> {\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  const controller = stream._transformStreamController;\n  const flushPromise = controller._flushAlgorithm();\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  // Return a promise that is fulfilled with undefined on success.\n  return transformPromiseWith(flushPromise, () => {\n    if (readable._state === 'errored') {\n      throw readable._storedError;\n    }\n    ReadableStreamDefaultControllerClose(readable._readableStreamController as ReadableStreamDefaultController<O>);\n  }, r => {\n    TransformStreamError(stream, r);\n    throw readable._storedError;\n  });\n}\n\n// TransformStreamDefaultSource Algorithms\n\nfunction TransformStreamDefaultSourcePullAlgorithm(stream: TransformStream): Promise<void> {\n  // Invariant. Enforced by the promises returned by start() and pull().\n  assert(stream._backpressure);\n\n  assert(stream._backpressureChangePromise !== undefined);\n\n  TransformStreamSetBackpressure(stream, false);\n\n  // Prevent the next pull() call until there is backpressure.\n  return stream._backpressureChangePromise;\n}\n\n// Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n\n// Helper functions for the TransformStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n", "/* c8 ignore start */\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\nif (!globalThis.ReadableStream) {\n  // `node:stream/web` got introduced in v16.5.0 as experimental\n  // and it's preferred over the polyfilled version. So we also\n  // suppress the warning that gets emitted by NodeJS for using it.\n  try {\n    const process = require('node:process')\n    const { emitWarning } = process\n    try {\n      process.emitWarning = () => {}\n      Object.assign(globalThis, require('node:stream/web'))\n      process.emitWarning = emitWarning\n    } catch (error) {\n      process.emitWarning = emitWarning\n      throw error\n    }\n  } catch (error) {\n    // fallback to polyfill implementation\n    Object.assign(globalThis, require('web-streams-polyfill/dist/ponyfill.es2018.js'))\n  }\n}\n\ntry {\n  // Don't use node: prefix for this, require+node: is not supported until node v14.14\n  // Only `import()` can use prefix in 12.20 and later\n  const { Blob } = require('buffer')\n  if (Blob && !Blob.prototype.stream) {\n    Blob.prototype.stream = function name (params) {\n      let position = 0\n      const blob = this\n\n      return new ReadableStream({\n        type: 'bytes',\n        async pull (ctrl) {\n          const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE))\n          const buffer = await chunk.arrayBuffer()\n          position += buffer.byteLength\n          ctrl.enqueue(new Uint8Array(buffer))\n\n          if (position === blob.size) {\n            ctrl.close()\n          }\n        }\n      })\n    }\n  }\n} catch (error) {}\n/* c8 ignore end */\n", "/*! fetch-blob. MIT License. Jimmy W\u00E4rting <https://jimmy.warting.se/opensource> */\n\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs'\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\n/** @param {(Blob | Uint8Array)[]} parts */\nasync function * toIterator (parts, clone = true) {\n  for (const part of parts) {\n    if ('stream' in part) {\n      yield * (/** @type {AsyncIterableIterator<Uint8Array>} */ (part.stream()))\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        let position = part.byteOffset\n        const end = part.byteOffset + part.byteLength\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE)\n          const chunk = part.buffer.slice(position, position + size)\n          position += chunk.byteLength\n          yield new Uint8Array(chunk)\n        }\n      } else {\n        yield part\n      }\n    /* c8 ignore next 10 */\n    } else {\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n      let position = 0, b = (/** @type {Blob} */ (part))\n      while (position !== b.size) {\n        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE))\n        const buffer = await chunk.arrayBuffer()\n        position += buffer.byteLength\n        yield new Uint8Array(buffer)\n      }\n    }\n  }\n}\n\nconst _Blob = class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n  #parts = []\n  #type = ''\n  #size = 0\n  #endings = 'transparent'\n\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */\n  constructor (blobParts = [], options = {}) {\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.')\n    }\n\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.')\n    }\n\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.')\n    }\n\n    if (options === null) options = {}\n\n    const encoder = new TextEncoder()\n    for (const element of blobParts) {\n      let part\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength))\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0))\n      } else if (element instanceof Blob) {\n        part = element\n      } else {\n        part = encoder.encode(`${element}`)\n      }\n\n      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size\n      this.#parts.push(part)\n    }\n\n    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`\n    const type = options.type === undefined ? '' : String(options.type)\n    this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : ''\n  }\n\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n  get size () {\n    return this.#size\n  }\n\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n  get type () {\n    return this.#type\n  }\n\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n  async text () {\n    // More optimized than using this.arrayBuffer()\n    // that requires twice as much ram\n    const decoder = new TextDecoder()\n    let str = ''\n    for await (const part of toIterator(this.#parts, false)) {\n      str += decoder.decode(part, { stream: true })\n    }\n    // Remaining\n    str += decoder.decode()\n    return str\n  }\n\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n  async arrayBuffer () {\n    // Easier way... Just a unnecessary overhead\n    // const view = new Uint8Array(this.size);\n    // await this.stream().getReader({mode: 'byob'}).read(view);\n    // return view.buffer;\n\n    const data = new Uint8Array(this.size)\n    let offset = 0\n    for await (const chunk of toIterator(this.#parts, false)) {\n      data.set(chunk, offset)\n      offset += chunk.length\n    }\n\n    return data.buffer\n  }\n\n  stream () {\n    const it = toIterator(this.#parts, true)\n\n    return new globalThis.ReadableStream({\n      // @ts-ignore\n      type: 'bytes',\n      async pull (ctrl) {\n        const chunk = await it.next()\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value)\n      },\n\n      async cancel () {\n        await it.return()\n      }\n    })\n  }\n\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n  slice (start = 0, end = this.size, type = '') {\n    const { size } = this\n\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size)\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size)\n\n    const span = Math.max(relativeEnd - relativeStart, 0)\n    const parts = this.#parts\n    const blobParts = []\n    let added = 0\n\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break\n      }\n\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size\n        relativeEnd -= size\n      } else {\n        let chunk\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.byteLength\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.size\n        }\n        relativeEnd -= size\n        blobParts.push(chunk)\n        relativeStart = 0 // All next sequential parts should start at 0\n      }\n    }\n\n    const blob = new Blob([], { type: String(type).toLowerCase() })\n    blob.#size = span\n    blob.#parts = blobParts\n\n    return blob\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return (\n      object &&\n      typeof object === 'object' &&\n      typeof object.constructor === 'function' &&\n      (\n        typeof object.stream === 'function' ||\n        typeof object.arrayBuffer === 'function'\n      ) &&\n      /^(Blob|File)$/.test(object[Symbol.toStringTag])\n    )\n  }\n}\n\nObject.defineProperties(_Blob.prototype, {\n  size: { enumerable: true },\n  type: { enumerable: true },\n  slice: { enumerable: true }\n})\n\n/** @type {typeof globalThis.Blob} */\nexport const Blob = _Blob\nexport default Blob\n", "import Blob from './index.js'\n\nconst _File = class File extends Blob {\n  #lastModified = 0\n  #name = ''\n\n  /**\n   * @param {*[]} fileBits\n   * @param {string} fileName\n   * @param {{lastModified?: number, type?: string}} options\n   */// @ts-ignore\n  constructor (fileBits, fileName, options = {}) {\n    if (arguments.length < 2) {\n      throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`)\n    }\n    super(fileBits, options)\n\n    if (options === null) options = {}\n\n    // Simulate WebIDL type casting for NaN value in lastModified option.\n    const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified)\n    if (!Number.isNaN(lastModified)) {\n      this.#lastModified = lastModified\n    }\n\n    this.#name = String(fileName)\n  }\n\n  get name () {\n    return this.#name\n  }\n\n  get lastModified () {\n    return this.#lastModified\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'File'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return !!object && object instanceof Blob &&\n      /^(File)$/.test(object[Symbol.toStringTag])\n  }\n}\n\n/** @type {typeof globalThis.File} */// @ts-ignore\nexport const File = _File\nexport default File\n", "/*! formdata-polyfill. MIT License. Jimmy W\u00E4rting <https://jimmy.warting.se/opensource> */\n\nimport C from 'fetch-blob'\nimport F from 'fetch-blob/file.js'\n\nvar {toStringTag:t,iterator:i,hasInstance:h}=Symbol,\nr=Math.random,\nm='append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(','),\nf=(a,b,c)=>(a+='',/^(Blob|File)$/.test(b && b[t])?[(c=c!==void 0?c+'':b[t]=='File'?b.name:'blob',a),b.name!==c||b[t]=='blob'?new F([b],c,b):b]:[a,b+'']),\ne=(c,f)=>(f?c:c.replace(/\\r?\\n|\\r/g,'\\r\\n')).replace(/\\n/g,'%0A').replace(/\\r/g,'%0D').replace(/\"/g,'%22'),\nx=(n, a, e)=>{if(a.length<e){throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`)}}\n\nexport const File = F\n\n/** @type {typeof globalThis.FormData} */\nexport const FormData = class FormData {\n#d=[];\nconstructor(...a){if(a.length)throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`)}\nget [t]() {return 'FormData'}\n[i](){return this.entries()}\nstatic [h](o) {return o&&typeof o==='object'&&o[t]==='FormData'&&!m.some(m=>typeof o[m]!='function')}\nappend(...a){x('append',arguments,2);this.#d.push(f(...a))}\ndelete(a){x('delete',arguments,1);a+='';this.#d=this.#d.filter(([b])=>b!==a)}\nget(a){x('get',arguments,1);a+='';for(var b=this.#d,l=b.length,c=0;c<l;c++)if(b[c][0]===a)return b[c][1];return null}\ngetAll(a,b){x('getAll',arguments,1);b=[];a+='';this.#d.forEach(c=>c[0]===a&&b.push(c[1]));return b}\nhas(a){x('has',arguments,1);a+='';return this.#d.some(b=>b[0]===a)}\nforEach(a,b){x('forEach',arguments,1);for(var [c,d]of this)a.call(b,d,c,this)}\nset(...a){x('set',arguments,2);var b=[],c=!0;a=f(...a);this.#d.forEach(d=>{d[0]===a[0]?c&&(c=!b.push(a)):b.push(d)});c&&b.push(a);this.#d=b}\n*entries(){yield*this.#d}\n*keys(){for(var[a]of this)yield a}\n*values(){for(var[,a]of this)yield a}}\n\n/** @param {FormData} F */\nexport function formDataToBlob (F,B=C){\nvar b=`${r()}${r()}`.replace(/\\./g, '').slice(-28).padStart(32, '-'),c=[],p=`--${b}\\r\\nContent-Disposition: form-data; name=\"`\nF.forEach((v,n)=>typeof v=='string'\n?c.push(p+e(n)+`\"\\r\\n\\r\\n${v.replace(/\\r(?!\\n)|(?<!\\r)\\n/g, '\\r\\n')}\\r\\n`)\n:c.push(p+e(n)+`\"; filename=\"${e(v.name, 1)}\"\\r\\nContent-Type: ${v.type||\"application/octet-stream\"}\\r\\n\\r\\n`, v, '\\r\\n'))\nc.push(`--${b}--`)\nreturn new B(c,{type:\"multipart/form-data; boundary=\"+b})}\n", "export class FetchBaseError extends Error {\n\tconstructor(message, type) {\n\t\tsuper(message);\n\t\t// Hide custom error implementation details from end-users\n\t\tError.captureStackTrace(this, this.constructor);\n\n\t\tthis.type = type;\n\t}\n\n\tget name() {\n\t\treturn this.constructor.name;\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn this.constructor.name;\n\t}\n}\n", "\nimport {FetchBaseError} from './base.js';\n\n/**\n * @typedef {{ address?: string, code: string, dest?: string, errno: number, info?: object, message: string, path?: string, port?: number, syscall: string}} SystemError\n*/\n\n/**\n * FetchError interface for operational errors\n */\nexport class FetchError extends FetchBaseError {\n\t/**\n\t * @param  {string} message -      Error message for human\n\t * @param  {string} [type] -        Error type for machine\n\t * @param  {SystemError} [systemError] - For Node.js system error\n\t */\n\tconstructor(message, type, systemError) {\n\t\tsuper(message, type);\n\t\t// When err.type is `system`, err.erroredSysCall contains system error and err.code contains system error code\n\t\tif (systemError) {\n\t\t\t// eslint-disable-next-line no-multi-assign\n\t\t\tthis.code = this.errno = systemError.code;\n\t\t\tthis.erroredSysCall = systemError.syscall;\n\t\t}\n\t}\n}\n", "/**\n * Is.js\n *\n * Object type checks.\n */\n\nconst NAME = Symbol.toStringTag;\n\n/**\n * Check if `obj` is a URLSearchParams object\n * ref: https://github.com/node-fetch/node-fetch/issues/296#issuecomment-307598143\n * @param {*} object - Object to check for\n * @return {boolean}\n */\nexport const isURLSearchParameters = object => {\n\treturn (\n\t\ttypeof object === 'object' &&\n\t\ttypeof object.append === 'function' &&\n\t\ttypeof object.delete === 'function' &&\n\t\ttypeof object.get === 'function' &&\n\t\ttypeof object.getAll === 'function' &&\n\t\ttypeof object.has === 'function' &&\n\t\ttypeof object.set === 'function' &&\n\t\ttypeof object.sort === 'function' &&\n\t\tobject[NAME] === 'URLSearchParams'\n\t);\n};\n\n/**\n * Check if `object` is a W3C `Blob` object (which `File` inherits from)\n * @param {*} object - Object to check for\n * @return {boolean}\n */\nexport const isBlob = object => {\n\treturn (\n\t\tobject &&\n\t\ttypeof object === 'object' &&\n\t\ttypeof object.arrayBuffer === 'function' &&\n\t\ttypeof object.type === 'string' &&\n\t\ttypeof object.stream === 'function' &&\n\t\ttypeof object.constructor === 'function' &&\n\t\t/^(Blob|File)$/.test(object[NAME])\n\t);\n};\n\n/**\n * Check if `obj` is an instance of AbortSignal.\n * @param {*} object - Object to check for\n * @return {boolean}\n */\nexport const isAbortSignal = object => {\n\treturn (\n\t\ttypeof object === 'object' && (\n\t\t\tobject[NAME] === 'AbortSignal' ||\n\t\t\tobject[NAME] === 'EventTarget'\n\t\t)\n\t);\n};\n\n/**\n * isDomainOrSubdomain reports whether sub is a subdomain (or exact match) of\n * the parent domain.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */\nexport const isDomainOrSubdomain = (destination, original) => {\n\tconst orig = new URL(original).hostname;\n\tconst dest = new URL(destination).hostname;\n\n\treturn orig === dest || orig.endsWith(`.${dest}`);\n};\n\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */\nexport const isSameProtocol = (destination, original) => {\n\tconst orig = new URL(original).protocol;\n\tconst dest = new URL(destination).protocol;\n\n\treturn orig === dest;\n};\n", "/*! node-domexception. MIT License. Jimmy W\u00E4rting <https://jimmy.warting.se/opensource> */\n\nif (!globalThis.DOMException) {\n  try {\n    const { MessageChannel } = require('worker_threads'),\n    port = new MessageChannel().port1,\n    ab = new ArrayBuffer()\n    port.postMessage(ab, [ab, ab])\n  } catch (err) {\n    err.constructor.name === 'DOMException' && (\n      globalThis.DOMException = err.constructor\n    )\n  }\n}\n\nmodule.exports = globalThis.DOMException\n", "import { statSync, createReadStream, promises as fs } from 'node:fs'\nimport { basename } from 'node:path'\nimport DOMException from 'node-domexception'\n\nimport File from './file.js'\nimport Blob from './index.js'\n\nconst { stat } = fs\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst blobFromSync = (path, type) => fromBlob(statSync(path), path, type)\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */\nconst blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */\nconst fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst fileFromSync = (path, type) => fromFile(statSync(path), path, type)\n\n// @ts-ignore\nconst fromBlob = (stat, path, type = '') => new Blob([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], { type })\n\n// @ts-ignore\nconst fromFile = (stat, path, type = '') => new File([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], basename(path), { type, lastModified: stat.mtimeMs })\n\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */\nclass BlobDataItem {\n  #path\n  #start\n\n  constructor (options) {\n    this.#path = options.path\n    this.#start = options.start\n    this.size = options.size\n    this.lastModified = options.lastModified\n  }\n\n  /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */\n  slice (start, end) {\n    return new BlobDataItem({\n      path: this.#path,\n      lastModified: this.lastModified,\n      size: end - start,\n      start: this.#start + start\n    })\n  }\n\n  async * stream () {\n    const { mtimeMs } = await stat(this.#path)\n    if (mtimeMs > this.lastModified) {\n      throw new DOMException('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError')\n    }\n    yield * createReadStream(this.#path, {\n      start: this.#start,\n      end: this.#start + this.size - 1\n    })\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n}\n\nexport default blobFromSync\nexport { File, Blob, blobFrom, blobFromSync, fileFrom, fileFromSync }\n", "import {File} from 'fetch-blob/from.js';\nimport {FormData} from 'formdata-polyfill/esm.min.js';\n\nlet s = 0;\nconst S = {\n\tSTART_BOUNDARY: s++,\n\tHEADER_FIELD_START: s++,\n\tHEADER_FIELD: s++,\n\tHEADER_VALUE_START: s++,\n\tHEADER_VALUE: s++,\n\tHEADER_VALUE_ALMOST_DONE: s++,\n\tHEADERS_ALMOST_DONE: s++,\n\tPART_DATA_START: s++,\n\tPART_DATA: s++,\n\tEND: s++\n};\n\nlet f = 1;\nconst F = {\n\tPART_BOUNDARY: f,\n\tLAST_BOUNDARY: f *= 2\n};\n\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nconst lower = c => c | 0x20;\n\nconst noop = () => {};\n\nclass MultipartParser {\n\t/**\n\t * @param {string} boundary\n\t */\n\tconstructor(boundary) {\n\t\tthis.index = 0;\n\t\tthis.flags = 0;\n\n\t\tthis.onHeaderEnd = noop;\n\t\tthis.onHeaderField = noop;\n\t\tthis.onHeadersEnd = noop;\n\t\tthis.onHeaderValue = noop;\n\t\tthis.onPartBegin = noop;\n\t\tthis.onPartData = noop;\n\t\tthis.onPartEnd = noop;\n\n\t\tthis.boundaryChars = {};\n\n\t\tboundary = '\\r\\n--' + boundary;\n\t\tconst ui8a = new Uint8Array(boundary.length);\n\t\tfor (let i = 0; i < boundary.length; i++) {\n\t\t\tui8a[i] = boundary.charCodeAt(i);\n\t\t\tthis.boundaryChars[ui8a[i]] = true;\n\t\t}\n\n\t\tthis.boundary = ui8a;\n\t\tthis.lookbehind = new Uint8Array(this.boundary.length + 8);\n\t\tthis.state = S.START_BOUNDARY;\n\t}\n\n\t/**\n\t * @param {Uint8Array} data\n\t */\n\twrite(data) {\n\t\tlet i = 0;\n\t\tconst length_ = data.length;\n\t\tlet previousIndex = this.index;\n\t\tlet {lookbehind, boundary, boundaryChars, index, state, flags} = this;\n\t\tconst boundaryLength = this.boundary.length;\n\t\tconst boundaryEnd = boundaryLength - 1;\n\t\tconst bufferLength = data.length;\n\t\tlet c;\n\t\tlet cl;\n\n\t\tconst mark = name => {\n\t\t\tthis[name + 'Mark'] = i;\n\t\t};\n\n\t\tconst clear = name => {\n\t\t\tdelete this[name + 'Mark'];\n\t\t};\n\n\t\tconst callback = (callbackSymbol, start, end, ui8a) => {\n\t\t\tif (start === undefined || start !== end) {\n\t\t\t\tthis[callbackSymbol](ui8a && ui8a.subarray(start, end));\n\t\t\t}\n\t\t};\n\n\t\tconst dataCallback = (name, clear) => {\n\t\t\tconst markSymbol = name + 'Mark';\n\t\t\tif (!(markSymbol in this)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (clear) {\n\t\t\t\tcallback(name, this[markSymbol], i, data);\n\t\t\t\tdelete this[markSymbol];\n\t\t\t} else {\n\t\t\t\tcallback(name, this[markSymbol], data.length, data);\n\t\t\t\tthis[markSymbol] = 0;\n\t\t\t}\n\t\t};\n\n\t\tfor (i = 0; i < length_; i++) {\n\t\t\tc = data[i];\n\n\t\t\tswitch (state) {\n\t\t\t\tcase S.START_BOUNDARY:\n\t\t\t\t\tif (index === boundary.length - 2) {\n\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else if (c !== CR) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (index - 1 === boundary.length - 2) {\n\t\t\t\t\t\tif (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t} else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c !== boundary[index + 2]) {\n\t\t\t\t\t\tindex = -2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === boundary[index + 2]) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_FIELD_START:\n\t\t\t\t\tstate = S.HEADER_FIELD;\n\t\t\t\t\tmark('onHeaderField');\n\t\t\t\t\tindex = 0;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_FIELD:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tclear('onHeaderField');\n\t\t\t\t\t\tstate = S.HEADERS_ALMOST_DONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === COLON) {\n\t\t\t\t\t\tif (index === 1) {\n\t\t\t\t\t\t\t// empty header field\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdataCallback('onHeaderField', true);\n\t\t\t\t\t\tstate = S.HEADER_VALUE_START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcl = lower(c);\n\t\t\t\t\tif (cl < A || cl > Z) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_START:\n\t\t\t\t\tif (c === SPACE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tmark('onHeaderValue');\n\t\t\t\t\tstate = S.HEADER_VALUE;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_VALUE:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tdataCallback('onHeaderValue', true);\n\t\t\t\t\t\tcallback('onHeaderEnd');\n\t\t\t\t\t\tstate = S.HEADER_VALUE_ALMOST_DONE;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADERS_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback('onHeadersEnd');\n\t\t\t\t\tstate = S.PART_DATA_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.PART_DATA_START:\n\t\t\t\t\tstate = S.PART_DATA;\n\t\t\t\t\tmark('onPartData');\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.PART_DATA:\n\t\t\t\t\tpreviousIndex = index;\n\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t// boyer-moore derrived algorithm to safely skip non-boundary data\n\t\t\t\t\t\ti += boundaryEnd;\n\t\t\t\t\t\twhile (i < bufferLength && !(data[i] in boundaryChars)) {\n\t\t\t\t\t\t\ti += boundaryLength;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti -= boundaryEnd;\n\t\t\t\t\t\tc = data[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index < boundary.length) {\n\t\t\t\t\t\tif (boundary[index] === c) {\n\t\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\t\tdataCallback('onPartData', true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index === boundary.length) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\t\t// CR = part boundary\n\t\t\t\t\t\t\tflags |= F.PART_BOUNDARY;\n\t\t\t\t\t\t} else if (c === HYPHEN) {\n\t\t\t\t\t\t\t// HYPHEN = end boundary\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index - 1 === boundary.length) {\n\t\t\t\t\t\tif (flags & F.PART_BOUNDARY) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tif (c === LF) {\n\t\t\t\t\t\t\t\t// unset the PART_BOUNDARY flag\n\t\t\t\t\t\t\t\tflags &= ~F.PART_BOUNDARY;\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (flags & F.LAST_BOUNDARY) {\n\t\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\t// when matching a possible boundary, keep a lookbehind reference\n\t\t\t\t\t\t// in case it turns out to be a false lead\n\t\t\t\t\t\tlookbehind[index - 1] = c;\n\t\t\t\t\t} else if (previousIndex > 0) {\n\t\t\t\t\t\t// if our boundary turned out to be rubbish, the captured lookbehind\n\t\t\t\t\t\t// belongs to partData\n\t\t\t\t\t\tconst _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n\t\t\t\t\t\tcallback('onPartData', 0, previousIndex, _lookbehind);\n\t\t\t\t\t\tpreviousIndex = 0;\n\t\t\t\t\t\tmark('onPartData');\n\n\t\t\t\t\t\t// reconsider the current character even so it interrupted the sequence\n\t\t\t\t\t\t// it could be the beginning of a new sequence\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.END:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected state entered: ${state}`);\n\t\t\t}\n\t\t}\n\n\t\tdataCallback('onHeaderField');\n\t\tdataCallback('onHeaderValue');\n\t\tdataCallback('onPartData');\n\n\t\t// Update properties for the next call\n\t\tthis.index = index;\n\t\tthis.state = state;\n\t\tthis.flags = flags;\n\t}\n\n\tend() {\n\t\tif ((this.state === S.HEADER_FIELD_START && this.index === 0) ||\n\t\t\t(this.state === S.PART_DATA && this.index === this.boundary.length)) {\n\t\t\tthis.onPartEnd();\n\t\t} else if (this.state !== S.END) {\n\t\t\tthrow new Error('MultipartParser.end(): stream ended unexpectedly');\n\t\t}\n\t}\n}\n\nfunction _fileName(headerValue) {\n\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\tconst m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n\tif (!m) {\n\t\treturn;\n\t}\n\n\tconst match = m[2] || m[3] || '';\n\tlet filename = match.slice(match.lastIndexOf('\\\\') + 1);\n\tfilename = filename.replace(/%22/g, '\"');\n\tfilename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n\t\treturn String.fromCharCode(code);\n\t});\n\treturn filename;\n}\n\nexport async function toFormData(Body, ct) {\n\tif (!/multipart/i.test(ct)) {\n\t\tthrow new TypeError('Failed to fetch');\n\t}\n\n\tconst m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n\tif (!m) {\n\t\tthrow new TypeError('no or bad content-type header, no multipart boundary');\n\t}\n\n\tconst parser = new MultipartParser(m[1] || m[2]);\n\n\tlet headerField;\n\tlet headerValue;\n\tlet entryValue;\n\tlet entryName;\n\tlet contentType;\n\tlet filename;\n\tconst entryChunks = [];\n\tconst formData = new FormData();\n\n\tconst onPartData = ui8a => {\n\t\tentryValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tconst appendToFile = ui8a => {\n\t\tentryChunks.push(ui8a);\n\t};\n\n\tconst appendFileToFormData = () => {\n\t\tconst file = new File(entryChunks, filename, {type: contentType});\n\t\tformData.append(entryName, file);\n\t};\n\n\tconst appendEntryToFormData = () => {\n\t\tformData.append(entryName, entryValue);\n\t};\n\n\tconst decoder = new TextDecoder('utf-8');\n\tdecoder.decode();\n\n\tparser.onPartBegin = function () {\n\t\tparser.onPartData = onPartData;\n\t\tparser.onPartEnd = appendEntryToFormData;\n\n\t\theaderField = '';\n\t\theaderValue = '';\n\t\tentryValue = '';\n\t\tentryName = '';\n\t\tcontentType = '';\n\t\tfilename = null;\n\t\tentryChunks.length = 0;\n\t};\n\n\tparser.onHeaderField = function (ui8a) {\n\t\theaderField += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderValue = function (ui8a) {\n\t\theaderValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderEnd = function () {\n\t\theaderValue += decoder.decode();\n\t\theaderField = headerField.toLowerCase();\n\n\t\tif (headerField === 'content-disposition') {\n\t\t\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\t\t\tconst m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n\n\t\t\tif (m) {\n\t\t\t\tentryName = m[2] || m[3] || '';\n\t\t\t}\n\n\t\t\tfilename = _fileName(headerValue);\n\n\t\t\tif (filename) {\n\t\t\t\tparser.onPartData = appendToFile;\n\t\t\t\tparser.onPartEnd = appendFileToFormData;\n\t\t\t}\n\t\t} else if (headerField === 'content-type') {\n\t\t\tcontentType = headerValue;\n\t\t}\n\n\t\theaderValue = '';\n\t\theaderField = '';\n\t};\n\n\tfor await (const chunk of Body) {\n\t\tparser.write(chunk);\n\t}\n\n\tparser.end();\n\n\treturn formData;\n}\n", "\n/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\n\nimport Stream, {PassThrough} from 'node:stream';\nimport {types, deprecate, promisify} from 'node:util';\nimport {Buffer} from 'node:buffer';\n\nimport Blob from 'fetch-blob';\nimport {FormData, formDataToBlob} from 'formdata-polyfill/esm.min.js';\n\nimport {FetchError} from './errors/fetch-error.js';\nimport {FetchBaseError} from './errors/base.js';\nimport {isBlob, isURLSearchParameters} from './utils/is.js';\n\nconst pipeline = promisify(Stream.pipeline);\nconst INTERNALS = Symbol('Body internals');\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Body {\n\tconstructor(body, {\n\t\tsize = 0\n\t} = {}) {\n\t\tlet boundary = null;\n\n\t\tif (body === null) {\n\t\t\t// Body is undefined or null\n\t\t\tbody = null;\n\t\t} else if (isURLSearchParameters(body)) {\n\t\t\t// Body is a URLSearchParams\n\t\t\tbody = Buffer.from(body.toString());\n\t\t} else if (isBlob(body)) {\n\t\t\t// Body is blob\n\t\t} else if (Buffer.isBuffer(body)) {\n\t\t\t// Body is Buffer\n\t\t} else if (types.isAnyArrayBuffer(body)) {\n\t\t\t// Body is ArrayBuffer\n\t\t\tbody = Buffer.from(body);\n\t\t} else if (ArrayBuffer.isView(body)) {\n\t\t\t// Body is ArrayBufferView\n\t\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t\t} else if (body instanceof Stream) {\n\t\t\t// Body is stream\n\t\t} else if (body instanceof FormData) {\n\t\t\t// Body is FormData\n\t\t\tbody = formDataToBlob(body);\n\t\t\tboundary = body.type.split('=')[1];\n\t\t} else {\n\t\t\t// None of the above\n\t\t\t// coerce to string then buffer\n\t\t\tbody = Buffer.from(String(body));\n\t\t}\n\n\t\tlet stream = body;\n\n\t\tif (Buffer.isBuffer(body)) {\n\t\t\tstream = Stream.Readable.from(body);\n\t\t} else if (isBlob(body)) {\n\t\t\tstream = Stream.Readable.from(body.stream());\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\tbody,\n\t\t\tstream,\n\t\t\tboundary,\n\t\t\tdisturbed: false,\n\t\t\terror: null\n\t\t};\n\t\tthis.size = size;\n\n\t\tif (body instanceof Stream) {\n\t\t\tbody.on('error', error_ => {\n\t\t\t\tconst error = error_ instanceof FetchBaseError ?\n\t\t\t\t\terror_ :\n\t\t\t\t\tnew FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n\t\t\t\tthis[INTERNALS].error = error;\n\t\t\t});\n\t\t}\n\t}\n\n\tget body() {\n\t\treturn this[INTERNALS].stream;\n\t}\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t}\n\n\t/**\n\t * Decode response as ArrayBuffer\n\t *\n\t * @return  Promise\n\t */\n\tasync arrayBuffer() {\n\t\tconst {buffer, byteOffset, byteLength} = await consumeBody(this);\n\t\treturn buffer.slice(byteOffset, byteOffset + byteLength);\n\t}\n\n\tasync formData() {\n\t\tconst ct = this.headers.get('content-type');\n\n\t\tif (ct.startsWith('application/x-www-form-urlencoded')) {\n\t\t\tconst formData = new FormData();\n\t\t\tconst parameters = new URLSearchParams(await this.text());\n\n\t\t\tfor (const [name, value] of parameters) {\n\t\t\t\tformData.append(name, value);\n\t\t\t}\n\n\t\t\treturn formData;\n\t\t}\n\n\t\tconst {toFormData} = await import('./utils/multipart-parser.js');\n\t\treturn toFormData(this.body, ct);\n\t}\n\n\t/**\n\t * Return raw response as Blob\n\t *\n\t * @return Promise\n\t */\n\tasync blob() {\n\t\tconst ct = (this.headers && this.headers.get('content-type')) || (this[INTERNALS].body && this[INTERNALS].body.type) || '';\n\t\tconst buf = await this.arrayBuffer();\n\n\t\treturn new Blob([buf], {\n\t\t\ttype: ct\n\t\t});\n\t}\n\n\t/**\n\t * Decode response as json\n\t *\n\t * @return  Promise\n\t */\n\tasync json() {\n\t\tconst text = await this.text();\n\t\treturn JSON.parse(text);\n\t}\n\n\t/**\n\t * Decode response as text\n\t *\n\t * @return  Promise\n\t */\n\tasync text() {\n\t\tconst buffer = await consumeBody(this);\n\t\treturn new TextDecoder().decode(buffer);\n\t}\n\n\t/**\n\t * Decode response as buffer (non-spec api)\n\t *\n\t * @return  Promise\n\t */\n\tbuffer() {\n\t\treturn consumeBody(this);\n\t}\n}\n\nBody.prototype.buffer = deprecate(Body.prototype.buffer, 'Please use \\'response.arrayBuffer()\\' instead of \\'response.buffer()\\'', 'node-fetch#buffer');\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: {enumerable: true},\n\tbodyUsed: {enumerable: true},\n\tarrayBuffer: {enumerable: true},\n\tblob: {enumerable: true},\n\tjson: {enumerable: true},\n\ttext: {enumerable: true},\n\tdata: {get: deprecate(() => {},\n\t\t'data doesn\\'t exist, use json(), text(), arrayBuffer(), or body instead',\n\t\t'https://github.com/node-fetch/node-fetch/issues/1000 (response)')}\n});\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\nasync function consumeBody(data) {\n\tif (data[INTERNALS].disturbed) {\n\t\tthrow new TypeError(`body used already for: ${data.url}`);\n\t}\n\n\tdata[INTERNALS].disturbed = true;\n\n\tif (data[INTERNALS].error) {\n\t\tthrow data[INTERNALS].error;\n\t}\n\n\tconst {body} = data;\n\n\t// Body is null\n\tif (body === null) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t/* c8 ignore next 3 */\n\tif (!(body instanceof Stream)) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t// Body is stream\n\t// get ready to actually consume the body\n\tconst accum = [];\n\tlet accumBytes = 0;\n\n\ttry {\n\t\tfor await (const chunk of body) {\n\t\t\tif (data.size > 0 && accumBytes + chunk.length > data.size) {\n\t\t\t\tconst error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n\t\t\t\tbody.destroy(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t}\n\t} catch (error) {\n\t\tconst error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n\t\tthrow error_;\n\t}\n\n\tif (body.readableEnded === true || body._readableState.ended === true) {\n\t\ttry {\n\t\t\tif (accum.every(c => typeof c === 'string')) {\n\t\t\t\treturn Buffer.from(accum.join(''));\n\t\t\t}\n\n\t\t\treturn Buffer.concat(accum, accumBytes);\n\t\t} catch (error) {\n\t\t\tthrow new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n\t\t}\n\t} else {\n\t\tthrow new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n\t}\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\nexport const clone = (instance, highWaterMark) => {\n\tlet p1;\n\tlet p2;\n\tlet {body} = instance[INTERNALS];\n\n\t// Don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// Check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif ((body instanceof Stream) && (typeof body.getBoundary !== 'function')) {\n\t\t// Tee instance body\n\t\tp1 = new PassThrough({highWaterMark});\n\t\tp2 = new PassThrough({highWaterMark});\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// Set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].stream = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n};\n\nconst getNonSpecFormDataBoundary = deprecate(\n\tbody => body.getBoundary(),\n\t'form-data doesn\\'t follow the spec and requires special treatment. Use alternative package',\n\t'https://github.com/node-fetch/node-fetch/issues/1167'\n);\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\nexport const extractContentType = (body, request) => {\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn null;\n\t}\n\n\t// Body is string\n\tif (typeof body === 'string') {\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n\n\t// Body is a URLSearchParams\n\tif (isURLSearchParameters(body)) {\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t}\n\n\t// Body is blob\n\tif (isBlob(body)) {\n\t\treturn body.type || null;\n\t}\n\n\t// Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\tif (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n\t\treturn null;\n\t}\n\n\tif (body instanceof FormData) {\n\t\treturn `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getBoundary === 'function') {\n\t\treturn `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n\t}\n\n\t// Body is stream - can't really do much about this\n\tif (body instanceof Stream) {\n\t\treturn null;\n\t}\n\n\t// Body constructor defaults other things to string\n\treturn 'text/plain;charset=UTF-8';\n};\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\nexport const getTotalBytes = request => {\n\tconst {body} = request[INTERNALS];\n\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn 0;\n\t}\n\n\t// Body is Blob\n\tif (isBlob(body)) {\n\t\treturn body.size;\n\t}\n\n\t// Body is Buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn body.length;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getLengthSync === 'function') {\n\t\treturn body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n\t}\n\n\t// Body is stream\n\treturn null;\n};\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {Promise<void>}\n */\nexport const writeToStream = async (dest, {body}) => {\n\tif (body === null) {\n\t\t// Body is null\n\t\tdest.end();\n\t} else {\n\t\t// Body is stream\n\t\tawait pipeline(body, dest);\n\t}\n};\n", "/**\n * Headers.js\n *\n * Headers class offers convenient helpers\n */\n\nimport {types} from 'node:util';\nimport http from 'node:http';\n\n/* c8 ignore next 9 */\nconst validateHeaderName = typeof http.validateHeaderName === 'function' ?\n\thttp.validateHeaderName :\n\tname => {\n\t\tif (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(name)) {\n\t\t\tconst error = new TypeError(`Header name must be a valid HTTP token [${name}]`);\n\t\t\tObject.defineProperty(error, 'code', {value: 'ERR_INVALID_HTTP_TOKEN'});\n\t\t\tthrow error;\n\t\t}\n\t};\n\n/* c8 ignore next 9 */\nconst validateHeaderValue = typeof http.validateHeaderValue === 'function' ?\n\thttp.validateHeaderValue :\n\t(name, value) => {\n\t\tif (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(value)) {\n\t\t\tconst error = new TypeError(`Invalid character in header content [\"${name}\"]`);\n\t\t\tObject.defineProperty(error, 'code', {value: 'ERR_INVALID_CHAR'});\n\t\t\tthrow error;\n\t\t}\n\t};\n\n/**\n * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit\n */\n\n/**\n * This Fetch API interface allows you to perform various actions on HTTP request and response headers.\n * These actions include retrieving, setting, adding to, and removing.\n * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.\n * You can add to this using methods like append() (see Examples.)\n * In all methods of this interface, header names are matched by case-insensitive byte sequence.\n *\n */\nexport default class Headers extends URLSearchParams {\n\t/**\n\t * Headers class\n\t *\n\t * @constructor\n\t * @param {HeadersInit} [init] - Response headers\n\t */\n\tconstructor(init) {\n\t\t// Validate and normalize init object in [name, value(s)][]\n\t\t/** @type {string[][]} */\n\t\tlet result = [];\n\t\tif (init instanceof Headers) {\n\t\t\tconst raw = init.raw();\n\t\t\tfor (const [name, values] of Object.entries(raw)) {\n\t\t\t\tresult.push(...values.map(value => [name, value]));\n\t\t\t}\n\t\t} else if (init == null) { // eslint-disable-line no-eq-null, eqeqeq\n\t\t\t// No op\n\t\t} else if (typeof init === 'object' && !types.isBoxedPrimitive(init)) {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\t\tif (method == null) {\n\t\t\t\t// Record<ByteString, ByteString>\n\t\t\t\tresult.push(...Object.entries(init));\n\t\t\t} else {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// Sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tresult = [...init]\n\t\t\t\t\t.map(pair => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttypeof pair !== 'object' || types.isBoxedPrimitive(pair)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new TypeError('Each header pair must be an iterable object');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [...pair];\n\t\t\t\t\t}).map(pair => {\n\t\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [...pair];\n\t\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Failed to construct \\'Headers\\': The provided value is not of type \\'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');\n\t\t}\n\n\t\t// Validate and lowercase\n\t\tresult =\n\t\t\tresult.length > 0 ?\n\t\t\t\tresult.map(([name, value]) => {\n\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\treturn [String(name).toLowerCase(), String(value)];\n\t\t\t\t}) :\n\t\t\t\tundefined;\n\n\t\tsuper(result);\n\n\t\t// Returning a Proxy that will lowercase key names, validate parameters and sort keys\n\t\t// eslint-disable-next-line no-constructor-return\n\t\treturn new Proxy(this, {\n\t\t\tget(target, p, receiver) {\n\t\t\t\tswitch (p) {\n\t\t\t\t\tcase 'append':\n\t\t\t\t\tcase 'set':\n\t\t\t\t\t\treturn (name, value) => {\n\t\t\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\t\t\treturn URLSearchParams.prototype[p].call(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tString(name).toLowerCase(),\n\t\t\t\t\t\t\t\tString(value)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\n\t\t\t\t\tcase 'delete':\n\t\t\t\t\tcase 'has':\n\t\t\t\t\tcase 'getAll':\n\t\t\t\t\t\treturn name => {\n\t\t\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\t\t\treturn URLSearchParams.prototype[p].call(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tString(name).toLowerCase()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\n\t\t\t\t\tcase 'keys':\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\ttarget.sort();\n\t\t\t\t\t\t\treturn new Set(URLSearchParams.prototype.keys.call(target)).keys();\n\t\t\t\t\t\t};\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn Reflect.get(target, p, receiver);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t/* c8 ignore next */\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn this.constructor.name;\n\t}\n\n\ttoString() {\n\t\treturn Object.prototype.toString.call(this);\n\t}\n\n\tget(name) {\n\t\tconst values = this.getAll(name);\n\t\tif (values.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet value = values.join(', ');\n\t\tif (/^content-encoding$/i.test(name)) {\n\t\t\tvalue = value.toLowerCase();\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tforEach(callback, thisArg = undefined) {\n\t\tfor (const name of this.keys()) {\n\t\t\tReflect.apply(callback, thisArg, [this.get(name), name, this]);\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const name of this.keys()) {\n\t\t\tyield this.get(name);\n\t\t}\n\t}\n\n\t/**\n\t * @type {() => IterableIterator<[string, string]>}\n\t */\n\t* entries() {\n\t\tfor (const name of this.keys()) {\n\t\t\tyield [name, this.get(name)];\n\t\t}\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this.entries();\n\t}\n\n\t/**\n\t * Node-fetch non-spec method\n\t * returning all headers and their values as array\n\t * @returns {Record<string, string[]>}\n\t */\n\traw() {\n\t\treturn [...this.keys()].reduce((result, key) => {\n\t\t\tresult[key] = this.getAll(key);\n\t\t\treturn result;\n\t\t}, {});\n\t}\n\n\t/**\n\t * For better console.log(headers) and also to convert Headers into Node.js Request compatible format\n\t */\n\t[Symbol.for('nodejs.util.inspect.custom')]() {\n\t\treturn [...this.keys()].reduce((result, key) => {\n\t\t\tconst values = this.getAll(key);\n\t\t\t// Http.request() only supports string as Host header.\n\t\t\t// This hack makes specifying custom Host header possible.\n\t\t\tif (key === 'host') {\n\t\t\t\tresult[key] = values[0];\n\t\t\t} else {\n\t\t\t\tresult[key] = values.length > 1 ? values : values[0];\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}, {});\n\t}\n}\n\n/**\n * Re-shaping object for Web IDL tests\n * Only need to do it for overridden methods\n */\nObject.defineProperties(\n\tHeaders.prototype,\n\t['get', 'entries', 'forEach', 'values'].reduce((result, property) => {\n\t\tresult[property] = {enumerable: true};\n\t\treturn result;\n\t}, {})\n);\n\n/**\n * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do\n * not conform to HTTP grammar productions.\n * @param {import('http').IncomingMessage['rawHeaders']} headers\n */\nexport function fromRawHeaders(headers = []) {\n\treturn new Headers(\n\t\theaders\n\t\t\t// Split into pairs\n\t\t\t.reduce((result, value, index, array) => {\n\t\t\t\tif (index % 2 === 0) {\n\t\t\t\t\tresult.push(array.slice(index, index + 2));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, [])\n\t\t\t.filter(([name, value]) => {\n\t\t\t\ttry {\n\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\treturn true;\n\t\t\t\t} catch {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t})\n\n\t);\n}\n", "const redirectStatus = new Set([301, 302, 303, 307, 308]);\n\n/**\n * Redirect code matching\n *\n * @param {number} code - Status code\n * @return {boolean}\n */\nexport const isRedirect = code => {\n\treturn redirectStatus.has(code);\n};\n", "/**\n * Response.js\n *\n * Response class provides content decoding\n */\n\nimport Headers from './headers.js';\nimport Body, {clone, extractContentType} from './body.js';\nimport {isRedirect} from './utils/is-redirect.js';\n\nconst INTERNALS = Symbol('Response internals');\n\n/**\n * Response class\n *\n * Ref: https://fetch.spec.whatwg.org/#response-class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Response extends Body {\n\tconstructor(body = null, options = {}) {\n\t\tsuper(body, options);\n\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition\n\t\tconst status = options.status != null ? options.status : 200;\n\n\t\tconst headers = new Headers(options.headers);\n\n\t\tif (body !== null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body, this);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\ttype: 'default',\n\t\t\turl: options.url,\n\t\t\tstatus,\n\t\t\tstatusText: options.statusText || '',\n\t\t\theaders,\n\t\t\tcounter: options.counter,\n\t\t\thighWaterMark: options.highWaterMark\n\t\t};\n\t}\n\n\tget type() {\n\t\treturn this[INTERNALS].type;\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS].status;\n\t}\n\n\t/**\n\t * Convenience property representing if the request ended normally\n\t */\n\tget ok() {\n\t\treturn this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS].headers;\n\t}\n\n\tget highWaterMark() {\n\t\treturn this[INTERNALS].highWaterMark;\n\t}\n\n\t/**\n\t * Clone this response\n\t *\n\t * @return  Response\n\t */\n\tclone() {\n\t\treturn new Response(clone(this, this.highWaterMark), {\n\t\t\ttype: this.type,\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected,\n\t\t\tsize: this.size,\n\t\t\thighWaterMark: this.highWaterMark\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} url    The URL that the new response is to originate from.\n\t * @param {number} status An optional status code for the response (e.g., 302.)\n\t * @returns {Response}    A Response object.\n\t */\n\tstatic redirect(url, status = 302) {\n\t\tif (!isRedirect(status)) {\n\t\t\tthrow new RangeError('Failed to execute \"redirect\" on \"response\": Invalid status code');\n\t\t}\n\n\t\treturn new Response(null, {\n\t\t\theaders: {\n\t\t\t\tlocation: new URL(url).toString()\n\t\t\t},\n\t\t\tstatus\n\t\t});\n\t}\n\n\tstatic error() {\n\t\tconst response = new Response(null, {status: 0, statusText: ''});\n\t\tresponse[INTERNALS].type = 'error';\n\t\treturn response;\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn 'Response';\n\t}\n}\n\nObject.defineProperties(Response.prototype, {\n\ttype: {enumerable: true},\n\turl: {enumerable: true},\n\tstatus: {enumerable: true},\n\tok: {enumerable: true},\n\tredirected: {enumerable: true},\n\tstatusText: {enumerable: true},\n\theaders: {enumerable: true},\n\tclone: {enumerable: true}\n});\n", "export const getSearch = parsedURL => {\n\tif (parsedURL.search) {\n\t\treturn parsedURL.search;\n\t}\n\n\tconst lastOffset = parsedURL.href.length - 1;\n\tconst hash = parsedURL.hash || (parsedURL.href[lastOffset] === '#' ? '#' : '');\n\treturn parsedURL.href[lastOffset - hash.length] === '?' ? '?' : '';\n};\n", "import {isIP} from 'node:net';\n\n/**\n * @external URL\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}\n */\n\n/**\n * @module utils/referrer\n * @private\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy \u00A78.4. Strip url for use as a referrer}\n * @param {string} URL\n * @param {boolean} [originOnly=false]\n */\nexport function stripURLForUseAsAReferrer(url, originOnly = false) {\n\t// 1. If url is null, return no referrer.\n\tif (url == null) { // eslint-disable-line no-eq-null, eqeqeq\n\t\treturn 'no-referrer';\n\t}\n\n\turl = new URL(url);\n\n\t// 2. If url's scheme is a local scheme, then return no referrer.\n\tif (/^(about|blob|data):$/.test(url.protocol)) {\n\t\treturn 'no-referrer';\n\t}\n\n\t// 3. Set url's username to the empty string.\n\turl.username = '';\n\n\t// 4. Set url's password to null.\n\t// Note: `null` appears to be a mistake as this actually results in the password being `\"null\"`.\n\turl.password = '';\n\n\t// 5. Set url's fragment to null.\n\t// Note: `null` appears to be a mistake as this actually results in the fragment being `\"#null\"`.\n\turl.hash = '';\n\n\t// 6. If the origin-only flag is true, then:\n\tif (originOnly) {\n\t\t// 6.1. Set url's path to null.\n\t\t// Note: `null` appears to be a mistake as this actually results in the path being `\"/null\"`.\n\t\turl.pathname = '';\n\n\t\t// 6.2. Set url's query to null.\n\t\t// Note: `null` appears to be a mistake as this actually results in the query being `\"?null\"`.\n\t\turl.search = '';\n\t}\n\n\t// 7. Return url.\n\treturn url;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}\n */\nexport const ReferrerPolicy = new Set([\n\t'',\n\t'no-referrer',\n\t'no-referrer-when-downgrade',\n\t'same-origin',\n\t'origin',\n\t'strict-origin',\n\t'origin-when-cross-origin',\n\t'strict-origin-when-cross-origin',\n\t'unsafe-url'\n]);\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}\n */\nexport const DEFAULT_REFERRER_POLICY = 'strict-origin-when-cross-origin';\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy \u00A73. Referrer Policies}\n * @param {string} referrerPolicy\n * @returns {string} referrerPolicy\n */\nexport function validateReferrerPolicy(referrerPolicy) {\n\tif (!ReferrerPolicy.has(referrerPolicy)) {\n\t\tthrow new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);\n\t}\n\n\treturn referrerPolicy;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy \u00A73.2. Is origin potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\nexport function isOriginPotentiallyTrustworthy(url) {\n\t// 1. If origin is an opaque origin, return \"Not Trustworthy\".\n\t// Not applicable\n\n\t// 2. Assert: origin is a tuple origin.\n\t// Not for implementations\n\n\t// 3. If origin's scheme is either \"https\" or \"wss\", return \"Potentially Trustworthy\".\n\tif (/^(http|ws)s:$/.test(url.protocol)) {\n\t\treturn true;\n\t}\n\n\t// 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return \"Potentially Trustworthy\".\n\tconst hostIp = url.host.replace(/(^\\[)|(]$)/g, '');\n\tconst hostIPVersion = isIP(hostIp);\n\n\tif (hostIPVersion === 4 && /^127\\./.test(hostIp)) {\n\t\treturn true;\n\t}\n\n\tif (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {\n\t\treturn true;\n\t}\n\n\t// 5. If origin's host component is \"localhost\" or falls within \".localhost\", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return \"Potentially Trustworthy\".\n\t// We are returning FALSE here because we cannot ensure conformance to\n\t// let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)\n\tif (url.host === 'localhost' || url.host.endsWith('.localhost')) {\n\t\treturn false;\n\t}\n\n\t// 6. If origin's scheme component is file, return \"Potentially Trustworthy\".\n\tif (url.protocol === 'file:') {\n\t\treturn true;\n\t}\n\n\t// 7. If origin's scheme component is one which the user agent considers to be authenticated, return \"Potentially Trustworthy\".\n\t// Not supported\n\n\t// 8. If origin has been configured as a trustworthy origin, return \"Potentially Trustworthy\".\n\t// Not supported\n\n\t// 9. Return \"Not Trustworthy\".\n\treturn false;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy \u00A73.3. Is url potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\nexport function isUrlPotentiallyTrustworthy(url) {\n\t// 1. If url is \"about:blank\" or \"about:srcdoc\", return \"Potentially Trustworthy\".\n\tif (/^about:(blank|srcdoc)$/.test(url)) {\n\t\treturn true;\n\t}\n\n\t// 2. If url's scheme is \"data\", return \"Potentially Trustworthy\".\n\tif (url.protocol === 'data:') {\n\t\treturn true;\n\t}\n\n\t// Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were\n\t// created. Therefore, blobs created in a trustworthy origin will themselves be potentially\n\t// trustworthy.\n\tif (/^(blob|filesystem):$/.test(url.protocol)) {\n\t\treturn true;\n\t}\n\n\t// 3. Return the result of executing \u00A73.2 Is origin potentially trustworthy? on url's origin.\n\treturn isOriginPotentiallyTrustworthy(url);\n}\n\n/**\n * Modifies the referrerURL to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy \u00A78.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerURLCallback\n * @param {external:URL} referrerURL\n * @returns {external:URL} modified referrerURL\n */\n\n/**\n * Modifies the referrerOrigin to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy \u00A78.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerOriginCallback\n * @param {external:URL} referrerOrigin\n * @returns {external:URL} modified referrerOrigin\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy \u00A78.3. Determine request's Referrer}\n * @param {Request} request\n * @param {object} o\n * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback\n * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback\n * @returns {external:URL} Request's referrer\n */\nexport function determineRequestsReferrer(request, {referrerURLCallback, referrerOriginCallback} = {}) {\n\t// There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for\n\t// these cases:\n\t// > Note: If request's referrer is \"no-referrer\", Fetch will not call into this algorithm.\n\t// > Note: If request's referrer policy is the empty string, Fetch will not call into this\n\t// > algorithm.\n\tif (request.referrer === 'no-referrer' || request.referrerPolicy === '') {\n\t\treturn null;\n\t}\n\n\t// 1. Let policy be request's associated referrer policy.\n\tconst policy = request.referrerPolicy;\n\n\t// 2. Let environment be request's client.\n\t// not applicable to node.js\n\n\t// 3. Switch on request's referrer:\n\tif (request.referrer === 'about:client') {\n\t\treturn 'no-referrer';\n\t}\n\n\t// \"a URL\": Let referrerSource be request's referrer.\n\tconst referrerSource = request.referrer;\n\n\t// 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.\n\tlet referrerURL = stripURLForUseAsAReferrer(referrerSource);\n\n\t// 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the\n\t//    origin-only flag set to true.\n\tlet referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);\n\n\t// 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set\n\t//    referrerURL to referrerOrigin.\n\tif (referrerURL.toString().length > 4096) {\n\t\treferrerURL = referrerOrigin;\n\t}\n\n\t// 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary\n\t//    policy considerations in the interests of minimizing data leakage. For example, the user\n\t//    agent could strip the URL down to an origin, modify its host, replace it with an empty\n\t//    string, etc.\n\tif (referrerURLCallback) {\n\t\treferrerURL = referrerURLCallback(referrerURL);\n\t}\n\n\tif (referrerOriginCallback) {\n\t\treferrerOrigin = referrerOriginCallback(referrerOrigin);\n\t}\n\n\t// 8.Execute the statements corresponding to the value of policy:\n\tconst currentURL = new URL(request.url);\n\n\tswitch (policy) {\n\t\tcase 'no-referrer':\n\t\t\treturn 'no-referrer';\n\n\t\tcase 'origin':\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'unsafe-url':\n\t\t\treturn referrerURL;\n\n\t\tcase 'strict-origin':\n\t\t\t// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 2. Return referrerOrigin.\n\t\t\treturn referrerOrigin.toString();\n\n\t\tcase 'strict-origin-when-cross-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 3. Return referrerOrigin.\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'same-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// 2. Return no referrer.\n\t\t\treturn 'no-referrer';\n\n\t\tcase 'origin-when-cross-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// Return referrerOrigin.\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'no-referrer-when-downgrade':\n\t\t\t// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 2. Return referrerURL.\n\t\t\treturn referrerURL;\n\n\t\tdefault:\n\t\t\tthrow new TypeError(`Invalid referrerPolicy: ${policy}`);\n\t}\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy \u00A78.1. Parse a referrer policy from a Referrer-Policy header}\n * @param {Headers} headers Response headers\n * @returns {string} policy\n */\nexport function parseReferrerPolicyFromHeader(headers) {\n\t// 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`\n\t//    and response\u2019s header list.\n\tconst policyTokens = (headers.get('referrer-policy') || '').split(/[,\\s]+/);\n\n\t// 2. Let policy be the empty string.\n\tlet policy = '';\n\n\t// 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty\n\t//    string, then set policy to token.\n\t// Note: This algorithm loops over multiple policy values to allow deployment of new policy\n\t// values with fallbacks for older user agents, as described in \u00A7 11.1 Unknown Policy Values.\n\tfor (const token of policyTokens) {\n\t\tif (token && ReferrerPolicy.has(token)) {\n\t\t\tpolicy = token;\n\t\t}\n\t}\n\n\t// 4. Return policy.\n\treturn policy;\n}\n", "/**\n * Request.js\n *\n * Request class contains server only options\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */\n\nimport {format as formatUrl} from 'node:url';\nimport {deprecate} from 'node:util';\nimport Headers from './headers.js';\nimport Body, {clone, extractContentType, getTotalBytes} from './body.js';\nimport {isAbortSignal} from './utils/is.js';\nimport {getSearch} from './utils/get-search.js';\nimport {\n\tvalidateReferrerPolicy, determineRequestsReferrer, DEFAULT_REFERRER_POLICY\n} from './utils/referrer.js';\n\nconst INTERNALS = Symbol('Request internals');\n\n/**\n * Check if `obj` is an instance of Request.\n *\n * @param  {*} object\n * @return {boolean}\n */\nconst isRequest = object => {\n\treturn (\n\t\ttypeof object === 'object' &&\n\t\ttypeof object[INTERNALS] === 'object'\n\t);\n};\n\nconst doBadDataWarn = deprecate(() => {},\n\t'.data is not a valid RequestInit property, use .body instead',\n\t'https://github.com/node-fetch/node-fetch/issues/1000 (request)');\n\n/**\n * Request class\n *\n * Ref: https://fetch.spec.whatwg.org/#request-class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nexport default class Request extends Body {\n\tconstructor(input, init = {}) {\n\t\tlet parsedURL;\n\n\t\t// Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)\n\t\tif (isRequest(input)) {\n\t\t\tparsedURL = new URL(input.url);\n\t\t} else {\n\t\t\tparsedURL = new URL(input);\n\t\t\tinput = {};\n\t\t}\n\n\t\tif (parsedURL.username !== '' || parsedURL.password !== '') {\n\t\t\tthrow new TypeError(`${parsedURL} is an url with embedded credentials.`);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tif (/^(delete|get|head|options|post|put)$/i.test(method)) {\n\t\t\tmethod = method.toUpperCase();\n\t\t}\n\n\t\tif (!isRequest(init) && 'data' in init) {\n\t\t\tdoBadDataWarn();\n\t\t}\n\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\tif ((init.body != null || (isRequest(input) && input.body !== null)) &&\n\t\t\t(method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tconst inputBody = init.body ?\n\t\t\tinit.body :\n\t\t\t(isRequest(input) && input.body !== null ?\n\t\t\t\tclone(input) :\n\t\t\t\tnull);\n\n\t\tsuper(inputBody, {\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody !== null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody, this);\n\t\t\tif (contentType) {\n\t\t\t\theaders.set('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ?\n\t\t\tinput.signal :\n\t\t\tnull;\n\t\tif ('signal' in init) {\n\t\t\tsignal = init.signal;\n\t\t}\n\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal or EventTarget');\n\t\t}\n\n\t\t// \u00A75.4, Request constructor steps, step 15.1\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\tlet referrer = init.referrer == null ? input.referrer : init.referrer;\n\t\tif (referrer === '') {\n\t\t\t// \u00A75.4, Request constructor steps, step 15.2\n\t\t\treferrer = 'no-referrer';\n\t\t} else if (referrer) {\n\t\t\t// \u00A75.4, Request constructor steps, step 15.3.1, 15.3.2\n\t\t\tconst parsedReferrer = new URL(referrer);\n\t\t\t// \u00A75.4, Request constructor steps, step 15.3.3, 15.3.4\n\t\t\treferrer = /^about:(\\/\\/)?client$/.test(parsedReferrer) ? 'client' : parsedReferrer;\n\t\t} else {\n\t\t\treferrer = undefined;\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal,\n\t\t\treferrer\n\t\t};\n\n\t\t// Node-fetch-only options\n\t\tthis.follow = init.follow === undefined ? (input.follow === undefined ? 20 : input.follow) : init.follow;\n\t\tthis.compress = init.compress === undefined ? (input.compress === undefined ? true : input.compress) : init.compress;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t\tthis.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;\n\t\tthis.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;\n\n\t\t// \u00A75.4, Request constructor steps, step 16.\n\t\t// Default is empty string per https://fetch.spec.whatwg.org/#concept-request-referrer-policy\n\t\tthis.referrerPolicy = init.referrerPolicy || input.referrerPolicy || '';\n\t}\n\n\t/** @returns {string} */\n\tget method() {\n\t\treturn this[INTERNALS].method;\n\t}\n\n\t/** @returns {string} */\n\tget url() {\n\t\treturn formatUrl(this[INTERNALS].parsedURL);\n\t}\n\n\t/** @returns {Headers} */\n\tget headers() {\n\t\treturn this[INTERNALS].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS].redirect;\n\t}\n\n\t/** @returns {AbortSignal} */\n\tget signal() {\n\t\treturn this[INTERNALS].signal;\n\t}\n\n\t// https://fetch.spec.whatwg.org/#dom-request-referrer\n\tget referrer() {\n\t\tif (this[INTERNALS].referrer === 'no-referrer') {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (this[INTERNALS].referrer === 'client') {\n\t\t\treturn 'about:client';\n\t\t}\n\n\t\tif (this[INTERNALS].referrer) {\n\t\t\treturn this[INTERNALS].referrer.toString();\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tget referrerPolicy() {\n\t\treturn this[INTERNALS].referrerPolicy;\n\t}\n\n\tset referrerPolicy(referrerPolicy) {\n\t\tthis[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);\n\t}\n\n\t/**\n\t * Clone this request\n\t *\n\t * @return  Request\n\t */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn 'Request';\n\t}\n}\n\nObject.defineProperties(Request.prototype, {\n\tmethod: {enumerable: true},\n\turl: {enumerable: true},\n\theaders: {enumerable: true},\n\tredirect: {enumerable: true},\n\tclone: {enumerable: true},\n\tsignal: {enumerable: true},\n\treferrer: {enumerable: true},\n\treferrerPolicy: {enumerable: true}\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param {Request} request - A Request instance\n * @return The options object to be passed to http.request\n */\nexport const getNodeRequestOptions = request => {\n\tconst {parsedURL} = request[INTERNALS];\n\tconst headers = new Headers(request[INTERNALS].headers);\n\n\t// Fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body === null && /^(post|put)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\n\tif (request.body !== null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\t// Set Content-Length if totalBytes is a number (that is not NaN)\n\t\tif (typeof totalBytes === 'number' && !Number.isNaN(totalBytes)) {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// 4.1. Main fetch, step 2.6\n\t// > If request's referrer policy is the empty string, then set request's referrer policy to the\n\t// > default referrer policy.\n\tif (request.referrerPolicy === '') {\n\t\trequest.referrerPolicy = DEFAULT_REFERRER_POLICY;\n\t}\n\n\t// 4.1. Main fetch, step 2.7\n\t// > If request's referrer is not \"no-referrer\", set request's referrer to the result of invoking\n\t// > determine request's referrer.\n\tif (request.referrer && request.referrer !== 'no-referrer') {\n\t\trequest[INTERNALS].referrer = determineRequestsReferrer(request);\n\t} else {\n\t\trequest[INTERNALS].referrer = 'no-referrer';\n\t}\n\n\t// 4.5. HTTP-network-or-cache fetch, step 6.9\n\t// > If httpRequest's referrer is a URL, then append `Referer`/httpRequest's referrer, serialized\n\t// >  and isomorphic encoded, to httpRequest's header list.\n\tif (request[INTERNALS].referrer instanceof URL) {\n\t\theaders.set('Referer', request.referrer);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip, deflate, br');\n\t}\n\n\tlet {agent} = request;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\tconst search = getSearch(parsedURL);\n\n\t// Pass the full URL directly to request(), but overwrite the following\n\t// options:\n\tconst options = {\n\t\t// Overwrite search to retain trailing ? (issue #776)\n\t\tpath: parsedURL.pathname + search,\n\t\t// The following options are not expressed in the URL\n\t\tmethod: request.method,\n\t\theaders: headers[Symbol.for('nodejs.util.inspect.custom')](),\n\t\tinsecureHTTPParser: request.insecureHTTPParser,\n\t\tagent\n\t};\n\n\treturn {\n\t\t/** @type {URL} */\n\t\tparsedURL,\n\t\toptions\n\t};\n};\n", "import {FetchBaseError} from './base.js';\n\n/**\n * AbortError interface for cancelled requests\n */\nexport class AbortError extends FetchBaseError {\n\tconstructor(message, type = 'aborted') {\n\t\tsuper(message, type);\n\t}\n}\n", "/**\n * Index.js\n *\n * a request API compatible with window.fetch\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */\n\nimport http from 'node:http';\nimport https from 'node:https';\nimport zlib from 'node:zlib';\nimport Stream, {PassThrough, pipeline as pump} from 'node:stream';\nimport {Buffer} from 'node:buffer';\n\nimport dataUriToBuffer from 'data-uri-to-buffer';\n\nimport {writeToStream, clone} from './body.js';\nimport Response from './response.js';\nimport Headers, {fromRawHeaders} from './headers.js';\nimport Request, {getNodeRequestOptions} from './request.js';\nimport {FetchError} from './errors/fetch-error.js';\nimport {AbortError} from './errors/abort-error.js';\nimport {isRedirect} from './utils/is-redirect.js';\nimport {FormData} from 'formdata-polyfill/esm.min.js';\nimport {isDomainOrSubdomain, isSameProtocol} from './utils/is.js';\nimport {parseReferrerPolicyFromHeader} from './utils/referrer.js';\nimport {\n\tBlob,\n\tFile,\n\tfileFromSync,\n\tfileFrom,\n\tblobFromSync,\n\tblobFrom\n} from 'fetch-blob/from.js';\n\nexport {FormData, Headers, Request, Response, FetchError, AbortError, isRedirect};\nexport {Blob, File, fileFromSync, fileFrom, blobFromSync, blobFrom};\n\nconst supportedSchemas = new Set(['data:', 'http:', 'https:']);\n\n/**\n * Fetch function\n *\n * @param   {string | URL | import('./request').default} url - Absolute url or Request instance\n * @param   {*} [options_] - Fetch options\n * @return  {Promise<import('./response').default>}\n */\nexport default async function fetch(url, options_) {\n\treturn new Promise((resolve, reject) => {\n\t\t// Build request object\n\t\tconst request = new Request(url, options_);\n\t\tconst {parsedURL, options} = getNodeRequestOptions(request);\n\t\tif (!supportedSchemas.has(parsedURL.protocol)) {\n\t\t\tthrow new TypeError(`node-fetch cannot load ${url}. URL scheme \"${parsedURL.protocol.replace(/:$/, '')}\" is not supported.`);\n\t\t}\n\n\t\tif (parsedURL.protocol === 'data:') {\n\t\t\tconst data = dataUriToBuffer(request.url);\n\t\t\tconst response = new Response(data, {headers: {'Content-Type': data.typeFull}});\n\t\t\tresolve(response);\n\t\t\treturn;\n\t\t}\n\n\t\t// Wrap http.request into fetch\n\t\tconst send = (parsedURL.protocol === 'https:' ? https : http).request;\n\t\tconst {signal} = request;\n\t\tlet response = null;\n\n\t\tconst abort = () => {\n\t\t\tconst error = new AbortError('The operation was aborted.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\trequest.body.destroy(error);\n\t\t\t}\n\n\t\t\tif (!response || !response.body) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = () => {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// Send request\n\t\tconst request_ = send(parsedURL.toString(), options);\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tconst finalize = () => {\n\t\t\trequest_.abort();\n\t\t\tif (signal) {\n\t\t\t\tsignal.removeEventListener('abort', abortAndFinalize);\n\t\t\t}\n\t\t};\n\n\t\trequest_.on('error', error => {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, 'system', error));\n\t\t\tfinalize();\n\t\t});\n\n\t\tfixResponseChunkedTransferBadEnding(request_, error => {\n\t\t\tif (response && response.body) {\n\t\t\t\tresponse.body.destroy(error);\n\t\t\t}\n\t\t});\n\n\t\t/* c8 ignore next 18 */\n\t\tif (process.version < 'v14') {\n\t\t\t// Before Node.js 14, pipeline() does not fully support async iterators and does not always\n\t\t\t// properly handle when the socket close/end events are out of order.\n\t\t\trequest_.on('socket', s => {\n\t\t\t\tlet endedWithEventsCount;\n\t\t\t\ts.prependListener('end', () => {\n\t\t\t\t\tendedWithEventsCount = s._eventsCount;\n\t\t\t\t});\n\t\t\t\ts.prependListener('close', hadError => {\n\t\t\t\t\t// if end happened before close but the socket didn't emit an error, do it now\n\t\t\t\t\tif (response && endedWithEventsCount < s._eventsCount && !hadError) {\n\t\t\t\t\t\tconst error = new Error('Premature close');\n\t\t\t\t\t\terror.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\t\tresponse.body.emit('error', error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\trequest_.on('response', response_ => {\n\t\t\trequest_.setTimeout(0);\n\t\t\tconst headers = fromRawHeaders(response_.rawHeaders);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (isRedirect(response_.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tlet locationURL = null;\n\t\t\t\ttry {\n\t\t\t\t\tlocationURL = location === null ? null : new URL(location, request.url);\n\t\t\t\t} catch {\n\t\t\t\t\t// error here can only be invalid URL in Location: header\n\t\t\t\t\t// do not throw when options.redirect == manual\n\t\t\t\t\t// let the user extract the errorneous redirect URL\n\t\t\t\t\tif (request.redirect !== 'manual') {\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// Nothing to do\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow': {\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOptions = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: clone(request),\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\tsize: request.size,\n\t\t\t\t\t\t\treferrer: request.referrer,\n\t\t\t\t\t\t\treferrerPolicy: request.referrerPolicy\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// when forwarding sensitive headers like \"Authorization\",\n\t\t\t\t\t\t// \"WWW-Authenticate\", and \"Cookie\" to untrusted targets,\n\t\t\t\t\t\t// headers will be ignored when following a redirect to a domain\n\t\t\t\t\t\t// that is not a subdomain match or exact match of the initial domain.\n\t\t\t\t\t\t// For example, a redirect from \"foo.com\" to either \"foo.com\" or \"sub.foo.com\"\n\t\t\t\t\t\t// will forward the sensitive headers, but a redirect to \"bar.com\" will not.\n\t\t\t\t\t\t// headers will also be ignored when following a redirect to a domain using\n\t\t\t\t\t\t// a different protocol. For example, a redirect from \"https://foo.com\" to \"http://foo.com\"\n\t\t\t\t\t\t// will not forward the sensitive headers\n\t\t\t\t\t\tif (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n\t\t\t\t\t\t\tfor (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {\n\t\t\t\t\t\t\t\trequestOptions.headers.delete(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (response_.statusCode !== 303 && request.body && options_.body instanceof Stream.Readable) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (response_.statusCode === 303 || ((response_.statusCode === 301 || response_.statusCode === 302) && request.method === 'POST')) {\n\t\t\t\t\t\t\trequestOptions.method = 'GET';\n\t\t\t\t\t\t\trequestOptions.body = undefined;\n\t\t\t\t\t\t\trequestOptions.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 14\n\t\t\t\t\t\tconst responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);\n\t\t\t\t\t\tif (responseReferrerPolicy) {\n\t\t\t\t\t\t\trequestOptions.referrerPolicy = responseReferrerPolicy;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOptions)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Prepare response\n\t\t\tif (signal) {\n\t\t\t\tresponse_.once('end', () => {\n\t\t\t\t\tsignal.removeEventListener('abort', abortAndFinalize);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet body = pump(response_, new PassThrough(), error => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t});\n\t\t\t// see https://github.com/nodejs/node/pull/29376\n\t\t\t/* c8 ignore next 3 */\n\t\t\tif (process.version < 'v12.10') {\n\t\t\t\tresponse_.on('aborted', abortAndFinalize);\n\t\t\t}\n\n\t\t\tconst responseOptions = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: response_.statusCode,\n\t\t\t\tstatusText: response_.statusMessage,\n\t\t\t\theaders,\n\t\t\t\tsize: request.size,\n\t\t\t\tcounter: request.counter,\n\t\t\t\thighWaterMark: request.highWaterMark\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// For gzip\n\t\t\tif (codings === 'gzip' || codings === 'x-gzip') {\n\t\t\t\tbody = pump(body, zlib.createGunzip(zlibOptions), error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For deflate\n\t\t\tif (codings === 'deflate' || codings === 'x-deflate') {\n\t\t\t\t// Handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = pump(response_, new PassThrough(), error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\traw.once('data', chunk => {\n\t\t\t\t\t// See http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = pump(body, zlib.createInflate(), error => {\n\t\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = pump(body, zlib.createInflateRaw(), error => {\n\t\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\traw.once('end', () => {\n\t\t\t\t\t// Some old IIS servers return zero-length OK deflate responses, so\n\t\t\t\t\t// 'data' is never emitted. See https://github.com/node-fetch/node-fetch/pull/903\n\t\t\t\t\tif (!response) {\n\t\t\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For br\n\t\t\tif (codings === 'br') {\n\t\t\t\tbody = pump(body, zlib.createBrotliDecompress(), error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise, use response as-is\n\t\t\tresponse = new Response(body, responseOptions);\n\t\t\tresolve(response);\n\t\t});\n\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\twriteToStream(request_, request).catch(reject);\n\t});\n}\n\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n\tconst LAST_CHUNK = Buffer.from('0\\r\\n\\r\\n');\n\n\tlet isChunkedTransfer = false;\n\tlet properLastChunkReceived = false;\n\tlet previousChunk;\n\n\trequest.on('response', response => {\n\t\tconst {headers} = response;\n\t\tisChunkedTransfer = headers['transfer-encoding'] === 'chunked' && !headers['content-length'];\n\t});\n\n\trequest.on('socket', socket => {\n\t\tconst onSocketClose = () => {\n\t\t\tif (isChunkedTransfer && !properLastChunkReceived) {\n\t\t\t\tconst error = new Error('Premature close');\n\t\t\t\terror.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\terrorCallback(error);\n\t\t\t}\n\t\t};\n\n\t\tconst onData = buf => {\n\t\t\tproperLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;\n\n\t\t\t// Sometimes final 0-length chunk and end of message code are in separate packets\n\t\t\tif (!properLastChunkReceived && previousChunk) {\n\t\t\t\tproperLastChunkReceived = (\n\t\t\t\t\tBuffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 &&\n\t\t\t\t\tBuffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpreviousChunk = buf;\n\t\t};\n\n\t\tsocket.prependListener('close', onSocketClose);\n\t\tsocket.on('data', onData);\n\n\t\trequest.on('close', () => {\n\t\t\tsocket.removeListener('close', onSocketClose);\n\t\t\tsocket.removeListener('data', onData);\n\t\t});\n\t});\n}\n", "import { Blob } from \"fetch-blob\"\n\nexport default Blob\n", "import { LatestWASL, Options } from \"../common/types\"\nimport * as languages from '../common/utils/languages'\nimport get from '../common/get'\nimport * as check from '../common/utils/check'\nimport * as utils from './utils'\n\nimport * as remoteImport from 'remote-esm'\nimport ESPlugin from \"es-plugins/dist/index.esm\"\n\nconst basePkgPath = './package.json'\n\nconst startTime = Date.now()\n\nclass WASL {\n\n    errors: any[] = []\n    warnings: any[] = []\n    files: { [x: string]: any } = {}\n    plugin?: ESPlugin\n    original?: { [x: string]: any } = {}\n    debug: undefined | { [x: string]: any } = undefined\n\n\n    #filesystem: Options['filesystem']\n\n\n    #input = {}\n    #options = {}\n    #url = undefined\n    #cache = {}\n    #main = ''\n    #mode = 'import'\n\n    #onImport = (path, info) => this.files[path] = info\n\n    #throw = (e) => {\n        const item = {\n            message: e.message,\n            file: e.file,\n            node: e.node,\n        }\n\n        const arr = (e.type === 'warning') ? this.warnings : this.errors\n        arr.push(item)\n    }\n\n    constructor(\n        urlOrObject: string | LatestWASL,\n        options: Options = {},\n        url?: string\n    ) {\n\n        this.#input = urlOrObject\n        this.#options = options\n        this.#url = url\n    }\n\n    get = async (...args) => {\n        const path = args[0]\n\n        return await get(args[0], args[1], this.#onImport).catch((e) => this.#throw({\n            message: e.message,\n            file: path\n        }))\n    }\n\n\n    // Load the internal \"plugins\" field in a WASL file to the dependent node\n    load = async (node, info, options, id?: any, symbols?, counter?) => {\n\n        if (node.plugins) {\n            for (let nestedName in node.plugins) {\n\n                const nestedNode = node.src.graph?.nodes?.[nestedName]\n\n                for (let key in node.plugins[nestedName]) {\n                    const newInfo = node.plugins[nestedName][key]\n\n                    if (typeof newInfo === 'object' && !Array.isArray(newInfo)) {\n\n                        const ogSrc = newInfo.src\n                        let newInfoForNode;\n                        if (id) newInfoForNode = this.#cache[id]?.[key] // check cache\n\n                        if (!newInfoForNode) {\n\n                            // Properly merge the resolved src info\n                            const optsCopy = Object.assign({}, options) as Options\n                            if (key === 'graph') optsCopy._deleteSrc = false // keep all node imports\n                            else optsCopy._deleteSrc = true\n\n                            newInfoForNode = (await this.resolve({ [key]: newInfo }, info, optsCopy, {\n                                nodes: newInfo\n                            }, symbols, counter))\n\n                            if (id) {\n                                if (!this.#cache[id]) this.#cache[id] = {}\n                                this.#cache[id][key] = newInfoForNode // cache\n                            }\n                        }\n\n                        // Only With Node Resolved\n                        if (nestedNode) {\n                            const newVal = newInfoForNode[key]\n\n                            if (newVal) {\n                                let chosenVal = newVal.src ?? newVal\n                                // merge default if the only key\n                                if ('default' in chosenVal && Object.keys(chosenVal).length === 1) chosenVal = chosenVal.default\n                                if (nestedNode) nestedNode[key] = chosenVal // MERGE BY REPLACEMENT\n                            } else {\n                                this.#throw({ message: `Could not resolve ${ogSrc}` })\n                            }\n                        }\n\n                    } else if (nestedNode) nestedNode[key] = newInfo // MERGE BY REPLACEMENT\n                }\n\n                // Source is Resolved but Node is Not\n                if (node.src.graph && !nestedNode) {\n                    this.#throw({\n                        message: `Plugin target '${nestedName}' does not exist`,\n                        node: name\n                    })\n                }\n            }\n        }\n    }\n\n    // --------- Main WASL Resolution Function ---------\n    // This method resolves all the src fields in the WASL file\n    resolve = async (target, info, options, graph: any = {}, symbols: string[] = [], counter) => {\n        const nodes = graph.nodes as any\n        const edges = graph.edges as any\n\n        counter++ // increment to show depth of resolution\n\n        const id = Symbol('unique')\n\n        let { url } = info\n\n        const mainPath = info.mainPath || this.#main // use base main if not specified\n\n\n        const symbolsRegistry = {}\n        // const innerTopLevel = options._top === true\n\n\n        for (let name in target) {\n\n            let symbolsCopy = symbolsRegistry[name] = [...symbols]\n\n            const node = target[name]\n            const isObj = node && typeof node === 'object' && !Array.isArray(node)\n\n            if (isObj) {\n                await this.load(node, info, options, id, symbolsCopy, counter) // before loading make sure graph is not specified at a higher level\n                let ogSrc = node.src ?? '';\n                if (utils.isSrc(ogSrc) || (nodes && edges && !ogSrc)) {\n                    node.src = null\n\n                    // Option #1: Active ESM source (TODO: Fetch text for ambiguous interpretation, i.e. other languages)\n                    let _internal: string | true = '' // don't mistake for user call\n                    let _modeOverride = options._modeOverride;\n                    let fullPath\n                    try {\n                        new URL(ogSrc);\n                        if (!options._overrideRemote || options._modeOverride === 'import') {\n                            _modeOverride = \"import\";\n                            _internal = fullPath = ogSrc;\n                        } else fullPath = `${ogSrc.split('://').slice(1).join('/')}` // no protocol\n                    } catch {\n                        if (ogSrc) fullPath = mainPath ? remoteImport.resolve(ogSrc, mainPath) : remoteImport.resolve(ogSrc);\n                    }\n\n                    let mode = options._modeOverride ?? this.#mode\n\n                    // Only Get Source based on the value present (though mainPath will allow for relative resolutions)\n                    if (ogSrc) {\n\n                        if (this.debug){\n\n                            // Get Flow\n                            let target = this.debug.flow\n                            symbolsCopy.forEach(str => {\n                                if (str) {\n                                    if (!target[str]) target[str] = {}\n                                    target = target[str]\n                                }\n                            })\n                            \n                            // Count Resolutions\n                            if (!this.debug.resolutions[name]) this.debug.resolutions[name] = {}\n                            let nameRes = this.debug.resolutions[name]\n                            if (!nameRes[fullPath]) nameRes[fullPath] = { _resolutions: 0, _depth: [], _time: [] }\n                            nameRes[fullPath]._resolutions++\n                            nameRes[fullPath]._depth.push(counter)\n                            nameRes[fullPath]._time.push(Date.now() - startTime)\n\n                            if (target) target[fullPath] = {}\n                        }\n\n\n                        //Import Mode\n                        if (_internal || mode === 'import') {\n                            let res = await this.get(fullPath, undefined) as LatestWASL\n                            if (res) node.src = res\n                            if (!node.src && !node.graph) utils.remove(ogSrc, fullPath, name, target) // remove if no source and no graph\n                        }\n\n                        // Reference Mode\n                        else {\n                            if (this.#filesystem) {\n\n                                let res;\n\n                                res = utils.checkFiles(fullPath, this.#filesystem)\n\n                                if (res) {\n\n                                    // Handle Node Specifications\n                                    if (\n                                        res.default // has a default export\n                                        || fullPath.includes('.json') // importing a wasl file\n                                    ) node.src = res\n                                    // Handle Errors\n                                    else {\n                                        this.#throw({\n                                            type: 'warning',\n                                            message: `Node (${name}) at ${fullPath} does not have a default export.`,\n                                            file: ogSrc\n                                        })\n                                        node.src = { default: res }\n                                    }\n\n                                    _internal = fullPath\n                                }\n                                else if (ogSrc) utils.remove(ogSrc, fullPath, name, target)\n\n                            } else {\n                                this.#throw({\n                                    message: 'No options.filesystem field to get JavaScript objects',\n                                    file: ogSrc\n                                })\n                            }\n                        }\n                    }\n\n\n                    if (!_internal) _internal = (ogSrc) ? remoteImport.resolve(ogSrc, url, true) : true // only set if not already present (e.g. for remote cases)\n\n                    let _top = false\n                    if (node.graph) {\n                        _top = true\n                        if (!node.src) node.src = {}\n                        node.src.graph = node.graph\n                        delete node.graph\n                    } \n    \n\n                    // drill into nested graphs\n                    if (node.src && node.src.graph) {\n                        await this.init(node.src, {\n                            _internal,\n                            _deleteSrc: options._deleteSrc,\n                            _top,\n                            _modeOverride,\n                            _overrideRemote: options._overrideRemote\n                        }, undefined, symbolsCopy, counter)\n                    } else symbolsCopy.push(fullPath) // ensure flow resolutions are properly scoped\n\n                }\n\n                // Load Embedded Src Files\n                for (let key in node) {\n\n                    if (\n                        !isObj // Alternative Loading Scheme\n                        && key === 'src'\n                        && node.src) {\n\n                        const language = node.src.language\n                        if (!language || languages.js.includes(language)) {\n\n                            // Option #2: Import full ESM text in JSON object\n                            if (node.src.text) {\n                                const esmImport = async (text) => {\n                                    try {\n                                        let imported = await remoteImport.importFromText(text)\n\n                                        // NOTE: getting default may be wrong\n                                        if (imported.default && Object.keys(imported).length === 1) imported = imported.default\n                                        return imported\n                                    } catch (e) {\n                                        console.error('Import did not work. Probably relies on something...')\n                                        this.#throw({\n                                            message: e.message,\n                                            file: name // NOTE: Is wrong...\n                                        })\n                                    }\n                                }\n\n                                const esm = await esmImport(node.src.text)\n                                if (esm) {\n                                    delete node.src.text\n                                    if (typeof esm === 'object') node.src = { default: Object.assign(node.src, esm) }\n                                    else node.src = esm\n                                } else {\n                                    this.#throw({\n                                        message: 'Could not import this text as ESM',\n                                        file: node.src\n                                    })\n                                }\n                            }\n\n                            // Option #3: Activate JS functions in JSON object\n                            else {\n\n                                const expectedFunctions = ['default', 'oncreate', 'onrender']\n                                for (let key in node.src) {\n                                    try {\n                                        if (expectedFunctions.includes(key) && typeof node.src[key] === 'string') node.src[key] = (0, eval)(`(${node.src[key]})`)\n                                    } catch (e) {\n                                        this.#throw({\n                                            message: `Field ${key} could not be parsed`,\n                                            file: node.src[key]\n                                        })\n                                    }\n                                }\n                            }\n                        }\n\n                        // Option #4: Allow downstream application to parse non-JS text\n                        else {\n                            console.warn(`Text is in ${language}, not JavaScript. This is not currently parsable automatically.`);\n                            this.#throw({\n                                message: `Source is in ${language}. Currently only JavaScript is supported.`,\n                                file: ogSrc\n                            })\n                        }\n                    }\n\n                    // Drill other object keys to replace and merge src...\n                    // NOTE: Sometimes duplicates a check because of looking at name === 'graph' again\n                    else if (node[key]) {\n                        if (typeof node[key] === 'object' && !Array.isArray(node[key])) {\n                            const optsCopy = Object.assign({}, options) as Options\n                            optsCopy._deleteSrc = key !== 'nodes' && name !== 'graph' // NOTE: Restricted progression\n                            await this.resolve(node[key], info, optsCopy, { nodes: node[key] }, symbolsCopy, counter) // check for src to merge\n                        }\n                    }\n                }\n\n            }\n        }\n\n\n        // Search the nodes that are produced for .src fields\n        // to modify it\n\n        // NOTE: If accompanied by an edges object, this is a full graph\n        // and should throw errors\n\n        for (let name in nodes) {\n\n            const node = nodes[name]\n\n            // Merge and validate plugins\n            if\n                (\n                node?.src &&\n                typeof node?.src === 'object' // Successfully loaded\n            ) {\n\n                // Merge node.plugins info with the actual node (i.e. instance) information\n                if (node.src.graph) await this.load(node, info, options, id, symbolsRegistry[name]) // attach to graph\n\n                // Only run if parent is a complete graph (i.e. you're an actual node)\n                else if (edges) {\n\n                    // VALIDATE: Source files must have a default export\n                    if (!('default' in node.src)) {\n                        this.#throw({\n                            message: 'No default export.',\n                            node: name\n                        })\n                    }\n\n                }\n\n                nodes[name] = utils.merge(node.src, node, options._deleteSrc)\n\n                // Scrub References for ES Plugins\n                if (nodes[name].src?.graph) nodes[name].src.graph = JSON.parse(JSON.stringify(nodes[name].graph)) // deep copy the source graph\n            }\n        }\n\n        return target\n    }\n\n    // --------- Main WASL Initialization Function ---------\n    // This method loads and merges all the src files\n    init = async (\n        urlOrObject: string | LatestWASL = this.#input,\n        options: Options = this.#options,\n        url: string = '',\n        symbols = [],\n        counter = 0\n    ) => {\n\n\n        if (options.debug) this.debug = {flow: {}, resolutions: {}}\n        else this.debug = undefined\n\n        // let symbol = Symbol('init')\n\n        const internalLoadCall = options._internal\n        const isFromValidator = !this.#main && typeof internalLoadCall === 'string'\n        // Original User Call\n        if (!this.#input) this.#input = urlOrObject\n        if (!this.#options) this.#options = options\n        if (!this.#filesystem) this.#filesystem = options.filesystem\n\n        if (!internalLoadCall) {\n            if (!url) url = this.#url // only use for the top-level call\n\n            // Scrub Options for Remote\n            try {\n                new URL(url ?? urlOrObject)\n                options.relativeTo = ''\n            } catch { }\n\n        }\n        else if (internalLoadCall === true) url = this.#main // use for internal unspecified calls\n\n        // Possibly From Validator\n        if (isFromValidator) url = this.#main = internalLoadCall as string// validator input for import syntax\n\n        const clonedOptions = Object.assign({}, options) as Options\n        // const isTopLevel = clonedOptions._top !== false\n        const innerTopLevel = clonedOptions._top === true\n        const isString = typeof urlOrObject === 'string'\n\n        let mode, object, mainPath; // catch internal calls\n\n        // ----------------------- Local Mode Handling -----------------------\n        if (typeof urlOrObject === 'object') {\n            object = Object.assign({}, urlOrObject)\n            if (typeof internalLoadCall === 'string') url = mainPath = remoteImport.resolve(internalLoadCall) // use internal call as base\n            mode = 'reference'\n        } else if (url || (isString)) {\n            if (!url) url = remoteImport.resolve(urlOrObject, options.relativeTo ?? '')\n            mode = 'import'\n        }\n        else console.error('Mode is not supported...')\n\n        if (!internalLoadCall) this.#mode = mode // set global mode\n\n\n        mode = clonedOptions._modeOverride ?? this.#mode // set local to global mode\n\n        // Check if input is valid\n        this.errors.push(...check.valid(urlOrObject, clonedOptions, 'load'))\n\n        // maintain a reference to the main path\n\n        // ------------------- Merge package.json and (optionally) resolve object-------------------\n\n        switch (mode) {\n            case 'reference':\n\n                // Graphs Nested in the Top Level Don't Have a package.json File\n                if (!innerTopLevel) {\n                    if (this.#filesystem) {\n                        const pkgPath = remoteImport.resolve(basePkgPath, url)\n                        const pkg = utils.checkFiles(pkgPath, this.#filesystem)\n                        if (pkg) object = Object.assign(pkg, isString ? {} : object) as any\n                        // else utils.remove(basePkgPath, pkgPath) // Package.json files are not required...\n                    }\n                }\n\n            default:\n                if (!object) {\n                    mainPath = await remoteImport.resolve(url)\n                    object = await this.get(mainPath, undefined) as LatestWASL\n                    if (!innerTopLevel) {\n                        const pkgUrl = remoteImport.resolve(basePkgPath, mainPath, true)\n                        const pkg = await this.get(pkgUrl, undefined)\n                        if (pkg) object = Object.assign(pkg, object) as any\n                    }\n                }\n        }\n\n        if (!internalLoadCall) this.#main = mainPath // save global main path\n        else if (this.#mode === 'reference' && !this.#main) this.#main = '' // ensures root scope\n\n\n        if (this.debug){\n            let target = this.debug.flow\n            symbols.forEach(str => target = target[str])\n            target[mainPath] = {}\n            symbols.push(mainPath)\n\n            if (mainPath) {\n                if (!this.debug.resolutions[mainPath]) this.debug.resolutions[mainPath] = { _resolutions: 0, _depth: [], _time: [] }\n                const res = this.debug.resolutions\n                res[mainPath]._resolutions++\n                res[mainPath]._depth.push(counter)\n                res[mainPath]._time.push(Date.now() - startTime)\n            }\n        }\n\n        if (this.errors.length === 0) {\n\n            // replace src with actual source text\n            const nodes = object.graph.nodes\n\n            await this.resolve(nodes, {\n                mainPath,\n                url,\n                object,\n            }, clonedOptions, object.graph, symbols, counter)\n\n\n            // convert valid nodes to ES Plugins\n            const drill = (parent, callback) => {\n                const nodes = parent.graph.nodes\n                for (let tag in nodes) {\n                    const res = callback(nodes[tag], {\n                        tag,\n                        parent,\n                        options: clonedOptions\n                    })\n\n                    if (res) nodes[tag] = res\n                }\n            }\n\n            // -------------------------- do plugin-dependent tests --------------------------\n            const drillToTest = (target) => {\n                drill(target, (node, info) => {\n\n                    // VALIDATE: Check that all edges point to valid nodes\n                    const edges = info.parent.graph.edges\n                    for (let output in edges) {\n\n                        const getTarget = (o, str) => o.graph?.nodes?.[str] ?? o[str]\n\n                        let outTarget = info.parent.graph.nodes\n                        output.split('.').forEach((str) => outTarget = getTarget(outTarget, str))\n\n                        if (!outTarget) {\n                            this.#throw({\n                                message: `Node '${output}' (output) does not exist to create an edge.`,\n                                file: url,\n                            })\n                        }\n\n                        for (let input in edges[output]) {\n                            let inTarget = nodes\n                            input.split('.').forEach((str) => inTarget = getTarget(inTarget, str))\n                            if (!inTarget) {\n                                this.#throw({\n                                    message: `Node '${input}' (input) does not exist to create an edge.`,\n                                    file: url,\n                                })\n                            }\n                        }\n                    }\n\n                })\n            }\n\n            // -------------------------- initialize plugins --------------------------\n            if (internalLoadCall === undefined) {\n                if (clonedOptions.output !== 'object') {\n\n                    // Convert to ES Plugin\n                    this.plugin = new ESPlugin(object, {\n                        activate: clonedOptions.activate,\n                        parentNode: clonedOptions.parentNode\n                    })\n\n                    // Derive Original Input\n                    this.original = Object.assign({}, this.plugin.initial)\n                    let drillCopy = (target) => {\n                        if (target?.graph) {\n                            let graph = Object.assign({}, target.graph)\n                            let nodes = graph.nodes = Object.assign({}, graph.nodes)\n                            if (nodes) {\n                                for (let k in nodes) {\n                                    nodes[k] = Object.assign({}, nodes[k].initial)\n                                    drillCopy(nodes[k])\n                                }\n                            }\n                            target.graph = graph\n                        }\n                    }\n                    drillCopy(this.original)\n\n                    return this.plugin\n                } else this.original = object\n\n                drillToTest(object) // test\n            }\n\n            return object\n        }\n    }\n\n    start = async () => {\n        if (this.plugin) return await this.plugin.start()\n    }\n\n    stop = async () => {\n        if (this.plugin) return await this.plugin.stop()\n    }\n\n\n}\n\n\nexport default WASL", "\nexport const js = ['js', 'mjs', 'cjs', 'javascript']\nexport const json = ['json']", "const fullSuffix = (fileName='') => (fileName).split('.').slice(1)\n\nexport const suffix = (fileName='') => {\n    const suffix = fullSuffix(fileName) // Allow no name\n    return suffix.join('.')\n}", "const urlSep = '://'\n\nexport const get = (path, rel = '', keepRelativeImports=false) => {\n    // if (!path.includes('./')) rel = '' // absolute\n\n    let prefix = ''\n    const getPrefix = (str) => {\n        prefix = (str.includes(urlSep)) ? str.split(urlSep).splice(0,1) : undefined\n        if (prefix) return str.replace(`${prefix}${urlSep}`, '')\n        else return str\n    }\n    if (path.includes(urlSep)) path = getPrefix(path)\n    if (rel.includes(urlSep)) rel = getPrefix(rel)\n\n    if (!keepRelativeImports) rel = rel.split('/').filter(v => v != '..').join('/') // Remove leading ..\n\n    if (rel[rel.length - 1] === '/') rel = rel.slice(0, -1) // Remove trailing slashes\n\n    let dirTokens = rel.split('/')\n    if (dirTokens.length === 1 && dirTokens[0] === '') dirTokens = [] // Remove consequence of empty string rel\n\n    const potentialFile = dirTokens.pop() // remove file name\n    if (potentialFile) {\n        const splitPath = potentialFile.split('.')\n       if (splitPath.length == 1 || (splitPath.length > 1 && splitPath.includes(''))) dirTokens.push(potentialFile) // ASSUMPTION: All files have an extension\n    }\n\n    const splitPath = path.split(\"/\")\n    const pathTokens = splitPath.filter((str, i) => !!str) // remove bookend slashes\n\n    // force back if using urls\n    // console.log('pathTokens', JSON.parse(JSON.stringify(pathTokens)))\n    // if (matches) {\n    //     dirTokens.forEach((_, i) => {\n    //         if (pathTokens[i] != '..') pathTokens.unshift('..')\n    //     })\n    // }\n    // console.log('pathTokens', JSON.parse(JSON.stringify(pathTokens)))\n\n    const extensionTokens = pathTokens.filter((str, i) => {\n        if (str === '..') {\n            dirTokens.pop() // Pop off directories\n            return false\n        } else if (str === '.') return false\n        else return true\n    })\n\n    // Concatenate with windowLocation if rel matched OR no rel and path matched...\n    const newPath = [...dirTokens, ...extensionTokens].join('/')\n\n    // Add prefix back if it exists\n    if (prefix) return prefix + '://' + newPath\n    else return newPath\n}", "import * as pathUtils from \"./path.js\"\n\nconst getURL = (path) => {\n    let url\n    try { url = new URL(path).href } \n    catch { url = pathUtils.get(path, globalThis.location.href) }\n    return url\n}\n\nexport const handleFetch = async (path, options={}, progressCallback) => {\n    if (!options.mode)  options.mode = 'cors' // Auto-CORS Support\n    const url = getURL(path) \n\n    const response = await fetchRemote(url, options, progressCallback)\n    if (!response) throw new Error('No response received.')\n    const type = response.type.split(';')[0] // Get mimeType (not fully specified)\n\n    return {\n        url,\n        type,\n        buffer: response.buffer\n    }\n}\n\nexport const fetchRemote = async (url, options={}, progressCallback) => {\n\n    const response = await globalThis.fetch(url, options)\n\n    return new Promise(async resolve => {\n\n        if (response) {\n\n            const type = response.headers.get('Content-Type')\n\n            // Browser Remote Parser\n            if (globalThis.REMOTEESM_NODE) {\n                const buffer = await response.arrayBuffer()\n                resolve({buffer, type})\n            }\n            \n            // Browser Remote Parser\n            else {\n\n                const reader = response.body.getReader();\n\n                const bytes = parseInt(response.headers.get('Content-Length'), 10)\n                let bytesReceived = 0\n                let buffer = [];\n\n                const processBuffer = async ({ done, value }) => {\n\n                    if (done) {\n                        const config = {}\n                        if (typeof type === 'string') config.type = type\n                        const blob = new Blob(buffer, config)\n                        const ab = await blob.arrayBuffer()\n                        resolve({buffer: new Uint8Array(ab), type})\n                        return;\n                    }\n\n                    bytesReceived += value.length;\n                    const chunk = value;\n                    buffer.push(chunk);\n\n                    if (progressCallback instanceof Function) progressCallback(response.headers.get('Range'), bytesReceived / bytes, bytes)\n\n                    // Read some more, and call this function again\n                    return reader.read().then(processBuffer)\n                }\n\n                reader.read().then(processBuffer);\n            }\n\n        } else {\n            console.warn('Response not received!', options.headers)\n            resolve(undefined)\n        }\n    })\n}", "import * as pathUtils from \"./utils/path.js\";\nimport { handleFetch } from \"./utils/request.js\";\n\nconst datauri = {} // Share references between loaded dataurl instances\n\n// Node Polyfills\nexport const ready = new Promise(async (resolve, reject) => {\n    try {\n        if(typeof process === 'object') { //indicates node\n            // globalThis.REMOTEESM_NODE = true\n            globalThis.fetch = (await import('node-fetch')).default\n            if (typeof globalThis.fetch !== 'function') globalThis.fetch = fetch\n\n            const Blob = (await import('cross-blob')).default\n            globalThis.Blob = Blob\n\n            if (typeof globalThis.Blob !== 'function') globalThis.Blob = Blob\n            resolve(true)\n        } else resolve(true)\n\n    } catch (err) {\n        console.log(err)\n        reject(err)\n    }\n})\n\n\n// Import ES6 Modules (and replace their imports with actual file imports!)\nconst re = /import([ \\n\\t]*(?:(?:\\* (?:as .+))|(?:[^ \\n\\t\\{\\}]+[ \\n\\t]*,?)|(?:[ \\n\\t]*\\{(?:[ \\n\\t]*[^ \\n\\t\"'\\{\\}]+[ \\n\\t]*,?)+\\}))[ \\n\\t]*)from[ \\n\\t]*(['\"])([^'\"\\n]+)(?:['\"])([ \\n\\t]*assert[ \\n\\t]*{type:[ \\n\\t]*(['\"])([^'\"\\n]+)(?:['\"])})?/g \nexport const moduleDataURI = (text, mimeType='text/javascript') => `data:${mimeType};base64,` + btoa(text);\n\n// Direct Import of ES6 Modules\nexport const importFromText = async (text, path, collection={}) => {\n    const extension = path.split('.').slice(-1)[0]\n    const isJSON = extension === 'json'\n    let mimeType = isJSON ? 'application/json' : 'application/javascript'\n    const uri = moduleDataURI(text, mimeType)\n    let imported = await (isJSON ? import(uri, { assert: { type: \"json\" } }) : import(uri)).catch((e) => {\n        if (e.message.includes('Unexpected token')) throw new Error('Failed to fetch') // Not found\n        else throw e;\n      });\n\n\n      const ref = {}\n\n    for (let key in imported) {\n        // mimic live bindings\n        Object.defineProperty(ref, key, {\n            get: () => imported[key], // get original import value\n            // set: (input) => imported[key] = input, // NOTE: Is immutable from this interface\n            enumerable: true,\n        })\n     }\n\n     collection[path] = uri// ref\n\n    return imported\n}\n\nexport const resolve = pathUtils.get\n\nconst getText = async (uri) => await globalThis.fetch(uri).then(res => res.text())\n\nconst safeImport =  async (uri, opts = {}) => {\n\n    const {\n        root,\n        onImport = ()=>{},\n        outputText,\n        forceImportFromText\n    } = opts\n\n    const uriCollection = opts.datauri || datauri\n\n    // Make sure fetch is ready\n    await ready\n    \n    // Register in Tree\n    if (opts.dependencies) opts.dependencies[uri] = {}\n\n\n    // Load the WASL file\n    const extension = uri.split('.').slice(-1)[0]\n    const isJSON = extension === \"json\";\n\n     let module = (!forceImportFromText) ? \n     await (isJSON ? import(uri, { assert: { type: \"json\" } }) : import(uri))\n     .catch(() => { }) // is available locally?\n     : undefined;\n\n     let text, originalText;\n    if (!module) {\n\n        text = originalText = await getText(uri)\n\n    try {\n        module = await importFromText(text, uri, uriCollection)\n    }\n\n    // Catch Nested Imports\n    catch (e) {\n\n        const base = pathUtils.get(\"\", uri);\n        let childBase = base;\n\n        // Use a Regular Expression to Splice Out the Import Details\n        const importInfo = []\n        let m;\n        do {\n            m = re.exec(text)\n            if (m == null) m = re.exec(text); // be extra sure (weird bug)\n            if (m) {\n                text = text.replace(m[0], ``) // Replace found text\n                const wildcard = !!m[1].match(/\\*\\s+as/)\n                const variables = m[1].replace(/\\*\\s+as/, '').trim()\n                importInfo.push({\n                    path: m[3],\n                    variables,\n                    wildcard\n                })\n            }\n        } while (m);\n\n        // Import Files Asynchronously\n        for (let i in importInfo){\n            const {variables, wildcard, path} = importInfo[i]\n\n            // Check If Already Exists\n            let correctPath = pathUtils.get(path, childBase)\n            const dependentFilePath = pathUtils.get(correctPath)\n            const dependentFileWithoutRoot = pathUtils.get(dependentFilePath.replace(root ?? '', ''))\n\n            if (opts.dependencies) opts.dependencies[uri][dependentFileWithoutRoot] = importInfo[i]\n            \n            // Check If Already Exists\n            let ref = uriCollection[dependentFilePath]\n            if (!ref) {\n                const extension = correctPath.split('.').slice(-1)[0]\n                const info = await handleFetch(correctPath);\n                let blob = new Blob([info.buffer], { type: info.type });\n                const isJS = extension.includes('js')\n                const newURI = dependentFileWithoutRoot\n                const newText = await blob.text()\n                let importedText = (isJS) ? await new Promise(async (resolve) => {\n                    await safeImport(newURI, {\n                        root: uri, \n                        onImport: (path, info)=> {\n                            onImport(path, info)\n                            if (path == newURI) resolve(info.text)\n                        }, \n                        outputText: true,\n                        forceImportFromText\n                    }) \n                }) : newText\n\n                await importFromText(importedText, correctPath, uriCollection) // registers in text references\n            }\n            \n            text = `import ${(wildcard) ? '* as ' : ''}${variables} from \"${uriCollection[correctPath]}\";\\n${text}`;\n        }\n\n        module = await importFromText(text, uri, uriCollection)\n    }\n}\n\nlet txt = outputText ? text ?? await getText(uri) : void 0\nonImport(uri, {\n  text: txt,\n  file: outputText ? originalText ?? txt : void 0,\n  module\n});\n\nreturn module\n\n}\n\nexport default safeImport", "import * as path from './utils/path'\nimport * as remoteImport from 'remote-esm'\n\nconst cache = {}\n// ESM File Importer with Cache Support\nconst get = async (relPath, relativeTo=\"\", onImport?) => {\n\n    let type = path.suffix(relPath)\n    const isJSON = (!type || type.includes('json'))\n\n    // Correct paths for the different locations in the filesystem\n    const fullPath = remoteImport.resolve(relPath, relativeTo)\n    const isFunc = typeof onImport === 'function'\n    const imported = cache[fullPath]?.imported ?? []\n\n    if (!cache[fullPath]){\n\n        const imported = []\n        cache[fullPath] = remoteImport.default(fullPath, {\n            onImport: (...args) => {                \n                if (isFunc) {\n                    imported.push(args)\n                    onImport(...args)\n                }\n            }, \n            outputText: true\n        }).catch(e => {\n            if (e.message.includes(\"Failed to fetch\")) throw new Error(\"404\");\n            else throw e\n        })\n\n        cache[fullPath].imported = imported\n\n        const res = await cache[fullPath]\n\n        if (isJSON) cache[fullPath] = res?.default ?? {}\n        else cache[fullPath] = res\n    } else if (isFunc) imported.forEach(args => onImport(...args))\n\n    return (isJSON) ? JSON.parse(JSON.stringify(cache[fullPath])) : cache[fullPath]\n}\n\nexport default get", "import { Options } from \"../types/index\"\n\nconst valid = (input:any, options: Options, location:string): any[] => {\n    \n    const errors: Options['errors'] = []\n    const isUndefined = options?.relativeTo === undefined\n    const isString = typeof input === 'string'\n    const isObject = typeof input === 'object'\n\n    let error: any;\n    if (isString) {\n        const hasRelTo = (!isUndefined && 'relativeTo' in options)\n        if (!hasRelTo && !options._remote){\n        \n            if (import.meta.url) {\n                error = {message: 'Not a valid relativeTo key (required) in options', file: input}\n                console.warn(`[wasl-${location}] Import Mode Error: Please pass a valid string to options.relativeTo (ideally import.meta.url).`)\n            } else {\n                 error = {message: 'import.meta.url is not supported', file: input}\n                console.warn(`[wasl-${location}] Import Mode Error: import.meta.url is not available. Does your bundler support it?`)\n            }\n\n        }\n\n    } else if (!isObject) {\n        error = {message: 'Not a valid object passed in the first argument', file: null}\n        console.warn(`[wasl-${location}] Reference Mode Error: Please pass a valid object in the first argument and pass file object references via the options.filesystem field.`)\n    } \n    \n\n    if (error) {\n        error.function = location\n        errors.push(error)\n    }\n\n    return errors\n}\n\nexport {\n    valid\n}", "import * as path from '../common/utils/path'\nimport * as languages from '../common/utils/languages'\n\nexport const isSrc = (str) => {\n    return typeof str === 'string' && Object.values(languages).find(arr => arr.includes(str.split('.').slice(-1)[0])) // Has supported extension\n}\n\nexport const merge = (main, override, deleteSrc=false) => {\n\n    const copy = Object.assign({}, main)\n    if (override){\n        if (deleteSrc) {\n            const ogSrc = override.src ?? override\n            delete override.src\n            if ('default' in ogSrc) return ogSrc.default // default export\n        }\n\n        const keys = Object.keys(copy)\n        const newKeys = new Set(Object.keys(override))\n\n        keys.forEach(k => {\n            newKeys.delete(k)\n            if (typeof override[k] === 'object' && !Array.isArray(override[k])) copy[k] = merge(copy[k], override[k])\n            else if (k in override) copy[k] = override[k] // replace values and arrays\n        })\n\n        newKeys.forEach(k => {\n            copy[k] = override[k]\n        })\n    }\n    \n    return copy // named exports\n}\n\nexport const checkFiles = (key, filesystem) => {\n    const isJSON = path.suffix(key).slice(-4) === \"json\" ? true : false;\n    const output = isJSON && filesystem[key] ? JSON.parse(JSON.stringify(filesystem[key])) : filesystem[key];\n    return output;\n}\n\nexport var remove = (original, search, key=original, o?)=> {\n    console.error(`Source was not ${original ? `resolved for ${original}` : `specified for ${key}`}. ${search ? `If available, refer to this object directly as options.filesystem[\"${search}\"]. ` : ''}${o ? `Automatically removing ${key} from the WASL file.` : ''}`);\n    if (o) delete o[key];\n  }\n", "const urlSep = '://'\n\nexport const get = (path, rel = '', keepRelativeImports=false) => {\n    // if (!path.includes('./')) rel = '' // absolute\n\n    let prefix = ''\n    const getPrefix = (str) => {\n        prefix = (str.includes(urlSep)) ? str.split(urlSep).splice(0,1) : undefined\n        if (prefix) return str.replace(`${prefix}${urlSep}`, '')\n        else return str\n    }\n    if (path.includes(urlSep)) path = getPrefix(path)\n    if (rel.includes(urlSep)) rel = getPrefix(rel)\n\n    if (!keepRelativeImports) rel = rel.split('/').filter(v => v != '..').join('/') // Remove leading ..\n\n    if (rel[rel.length - 1] === '/') rel = rel.slice(0, -1) // Remove trailing slashes\n\n    let dirTokens = rel.split('/')\n    if (dirTokens.length === 1 && dirTokens[0] === '') dirTokens = [] // Remove consequence of empty string rel\n\n    const potentialFile = dirTokens.pop() // remove file name\n    if (potentialFile) {\n        const splitPath = potentialFile.split('.')\n       if (splitPath.length == 1 || (splitPath.length > 1 && splitPath.includes(''))) dirTokens.push(potentialFile) // ASSUMPTION: All files have an extension\n    }\n\n    const splitPath = path.split(\"/\")\n    const pathTokens = splitPath.filter((str, i) => !!str) // remove bookend slashes\n\n    // force back if using urls\n    // console.log('pathTokens', JSON.parse(JSON.stringify(pathTokens)))\n    // if (matches) {\n    //     dirTokens.forEach((_, i) => {\n    //         if (pathTokens[i] != '..') pathTokens.unshift('..')\n    //     })\n    // }\n    // console.log('pathTokens', JSON.parse(JSON.stringify(pathTokens)))\n\n    const extensionTokens = pathTokens.filter((str, i) => {\n        if (str === '..') {\n            dirTokens.pop() // Pop off directories\n            return false\n        } else if (str === '.') return false\n        else return true\n    })\n\n    // Concatenate with windowLocation if rel matched OR no rel and path matched...\n    const newPath = [...dirTokens, ...extensionTokens].join('/')\n\n    // Add prefix back if it exists\n    if (prefix) return prefix + '://' + newPath\n    else return newPath\n}", "import * as pathUtils from \"./utils/path.js\";\nimport { handleFetch } from \"./utils/request.js\";\n\nconst datauri = {} // Share references between loaded dataurl instances\n\n// Node Polyfills\nexport const ready = new Promise(async (resolve, reject) => {\n    try {\n        if(typeof process === 'object') { //indicates node\n            // globalThis.REMOTEESM_NODE = true\n            globalThis.fetch = (await import('node-fetch')).default\n            if (typeof globalThis.fetch !== 'function') globalThis.fetch = fetch\n\n            const Blob = (await import('cross-blob')).default\n            globalThis.Blob = Blob\n\n            if (typeof globalThis.Blob !== 'function') globalThis.Blob = Blob\n            resolve(true)\n        } else resolve(true)\n\n    } catch (err) {\n        console.log(err)\n        reject(err)\n    }\n})\n\n\n// Import ES6 Modules (and replace their imports with actual file imports!)\nconst re = /import([ \\n\\t]*(?:(?:\\* (?:as .+))|(?:[^ \\n\\t\\{\\}]+[ \\n\\t]*,?)|(?:[ \\n\\t]*\\{(?:[ \\n\\t]*[^ \\n\\t\"'\\{\\}]+[ \\n\\t]*,?)+\\}))[ \\n\\t]*)from[ \\n\\t]*(['\"])([^'\"\\n]+)(?:['\"])([ \\n\\t]*assert[ \\n\\t]*{type:[ \\n\\t]*(['\"])([^'\"\\n]+)(?:['\"])})?/g \nexport const moduleDataURI = (text, mimeType='text/javascript') => `data:${mimeType};base64,` + btoa(text);\n\n// Direct Import of ES6 Modules\nexport const importFromText = async (text, path, collection={}) => {\n    const extension = path.split('.').slice(-1)[0]\n    const isJSON = extension === 'json'\n    let mimeType = isJSON ? 'application/json' : 'application/javascript'\n    const uri = moduleDataURI(text, mimeType)\n    let imported = await (isJSON ? import(uri, { assert: { type: \"json\" } }) : import(uri)).catch((e) => {\n        if (e.message.includes('Unexpected token')) throw new Error('Failed to fetch') // Not found\n        else throw e;\n      });\n\n\n      const ref = {}\n\n    for (let key in imported) {\n        // mimic live bindings\n        Object.defineProperty(ref, key, {\n            get: () => imported[key], // get original import value\n            // set: (input) => imported[key] = input, // NOTE: Is immutable from this interface\n            enumerable: true,\n        })\n     }\n\n     collection[path] = uri// ref\n\n    return imported\n}\n\nexport const resolve = pathUtils.get\n\nconst getText = async (uri) => await globalThis.fetch(uri).then(res => res.text())\n\nconst safeImport =  async (uri, opts = {}) => {\n\n    const {\n        root,\n        onImport = ()=>{},\n        outputText,\n        forceImportFromText\n    } = opts\n\n    const uriCollection = opts.datauri || datauri\n\n    // Make sure fetch is ready\n    await ready\n    \n    // Register in Tree\n    if (opts.dependencies) opts.dependencies[uri] = {}\n\n\n    // Load the WASL file\n    const extension = uri.split('.').slice(-1)[0]\n    const isJSON = extension === \"json\";\n\n     let module = (!forceImportFromText) ? \n     await (isJSON ? import(uri, { assert: { type: \"json\" } }) : import(uri))\n     .catch(() => { }) // is available locally?\n     : undefined;\n\n     let text, originalText;\n    if (!module) {\n\n        text = originalText = await getText(uri)\n\n    try {\n        module = await importFromText(text, uri, uriCollection)\n    }\n\n    // Catch Nested Imports\n    catch (e) {\n\n        const base = pathUtils.get(\"\", uri);\n        let childBase = base;\n\n        // Use a Regular Expression to Splice Out the Import Details\n        const importInfo = []\n        let m;\n        do {\n            m = re.exec(text)\n            if (m == null) m = re.exec(text); // be extra sure (weird bug)\n            if (m) {\n                text = text.replace(m[0], ``) // Replace found text\n                const wildcard = !!m[1].match(/\\*\\s+as/)\n                const variables = m[1].replace(/\\*\\s+as/, '').trim()\n                importInfo.push({\n                    path: m[3],\n                    variables,\n                    wildcard\n                })\n            }\n        } while (m);\n\n        // Import Files Asynchronously\n        for (let i in importInfo){\n            const {variables, wildcard, path} = importInfo[i]\n\n            // Check If Already Exists\n            let correctPath = pathUtils.get(path, childBase)\n            const dependentFilePath = pathUtils.get(correctPath)\n            const dependentFileWithoutRoot = pathUtils.get(dependentFilePath.replace(root ?? '', ''))\n\n            if (opts.dependencies) opts.dependencies[uri][dependentFileWithoutRoot] = importInfo[i]\n            \n            // Check If Already Exists\n            let ref = uriCollection[dependentFilePath]\n            if (!ref) {\n                const extension = correctPath.split('.').slice(-1)[0]\n                const info = await handleFetch(correctPath);\n                let blob = new Blob([info.buffer], { type: info.type });\n                const isJS = extension.includes('js')\n                const newURI = dependentFileWithoutRoot\n                const newText = await blob.text()\n                let importedText = (isJS) ? await new Promise(async (resolve) => {\n                    await safeImport(newURI, {\n                        root: uri, \n                        onImport: (path, info)=> {\n                            onImport(path, info)\n                            if (path == newURI) resolve(info.text)\n                        }, \n                        outputText: true,\n                        forceImportFromText\n                    }) \n                }) : newText\n\n                await importFromText(importedText, correctPath, uriCollection) // registers in text references\n            }\n            \n            text = `import ${(wildcard) ? '* as ' : ''}${variables} from \"${uriCollection[correctPath]}\";\\n${text}`;\n        }\n\n        module = await importFromText(text, uri, uriCollection)\n    }\n}\n\nlet txt = outputText ? text ?? await getText(uri) : void 0\nonImport(uri, {\n  text: txt,\n  file: outputText ? originalText ?? txt : void 0,\n  module\n});\n\nreturn module\n\n}\n\nexport default safeImport", "// src/graphscript/Graph.ts\nfunction parseFunctionFromText(method = \"\") {\n  let getFunctionBody = (methodString) => {\n    return methodString.replace(/^\\W*(function[^{]+\\{([\\s\\S]*)\\}|[^=]+=>[^{]*\\{([\\s\\S]*)\\}|[^=]+=>(.+))/i, \"$2$3$4\");\n  };\n  let getFunctionHead = (methodString) => {\n    let startindex = methodString.indexOf(\"=>\") + 1;\n    if (startindex <= 0) {\n      startindex = methodString.indexOf(\"){\");\n    }\n    if (startindex <= 0) {\n      startindex = methodString.indexOf(\") {\");\n    }\n    return methodString.slice(0, methodString.indexOf(\"{\", startindex) + 1);\n  };\n  let newFuncHead = getFunctionHead(method);\n  let newFuncBody = getFunctionBody(method);\n  let newFunc;\n  if (newFuncHead.includes(\"function\")) {\n    let varName = newFuncHead.split(\"(\")[1].split(\")\")[0];\n    newFunc = new Function(varName, newFuncBody);\n  } else {\n    if (newFuncHead.substring(0, 6) === newFuncBody.substring(0, 6)) {\n      let varName = newFuncHead.split(\"(\")[1].split(\")\")[0];\n      newFunc = new Function(varName, newFuncBody.substring(newFuncBody.indexOf(\"{\") + 1, newFuncBody.length - 1));\n    } else {\n      try {\n        newFunc = (0, eval)(newFuncHead + newFuncBody + \"}\");\n      } catch {\n      }\n    }\n  }\n  return newFunc;\n}\nvar EventHandler = class {\n  constructor() {\n    this.pushToState = {};\n    this.data = {};\n    this.triggers = {};\n    this.setState = (updateObj) => {\n      Object.assign(this.data, updateObj);\n      for (const prop of Object.getOwnPropertyNames(updateObj)) {\n        if (this.triggers[prop])\n          this.triggers[prop].forEach((obj) => obj.onchange(this.data[prop]));\n      }\n      return this.data;\n    };\n    this.subscribeTrigger = (key, onchange) => {\n      if (key) {\n        if (!this.triggers[key]) {\n          this.triggers[key] = [];\n        }\n        let l = this.triggers[key].length;\n        this.triggers[key].push({ idx: l, onchange });\n        return this.triggers[key].length - 1;\n      } else\n        return void 0;\n    };\n    this.unsubscribeTrigger = (key, sub) => {\n      let triggers = this.triggers[key];\n      if (triggers) {\n        if (!sub)\n          delete this.triggers[key];\n        else {\n          let idx = void 0;\n          let obj = triggers.find((o, i) => {\n            if (o.idx === sub) {\n              idx = i;\n              return true;\n            }\n          });\n          if (obj)\n            triggers.splice(idx, 1);\n          return true;\n        }\n      }\n    };\n    this.subscribeTriggerOnce = (key, onchange) => {\n      let sub;\n      let changed = (value) => {\n        onchange(value);\n        this.unsubscribeTrigger(key, sub);\n      };\n      sub = this.subscribeTrigger(key, changed);\n    };\n  }\n};\nvar state = new EventHandler();\nfunction addLocalState(props) {\n  if (!this._state)\n    this._state = {};\n  for (let k in props) {\n    if (k === \"_state\" || k === \"graph\")\n      continue;\n    else {\n      this._state[k] = props[k];\n      if (k in this)\n        this[k] = props[k];\n      else\n        Object.defineProperty(this, k, {\n          get: () => {\n            this._state[k];\n          },\n          set: (v) => {\n            this._state[k] = v;\n            if (this.state.triggers[this._unique])\n              this.setState({ [this._unique]: this._state });\n          },\n          enumerable: true,\n          configurable: true\n        });\n    }\n  }\n}\nvar GraphNode = class {\n  constructor(properties = {}, parent, graph) {\n    this.nodes = /* @__PURE__ */ new Map();\n    this._initial = {};\n    this._unique = `${Math.random()}`;\n    this.state = state;\n    this.isLooping = false;\n    this.isAnimating = false;\n    this.looper = void 0;\n    this.animation = void 0;\n    this.forward = true;\n    this.backward = false;\n    this.reactive = false;\n    this.runSync = false;\n    this.firstRun = true;\n    this.DEBUGNODE = false;\n    this.addLocalState = addLocalState;\n    this.operator = (...args) => {\n      return args;\n    };\n    this.runOp = (...args) => {\n      if (this.DEBUGNODE)\n        console.time(this.tag);\n      let result = this.operator(...args);\n      if (result instanceof Promise) {\n        result.then((res) => {\n          if (res !== void 0)\n            this.setState({ [this.tag]: res });\n          if (this.DEBUGNODE) {\n            console.timeEnd(this.tag);\n            if (result !== void 0)\n              console.log(`${this.tag} result:`, result);\n          }\n          ;\n          return res;\n        });\n      } else {\n        if (result !== void 0)\n          this.setState({ [this.tag]: result });\n        if (this.DEBUGNODE) {\n          console.timeEnd(this.tag);\n          if (result !== void 0)\n            console.log(`${this.tag} result:`, result);\n        }\n        ;\n      }\n      return result;\n    };\n    this.setOperator = (operator) => {\n      if (typeof operator !== \"function\")\n        return operator;\n      this.operator = operator.bind(this);\n      return operator;\n    };\n    this.runAsync = (...args) => {\n      return new Promise((res, rej) => {\n        res(this.run(...args));\n      });\n    };\n    this.transformArgs = (args = []) => args;\n    this.isRunSync = () => {\n      return !(this.children && this.forward || this.parent && this.backward || this.repeat || this.delay || this.frame || this.recursive || this.branch);\n    };\n    this.run = (...args) => {\n      if (typeof this.transformArgs === \"function\")\n        args = this.transformArgs(args, this);\n      if (this.firstRun) {\n        this.firstRun = false;\n        this.runSync = this.isRunSync();\n        if (this.animate && !this.isAnimating) {\n          this.runAnimation(this.animation, args);\n        }\n        if (this.loop && typeof this.loop === \"number\" && !this.isLooping) {\n          this.runLoop(this.looper, args);\n        }\n        if (this.loop || this.animate)\n          return;\n      }\n      if (this.runSync) {\n        let res = this.runOp(...args);\n        return res;\n      }\n      return new Promise(async (resolve) => {\n        if (this) {\n          let run = (node, tick = 0, ...input) => {\n            return new Promise(async (r) => {\n              tick++;\n              let res = await node.runOp(...input);\n              if (node.repeat) {\n                while (tick < node.repeat) {\n                  if (node.delay) {\n                    setTimeout(async () => {\n                      r(await run(node, tick, ...input));\n                    }, node.delay);\n                    break;\n                  } else if (node.frame && window?.requestAnimationFrame) {\n                    requestAnimationFrame(async () => {\n                      r(await run(node, tick, ...input));\n                    });\n                    break;\n                  } else\n                    res = await node.runOp(...input);\n                  tick++;\n                }\n                if (tick === node.repeat) {\n                  r(res);\n                  return;\n                }\n              } else if (node.recursive) {\n                while (tick < node.recursive) {\n                  if (node.delay) {\n                    setTimeout(async () => {\n                      r(await run(node, tick, ...res));\n                    }, node.delay);\n                    break;\n                  } else if (node.frame && window?.requestAnimationFrame) {\n                    requestAnimationFrame(async () => {\n                      r(await run(node, tick, ...res));\n                    });\n                    break;\n                  } else\n                    res = await node.runOp(...res);\n                  tick++;\n                }\n                if (tick === node.recursive) {\n                  r(res);\n                  return;\n                }\n              } else {\n                r(res);\n                return;\n              }\n            });\n          };\n          let runnode = async () => {\n            let res = await run(this, void 0, ...args);\n            if (res !== void 0) {\n              if (this.backward && this.parent instanceof GraphNode) {\n                if (Array.isArray(res))\n                  await this.runParent(this, ...res);\n                else\n                  await this.runParent(this, res);\n              }\n              if (this.children && this.forward) {\n                if (Array.isArray(res))\n                  await this.runChildren(this, ...res);\n                else\n                  await this.runChildren(this, res);\n              }\n              if (this.branch) {\n                this.runBranch(this, res);\n              }\n            }\n            return res;\n          };\n          if (this.delay) {\n            setTimeout(async () => {\n              resolve(await runnode());\n            }, this.delay);\n          } else if (this.frame && window?.requestAnimationFrame) {\n            requestAnimationFrame(async () => {\n              resolve(await runnode());\n            });\n          } else {\n            resolve(await runnode());\n          }\n        } else\n          resolve(void 0);\n      });\n    };\n    this.runParent = async (n, ...args) => {\n      if (n.backward && n.parent) {\n        if (typeof n.parent === \"string\") {\n          if (n.graph && n.graph?.get(n.parent)) {\n            n.parent = n.graph;\n            if (n.parent)\n              this.nodes.set(n.parent.tag, n.parent);\n          } else\n            n.parent = this.nodes.get(n.parent);\n        }\n        if (n.parent instanceof GraphNode)\n          await n.parent.run(...args);\n      }\n    };\n    this.runChildren = async (n, ...args) => {\n      if (typeof n.children === \"object\") {\n        for (const key in n.children) {\n          if (typeof n.children[key] === \"string\") {\n            if (n.graph && n.graph?.get(n.children[key])) {\n              n.children[key] = n.graph.get(n.children[key]);\n              if (!n.nodes.get(n.children[key].tag))\n                n.nodes.set(n.children[key].tag, n.children[key]);\n            }\n            if (!n.children[key] && n.nodes.get(n.children[key]))\n              n.children[key] = n.nodes.get(n.children[key]);\n          } else if (typeof n.children[key] === \"undefined\" || n.children[key] === true) {\n            if (n.graph && n.graph?.get(key)) {\n              n.children[key] = n.graph.get(key);\n              if (!n.nodes.get(n.children[key].tag))\n                n.nodes.set(n.children[key].tag, n.children[key]);\n            }\n            if (!n.children[key] && n.nodes.get(key))\n              n.children[key] = n.nodes.get(key);\n          }\n          if (n.children[key]?.runOp)\n            await n.children[key].run(...args);\n        }\n      }\n    };\n    this.runBranch = async (n, output) => {\n      if (n.branch) {\n        let keys = Object.keys(n.branch);\n        await Promise.all(keys.map(async (k) => {\n          if (typeof n.branch[k].if === \"object\")\n            n.branch[k].if = stringifyFast(n.branch[k].if);\n          let pass = false;\n          if (typeof n.branch[k].if === \"function\") {\n            pass = n.branch[k].if(output);\n          } else {\n            if (typeof output === \"object\") {\n              if (stringifyFast(output) === n.branch[k].if)\n                pass = true;\n            } else if (output === n.branch[k].if)\n              pass = true;\n          }\n          if (pass) {\n            if (n.branch[k].then.run) {\n              if (Array.isArray(output))\n                await n.branch[k].then.run(...output);\n              else\n                await n.branch[k].then.run(...output);\n            } else if (typeof n.branch[k].then === \"function\") {\n              if (Array.isArray(output))\n                await n.branch[k].then(...output);\n              else\n                await n.branch[k].then(output);\n            } else if (typeof n.branch[k].then === \"string\") {\n              if (n.graph)\n                n.branch[k].then = n.graph.nodes.get(n.branch[k].then);\n              else\n                n.branch[k].then = n.nodes.get(n.branch[k].then);\n              if (n.branch[k].then.run) {\n                if (Array.isArray(output))\n                  await n.branch[k].then.run(...output);\n                else\n                  await n.branch[k].then.run(...output);\n              }\n            }\n          }\n          return pass;\n        }));\n      }\n    };\n    this.runAnimation = (animation = this.animation, args = []) => {\n      this.animation = animation;\n      if (!animation)\n        this.animation = this.operator;\n      if (this.animate && !this.isAnimating && \"requestAnimationFrame\" in window) {\n        this.isAnimating = true;\n        let anim = async () => {\n          if (this.isAnimating) {\n            if (this.DEBUGNODE)\n              console.time(this.tag);\n            let result = this.animation.call(this, ...args);\n            if (result instanceof Promise) {\n              result = await result;\n            }\n            if (this.DEBUGNODE) {\n              console.timeEnd(this.tag);\n              if (result !== void 0)\n                console.log(`${this.tag} result:`, result);\n            }\n            ;\n            if (result !== void 0) {\n              if (this.tag)\n                this.setState({ [this.tag]: result });\n              if (this.backward && this.parent?.run) {\n                if (Array.isArray(result))\n                  await this.runParent(this, ...result);\n                else\n                  await this.runParent(this, result);\n              }\n              if (this.children && this.forward) {\n                if (Array.isArray(result))\n                  await this.runChildren(this, ...result);\n                else\n                  await this.runChildren(this, result);\n              }\n              if (this.branch) {\n                this.runBranch(this, result);\n              }\n              this.setState({ [this.tag]: result });\n            }\n            requestAnimationFrame(anim);\n          }\n        };\n        requestAnimationFrame(anim);\n      }\n    };\n    this.runLoop = (loop = this.looper, args = [], timeout = this.loop) => {\n      this.looper = loop;\n      if (!loop)\n        this.looper = this.operator;\n      if (typeof timeout === \"number\" && !this.isLooping) {\n        this.isLooping = true;\n        let looping = async () => {\n          if (this.isLooping) {\n            if (this.DEBUGNODE)\n              console.time(this.tag);\n            let result = this.looper.call(this, ...args);\n            if (result instanceof Promise) {\n              result = await result;\n            }\n            if (this.DEBUGNODE) {\n              console.timeEnd(this.tag);\n              if (result !== void 0)\n                console.log(`${this.tag} result:`, result);\n            }\n            ;\n            if (result !== void 0) {\n              if (this.tag)\n                this.setState({ [this.tag]: result });\n              if (this.backward && this.parent?.run) {\n                if (Array.isArray(result))\n                  await this.runParent(this, ...result);\n                else\n                  await this.runParent(this, result);\n              }\n              if (this.children && this.forward) {\n                if (Array.isArray(result))\n                  await this.runChildren(this, ...result);\n                else\n                  await this.runChildren(this, result);\n              }\n              if (this.branch) {\n                this.runBranch(this, result);\n              }\n              this.setState({ [this.tag]: result });\n            }\n            setTimeout(async () => {\n              await looping();\n            }, timeout);\n          }\n        };\n        looping();\n      }\n    };\n    this.setParent = (parent) => {\n      this.parent = parent;\n      if (this.backward)\n        this.runSync = false;\n    };\n    this.setChildren = (children) => {\n      this.children = children;\n      if (this.forward)\n        this.runSync = false;\n    };\n    this.add = (n = {}) => {\n      if (typeof n === \"function\")\n        n = { operator: n };\n      if (n?.node instanceof GraphNode)\n        n = n.node;\n      if (!(n instanceof GraphNode))\n        n = new GraphNode(n.node ?? n, this, this.graph);\n      this.nodes.set(n.tag, n);\n      if (this.graph) {\n        this.graph.nodes.set(n.tag, n);\n        this.graph.nNodes = this.graph.nodes.size;\n      }\n      return n;\n    };\n    this.remove = (n) => {\n      if (typeof n === \"string\")\n        n = this.nodes.get(n);\n      if (n?.tag) {\n        this.nodes.delete(n.tag);\n        if (this.children[n.tag])\n          delete this.children[n.tag];\n        if (this.graph) {\n          this.graph.nodes.delete(n.tag);\n          this.graph.nNodes = this.graph.nodes.size;\n        }\n        this.nodes.forEach((n2) => {\n          if (n2.nodes.get(n2.tag)) {\n            n2.nodes.delete(n2.tag);\n            if (n2.children[n2.tag])\n              delete n2.children[n2.tag];\n            if (n2.parent?.tag === n2.tag)\n              delete n2.parent;\n          }\n        });\n        if (n.ondelete)\n          n.ondelete(n);\n      }\n      if (typeof this._state === \"object\") {\n        this.state.unsubscribeTrigger(this._unique);\n      }\n    };\n    this.append = (n, parentNode = this) => {\n      if (typeof n === \"string\")\n        n = this.nodes.get(n);\n      if (n?.nodes) {\n        parentNode.addChildren(n);\n        if (n.forward)\n          n.runSync = false;\n      }\n    };\n    this.subscribe = (callback, tag = this.tag) => {\n      if (typeof callback === \"string\") {\n        if (this.graph)\n          callback = this.graph.get(callback);\n        else\n          callback = this.nodes.get(callback);\n      }\n      if (typeof callback === \"function\") {\n        return this.state.subscribeTrigger(tag, callback);\n      } else if (callback)\n        return this.state.subscribeTrigger(tag, (res) => {\n          callback.run(res);\n        });\n    };\n    this.unsubscribe = (sub, tag = this.tag) => {\n      return this.state.unsubscribeTrigger(tag, sub);\n    };\n    this.subscribeState = (callback) => {\n      if (!this.reactive) {\n        return void 0;\n      } else {\n        if (typeof callback === \"string\") {\n          if (this.graph)\n            callback = this.graph.get(callback);\n          else\n            callback = this.nodes.get(callback);\n        }\n        if (typeof callback === \"function\") {\n          return this.state.subscribeTrigger(this._unique, callback);\n        } else if (callback)\n          return this.state.subscribeTrigger(this._unique, (_state) => {\n            callback.run(_state);\n          });\n      }\n    };\n    this.addChildren = (children) => {\n      if (!this.children)\n        this.children = {};\n      if (typeof children === \"object\") {\n        Object.assign(this.children, children);\n      }\n      this.convertChildrenToNodes();\n      if (this.forward)\n        this.runSync = false;\n    };\n    this.callParent = (...args) => {\n      if (typeof this.parent === \"string\") {\n        if (this.graph && this.graph?.get(this.parent)) {\n          this.parent = this.graph;\n          if (this.parent)\n            this.nodes.set(this.parent.tag, this.parent);\n        } else\n          this.parent = this.nodes.get(this.parent);\n      }\n      if (typeof this.parent?.operator === \"function\")\n        return this.parent.runOp(...args);\n    };\n    this.callChildren = (...args) => {\n      let result;\n      if (typeof this.children === \"object\") {\n        for (const key in this.children) {\n          if (this.children[key]?.runOp)\n            this.children[key].runOp(...args);\n        }\n      }\n      return result;\n    };\n    this.getProps = (n = this, getInitial = true) => {\n      let baseprops = {\n        tag: n.tag,\n        operator: n.operator,\n        graph: n.graph,\n        children: n.children,\n        parent: n.parent,\n        forward: n.forward,\n        backward: n.bacward,\n        loop: n.loop,\n        animate: n.animate,\n        frame: n.frame,\n        delay: n.delay,\n        recursive: n.recursive,\n        repeat: n.repeat,\n        branch: n.branch,\n        oncreate: n.oncreate,\n        reactive: n.reactive,\n        DEBUGNODE: n.DEBUGNODE\n      };\n      if (!getInitial) {\n        let uniqueprops = {};\n        for (const key in this._initial) {\n          uniqueprops[key] = this[key];\n        }\n        return Object.assign(baseprops, uniqueprops);\n      } else\n        return {\n          tag: n.tag,\n          operator: n.operator,\n          graph: n.graph,\n          children: n.children,\n          parent: n.parent,\n          forward: n.forward,\n          backward: n.bacward,\n          loop: n.loop,\n          animate: n.animate,\n          frame: n.frame,\n          delay: n.delay,\n          recursive: n.recursive,\n          repeat: n.repeat,\n          branch: n.branch,\n          oncreate: n.oncreate,\n          reactive: n.reactive,\n          DEBUGNODE: n.DEBUGNODE,\n          ...this._initial\n        };\n    };\n    this.setProps = (props = {}) => {\n      let tmp = Object.assign({}, props);\n      if (tmp.children) {\n        this.addChildren(props.children);\n        delete tmp.children;\n      }\n      if (tmp.operator) {\n        this.setOperator(props.operator);\n        delete tmp.operator;\n      }\n      Object.assign(tmp, props);\n      this.runSync = this.isRunSync();\n    };\n    this.removeTree = (n) => {\n      if (n) {\n        if (typeof n === \"string\")\n          n = this.nodes.get(n);\n      }\n      if (n?.nodes) {\n        let checked = {};\n        const recursivelyRemove = (node) => {\n          if (typeof node.children === \"object\" && !checked[node.tag]) {\n            checked[node.tag] = true;\n            for (const key in node.children) {\n              if (node.children[key].stopNode)\n                node.children[key].stopNode();\n              if (node.children[key].tag) {\n                if (this.nodes.get(node.children[key].tag))\n                  this.nodes.delete(node.children[key].tag);\n                this.nodes.forEach((n2) => {\n                  if (n2.nodes.get(node.children[key].tag))\n                    n2.nodes.delete(node.children[key].tag);\n                  if (n2.children[key] instanceof GraphNode)\n                    delete n2.children[key];\n                });\n                recursivelyRemove(node.children[key]);\n              }\n            }\n          }\n        };\n        if (n.stopNode)\n          n.stopNode();\n        if (n.tag) {\n          this.nodes.delete(n.tag);\n          if (this.children[n.tag])\n            delete this.children[n.tag];\n          if (this.parent?.tag === n.tag)\n            delete this.parent;\n          if (this[n.tag] instanceof GraphNode)\n            delete this[n.tag];\n          this.nodes.forEach((n2) => {\n            if (n2?.tag) {\n              if (n2.nodes.get(n2.tag))\n                n2.nodes.delete(n2.tag);\n              if (n2.children[n2.tag] instanceof GraphNode)\n                delete n2.children[n2.tag];\n            }\n          });\n          recursivelyRemove(n);\n          if (this.graph)\n            this.graph.removeTree(n, checked);\n          else if (n.ondelete)\n            n.ondelete(n);\n        }\n      }\n    };\n    this.checkNodesHaveChildMapped = (n, child, checked = {}) => {\n      let tag = n.tag;\n      if (!tag)\n        tag = n.name;\n      if (!checked[tag]) {\n        checked[tag] = true;\n        if (n.children) {\n          if (child.tag in n.children) {\n            if (n.children[child.tag] instanceof GraphNode) {\n              if (!n.nodes.get(child.tag))\n                n.nodes.set(child.tag, child);\n              n.children[child.tag] = child;\n              if (!n.firstRun)\n                n.firstRun = true;\n            }\n          }\n        }\n        if (n.parent instanceof GraphNode) {\n          if (n.nodes.get(child.tag))\n            n.parent.nodes.set(child.tag, child);\n          if (n.parent.children) {\n            this.checkNodesHaveChildMapped(n.parent, child, checked);\n          } else if (n.nodes) {\n            n.nodes.forEach((n2) => {\n              if (!checked[n2.tag]) {\n                this.checkNodesHaveChildMapped(n2, child, checked);\n              }\n            });\n          }\n        }\n        if (n.graph) {\n          if (n.parent && n.parent.name !== n.graph.name) {\n            n.graph.nodes.forEach((n2) => {\n              if (!checked[n2.tag]) {\n                this.checkNodesHaveChildMapped(n2, child, checked);\n              }\n            });\n          }\n        }\n      }\n    };\n    this.convertChildrenToNodes = (n = this) => {\n      if (n?.children) {\n        for (const key in n.children) {\n          if (!(n.children[key] instanceof GraphNode)) {\n            if (typeof n.children[key] === \"object\") {\n              if (!n.children[key].tag)\n                n.children[key].tag = key;\n              if (!n.nodes.get(n.children[key].tag)) {\n                n.children[key] = new GraphNode(n.children[key], n, n.graph);\n                this.checkNodesHaveChildMapped(n, n.children[key]);\n              }\n            } else {\n              if (typeof n.children[key] === \"undefined\" || n.children[key] == true) {\n                n.children[key] = n.graph.get(key);\n                if (!n.children[key])\n                  n.children[key] = n.nodes.get(key);\n              } else if (typeof n.children[key] === \"string\") {\n                let k = n.children[key];\n                n.children[key] = n.graph.get(k);\n                if (!n.children[key])\n                  n.children[key] = n.nodes.get(key);\n              }\n              if (n.children[key] instanceof GraphNode) {\n                n.nodes.set(n.children[key].tag, n.children[key]);\n                this.checkNodesHaveChildMapped(n, n.children[key]);\n                if (!(n.children[key].tag in n))\n                  n[n.children[key].tag] = n.children[key];\n              }\n            }\n          }\n        }\n      }\n      return n.children;\n    };\n    this.stopLooping = (n = this) => {\n      n.isLooping = false;\n    };\n    this.stopAnimating = (n = this) => {\n      n.isAnimating = false;\n    };\n    this.stopNode = (n = this) => {\n      n.stopAnimating(n);\n      n.stopLooping(n);\n    };\n    this.subscribeNode = (n) => {\n      if (typeof n === \"string\")\n        n = this.nodes.get(n);\n      if (n.tag)\n        this.nodes.set(n.tag, n);\n      if (n)\n        return this.state.subscribeTrigger(this.tag, (res) => {\n          if (Array.isArray(res))\n            n.run(...res);\n          else\n            n.run(res);\n        });\n    };\n    this.print = (n = this, printChildren = true, nodesPrinted = []) => {\n      let dummyNode = new GraphNode();\n      if (typeof n === \"string\")\n        n = this.nodes.get(n);\n      if (n instanceof GraphNode) {\n        nodesPrinted.push(n.tag);\n        let jsonToPrint = {\n          tag: n.tag,\n          operator: n.operator.toString()\n        };\n        if (n.parent)\n          jsonToPrint.parent = n.parent.tag;\n        if (typeof n.children === \"object\") {\n          for (const key in n.children) {\n            if (typeof n.children[key] === \"string\")\n              return n.children[key];\n            if (nodesPrinted.includes(n.children[key].tag))\n              return n.children[key].tag;\n            else if (!printChildren) {\n              return n.children[key].tag;\n            } else\n              return n.children[key].print(n.children[key], printChildren, nodesPrinted);\n          }\n        }\n        for (const prop in n) {\n          if (prop === \"parent\" || prop === \"children\")\n            continue;\n          if (typeof dummyNode[prop] === \"undefined\") {\n            if (typeof n[prop] === \"function\") {\n              jsonToPrint[prop] = n[prop].toString();\n            } else if (typeof n[prop] === \"object\") {\n              jsonToPrint[prop] = JSON.stringifyWithCircularRefs(n[prop]);\n            } else {\n              jsonToPrint[prop] = n[prop];\n            }\n          }\n        }\n        return JSON.stringify(jsonToPrint);\n      }\n    };\n    this.reconstruct = (json) => {\n      let parsed = reconstructObject(json);\n      if (parsed)\n        return this.add(parsed);\n    };\n    this.setState = (data) => {\n      this.state.setState(data);\n    };\n    this.DEBUGNODES = (debugging = true) => {\n      this.DEBUGNODE = debugging;\n      this.nodes.forEach((n) => {\n        if (debugging)\n          n.DEBUGNODE = true;\n        else\n          n.DEBUGNODE = false;\n      });\n    };\n    if (typeof properties === \"function\") {\n      properties = { operator: properties };\n    }\n    if (typeof properties === \"object\") {\n      if (properties instanceof GraphNode && properties._initial)\n        Object.assign(properties, properties._initial);\n      if (properties instanceof Graph) {\n        let source = properties;\n        properties = {\n          source,\n          operator: (input) => {\n            if (typeof input === \"object\") {\n              let result = {};\n              for (const key in input) {\n                if (typeof source[key] === \"function\") {\n                  if (Array.isArray(input[key]))\n                    result[key] = source[key](...input[key]);\n                  else\n                    result[key] = source[key](input[key]);\n                } else {\n                  source[key] = input[key];\n                  result[key] = source[key];\n                }\n              }\n              return result;\n            }\n            return source;\n          }\n        };\n        if (source.operator)\n          properties.operator = source.operator;\n        if (source.children)\n          properties.children = source.children;\n        if (source.forward)\n          properties.forward = source.forward;\n        if (source.backward)\n          properties.backward = source.backward;\n        if (source.repeat)\n          properties.repeat = source.repeat;\n        if (source.recursive)\n          properties.recursive = source.recursive;\n        if (source.loop)\n          properties.loop = source.loop;\n        if (source.animate)\n          properties.animate = source.animate;\n        if (source.looper)\n          properties.looper = source.looper;\n        if (source.animation)\n          properties.animation = source.animation;\n        if (source.delay)\n          properties.delay = source.delay;\n        if (source.oncreate)\n          properties.oncreate = source.oncreate;\n        if (source.node) {\n          if (source.node._initial)\n            Object.assign(properties, source.node._initial);\n        }\n        if (source._initial)\n          Object.assign(properties, source._initial);\n        if (source.tag)\n          properties.tag = source.tag;\n        this.nodes = source.nodes;\n        source.node = this;\n        if (graph) {\n          source.nodes.forEach((n) => {\n            if (!graph.nodes.get(n.tag)) {\n              graph.nodes.set(n.tag, n);\n              graph.nNodes++;\n            }\n          });\n        }\n      }\n      if (typeof parent === \"string\") {\n        if (graph)\n          parent = graph.nodes.get(parent);\n        else\n          parent = void 0;\n      }\n      if (properties.tag && (graph || parent)) {\n        let hasnode;\n        if (graph?.nodes) {\n          hasnode = graph.nodes.get(properties.tag);\n        }\n        if (!hasnode && parent?.nodes) {\n          hasnode = parent.nodes.get(properties.tag);\n        }\n        if (hasnode) {\n          if (this.reactive) {\n            this.addLocalState(hasnode);\n          }\n          if (!this.source)\n            this.source = hasnode;\n          let props = hasnode.getProps();\n          delete props.graph;\n          delete props.parent;\n          for (let k in props)\n            properties[k] = props[k];\n        }\n      }\n      if (properties?.operator) {\n        properties.operator = this.setOperator(properties.operator);\n      }\n      if (!properties.tag && graph) {\n        properties.tag = `node${graph.nNodes}`;\n      } else if (!properties.tag) {\n        properties.tag = `node${Math.floor(Math.random() * 1e10)}`;\n      }\n      let keys = Object.getOwnPropertyNames(this);\n      for (const key in properties) {\n        if (!keys.includes(key))\n          this._initial[key] = properties[key];\n      }\n      if (properties.children)\n        this._initial.children = Object.assign({}, properties.children);\n      if (properties.run) {\n        console.log(\"Transferring\", properties, \"to\", this);\n      }\n      Object.assign(this, properties);\n      if (!this.tag) {\n        if (graph) {\n          this.tag = `node${graph.nNodes}`;\n        } else {\n          this.tag = `node${Math.floor(Math.random() * 1e10)}`;\n        }\n      }\n      if (graph) {\n        this.graph = graph;\n        if (graph.nodes.get(this.tag)) {\n          this.tag = `${this.tag}${graph.nNodes + 1}`;\n        }\n        graph.nodes.set(this.tag, this);\n        graph.nNodes++;\n        this.state = graph.state;\n      }\n      if (this.reactive) {\n        addLocalState(properties);\n        if (typeof this.reactive === \"function\") {\n          this.state.subscribeTrigger(this._unique, this.reactive);\n        }\n      }\n      if (typeof parent === \"object\") {\n        this.parent = parent;\n        if (parent instanceof GraphNode || parent instanceof Graph)\n          parent.nodes.set(this.tag, this);\n      }\n      if (typeof properties.tree === \"object\") {\n        for (const key in properties.tree) {\n          if (typeof properties.tree[key] === \"object\") {\n            if ((!properties.tree[key]).tag) {\n              properties.tree[key].tag = key;\n            }\n          }\n          let node = new GraphNode(properties.tree[key], this, graph);\n          this.nodes.set(node.tag, node);\n        }\n      }\n      if (this.children)\n        this.convertChildrenToNodes(this);\n      if (this.parent instanceof GraphNode || this.parent instanceof Graph)\n        this.checkNodesHaveChildMapped(this.parent, this);\n      if (typeof this.oncreate === \"function\")\n        this.oncreate(this);\n      if (!this.firstRun)\n        this.firstRun = true;\n      if (this.animation && !this.animate)\n        this.animate = true;\n    } else\n      return properties;\n  }\n};\nvar Graph = class {\n  constructor(tree, tag, props) {\n    this.nNodes = 0;\n    this.nodes = /* @__PURE__ */ new Map();\n    this.state = new EventHandler();\n    this._unique = `${Math.random()}`;\n    this.tree = {};\n    this.addLocalState = addLocalState;\n    this.add = (n = {}) => {\n      if (n?.node instanceof GraphNode)\n        n = n.node;\n      let props = n;\n      if (!(n instanceof GraphNode))\n        n = new GraphNode(props?.node ?? props, this, this);\n      else {\n        this.nNodes = this.nodes.size;\n        if (n.tag) {\n          this.tree[n.tag] = props;\n          this.nodes.set(n.tag, n);\n        }\n      }\n      return n;\n    };\n    this.setTree = (tree = this.tree) => {\n      if (!tree)\n        return;\n      for (const node in tree) {\n        const n = this.nodes.get(node);\n        if (!n) {\n          if (typeof tree[node] === \"function\") {\n            this.add({ tag: node, operator: tree[node] });\n          } else if (typeof tree[node] === \"object\" && !Array.isArray(tree[node])) {\n            if (!tree[node].tag)\n              tree[node].tag = node;\n            let newNode = this.add(tree[node]);\n            if (tree[node].aliases) {\n              tree[node].aliases.forEach((a) => {\n                this.nodes.set(a, newNode);\n              });\n            }\n          } else {\n            this.add({ tag: node, operator: (...args) => {\n              return tree[node];\n            } });\n          }\n        } else {\n          if (typeof tree[node] === \"function\") {\n            n.setOperator(tree[node]);\n          } else if (typeof tree[node] === \"object\") {\n            if (tree[node] instanceof GraphNode) {\n              this.add(tree[node]);\n            } else if (tree[node] instanceof Graph) {\n              let source = tree[node];\n              let properties = {};\n              if (source.operator)\n                properties.operator = source.operator;\n              if (source.children)\n                properties.children = source.children;\n              if (source.forward)\n                properties.forward = source.forward;\n              if (source.backward)\n                properties.backward = source.backward;\n              if (source.repeat)\n                properties.repeat = source.repeat;\n              if (source.recursive)\n                properties.recursive = source.recursive;\n              if (source.loop)\n                properties.loop = source.loop;\n              if (source.animate)\n                properties.animate = source.animate;\n              if (source.looper)\n                properties.looper = source.looper;\n              if (source.animation)\n                properties.animation = source.animation;\n              if (source.delay)\n                properties.delay = source.delay;\n              if (source.tag)\n                properties.tag = source.tag;\n              if (source.oncreate)\n                properties.oncreate = source.oncreate;\n              if (source.node?._initial)\n                Object.assign(properties, source.node._initial);\n              properties.nodes = source.nodes;\n              properties.source = source;\n              n.setProps(properties);\n            } else {\n              n.setProps(tree[node]);\n            }\n          }\n        }\n      }\n      this.nodes.forEach((node) => {\n        if (typeof node.children === \"object\") {\n          for (const key in node.children) {\n            if (typeof node.children[key] === \"string\") {\n              if (this.nodes.get(node.children[key])) {\n                node.children[key] = this.nodes.get(node.children[key]);\n              }\n            } else if (node.children[key] === true || typeof node.children[key] === \"undefined\") {\n              if (this.nodes.get(key)) {\n                node.children[key] = this.nodes.get(key);\n              }\n            }\n            if (node.children[key] instanceof GraphNode) {\n              node.checkNodesHaveChildMapped(node, node.children[key]);\n            }\n          }\n        }\n        if (typeof node.parent === \"string\") {\n          if (this.nodes.get(node.parent)) {\n            node.parent = this.nodes.get(node.parent);\n            node.nodes.set(node.parent.tag, node.parent);\n          }\n        }\n      });\n    };\n    this.get = (tag) => {\n      return this.nodes.get(tag);\n    };\n    this.set = (n) => {\n      return this.nodes.set(n.tag, n);\n    };\n    this.run = (n, ...args) => {\n      if (typeof n === \"string\")\n        n = this.nodes.get(n);\n      if (n?.run)\n        return n.run(...args);\n      else\n        return void 0;\n    };\n    this.runAsync = (n, ...args) => {\n      if (typeof n === \"string\")\n        n = this.nodes.get(n);\n      if (n?.run)\n        return new Promise((res, rej) => {\n          res(n.run(...args));\n        });\n      else\n        return new Promise((res, rej) => {\n          res(void 0);\n        });\n    };\n    this.removeTree = (n, checked) => {\n      if (typeof n === \"string\")\n        n = this.nodes.get(n);\n      if (n?.nodes) {\n        if (!checked)\n          checked = {};\n        const recursivelyRemove = (node) => {\n          if (node.children && !checked[node.tag]) {\n            checked[node.tag] = true;\n            if (Array.isArray(node.children)) {\n              node.children.forEach((c) => {\n                if (c.stopNode)\n                  c.stopNode();\n                if (c.tag) {\n                  if (this.nodes.get(c.tag))\n                    this.nodes.delete(c.tag);\n                }\n                this.nodes.forEach((n2) => {\n                  if (n2.nodes.get(c.tag))\n                    n2.nodes.delete(c.tag);\n                });\n                recursivelyRemove(c);\n              });\n            } else if (typeof node.children === \"object\") {\n              if (node.stopNode)\n                node.stopNode();\n              if (node.tag) {\n                if (this.nodes.get(node.tag))\n                  this.nodes.delete(node.tag);\n              }\n              this.nodes.forEach((n2) => {\n                if (n2.nodes.get(node.tag))\n                  n2.nodes.delete(node.tag);\n              });\n              recursivelyRemove(node);\n            }\n          }\n        };\n        if (n.stopNode)\n          n.stopNode();\n        if (n.tag) {\n          this.nodes.delete(n.tag);\n          this.nodes.forEach((n2) => {\n            if (n2.nodes.get(n2.tag))\n              n2.nodes.delete(n2.tag);\n          });\n          this.nNodes = this.nodes.size;\n          recursivelyRemove(n);\n        }\n        if (n.ondelete)\n          n.ondelete(n);\n      }\n      return n;\n    };\n    this.remove = (n) => {\n      if (typeof n === \"string\")\n        n = this.nodes.get(n);\n      if (n?.nodes) {\n        if (n.stopNode)\n          n.stopNode();\n        if (n?.tag) {\n          if (this.nodes.get(n.tag)) {\n            this.nodes.delete(n.tag);\n            this.nodes.forEach((n2) => {\n              if (n2.nodes.get(n2.tag))\n                n2.nodes.delete(n2.tag);\n            });\n          }\n        }\n        if (n.ondelete)\n          n.ondelete(n);\n      }\n      return n;\n    };\n    this.append = (n, parentNode) => {\n      parentNode.addChildren(n);\n    };\n    this.callParent = async (n, ...args) => {\n      if (n?.parent) {\n        return await n.callParent(...args);\n      }\n    };\n    this.callChildren = async (n, ...args) => {\n      if (n?.children) {\n        return await n.callChildren(...args);\n      }\n    };\n    this.subscribe = (n, callback) => {\n      if (!callback)\n        return;\n      if (n?.subscribe && typeof callback === \"function\") {\n        return n.subscribe(callback);\n      } else if (callback instanceof GraphNode || typeof callback === \"string\")\n        return this.subscribeNode(n, callback);\n      else if (typeof n == \"string\") {\n        return this.state.subscribeTrigger(n, callback);\n      }\n    };\n    this.unsubscribe = (tag, sub) => {\n      return this.state.unsubscribeTrigger(tag, sub);\n    };\n    this.subscribeState = (callback) => {\n      if (!this.reactive) {\n        return void 0;\n      } else {\n        if (typeof callback === \"string\") {\n          if (this.graph)\n            callback = this.graph.get(callback);\n          else\n            callback = this.nodes.get(callback);\n        }\n        if (typeof callback === \"function\") {\n          return this.state.subscribeTrigger(this._unique, callback);\n        } else if (callback)\n          return this.state.subscribeTrigger(this._unique, (_state) => {\n            callback.run(_state);\n          });\n      }\n    };\n    this.subscribeNode = (inputNode, outputNode) => {\n      let tag;\n      if (inputNode?.tag)\n        tag = inputNode.tag;\n      else if (typeof inputNode === \"string\")\n        tag = inputNode;\n      if (typeof outputNode === \"string\")\n        outputNode = this.nodes.get(outputNode);\n      if (inputNode && outputNode) {\n        let sub = this.state.subscribeTrigger(tag, (res) => {\n          if (Array.isArray(res))\n            outputNode.run(...res);\n          else\n            outputNode.run(res);\n        });\n        return sub;\n      }\n    };\n    this.stopNode = (n) => {\n      if (typeof n === \"string\") {\n        n = this.nodes.get(n);\n      }\n      if (n?.stopNode) {\n        n.stopNode();\n      }\n    };\n    this.print = (n, printChildren = true) => {\n      if (n?.print)\n        return n.print(n, printChildren);\n      else {\n        let printed = `{`;\n        this.nodes.forEach((n2) => {\n          printed += `\n\"${n2.tag}:${n2.print(n2, printChildren)}\"`;\n        });\n        return printed;\n      }\n    };\n    this.reconstruct = (json) => {\n      let parsed = reconstructObject(json);\n      if (parsed)\n        return this.add(parsed);\n    };\n    this.create = (operator, parentNode, props) => {\n      return createNode(operator, parentNode, props, this);\n    };\n    this.setState = (data) => {\n      this.state.setState(data);\n    };\n    this.DEBUGNODES = (debugging = true) => {\n      this.nodes.forEach((n) => {\n        if (debugging)\n          n.DEBUGNODE = true;\n        else\n          n.DEBUGNODE = false;\n      });\n    };\n    this.tag = tag ? tag : `graph${Math.floor(Math.random() * 1e11)}`;\n    if (props) {\n      if (props.reactive) {\n        this.addLocalState(props);\n      } else\n        Object.assign(this, props);\n      this._initial = props;\n    }\n    if (tree || Object.keys(this.tree).length > 0)\n      this.setTree(tree);\n  }\n};\nfunction reconstructObject(json = \"{}\") {\n  try {\n    let parsed = typeof json === \"string\" ? JSON.parse(json) : json;\n    const parseObj = (obj) => {\n      for (const prop in obj) {\n        if (typeof obj[prop] === \"string\") {\n          let funcParsed = parseFunctionFromText(obj[prop]);\n          if (typeof funcParsed === \"function\") {\n            obj[prop] = funcParsed;\n          }\n        } else if (typeof obj[prop] === \"object\") {\n          parseObj(obj[prop]);\n        }\n      }\n      return obj;\n    };\n    return parseObj(parsed);\n  } catch (err) {\n    console.error(err);\n    return void 0;\n  }\n}\nvar stringifyWithCircularRefs = function() {\n  const refs = /* @__PURE__ */ new Map();\n  const parents = [];\n  const path = [\"this\"];\n  function clear() {\n    refs.clear();\n    parents.length = 0;\n    path.length = 1;\n  }\n  function updateParents(key, value) {\n    var idx = parents.length - 1;\n    var prev = parents[idx];\n    if (typeof prev === \"object\") {\n      if (prev[key] === value || idx === 0) {\n        path.push(key);\n        parents.push(value.pushed);\n      } else {\n        while (idx-- >= 0) {\n          prev = parents[idx];\n          if (typeof prev === \"object\") {\n            if (prev[key] === value) {\n              idx += 2;\n              parents.length = idx;\n              path.length = idx;\n              --idx;\n              parents[idx] = value;\n              path[idx] = key;\n              break;\n            }\n          }\n          idx--;\n        }\n      }\n    }\n  }\n  function checkCircular(key, value) {\n    if (value != null) {\n      if (typeof value === \"object\") {\n        if (key) {\n          updateParents(key, value);\n        }\n        let other = refs.get(value);\n        if (other) {\n          return \"[Circular Reference]\" + other;\n        } else {\n          refs.set(value, path.join(\".\"));\n        }\n      }\n    }\n    return value;\n  }\n  return function stringifyWithCircularRefs2(obj, space) {\n    try {\n      parents.push(obj);\n      return JSON.stringify(obj, checkCircular, space);\n    } finally {\n      clear();\n    }\n  };\n}();\nif (JSON.stringifyWithCircularRefs === void 0) {\n  JSON.stringifyWithCircularRefs = stringifyWithCircularRefs;\n}\nvar stringifyFast = function() {\n  const refs = /* @__PURE__ */ new Map();\n  const parents = [];\n  const path = [\"this\"];\n  function clear() {\n    refs.clear();\n    parents.length = 0;\n    path.length = 1;\n  }\n  function updateParents(key, value) {\n    var idx = parents.length - 1;\n    if (parents[idx]) {\n      var prev = parents[idx];\n      if (typeof prev === \"object\") {\n        if (prev[key] === value || idx === 0) {\n          path.push(key);\n          parents.push(value.pushed);\n        } else {\n          while (idx-- >= 0) {\n            prev = parents[idx];\n            if (typeof prev === \"object\") {\n              if (prev[key] === value) {\n                idx += 2;\n                parents.length = idx;\n                path.length = idx;\n                --idx;\n                parents[idx] = value;\n                path[idx] = key;\n                break;\n              }\n            }\n            idx++;\n          }\n        }\n      }\n    }\n  }\n  function checkValues(key, value) {\n    let val;\n    if (value != null) {\n      if (typeof value === \"object\") {\n        let c = value.constructor.name;\n        if (key && c === \"Object\") {\n          updateParents(key, value);\n        }\n        let other = refs.get(value);\n        if (other) {\n          return \"[Circular Reference]\" + other;\n        } else {\n          refs.set(value, path.join(\".\"));\n        }\n        if (c === \"Array\") {\n          if (value.length > 20) {\n            val = value.slice(value.length - 20);\n          } else\n            val = value;\n        } else if (c.includes(\"Set\")) {\n          val = Array.from(value);\n        } else if (c !== \"Object\" && c !== \"Number\" && c !== \"String\" && c !== \"Boolean\") {\n          val = \"instanceof_\" + c;\n        } else if (c === \"Object\") {\n          let obj = {};\n          for (const prop in value) {\n            if (value[prop] == null) {\n              obj[prop] = value[prop];\n            } else if (Array.isArray(value[prop])) {\n              if (value[prop].length > 20)\n                obj[prop] = value[prop].slice(value[prop].length - 20);\n              else\n                obj[prop] = value[prop];\n            } else if (value[prop].constructor.name === \"Object\") {\n              obj[prop] = {};\n              for (const p in value[prop]) {\n                if (Array.isArray(value[prop][p])) {\n                  if (value[prop][p].length > 20)\n                    obj[prop][p] = value[prop][p].slice(value[prop][p].length - 20);\n                  else\n                    obj[prop][p] = value[prop][p];\n                } else {\n                  if (value[prop][p] != null) {\n                    let con = value[prop][p].constructor.name;\n                    if (con.includes(\"Set\")) {\n                      obj[prop][p] = Array.from(value[prop][p]);\n                    } else if (con !== \"Number\" && con !== \"String\" && con !== \"Boolean\") {\n                      obj[prop][p] = \"instanceof_\" + con;\n                    } else {\n                      obj[prop][p] = value[prop][p];\n                    }\n                  } else {\n                    obj[prop][p] = value[prop][p];\n                  }\n                }\n              }\n            } else {\n              let con = value[prop].constructor.name;\n              if (con.includes(\"Set\")) {\n                obj[prop] = Array.from(value[prop]);\n              } else if (con !== \"Number\" && con !== \"String\" && con !== \"Boolean\") {\n                obj[prop] = \"instanceof_\" + con;\n              } else {\n                obj[prop] = value[prop];\n              }\n            }\n          }\n          val = obj;\n        } else {\n          val = value;\n        }\n      } else {\n        val = value;\n      }\n    }\n    return val;\n  }\n  return function stringifyFast2(obj, space) {\n    parents.push(obj);\n    let res = JSON.stringify(obj, checkValues, space);\n    clear();\n    return res;\n  };\n}();\nif (JSON.stringifyFast === void 0) {\n  JSON.stringifyFast = stringifyFast;\n}\nfunction createNode(operator, parentNode, props, graph) {\n  if (typeof props === \"object\") {\n    props.operator = operator;\n    return new GraphNode(props, parentNode, graph);\n  }\n  return new GraphNode({ operator }, parentNode, graph);\n}\n\n// src/graphscript/services/dom/DOMElement.js\nvar DOMElement = class extends HTMLElement {\n  template = function(self2 = this, props) {\n    return `<div> Custom Fragment Props: ${JSON.stringify(props)} </div>`;\n  };\n  props = {};\n  useShadow = false;\n  styles;\n  oncreate;\n  onresize;\n  ondelete;\n  onchanged;\n  renderonchanged = false;\n  FRAGMENT;\n  STYLE;\n  attachedShadow = false;\n  obsAttributes = [\"props\", \"options\", \"onchanged\", \"onresize\", \"ondelete\", \"oncreate\", \"template\"];\n  get observedAttributes() {\n    return this.obsAttributes;\n  }\n  get obsAttributes() {\n    return this.obsAttributes;\n  }\n  set obsAttributes(att) {\n    if (typeof att === \"string\") {\n      this.obsAttributes.push(att);\n    } else if (Array.isArray(att))\n      this.obsAttributes = att;\n  }\n  static get tag() {\n    return this.name.toLowerCase() + \"-\";\n  }\n  static addElement(tag = this.tag, cls = this, extend = void 0) {\n    addCustomElement(cls, tag, extend);\n  }\n  attributeChangedCallback = (name, old, val) => {\n    if (name === \"onchanged\") {\n      let onchanged = val;\n      if (typeof onchanged === \"string\")\n        onchanged = parseFunctionFromText2(onchanged);\n      if (typeof onchanged === \"function\") {\n        this.onchanged = onchanged;\n        this.state.data.props = this.props;\n        this.state.unsubscribeTrigger(\"props\");\n        this.state.subscribeTrigger(\"props\", this.onchanged);\n        let changed = new CustomEvent(\"changed\", { detail: { props: this.props, self: this } });\n        this.state.subscribeTrigger(\"props\", () => {\n          this.dispatchEvent(changed);\n        });\n      }\n    } else if (name === \"onresize\") {\n      let onresize = val;\n      if (typeof onresize === \"string\")\n        onresize = parseFunctionFromText2(onresize);\n      if (typeof onresize === \"function\") {\n        if (this.ONRESIZE) {\n          try {\n            window.removeEventListener(\"resize\", this.ONRESIZE);\n          } catch (err) {\n          }\n        }\n        this.ONRESIZE = (ev) => {\n          this.onresize(this.props, this);\n        };\n        this.onresize = onresize;\n        window.addEventListener(\"resize\", this.ONRESIZE);\n      }\n    } else if (name === \"ondelete\") {\n      let ondelete = val;\n      if (typeof ondelete === \"string\")\n        ondelete = parseFunctionFromText2(ondelete);\n      if (typeof ondelete === \"function\") {\n        this.ondelete = () => {\n          if (this.ONRESIZE)\n            window.removeEventListener(\"resize\", this.ONRESIZE);\n          this.state.unsubscribeTrigger(\"props\");\n          if (ondelete)\n            ondelete(this.props, this);\n        };\n      }\n    } else if (name === \"oncreate\") {\n      let oncreate = val;\n      if (typeof oncreate === \"string\")\n        oncreate = parseFunctionFromText2(oncreate);\n      if (typeof oncreate === \"function\") {\n        this.oncreate = oncreate;\n      }\n    } else if (name === \"renderonchanged\") {\n      let rpc = val;\n      if (typeof this.renderonchanged === \"number\")\n        this.unsubscribeTrigger(this.renderonchanged);\n      if (typeof rpc === \"string\")\n        rpc = parseFunctionFromText2(rpc);\n      if (typeof rpc === \"function\") {\n        this.renderonchanged = this.state.subscribeTrigger(\"props\", (p) => {\n          this.render(p);\n          rpc(this, p);\n        });\n      } else if (rpc != false)\n        this.renderonchanged = this.state.subscribeTrigger(\"props\", this.render);\n    } else if (name === \"props\") {\n      let newProps = val;\n      if (typeof newProps === \"string\")\n        newProps = JSON.parse(newProps);\n      Object.assign(this.props, newProps);\n      this.state.setState({ props: this.props });\n    } else if (name === \"template\") {\n      let template = val;\n      this.template = template;\n      this.render(this.props);\n      let created = new CustomEvent(\"created\", { detail: { props: this.props } });\n      this.dispatchEvent(created);\n    } else {\n      let parsed = val;\n      if (name.includes(\"eval_\")) {\n        name = name.split(\"_\");\n        name.shift();\n        name = name.join();\n        parsed = parseFunctionFromText2(val);\n      } else if (typeof val === \"string\") {\n        try {\n          parsed = JSON.parse(val);\n        } catch (err) {\n          parsed = val;\n        }\n      }\n      this[name] = parsed;\n      if (name !== \"props\" && this.props)\n        this.props[name] = parsed;\n    }\n  };\n  connectedCallback() {\n    if (!this.props)\n      this.props = {};\n    let newProps = this.getAttribute(\"props\");\n    if (typeof newProps === \"string\")\n      newProps = JSON.parse(newProps);\n    Object.assign(this.props, newProps);\n    this.state.setState({ props: this.props });\n    Array.from(this.attributes).forEach((att) => {\n      let name = att.name;\n      let parsed = att.value;\n      if (name.includes(\"eval_\") || name.includes(\"()\")) {\n        if (name.includes(\"eval_\"))\n          name = name.split(\"_\");\n        else if (name.includes(\"()\"))\n          name = name.substring(0, name.indexOf(\"(\"));\n        name.shift();\n        name = name.join();\n        parsed = parseFunctionFromText2(att.value);\n      } else if (typeof att.value === \"string\") {\n        try {\n          parsed = JSON.parse(att.value);\n        } catch (err) {\n          parsed = att.value;\n        }\n      }\n      if (!this[name]) {\n        Object.defineProperties(this, att, {\n          value: parsed,\n          writable: true,\n          get() {\n            return this[name];\n          },\n          set(val) {\n            this.setAttribute(name, val);\n          }\n        });\n      }\n      this[name] = parsed;\n      if (name !== \"props\")\n        this.props[name] = parsed;\n      this.obsAttributes.push(name);\n    });\n    let resizeevent = new CustomEvent(\"resized\", { detail: { props: this.props, self: this } });\n    let changed = new CustomEvent(\"changed\", { detail: { props: this.props, self: this } });\n    let deleted = new CustomEvent(\"deleted\", { detail: { props: this.props, self: this } });\n    let created = new CustomEvent(\"created\", { detail: { props: this.props, self: this } });\n    this.render(this.props);\n    this.dispatchEvent(created);\n    this.state.subscribeTrigger(\"props\", () => {\n      this.dispatchEvent(changed);\n    });\n    if (typeof this.onresize === \"function\") {\n      if (this.ONRESIZE) {\n        try {\n          window.removeEventListener(\"resize\", this.ONRESIZE);\n        } catch (err) {\n        }\n      }\n      this.ONRESIZE = (ev) => {\n        this.onresize(this, this.props);\n        this.dispatchEvent(resizeevent);\n      };\n      window.addEventListener(\"resize\", this.ONRESIZE);\n    }\n    if (typeof this.ondelete === \"function\") {\n      let ondelete = this.ondelete;\n      this.ondelete = (props = this.props) => {\n        if (this.ONRESIZE)\n          window.removeEventListener(\"resize\", this.ONRESIZE);\n        this.state.unsubscribeTrigger(\"props\");\n        this.dispatchEvent(deleted);\n        ondelete(this, props);\n      };\n    }\n    if (typeof this.onchanged === \"function\") {\n      this.state.data.props = this.props;\n      this.state.subscribeTrigger(\"props\", this.onchanged);\n    }\n    if (this.renderonchanged) {\n      let rpc = this.renderonchanged;\n      if (typeof this.renderonchanged === \"number\")\n        this.unsubscribeTrigger(this.renderonchanged);\n      if (typeof rpc === \"string\")\n        rpc = parseFunctionFromText2(rpc);\n      if (typeof rpc === \"function\") {\n        this.renderonchanged = this.state.subscribeTrigger(\"props\", (p) => {\n          this.render(p);\n          rpc(this, p);\n        });\n      } else if (rpc !== false)\n        this.renderonchanged = this.state.subscribeTrigger(\"props\", this.render);\n    }\n  }\n  constructor() {\n    super();\n  }\n  delete = () => {\n    this.remove();\n    if (typeof this.ondelete === \"function\")\n      this.ondelete(this.props);\n  };\n  render = (props = this.props) => {\n    if (typeof this.template === \"function\")\n      this.templateResult = this.template(this, props);\n    else\n      this.templateResult = this.template;\n    if (this.styles)\n      this.templateResult = `<style>${this.styles}</style>${this.templateResult}`;\n    const t = document.createElement(\"template\");\n    if (typeof this.templateResult === \"string\")\n      t.innerHTML = this.templateResult;\n    else if (this.templateResult instanceof HTMLElement) {\n      if (this.templateResult.parentNode) {\n        this.templateResult.parentNode.removeChild(this.templateResult);\n      }\n      t.appendChild(this.templateResult);\n    }\n    const fragment = t.content;\n    if (this.FRAGMENT) {\n      if (this.useShadow) {\n        if (this.STYLE)\n          this.shadowRoot.removeChild(this.STYLE);\n        this.shadowRoot.removeChild(this.FRAGMENT);\n      } else\n        this.removeChild(this.FRAGMENT);\n    }\n    if (this.useShadow) {\n      if (!this.attachedShadow) {\n        this.attachShadow({ mode: \"open\" }).innerHTML = \"<slot></slot>\";\n        this.attachedShadow = true;\n      }\n      if (this.styles) {\n        let style = document.createElement(\"style\");\n        style.textContent = this.styles;\n        this.shadowRoot.prepend(style);\n        this.STYLE = style;\n      }\n      this.shadowRoot.prepend(fragment);\n      this.FRAGMENT = this.shadowRoot.childNodes[0];\n    } else {\n      this.prepend(fragment);\n      this.FRAGMENT = this.childNodes[0];\n    }\n    let rendered = new CustomEvent(\"rendered\", { detail: { props: this.props, self: this } });\n    this.dispatchEvent(rendered);\n    if (this.oncreate)\n      this.oncreate(this, props);\n  };\n  state = {\n    pushToState: {},\n    data: {},\n    triggers: {},\n    setState(updateObj) {\n      Object.assign(this.pushToState, updateObj);\n      if (Object.keys(this.triggers).length > 0) {\n        for (const prop of Object.getOwnPropertyNames(this.triggers)) {\n          if (this.pushToState[prop]) {\n            this.data[prop] = this.pushToState[prop];\n            delete this.pushToState[prop];\n            this.triggers[prop].forEach((obj) => {\n              obj.onchanged(this.data[prop]);\n            });\n          }\n        }\n      }\n      return this.pushToState;\n    },\n    subscribeTrigger(key, onchanged = (res) => {\n    }) {\n      if (key) {\n        if (!this.triggers[key]) {\n          this.triggers[key] = [];\n        }\n        let l = this.triggers[key].length;\n        this.triggers[key].push({ idx: l, onchanged });\n        return this.triggers[key].length - 1;\n      } else\n        return void 0;\n    },\n    unsubscribeTrigger(key, sub) {\n      let triggers = this.triggers[key];\n      if (triggers) {\n        if (!sub)\n          delete this.triggers[key];\n        else {\n          let idx = void 0;\n          let obj = triggers.find((o, i) => {\n            if (o.idx === sub) {\n              idx = i;\n              return true;\n            }\n          });\n          if (obj)\n            triggers.splice(idx, 1);\n          return true;\n        }\n      }\n    },\n    subscribeTriggerOnce(key = void 0, onchanged = (value) => {\n    }) {\n      let sub;\n      let changed = (value) => {\n        onchanged(value);\n        this.unsubscribeTrigger(key, sub);\n      };\n      sub = this.subscribeTrigger(key, changed);\n    }\n  };\n  get props() {\n    return this.props;\n  }\n  set props(newProps = {}) {\n    this.setAttribute(\"props\", newProps);\n  }\n  get template() {\n    return this.template;\n  }\n  set template(template) {\n    this.setAttribute(\"template\", template);\n  }\n  get render() {\n    return this.render;\n  }\n  get delete() {\n    return this.delete;\n  }\n  get state() {\n    return this.state;\n  }\n  get onchanged() {\n    return this.onchanged;\n  }\n  set onchanged(onchanged) {\n    this.setAttribute(\"onchanged\", onchanged);\n  }\n  get styles() {\n    return this.styles;\n  }\n  set styles(templateStr) {\n    this.styles = templateStr;\n    if (this.querySelector(\"style\")) {\n      this.querySelector(\"style\").innerHTML = templateStr;\n    } else {\n      this.render();\n    }\n  }\n  get renderonchanged() {\n    return this.renderonchanged;\n  }\n  set renderonchanged(onchanged) {\n    this.setAttribute(\"renderonchanged\", onchanged);\n  }\n  get onresize() {\n    return this.props;\n  }\n  set onresize(onresize) {\n    this.setAttribute(\"onresize\", onresize);\n  }\n  get ondelete() {\n    return this.props;\n  }\n  set ondelete(ondelete) {\n    this.setAttribute(\"ondelete\", ondelete);\n  }\n  get oncreate() {\n    return this.oncreate;\n  }\n  set oncreate(oncreate) {\n    this.setAttribute(\"oncreated\", oncreate);\n  }\n};\nfunction addCustomElement(cls, tag, extend = null) {\n  try {\n    if (extend) {\n      if (tag)\n        window.customElements.define(tag, cls, { extends: extend });\n      else\n        window.customElements.define(cls.name.toLowerCase() + \"-\", cls, { extends: extend });\n    } else {\n      if (tag)\n        window.customElements.define(tag, cls);\n      else\n        window.customElements.define(cls.name.toLowerCase() + \"-\", cls);\n    }\n  } catch (err) {\n  }\n}\nfunction parseFunctionFromText2(method) {\n  let getFunctionBody = (methodString) => {\n    return methodString.replace(/^\\W*(function[^{]+\\{([\\s\\S]*)\\}|[^=]+=>[^{]*\\{([\\s\\S]*)\\}|[^=]+=>(.+))/i, \"$2$3$4\");\n  };\n  let getFunctionHead = (methodString) => {\n    let startindex = methodString.indexOf(\")\");\n    return methodString.slice(0, methodString.indexOf(\"{\", startindex) + 1);\n  };\n  let newFuncHead = getFunctionHead(method);\n  let newFuncBody = getFunctionBody(method);\n  let newFunc;\n  try {\n    if (newFuncHead.includes(\"function\")) {\n      let varName = newFuncHead.split(\"(\")[1].split(\")\")[0];\n      newFunc = new Function(varName, newFuncBody);\n    } else {\n      if (newFuncHead.substring(0, 6) === newFuncBody.substring(0, 6)) {\n        let varName = newFuncHead.split(\"(\")[1].split(\")\")[0];\n        newFunc = new Function(varName, newFuncBody.substring(newFuncBody.indexOf(\"{\") + 1, newFuncBody.length - 1));\n      } else {\n        try {\n          newFunc = (0, eval)(newFuncHead + newFuncBody + \"}\");\n        } catch (err) {\n          newFunc = (0, eval)(method);\n        }\n      }\n    }\n  } catch (err) {\n  }\n  return newFunc;\n}\n\n// src/graphscript/services/Service.ts\nvar Service = class extends Graph {\n  constructor(options = {}) {\n    super(void 0, options.name ? options.name : `service${Math.floor(Math.random() * 1e14)}`, options.props);\n    this.routes = {};\n    this.loadDefaultRoutes = false;\n    this.keepState = true;\n    this.firstLoad = true;\n    this.customRoutes = {};\n    this.customChildren = {};\n    this.init = (options) => {\n      if (options)\n        options = Object.assign({}, options);\n      else\n        options = {};\n      if (options.customRoutes)\n        Object.assign(options.customRoutes, this.customRoutes);\n      else\n        options.customRoutes = this.customRoutes;\n      if (options.customChildren)\n        Object.assign(options.customChildren, this.customChildren);\n      else\n        options.customChildren = this.customChildren;\n      if (Array.isArray(options.routes)) {\n        options.routes.forEach((r) => {\n          this.load(r, options.includeClassName, options.routeFormat, options.customRoutes, options.customChildren, options.sharedState);\n        });\n      } else if (options.routes || (Object.keys(this.routes).length > 0 || this.loadDefaultRoutes) && this.firstLoad)\n        this.load(options.routes, options.includeClassName, options.routeFormat, options.customRoutes, options.customChildren, options.sharedState);\n    };\n    this.load = (routes, includeClassName = true, routeFormat = \".\", customRoutes, customChildren, sharedState = true) => {\n      if (!routes && !this.loadDefaultRoutes && (Object.keys(this.routes).length > 0 || this.firstLoad))\n        return;\n      if (this.firstLoad)\n        this.firstLoad = false;\n      if (customRoutes)\n        customRoutes = Object.assign(this.customRoutes, customRoutes);\n      else\n        customRoutes = this.customRoutes;\n      let service;\n      let allRoutes = {};\n      if (routes) {\n        if (!(routes instanceof Graph) && routes?.name && !routes.setTree) {\n          if (routes.module) {\n            let mod = routes;\n            routes = {};\n            Object.getOwnPropertyNames(routes.module).forEach((prop) => {\n              if (includeClassName)\n                routes[mod.name + routeFormat + prop] = routes.module[prop];\n              else\n                routes[prop] = routes.module[prop];\n            });\n          } else if (typeof routes === \"function\") {\n            service = new routes({ loadDefaultRoutes: this.loadDefaultRoutes });\n            service.load();\n            if (sharedState)\n              service.state = this.state;\n            routes = service.routes;\n            if (service.customRoutes && !this.customRoutes)\n              this.customRoutes = service.customRoutes;\n            else if (service.customRoutes && this.customRoutes)\n              Object.assign(this.customRoutes, service.customRoutes);\n            if (service.customChildren && !this.customChildren)\n              this.customChildren = service.customChildren;\n            else if (service.customChildren && this.customChildren)\n              Object.assign(this.customChildren, service.customChildren);\n          }\n        } else if (routes instanceof Graph || routes.source instanceof Graph || routes.setTree) {\n          service = routes;\n          routes = {};\n          if (sharedState)\n            service.state = this.state;\n          if (includeClassName) {\n            let name = service.name;\n            if (!name) {\n              name = service.tag;\n              service.name = name;\n            }\n            if (!name) {\n              name = `graph${Math.floor(Math.random() * 1e15)}`;\n              service.name = name;\n              service.tag = name;\n            }\n          }\n          if (service.customRoutes && !this.customRoutes)\n            this.customRoutes = service.customRoutes;\n          else if (service.customRoutes && this.customRoutes)\n            Object.assign(this.customRoutes, service.customRoutes);\n          if (service.customChildren && !this.customChildren)\n            this.customChildren = service.customChildren;\n          else if (service.customChildren && this.customChildren)\n            Object.assign(this.customChildren, service.customChildren);\n          service.nodes.forEach((node) => {\n            routes[node.tag] = node;\n            let checked = {};\n            let checkChildGraphNodes = (nd, par) => {\n              if (!checked[nd.tag] || par && includeClassName && !checked[par?.tag + routeFormat + nd.tag]) {\n                if (!par)\n                  checked[nd.tag] = true;\n                else\n                  checked[par.tag + routeFormat + nd.tag] = true;\n                if (nd instanceof Graph || nd.source instanceof Graph || nd.setTree) {\n                  if (sharedState)\n                    nd.state = this.state;\n                  if (includeClassName) {\n                    let nm = nd.name;\n                    if (!nm) {\n                      nm = nd.tag;\n                      nd.name = nm;\n                    }\n                    if (!nm) {\n                      nm = `graph${Math.floor(Math.random() * 1e15)}`;\n                      nd.name = nm;\n                      nd.tag = nm;\n                    }\n                  }\n                  nd.nodes.forEach((n) => {\n                    if (includeClassName && !routes[nd.tag + routeFormat + n.tag])\n                      routes[nd.tag + routeFormat + n.tag] = n;\n                    else if (!routes[n.tag])\n                      routes[n.tag] = n;\n                    checkChildGraphNodes(n, nd);\n                  });\n                }\n              }\n            };\n            checkChildGraphNodes(node);\n          });\n        } else if (typeof routes === \"object\") {\n          let name = routes.constructor.name;\n          if (name === \"Object\") {\n            name = Object.prototype.toString.call(routes);\n            if (name)\n              name = name.split(\" \")[1];\n            if (name)\n              name = name.split(\"]\")[0];\n          }\n          if (name && name !== \"Object\") {\n            let module = routes;\n            routes = {};\n            Object.getOwnPropertyNames(module).forEach((route) => {\n              if (includeClassName)\n                routes[name + routeFormat + route] = module[route];\n              else\n                routes[route] = module[route];\n            });\n          }\n        }\n        if ((service instanceof Graph || service?.setTree) && service.name && includeClassName) {\n          routes = Object.assign({}, routes);\n          for (const prop in routes) {\n            let route = routes[prop];\n            delete routes[prop];\n            routes[service.name + routeFormat + prop] = route;\n          }\n        }\n      }\n      if (this.loadDefaultRoutes) {\n        let rts = Object.assign({}, this.defaultRoutes);\n        if (routes) {\n          Object.assign(rts, this.routes);\n          routes = Object.assign(rts, routes);\n        } else\n          routes = Object.assign(rts, this.routes);\n        this.loadDefaultRoutes = false;\n      }\n      if (!routes)\n        routes = this.routes;\n      let incr = 0;\n      for (const tag in routes) {\n        incr++;\n        let childrenIter = (route, routeKey) => {\n          if (typeof route === \"object\") {\n            if (!route.tag)\n              route.tag = routeKey;\n            if (typeof route?.children === \"object\") {\n              nested:\n                for (const key in route.children) {\n                  incr++;\n                  if (typeof route.children[key] === \"object\") {\n                    let rt = route.children[key];\n                    if (rt.tag && allRoutes[rt.tag])\n                      continue;\n                    if (customChildren) {\n                      for (const k2 in customChildren) {\n                        rt = customChildren[k2](rt, key, route, routes, allRoutes);\n                        if (!rt)\n                          continue nested;\n                      }\n                    }\n                    if (rt.id && !rt.tag) {\n                      rt.tag = rt.id;\n                    }\n                    let k;\n                    if (rt.tag) {\n                      if (allRoutes[rt.tag]) {\n                        let randkey = `${rt.tag}${incr}`;\n                        allRoutes[randkey] = rt;\n                        rt.tag = randkey;\n                        childrenIter(allRoutes[randkey], key);\n                        k = randkey;\n                      } else {\n                        allRoutes[rt.tag] = rt;\n                        childrenIter(allRoutes[rt.tag], key);\n                        k = rt.tag;\n                      }\n                    } else {\n                      if (allRoutes[key]) {\n                        let randkey = `${key}${incr}`;\n                        allRoutes[randkey] = rt;\n                        rt.tag = randkey;\n                        childrenIter(allRoutes[randkey], key);\n                        k = randkey;\n                      } else {\n                        allRoutes[key] = rt;\n                        childrenIter(allRoutes[key], key);\n                        k = key;\n                      }\n                    }\n                    if (service?.name && includeClassName) {\n                      allRoutes[service.name + routeFormat + k] = rt;\n                      delete allRoutes[k];\n                    } else\n                      allRoutes[k] = rt;\n                  }\n                }\n            }\n          }\n        };\n        allRoutes[tag] = routes[tag];\n        childrenIter(routes[tag], tag);\n      }\n      top:\n        for (const route in allRoutes) {\n          if (typeof allRoutes[route] === \"object\") {\n            let r = allRoutes[route];\n            if (typeof r === \"object\") {\n              if (customRoutes) {\n                for (const key in customRoutes) {\n                  r = customRoutes[key](r, route, allRoutes);\n                  if (!r)\n                    continue top;\n                }\n              }\n              if (r.get) {\n                if (typeof r.get == \"object\") {\n                }\n              }\n              if (r.post) {\n              }\n              if (r.delete) {\n              }\n              if (r.put) {\n              }\n              if (r.head) {\n              }\n              if (r.patch) {\n              }\n              if (r.options) {\n              }\n              if (r.connect) {\n              }\n              if (r.trace) {\n              }\n              if (r.post && !r.operator) {\n                allRoutes[route].operator = r.post;\n              } else if (!r.operator && typeof r.get == \"function\") {\n                allRoutes[route].operator = r.get;\n              }\n            }\n          }\n        }\n      for (const route in routes) {\n        if (typeof routes[route] === \"object\") {\n          if (this.routes[route]) {\n            if (typeof this.routes[route] === \"object\")\n              Object.assign(this.routes[route], routes[route]);\n            else\n              this.routes[route] = routes[route];\n          } else\n            this.routes[route] = routes[route];\n        } else if (this.routes[route]) {\n          if (typeof this.routes[route] === \"object\")\n            Object.assign(this.routes[route], routes[route]);\n          else\n            this.routes[route] = routes[route];\n        } else\n          this.routes[route] = routes[route];\n      }\n      if (service) {\n        for (const key in this.routes) {\n          if (this.routes[key] instanceof GraphNode || this.routes[key].constructor.name.includes(\"GraphNode\")) {\n            this.nodes.set(key, this.routes[key]);\n            this.nNodes = this.nodes.size;\n          }\n        }\n      } else\n        this.setTree(this.routes);\n      for (const prop in this.routes) {\n        if (this.routes[prop]?.aliases) {\n          let aliases = this.routes[prop].aliases;\n          aliases.forEach((a) => {\n            if (service?.name && includeClassName)\n              routes[service.name + routeFormat + a] = this.routes[prop];\n            else\n              routes[a] = this.routes[prop];\n          });\n        }\n      }\n      return this.routes;\n    };\n    this.unload = (routes = this.routes) => {\n      if (!routes)\n        return;\n      let service;\n      if (!(routes instanceof Service) && typeof routes === \"function\") {\n        service = new Service();\n        routes = service.routes;\n      } else if (routes instanceof Service) {\n        routes = routes.routes;\n      }\n      for (const r in routes) {\n        delete this.routes[r];\n        if (this.nodes.get(r))\n          this.remove(r);\n      }\n      return this.routes;\n    };\n    this.handleMethod = (route, method, args) => {\n      let m = method.toLowerCase();\n      let src = this.nodes.get(route);\n      if (!src) {\n        src = this.routes[route];\n        if (!src)\n          src = this.tree[route];\n      }\n      if (src?.[m]) {\n        if (!(src[m] instanceof Function)) {\n          if (args)\n            src[m] = args;\n          return src[m];\n        } else\n          return src[m](args);\n      } else\n        return this.handleServiceMessage({ route, args, method });\n    };\n    this.transmit = (...args) => {\n      if (typeof args[0] === \"object\") {\n        if (args[0].method) {\n          return this.handleMethod(args[0].route, args[0].method, args[0].args);\n        } else if (args[0].route) {\n          return this.handleServiceMessage(args[0]);\n        } else if (args[0].node) {\n          return this.handleGraphNodeCall(args[0].node, args[0].args);\n        } else if (this.keepState) {\n          if (args[0].route)\n            this.setState({ [args[0].route]: args[0].args });\n          if (args[0].node)\n            this.setState({ [args[0].node]: args[0].args });\n        }\n        return args;\n      } else\n        return args;\n    };\n    this.receive = (...args) => {\n      if (args[0]) {\n        if (typeof args[0] === \"string\") {\n          let substr = args[0].substring(0, 8);\n          if (substr.includes(\"{\") || substr.includes(\"[\")) {\n            if (substr.includes(\"\\\\\"))\n              args[0] = args[0].replace(/\\\\/g, \"\");\n            if (args[0][0] === '\"') {\n              args[0] = args[0].substring(1, args[0].length - 1);\n            }\n            ;\n            args[0] = JSON.parse(args[0]);\n          }\n        }\n      }\n      if (typeof args[0] === \"object\") {\n        if (args[0].method) {\n          return this.handleMethod(args[0].route, args[0].method, args[0].args);\n        } else if (args[0].route) {\n          return this.handleServiceMessage(args[0]);\n        } else if (args[0].node) {\n          return this.handleGraphNodeCall(args[0].node, args[0].args);\n        } else if (this.keepState) {\n          if (args[0].route)\n            this.setState({ [args[0].route]: args[0].args });\n          if (args[0].node)\n            this.setState({ [args[0].node]: args[0].args });\n        }\n        return args;\n      } else\n        return args;\n    };\n    this.pipe = (source, destination, endpoint, method, callback) => {\n      if (source instanceof GraphNode) {\n        if (callback)\n          return source.subscribe((res) => {\n            let mod = callback(res);\n            if (mod !== void 0)\n              this.transmit({ route: destination, args: mod, method });\n            else\n              this.transmit({ route: destination, args: res, method }, endpoint);\n          });\n        else\n          return this.subscribe(source, (res) => {\n            this.transmit({ route: destination, args: res, method }, endpoint);\n          });\n      } else if (typeof source === \"string\")\n        return this.subscribe(source, (res) => {\n          this.transmit({ route: destination, args: res, method }, endpoint);\n        });\n    };\n    this.pipeOnce = (source, destination, endpoint, method, callback) => {\n      if (source instanceof GraphNode) {\n        if (callback)\n          return source.state.subscribeTriggerOnce(source.tag, (res) => {\n            let mod = callback(res);\n            if (mod !== void 0)\n              this.transmit({ route: destination, args: mod, method });\n            else\n              this.transmit({ route: destination, args: res, method }, endpoint);\n          });\n        else\n          return this.state.subscribeTriggerOnce(source.tag, (res) => {\n            this.transmit({ route: destination, args: res, method }, endpoint);\n          });\n      } else if (typeof source === \"string\")\n        return this.state.subscribeTriggerOnce(source, (res) => {\n          this.transmit({ route: destination, args: res, method }, endpoint);\n        });\n    };\n    this.terminate = (...args) => {\n      this.nodes.forEach((n) => {\n        n.stopNode();\n      });\n    };\n    this.recursivelyAssign = (target, obj) => {\n      for (const key in obj) {\n        if (typeof obj[key] === \"object\" && !Array.isArray(obj[key])) {\n          if (typeof target[key] === \"object\" && !Array.isArray(target[key]))\n            this.recursivelyAssign(target[key], obj[key]);\n          else\n            target[key] = this.recursivelyAssign({}, obj[key]);\n        } else\n          target[key] = obj[key];\n      }\n      return target;\n    };\n    this.defaultRoutes = {\n      \"/\": {\n        get: () => {\n          return this.print();\n        },\n        aliases: [\"\"]\n      },\n      ping: () => {\n        console.log(\"ping\");\n        return \"pong\";\n      },\n      echo: (...args) => {\n        this.transmit(...args);\n        return args;\n      },\n      assign: (source) => {\n        if (typeof source === \"object\") {\n          Object.assign(this, source);\n          return true;\n        }\n        return false;\n      },\n      recursivelyAssign: (source) => {\n        if (typeof source === \"object\") {\n          this.recursivelyAssign(this, source);\n          return true;\n        }\n        return false;\n      },\n      log: {\n        post: (...args) => {\n          console.log(\"Log: \", ...args);\n        },\n        aliases: [\"info\"]\n      },\n      error: (message) => {\n        let er = new Error(message);\n        console.error(message);\n        return er;\n      },\n      state: (key) => {\n        if (key) {\n          return this.state.data[key];\n        } else\n          return this.state.data;\n      },\n      printState: (key) => {\n        if (key) {\n          return stringifyWithCircularRefs(this.state.data[key]);\n        } else\n          return stringifyWithCircularRefs(this.state.data);\n      },\n      spliceTypedArray: this.spliceTypedArray,\n      transmit: this.transmit,\n      receive: this.receive,\n      load: this.load,\n      unload: this.unload,\n      pipe: this.pipe,\n      terminate: this.terminate,\n      run: this.run,\n      subscribe: this.subscribe,\n      subscribeNode: this.subscribeNode,\n      unsubscribe: this.unsubscribe,\n      stopNode: this.stopNode,\n      get: this.get,\n      add: this.add,\n      remove: this.remove,\n      setTree: this.setTree,\n      setState: this.setState,\n      print: this.print,\n      reconstruct: this.reconstruct,\n      handleMethod: this.handleMethod,\n      handleServiceMessage: this.handleServiceMessage,\n      handleGraphNodeCall: this.handleGraphNodeCall\n    };\n    if (options.name)\n      this.name = options.name;\n    else\n      options.name = this.tag;\n    if (\"loadDefaultRoutes\" in options) {\n      this.loadDefaultRoutes = options.loadDefaultRoutes;\n      this.routes = Object.assign(this.defaultRoutes, this.routes);\n    }\n    if (options || Object.keys(this.routes).length > 0)\n      this.init(options);\n  }\n  handleServiceMessage(message) {\n    let call;\n    if (typeof message === \"object\") {\n      if (message.route)\n        call = message.route;\n      else if (message.node)\n        call = message.node;\n    }\n    if (call) {\n      if (Array.isArray(message.args))\n        return this.run(call, ...message.args);\n      else\n        return this.run(call, message.args);\n    } else\n      return message;\n  }\n  handleGraphNodeCall(route, args) {\n    if (!route)\n      return args;\n    if (args?.args) {\n      this.handleServiceMessage(args);\n    } else if (Array.isArray(args))\n      return this.run(route, ...args);\n    else\n      return this.run(route, args);\n  }\n  isTypedArray(x) {\n    return ArrayBuffer.isView(x) && Object.prototype.toString.call(x) !== \"[object DataView]\";\n  }\n  spliceTypedArray(arr, start, end) {\n    let s = arr.subarray(0, start);\n    let e;\n    if (end) {\n      e = arr.subarray(end + 1);\n    }\n    let n;\n    if (s.length > 0 || e?.length > 0)\n      n = new arr.constructor(s.length + e.length);\n    if (s.length > 0)\n      n.set(s);\n    if (e && e.length > 0)\n      n.set(e, s.length);\n    return n;\n  }\n};\n\n// src/graphscript/services/dom/DOM.service.ts\nvar DOMService = class extends Service {\n  constructor(options, parentNode, interpreters) {\n    super({ props: options?.props, name: options?.name ? options.name : `dom${Math.floor(Math.random() * 1e15)}` });\n    this.loadDefaultRoutes = false;\n    this.keepState = true;\n    this.parentNode = document.body;\n    this.interpreters = {\n      md: (template, options) => {\n        if (typeof markdownit === \"undefined\") {\n          document.head.insertAdjacentHTML(\"beforeend\", `\n                    <script src='https://unpkg.com/markdown-it@latest/dist/markdown-it.min.js'><\\/script>`);\n        }\n        let md = globalThis.markdownit();\n        let html = md.render(template);\n        options.template = html;\n      },\n      jsx: (template, options) => {\n        if (!options.parentNode)\n          options.parentNode = this.parentNode;\n        if (typeof options.parentNode === \"string\")\n          options.parentNode = document.getElementById(options.parentNode);\n        if (typeof ReactDOM === \"undefined\") {\n          document.head.insertAdjacentHTML(\"beforeend\", `\n                    <script src='https://unpkg.com/react@latest/umd/react.production.min.js'><\\/script>\n                    <script src='https://unpkg.com/react-dom@latest/umd/react-dom.production.min.js'><\\/script>`);\n        }\n        options.template = \"\";\n        let onrender = options.onrender;\n        options.onrender = (self2, info) => {\n          const modal = ReactDOM.createPortal(template, options.id);\n          onrender(self2, info);\n        };\n      }\n    };\n    this.customRoutes = {\n      \"dom\": (r, route, routes) => {\n        if (!(r instanceof GraphNode)) {\n          if (r.element?.parentNode?.id && r.graph?.parentNode?.id) {\n            if (r.graph.parentNode.id === r.element.id) {\n              r.parentNode = this.parentNode;\n            }\n          } else {\n            if (r.template) {\n              if (!r.tag)\n                r.tag = route;\n              this.addComponent(r, r.generateChildElementNodes);\n            } else if (r.context) {\n              if (!r.tag)\n                r.tag = route;\n              this.addCanvasComponent(r);\n            } else if (r.tagName || r.element) {\n              if (!r.tag)\n                r.tag = route;\n              this.addElement(r, r.generateChildElementNodes);\n            }\n          }\n        }\n        return r;\n      }\n    };\n    this.customChildren = {\n      \"dom\": (rt, routeKey, parent, routes, checked) => {\n        if ((parent.tag || parent.id) && (parent.template || parent.context || parent.tagName || parent.element) && (rt.template || rt.context || rt.tagName || rt.element) && !rt.parentNode) {\n          if (parent.tag)\n            rt.parentNode = parent.tag;\n          if (parent.id)\n            rt.parentNode = parent.id;\n        }\n        return rt;\n      }\n    };\n    this.elements = {};\n    this.components = {};\n    this.templates = {};\n    this.addElement = (options, generateChildElementNodes = false) => {\n      let elm = this.createElement(options);\n      if (!options.element)\n        options.element = elm;\n      if (!options.operator)\n        options.operator = function(props) {\n          if (typeof props === \"object\")\n            for (const key in props) {\n              if (this.element) {\n                if (typeof this.element[key] === \"function\" && typeof props[key] !== \"function\") {\n                  if (Array.isArray(props[key]))\n                    this.element[key](...props[key]);\n                  else\n                    this.element[key](props[key]);\n                } else if (key === \"style\") {\n                  Object.assign(this.element[key], props[key]);\n                } else\n                  this.element[key] = props[key];\n              }\n            }\n          return props;\n        };\n      let node = this.resolveGraphNode(elm, options);\n      let divs = Array.from(elm.querySelectorAll(\"*\"));\n      if (generateChildElementNodes) {\n        divs = divs.map((d, i) => this.addElement({ element: d }));\n      }\n      this.elements[options.id] = { element: elm, node, parentNode: options.parentNode, divs };\n      if (!node.ondelete)\n        node.ondelete = (node2) => {\n          elm.remove();\n          if (options.onremove)\n            options.onremove.call(this.elements[options.id].node, elm, this.elements[options.id]);\n        };\n      if (options.onresize) {\n        let onresize = options.onresize;\n        options.onresize = (ev) => {\n          onresize.call(this.elements[options.id].node, ev, elm, this.elements[options.id]);\n        };\n        window.addEventListener(\"resize\", options.onresize);\n      }\n      return this.elements[options.id];\n    };\n    this.createElement = (options) => {\n      let elm;\n      if (options.element) {\n        if (typeof options.element === \"string\") {\n          elm = document.querySelector(options.element);\n          if (!elm)\n            elm = document.getElementById(options.element);\n        } else\n          elm = options.element;\n      } else if (options.tagName)\n        elm = document.createElement(options.tagName);\n      else if (options.id && document.getElementById(options.id))\n        elm = document.getElementById(options.id);\n      if (!elm)\n        return void 0;\n      this.updateOptions(options, elm);\n      return elm;\n    };\n    this.updateOptions = (options, element) => {\n      if (!options.id && options.tag)\n        options.id = options.tag;\n      if (!options.tag && options.id)\n        options.tag = options.id;\n      if (!options.id)\n        options.id = `${options.tagName ?? \"element\"}${Math.floor(Math.random() * 1e15)}`;\n      let p = options.parentNode;\n      delete options.parentNode;\n      Object.defineProperty(options, \"parentNode\", {\n        get: function() {\n          return element.parentNode;\n        },\n        set: (v) => {\n          if (element.parentNode) {\n            element.parentNode.removeChild(element);\n          }\n          this.resolveParentNode(element, v ? v : this.parentNode, options, options.onrender);\n        },\n        enumerable: true,\n        configurable: true\n      });\n      options.parentNode = p ? p : this.parentNode;\n      element.id = options.id;\n      if (options.style)\n        Object.assign(element.style, options.style);\n      if (options.attributes) {\n        for (let key in options.attributes) {\n          if (typeof options.attributes[key] === \"function\")\n            element[key] = (...args) => options.attributes[key](...args);\n          else\n            element[key] = options.attributes[key];\n        }\n      }\n      if (!options.attributes?.innerHTML && options.innerHTML) {\n        element.innerHTML = options.innerHTML;\n      } else if (!options.attributes?.innerText && options.innerText) {\n        element.innerText = options.innerText;\n      }\n      return options;\n    };\n    this.resolveParentNode = (elm, parentNode, options, oncreate) => {\n      if (!elm.parentNode) {\n        setTimeout(() => {\n          if (typeof parentNode === \"string\")\n            parentNode = document.getElementById(parentNode);\n          if (parentNode && typeof parentNode === \"object\") {\n            parentNode.appendChild(elm);\n          }\n          if (oncreate)\n            oncreate.call(elm.node, elm, this.elements[options.id]);\n          if (elm.node.animation || elm.node.animate) {\n            elm.node.runAnimation();\n          }\n          if (elm.node.looper || typeof elm.node.loop === \"number\" && elm.node.loop) {\n            elm.node.runLoop();\n          }\n        }, 0.01);\n      }\n    };\n    this.resolveGraphNode = (element, options) => {\n      let node;\n      if (this.nodes.get(options.id)?.element?.parentNode?.id === options.parentNode || this.nodes.get(options.id)?.parentNode === options.parentNode) {\n        node = this.nodes.get(options.id);\n      } else {\n        let parentId = options.parentNode instanceof HTMLElement ? options.parentNode?.id : typeof options.parentNode === \"string\" ? options.parentNode : void 0;\n        let parent;\n        if (parentId)\n          parent = this.nodes.get(parentId);\n        node = new GraphNode(options instanceof Graph ? options : Object.assign({}, options), parent, this);\n      }\n      delete node.parentNode;\n      Object.defineProperty(node, \"parentNode\", {\n        get: function() {\n          return element.parentNode;\n        },\n        set: (v) => {\n          if (element.parentNode) {\n            element.parentNode.removeChild(element);\n          }\n          this.resolveParentNode(element, v ? v : this.parentNode, options, options.onrender);\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(node, \"element\", {\n        get: () => element,\n        set: (v) => {\n          element = v;\n          node.nodes.forEach((n) => {\n            if (node.source?._unique === n.graph?._unique)\n              n.parentNode = element;\n          });\n        }\n      });\n      node.element = element;\n      element.node = node;\n      const initialOptions = options._initial ?? options;\n      for (let key in initialOptions) {\n        if (typeof initialOptions[key] === \"function\")\n          initialOptions[key] = initialOptions[key].bind(node);\n        else if (key === \"attributes\") {\n          for (let key2 in initialOptions.attributes) {\n            if (typeof initialOptions.attributes[key2] === \"function\") {\n              initialOptions.attributes[key2] = initialOptions.attributes[key2].bind(node);\n            }\n          }\n        }\n      }\n      return node;\n    };\n    this.addComponent = (options, generateChildElementNodes = true) => {\n      if (options.onrender) {\n        let oncreate = options.onrender;\n        options.onrender = (element) => {\n          oncreate.call(element.node, element, options);\n        };\n      }\n      if (options.onresize) {\n        let onresize = options.onresize;\n        options.onresize = (element) => {\n          onresize.call(element.node, element, options);\n        };\n      }\n      if (options.onremove) {\n        let ondelete = options.onremove;\n        options.onremove = (element) => {\n          ondelete.call(element.node, self, options);\n        };\n      }\n      if (typeof options.renderonchanged === \"function\") {\n        let renderonchanged = options.renderonchanged;\n        options.renderonchanged = (element) => {\n          renderonchanged.call(element.node, element, options);\n        };\n      }\n      if (options.interpreter && options.interpreter !== \"wc\") {\n        this.interpreters[options.interpreter](options.template, options);\n      }\n      class CustomElement extends DOMElement {\n        constructor() {\n          super(...arguments);\n          this.props = options.props;\n          this.styles = options.styles;\n          this.useShadow = options.useShadow;\n          this.template = options.template;\n          this.oncreate = options.onrender;\n          this.onresize = options.onresize;\n          this.ondelete = options.onremove;\n          this.renderonchanged = options.renderonchanged;\n        }\n      }\n      if (!options.tagName)\n        options.tagName = `custom-element${Math.random() * 1e15}`;\n      CustomElement.addElement(options.tagName);\n      let elm = document.createElement(options.tagName);\n      let completeOptions = this.updateOptions(options, elm);\n      this.templates[completeOptions.id] = completeOptions;\n      let divs = Array.from(elm.querySelectorAll(\"*\"));\n      if (generateChildElementNodes) {\n        divs = divs.map((d) => this.addElement({ element: d }));\n      }\n      if (!options.element)\n        options.element = elm;\n      if (!options.operator)\n        options.operator = function op(props) {\n          if (typeof props === \"object\")\n            for (const key in props) {\n              if (this.element) {\n                if (typeof this.element[key] === \"function\" && typeof props[key] !== \"function\") {\n                  if (Array.isArray(props[key]))\n                    this.element[key](...props[key]);\n                  else\n                    this.element[key](props[key]);\n                } else if (key === \"style\") {\n                  Object.assign(this.element[key], props[key]);\n                } else\n                  this.element[key] = props[key];\n              }\n            }\n          return props;\n        };\n      let node = this.resolveGraphNode(elm, options);\n      if (!node.ondelete)\n        node.ondelete = (node2) => {\n          elm.delete();\n        };\n      this.components[completeOptions.id] = {\n        element: elm,\n        class: CustomElement,\n        node,\n        divs,\n        ...completeOptions\n      };\n      return this.components[completeOptions.id];\n    };\n    this.addCanvasComponent = (options) => {\n      if (!options.canvas) {\n        options.template = `<canvas `;\n        if (options.width)\n          options.template += `width=\"${options.width}\"`;\n        if (options.height)\n          options.template += `height=\"${options.height}\"`;\n        options.template += ` ></canvas>`;\n      } else\n        options.template = options.canvas;\n      if (options.onrender) {\n        let oncreate = options.onrender;\n        options.onrender = (element) => {\n          oncreate.call(element.node, element, options);\n        };\n      }\n      if (options.onresize) {\n        let onresize = options.onresize;\n        options.onresize = (element) => {\n          onresize.call(element.node, element, options);\n        };\n      }\n      if (options.ondelete) {\n        let ondelete = options.onremove;\n        options.onremove = (element) => {\n          ondelete.call(element.node, element, options);\n        };\n      }\n      if (typeof options.renderonchanged === \"function\") {\n        let renderonchanged = options.renderonchanged;\n        options.renderonchanged = (element) => {\n          renderonchanged.call(element.node, element, options);\n        };\n      }\n      class CustomElement extends DOMElement {\n        constructor() {\n          super(...arguments);\n          this.props = options.props;\n          this.styles = options.styles;\n          this.template = options.template;\n          this.oncreate = options.onrender;\n          this.onresize = options.onresize;\n          this.ondelete = options.onremove;\n          this.renderonchanged = options.renderonchanged;\n        }\n      }\n      if (!options.tagName)\n        options.tagName = `custom-element${Math.random() * 1e15}`;\n      CustomElement.addElement(options.tagName);\n      let elm = document.createElement(options.tagName);\n      const completeOptions = this.updateOptions(options, elm);\n      let animation = () => {\n        if (this.components[completeOptions.id]?.animating) {\n          this.components[completeOptions.id].draw(this.components[completeOptions.id].element, this.components[completeOptions.id]);\n          requestAnimationFrame(animation);\n        }\n      };\n      this.templates[completeOptions.id] = completeOptions;\n      if (!options.element)\n        options.element = elm;\n      if (!options.operator)\n        options.operator = function op(props) {\n          if (typeof props === \"object\")\n            for (const key in props) {\n              if (this.element) {\n                if (typeof this.element[key] === \"function\" && typeof props[key] !== \"function\") {\n                  if (Array.isArray(props[key]))\n                    this.element[key](...props[key]);\n                  else\n                    this.element[key](props[key]);\n                } else if (key === \"style\") {\n                  Object.assign(this.element[key], props[key]);\n                } else\n                  this.element[key] = props[key];\n              }\n            }\n          return props;\n        };\n      let node = this.resolveGraphNode(elm, options);\n      if (!node.ondelete)\n        node.ondelete = (node2) => {\n          elm.delete();\n        };\n      let canvas = elm.querySelector(\"canvas\");\n      if (completeOptions.style)\n        Object.assign(canvas.style, completeOptions.style);\n      let context;\n      if (typeof completeOptions.context === \"object\")\n        context = options.context;\n      else if (typeof completeOptions.context === \"string\")\n        context = canvas.getContext(completeOptions.context);\n      this.components[completeOptions.id] = {\n        element: elm,\n        class: CustomElement,\n        template: completeOptions.template,\n        canvas,\n        node,\n        ...completeOptions\n      };\n      this.components[completeOptions.id].context = context;\n      elm.canvas = canvas;\n      elm.context = context;\n      node.canvas = canvas;\n      node.context = context;\n      return this.components[completeOptions.id];\n    };\n    this.terminate = (element) => {\n      if (typeof element === \"object\") {\n        if (element.animating)\n          element.animating = false;\n        if (element.element)\n          element = element.element;\n      } else if (typeof element === \"string\" && this.components[element]) {\n        if (this.components[element].node.isAnimating)\n          this.components[element].node.stopNode();\n        if (this.components[element].divs)\n          this.components[element].divs.forEach((d) => this.terminate(d));\n        let temp = this.components[element].element;\n        delete this.components[element];\n        element = temp;\n      } else if (typeof element === \"string\" && this.elements[element]) {\n        if (this.elements[element].divs)\n          this.elements[element].divs.forEach((d) => this.terminate(d));\n        let temp = this.elements[element].element;\n        if (this.elements[element].onresize)\n          window.removeEventListener(\"resize\", this.elements[element].onresize);\n        if (this.elements[element].ondelete)\n          this.elements[element].ondelete(temp, this.elements[element]);\n        delete this.elements[element];\n        element = temp;\n      }\n      if (element) {\n        if (this.nodes.get(element.id)) {\n          this.removeTree(element.id);\n        }\n        if (element instanceof DOMElement)\n          element.delete();\n        else if (element?.parentNode) {\n          element.parentNode.removeChild(element);\n        }\n        return true;\n      }\n      return false;\n    };\n    this.defaultRoutes = {\n      addElement: this.addElement,\n      addComponent: this.addComponent,\n      addCanvasComponent: this.addCanvasComponent,\n      terminate: this.terminate\n    };\n    if (options?.parentNode)\n      parentNode = options.parentNode;\n    if (typeof parentNode === \"string\")\n      parentNode = document.getElementById(parentNode);\n    if (parentNode instanceof HTMLElement)\n      this.parentNode = parentNode;\n    if (interpreters) {\n      Object.assign(this.interpreters, interpreters);\n    }\n    this.init(options);\n  }\n};\n\n// src/graphscript/services/router/Router.ts\nvar Router = class extends Service {\n  constructor(options) {\n    super(options);\n    this.name = \"router\";\n    this.connections = {};\n    this.sources = {};\n    this.services = {};\n    this.serviceConnections = {};\n    this.users = {};\n    this.addUser = async (info, connections, config, receiving) => {\n      if (!info._id) {\n        info._id = `user${Math.floor(Math.random() * 1e15)}`;\n      }\n      let user = Object.assign({}, info);\n      if (connections) {\n        for (const key in connections) {\n          if (typeof connections[key] === \"object\") {\n            if (!connections[key].connection._id) {\n              await new Promise((res, rej) => {\n                let start = performance.now();\n                let checker = () => {\n                  if (!connections[key].connection._id) {\n                    if (performance.now() - start > 3e3) {\n                      delete connections[key];\n                      rej(false);\n                    } else {\n                      setTimeout(() => {\n                        checker();\n                      }, 100);\n                    }\n                  } else {\n                    res(true);\n                  }\n                };\n                checker();\n              }).catch((er) => {\n                console.error(\"Connections timed out:\", er);\n              });\n            }\n          }\n        }\n        for (const key in connections) {\n          connections[key] = this.addConnection(connections[key], user._id);\n        }\n      }\n      if (config) {\n        for (const c in config) {\n          this.openConnection(config[c].service, config[c], user._id, config[c].args);\n        }\n      }\n      let send = (message, ...a) => {\n        let connection = this.getConnection(user._id, \"send\");\n        if (connection?.send)\n          return connection.send(message, ...a);\n      };\n      let request = (message, method, ...a) => {\n        let connection = this.getConnection(user._id, \"request\");\n        if (connection?.request)\n          return connection.request(message, method, ...a);\n      };\n      let post = (route, args, method, ...a) => {\n        let connection = this.getConnection(user._id, \"post\");\n        if (connection?.post)\n          return connection.post(route, args, method, ...a);\n      };\n      let run = (route, args, method, ...a) => {\n        let connection = this.getConnection(user._id, \"run\");\n        if (connection?.run)\n          return connection.run(route, args, method, ...a);\n      };\n      let subscribe = (route, callback, ...a) => {\n        let connection = this.getConnection(user._id, \"subscribe\");\n        if (connection?.subscribe)\n          return connection.subscribe(route, callback, ...a);\n      };\n      let unsubscribe = (route, sub, ...a) => {\n        let connection = this.getConnection(user._id, \"unsubscribe\");\n        if (connection?.unsubscribe)\n          return connection.unsubscribe(route, sub, ...a);\n      };\n      let terminate = () => {\n        return this.removeUser(user);\n      };\n      user.send = send;\n      user.request = request;\n      user.post = post;\n      user.run = run;\n      user.subscribe = subscribe;\n      user.unsubscribe = unsubscribe;\n      user.terminate = terminate;\n      this.users[user._id] = user;\n      if (connections && !receiving) {\n        let connectionIds = {};\n        let pass = false;\n        Object.keys(connections).map((k, i) => {\n          if (connections[k]?._id) {\n            connectionIds[`${i}`] = connections[k]?._id;\n            pass = true;\n          }\n        });\n        if (pass) {\n          user.send({\n            route: \"addUser\",\n            args: [\n              { _id: user._id },\n              connectionIds,\n              void 0,\n              true\n            ]\n          });\n        }\n      }\n      return user;\n    };\n    this.getConnection = (sourceId, hasMethod) => {\n      if (this.sources[sourceId]) {\n        if (this.order) {\n          for (let i = 0; i < this.order.length; i++) {\n            let k = this.order[i];\n            for (const key in this.sources[sourceId]) {\n              if (this.sources[sourceId][key].service) {\n                if (typeof this.sources[sourceId][key].service === \"object\") {\n                  if (this.sources[sourceId][key].service.tag === k) {\n                    if (this.sources[sourceId][key].connectionType && this.sources[sourceId][key].service?.name) {\n                      if (!this.serviceConnections[this.sources[sourceId][key].service.name]) {\n                        this.removeConnection(this.sources[sourceId][key]);\n                        continue;\n                      }\n                    }\n                    return this.sources[sourceId][key];\n                  }\n                } else if (this.sources[sourceId][key].service === k) {\n                  if (this.sources[sourceId][key].connectionType && this.sources[sourceId][key].service?.name) {\n                    if (!this.serviceConnections[this.sources[sourceId][key].service.name])\n                      this.removeConnection(this.sources[sourceId][key]);\n                    continue;\n                  }\n                  return this.sources[sourceId][key];\n                }\n              }\n            }\n          }\n        } else {\n          for (const k in this.sources[sourceId]) {\n            if (this.sources[sourceId][k].connectionType && this.sources[sourceId][k].service?.name) {\n              if (!this.serviceConnections[this.sources[sourceId][k].service.name]) {\n                this.removeConnection(this.sources[sourceId][k]);\n                continue;\n              }\n            }\n            if (hasMethod && this.sources[sourceId][k][hasMethod]) {\n              return this.sources[sourceId][k];\n            } else {\n              return this.sources[sourceId][k];\n            }\n          }\n        }\n      } else if (this.order) {\n        for (let i = 0; i < this.order.length; i++) {\n          let k = this.order[i];\n          if (this.sources[k]?.[sourceId]) {\n            if (this.sources[k][sourceId].connectionType && this.sources[k][sourceId].service?.name) {\n              if (!this.serviceConnections[this.sources[k][sourceId].service.service.name]) {\n                this.removeConnection(this.sources[k][sourceId].service);\n                continue;\n              }\n            }\n            if (hasMethod && this.sources[k][sourceId]?.[hasMethod]) {\n              return this.sources[k][sourceId];\n            } else {\n              return this.sources[k][sourceId];\n            }\n          }\n        }\n      }\n      if (typeof sourceId === \"string\" && this.connections[sourceId] && this.connections[sourceId].send) {\n        return this.connections[sourceId];\n      }\n    };\n    this.getConnections = (sourceId, hasMethod, props) => {\n      if (this.sources[sourceId]) {\n        if (!props && !hasMethod)\n          return this.sources[sourceId];\n        let found = {};\n        for (const key in this.sources[sourceId]) {\n          if (typeof this.sources[sourceId][key] === \"object\") {\n            if (!this.sources[sourceId][key]._id) {\n              for (const k in this.sources[sourceId][key]) {\n                if (typeof this.sources[sourceId][key][k] === \"object\") {\n                  let pass = true;\n                  if (hasMethod && !this.sources[sourceId][key][k][hasMethod])\n                    pass = false;\n                  for (const p in props) {\n                    if (typeof this.sources[sourceId][key][k][p] === \"object\" && typeof props[p] === \"object\") {\n                      for (const pp in props[p]) {\n                        if (props[p][pp] !== this.sources[sourceId][key][k][p][pp]) {\n                          pass = false;\n                          break;\n                        }\n                      }\n                    } else if (this.sources[sourceId][key][k][p] !== props[p]) {\n                      pass = false;\n                    } else {\n                      pass = false;\n                      break;\n                    }\n                  }\n                  if (pass) {\n                    found[this.sources[sourceId][key][k]._id] = this.sources[sourceId][key][k];\n                  }\n                }\n              }\n            } else {\n              let pass = true;\n              if (hasMethod && !this.sources[sourceId][key][hasMethod])\n                pass = false;\n              for (const p in props) {\n                if (typeof this.sources[sourceId][key][p] === \"object\" && typeof props[p] === \"object\") {\n                  for (const pp in props[p]) {\n                    if (props[p][pp] !== this.sources[sourceId][key][p][pp]) {\n                      pass = false;\n                      break;\n                    }\n                  }\n                } else if (this.sources[sourceId][key][p] !== props[p]) {\n                  pass = false;\n                } else {\n                  pass = false;\n                  break;\n                }\n              }\n              if (pass) {\n                if (this.getConnection(this.sources[sourceId][key], hasMethod))\n                  found[this.sources[sourceId][key]._id] = this.sources[sourceId][key];\n              }\n            }\n          }\n        }\n      }\n    };\n    this.addConnection = (options, source) => {\n      let settings = {};\n      if (typeof options === \"string\") {\n        if (this.connections[options]) {\n          options = this.connections[options];\n        } else {\n          for (const j in this.serviceConnections) {\n            for (const k in this.serviceConnections[j]) {\n              if (this.serviceConnections[j][k][options]) {\n                options = { connection: this.serviceConnections[j][k][options] };\n                options.service = j;\n                settings.connectionType = j;\n                settings.connectionsKey = k;\n                break;\n              }\n            }\n          }\n        }\n        if (typeof options === \"string\" && this.nodes.get(options))\n          options = { connection: this.nodes.get(options) };\n      }\n      if (!options || typeof options === \"string\")\n        return void 0;\n      if (source)\n        settings.source = source;\n      if (options.connection instanceof GraphNode) {\n        settings.connection = options.connection;\n        let node = settings.connection;\n        settings.send = async (message) => {\n          if (message.method) {\n            if (Array.isArray(message.args)) {\n              return node[message.method]?.(...message.args);\n            } else\n              return node[message.method]?.(message.args);\n          } else {\n            if (Array.isArray(message.args)) {\n              return node.run(...message.args);\n            } else\n              return node.run(message.args);\n          }\n        };\n        settings.request = async (message, method) => {\n          if (method) {\n            if (Array.isArray(message.args)) {\n              return node[method]?.(...message.args);\n            } else\n              return node[method]?.(message.args);\n          } else {\n            if (Array.isArray(message.args)) {\n              return node.run(...message.args);\n            } else\n              return node.run(message.args);\n          }\n        };\n        settings.post = async (route, args, method) => {\n          if (route && node.get(route)) {\n            let n = node.get(route);\n            if (method) {\n              if (Array.isArray(args)) {\n                return n[method]?.(...args);\n              } else\n                return n[method]?.(args);\n            } else {\n              if (Array.isArray(args)) {\n                return n.run(...args);\n              } else\n                return n.run(args);\n            }\n          } else {\n            if (method) {\n              if (Array.isArray(args)) {\n                return node[method]?.(...args);\n              } else\n                return node[method]?.(args);\n            } else {\n              if (Array.isArray(args)) {\n                return node.run(...args);\n              } else\n                return node.run(args);\n            }\n          }\n        };\n        settings.run = settings.post;\n        settings.subscribe = async (route, callback) => {\n          return node.subscribe(callback, route);\n        };\n        settings.unsubscribe = async (route, sub) => {\n          return node.unsubscribe(sub, route);\n        };\n        settings.terminate = () => {\n          node.graph.remove(node);\n          return true;\n        };\n        settings.onclose = options.onclose;\n        if (settings.onclose) {\n          let oldondelete;\n          if (node.ondelete)\n            oldondelete = node.ondelete;\n          node.ondelete = (n) => {\n            if (settings.onclose)\n              settings.onclose(settings, n);\n            if (oldondelete)\n              oldondelete(n);\n          };\n        }\n      } else if (options.connection instanceof Graph) {\n        if (options.connection.nodes.get(\"open\"))\n          settings.service = options.connection;\n        let graph = settings.connection;\n        settings.send = async (message) => {\n          if (Array.isArray(message.args))\n            graph.run(message.route, ...message.args);\n          else\n            graph.run(message.route, message.args);\n        };\n        settings.request = async (message, method) => {\n          if (!message.route)\n            return void 0;\n          if (method) {\n            if (Array.isArray(message.args)) {\n              return graph.nodes.get(message.route)[method]?.(...message.args);\n            } else\n              return graph.nodes.get(message.route)[method]?.(message.args);\n          } else {\n            if (Array.isArray(message.args)) {\n              return graph.run(message.route, ...message.args);\n            } else\n              return graph.run(message.route, message.args);\n          }\n        };\n        settings.post = async (route, args, method) => {\n          if (route && graph.get(route)) {\n            let n = graph.get(route);\n            if (method) {\n              if (Array.isArray(args)) {\n                return n[method]?.(...args);\n              } else\n                return n[method]?.(args);\n            } else {\n              if (Array.isArray(args)) {\n                return n.run(...args);\n              } else\n                return n.run(args);\n            }\n          }\n        };\n        settings.run = settings.post;\n        settings.subscribe = async (route, callback) => {\n          return graph.subscribe(route, callback);\n        };\n        settings.unsubscribe = async (route, sub) => {\n          return graph.unsubscribe(route, sub);\n        };\n        settings.terminate = (n) => {\n          graph.remove(n);\n          return true;\n        };\n      } else if (!(options._id && this.connections[options._id])) {\n        let c = options.connection;\n        if (typeof c === \"string\") {\n          if (this.connections[c])\n            c = this.connections[c];\n          else if (options.service) {\n            if (typeof options.service === \"string\") {\n              options.service = this.services[options.service];\n            }\n            if (typeof options.service === \"object\") {\n              if (options.service.connections) {\n                for (const key in options.service.connections) {\n                  if (options.service.connections[key][c]) {\n                    c = options.service.connections[key][c];\n                    settings.connectionType = key;\n                    settings.connectionsKey = c;\n                    break;\n                  }\n                }\n              }\n            }\n          } else {\n            for (const j in this.serviceConnections) {\n              for (const k in this.serviceConnections[j]) {\n                if (this.serviceConnections[j][k][c]) {\n                  c = this.serviceConnections[j][k][c];\n                  options.service = j;\n                  settings.connectionType = j;\n                  settings.connectionsKey = k;\n                  break;\n                }\n              }\n            }\n          }\n        }\n        if (typeof c !== \"object\")\n          return void 0;\n        settings._id = c._id;\n        settings.send = c.send;\n        settings.request = c.request;\n        settings.run = c.run;\n        settings.post = c.post;\n        settings.subscribe = c.subscribe;\n        settings.unsubscribe = c.unsubscribe;\n        settings.terminate = c.terminate;\n        settings.onclose = options.onclose;\n        if (settings.onclose) {\n          if (!(c.onclose && settings.onclose.toString() === c.onclose.toString())) {\n            let oldonclose = c.onclose;\n            c.onclose = (...args) => {\n              if (settings.onclose)\n                settings.onclose(settings, ...args);\n              if (this.users[settings.source] && Object.keys(this.sources[settings.source]).length === 0) {\n                this.removeUser(settings.source, false);\n              }\n              if (oldonclose)\n                oldonclose(...args);\n            };\n          }\n        } else {\n          let oldonclose = c.onclose;\n          c.onclose = (...args) => {\n            this.removeConnection(settings);\n            if (this.users[settings.source] && Object.keys(this.sources[settings.source]).length === 0) {\n              this.removeUser(settings.source, false);\n            }\n            if (oldonclose)\n              oldonclose(...args);\n          };\n        }\n        if (options.service) {\n          if (typeof options.service === \"string\")\n            options.service = this.services[options.service];\n          settings.service = options.service;\n        } else if (c.graph)\n          settings.service = c.graph;\n      }\n      if (!settings.source && options.source) {\n        settings.source = options.source;\n      } else if (!settings.source && options.service) {\n        settings.source = typeof options.service === \"object\" ? options.service.name : void 0;\n      } else if (!settings.source && (settings.connection instanceof GraphNode || settings.connection instanceof Graph)) {\n        settings.source = \"local\";\n        if (!this.order.indexOf(\"local\"))\n          this.order.unshift(\"local\");\n      }\n      if (!settings._id)\n        settings._id = `connection${Math.floor(Math.random() * 1e15)}`;\n      if (settings.source) {\n        if (!this.sources[settings.source])\n          this.sources[settings.source] = {};\n        this.sources[settings.source][settings._id] = settings;\n      }\n      if (!this.connections[settings._id])\n        this.connections[settings._id] = settings;\n      return settings;\n    };\n    this.removeConnection = (connection, terminate = false) => {\n      if (typeof connection === \"object\" && connection._id)\n        connection = connection._id;\n      if (typeof connection === \"string\") {\n        if (this.connections[connection]) {\n          if (terminate && this.connections[connection])\n            this.connections[connection].terminate();\n          delete this.connections[connection];\n          for (const key in this.sources) {\n            if (this.sources[key][connection])\n              delete this.sources[key][connection];\n            else {\n              for (const k in this.sources[key]) {\n                if (this.sources[key][k]?.[connection]) {\n                  delete this.sources[key][connection];\n                }\n              }\n            }\n          }\n          return true;\n        } else if (this.sources[connection]) {\n          for (const key in this.sources[connection]) {\n            this.removeConnection(this.sources[connection][key], terminate);\n          }\n          return true;\n        }\n      }\n    };\n    this.addService = (service, connections, includeClassName, routeFormat, syncServices, source, order) => {\n      this.load(service, includeClassName, routeFormat, this.customRoutes, this.customChildren);\n      this.services[service.name] = service;\n      if (connections) {\n        if (typeof connections === \"string\")\n          this.addServiceConnections(service, connections, source);\n        else {\n          for (const c in connections) {\n            this.addServiceConnections(service, c, source);\n          }\n        }\n      }\n      if (syncServices)\n        this.syncServices();\n      if (order)\n        this.order = order;\n      else {\n        if (!this.order)\n          this.order = [];\n        this.order.push(service.name);\n      }\n    };\n    this.addServiceConnections = (service, connectionsKey, source) => {\n      if (typeof service === \"string\") {\n        service = this.services[service];\n      }\n      if (connectionsKey && service[connectionsKey]) {\n        let newConnections = {};\n        if (!this.serviceConnections[service.name])\n          this.serviceConnections[service.name] = {};\n        this.serviceConnections[service.name][connectionsKey] = service[connectionsKey];\n        for (const key in service[connectionsKey]) {\n          if (!this.connections[key]) {\n            newConnections[key] = this.addConnection({ connection: service[connectionsKey][key], service }, source);\n            newConnections[key].connectionType = connectionsKey;\n          }\n        }\n        return newConnections;\n      }\n    };\n    this.openConnection = async (service, options, source, ...args) => {\n      if (typeof service === \"string\") {\n        service = this.services[service];\n      }\n      if (service instanceof Service) {\n        let connection = service.run(\"open\", options, ...args);\n        if (connection instanceof Promise) {\n          return connection.then(async (info) => {\n            if (!info._id) {\n              await new Promise((res, rej) => {\n                let start = performance.now();\n                let checker = () => {\n                  if (!info._id) {\n                    if (performance.now() - start > 3e3) {\n                      rej(false);\n                    } else {\n                      setTimeout(() => {\n                        checker();\n                      }, 100);\n                    }\n                  } else {\n                    res(true);\n                  }\n                };\n                checker();\n              }).catch((er) => {\n                console.error(\"Connections timed out:\", er);\n              });\n            }\n            if (info._id)\n              this.addConnection({ connection: info, service }, source);\n          });\n        } else if (connection) {\n          if (!connection._id) {\n            await new Promise((res, rej) => {\n              let start = performance.now();\n              let checker = () => {\n                if (!connection._id) {\n                  if (performance.now() - start > 3e3) {\n                    rej(false);\n                  } else {\n                    setTimeout(() => {\n                      checker();\n                    }, 100);\n                  }\n                } else {\n                  res(true);\n                }\n              };\n              checker();\n            }).catch((er) => {\n              console.error(\"Connections timed out:\", er);\n            });\n          }\n          if (connection._id)\n            return this.addConnection({ connection, service }, source);\n        }\n      }\n    };\n    this.terminate = (connection) => {\n      if (typeof connection === \"string\")\n        connection = this.connections[connection];\n      return connection.terminate();\n    };\n    this.subscribeThroughConnection = (route, relay, endpoint, callback, ...args) => {\n      if (typeof relay === \"string\") {\n        relay = this.getConnection(relay, \"run\");\n      }\n      if (typeof relay === \"object\")\n        return new Promise((res, rej) => {\n          relay.run(\"routeConnections\", [route, endpoint, relay._id, ...args]).then((sub) => {\n            this.subscribe(endpoint, (res2) => {\n              if (res2?.callbackId === route) {\n                if (!callback)\n                  this.setState({ [endpoint]: res2.args });\n                else if (typeof callback === \"string\") {\n                  this.setState({ [callback]: res2.args });\n                } else\n                  callback(res2.args);\n              }\n            });\n            res(sub);\n          }).catch(rej);\n        });\n    };\n    this.routeConnections = (route, transmitter, receiver, ...args) => {\n      let rxsrc;\n      if (typeof receiver === \"string\") {\n        if (this.sources[receiver]) {\n          rxsrc = receiver;\n        }\n        receiver = this.getConnection(receiver, \"send\");\n      }\n      if (typeof transmitter === \"string\") {\n        transmitter = this.getConnection(transmitter, \"subscribe\");\n      }\n      if (transmitter?.subscribe && receiver?.send) {\n        let res = new Promise((res2, rej) => {\n          transmitter.subscribe(route, transmitter._id, (res3) => {\n            if (!this.connections[receiver._id] && rxsrc) {\n              if (this.sources[rxsrc]) {\n                rxsrc = receiver;\n                Object.keys(this.sources[rxsrc]).forEach((k) => {\n                  if (this.sources[receiver][k].send) {\n                    receiver = this.sources[receiver][k];\n                  }\n                });\n              }\n            }\n            if (this.connections[receiver._id])\n              receiver.send({ callbackId: route, args: res3 });\n          }, ...args).then((sub) => {\n            res2(sub);\n          });\n        });\n        return res;\n      }\n    };\n    this.syncServices = () => {\n      for (const name in this.services) {\n        if (\"users\" in this.services[name])\n          this.services[name].users = this.users;\n        this.nodes.forEach((n, tag) => {\n          if (!this.services[name].nodes.get(n.tag)) {\n            this.services[name].nodes.set(n.tag, n);\n          } else {\n            if (!this.services[name].nodes.get(tag) && n._UNIQUE !== this.services[name].nodes.get(n.tag)._UNIQUE)\n              this.services[name].nodes.set(tag, n);\n          }\n        });\n      }\n    };\n    this.setUserData = (user, data) => {\n      if (user) {\n        if (typeof user === \"string\") {\n          user = this.users[user];\n          if (!user)\n            return false;\n        }\n      }\n      if (data) {\n        if (typeof data === \"string\") {\n          data = JSON.parse(data);\n        }\n      }\n      if (typeof data === \"object\") {\n        this.recursivelyAssign(user, data);\n        return true;\n      }\n    };\n    this.routes = {\n      addUser: this.addUser,\n      removeUser: this.removeUser,\n      getConnection: this.getConnection,\n      addConnection: this.addConnection,\n      removeConnection: this.removeConnection,\n      addService: this.addService,\n      addServiceConnections: this.addServiceConnections,\n      openConnection: this.openConnection,\n      terminate: this.terminate,\n      routeConnections: this.routeConnections,\n      subscribeThroughConnection: this.subscribeThroughConnection,\n      syncServices: this.syncServices\n    };\n    this.load(this.routes);\n    if (options) {\n      if (options.order)\n        this.order = options.order;\n      if (options.services) {\n        for (const key in options.services) {\n          let opt = options.services[key];\n          if (opt instanceof Service) {\n            opt.service.name = key;\n            opt.service.tag = key;\n            this.addService(opt.service, opt.connections, options.includeClassName, options.routeFormat, options.syncServices);\n          } else if (typeof opt === \"function\") {\n            let service = new opt();\n            service.name = key;\n            service.tag = key;\n            if (service)\n              this.addService(service, service.connections, options.includeClassName, options.routeFormat, options.syncServices);\n          } else {\n            if (typeof opt.service === \"function\") {\n              let service = new opt.service({ name: key });\n              service.name = key;\n              service.tag = key;\n              if (service)\n                this.addService(service, void 0, options.includeClassName, options.routeFormat, options.syncServices);\n              opt.service = service;\n            } else if (opt.service instanceof Service) {\n              opt.service.name = key;\n              opt.service.tag = key;\n              this.addService(opt.service, void 0, options.includeClassName, options.routeFormat, options.syncServices);\n            }\n            if (typeof opt.service === \"object\") {\n              if (opt.connections) {\n                if (Array.isArray(opt.connections)) {\n                  opt.connections.forEach((k) => {\n                    this.addServiceConnections(opt[key].service, k);\n                  });\n                } else\n                  this.addServiceConnections(opt.service, opt.connections);\n              }\n              if (opt.config) {\n                for (const c in opt.config) {\n                  this.openConnection(opt.service, opt.config[c], opt.config[c].source, opt.config[c].args);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  removeUser(profile, terminate) {\n    if (terminate)\n      this.removeConnection(profile, terminate);\n    if (typeof profile === \"string\")\n      profile = this.users[profile];\n    if (typeof profile === \"object\" && profile._id) {\n      delete this.users[profile._id];\n      if (profile.onclose)\n        profile.onclose(profile);\n    }\n    return true;\n  }\n};\n\n// src/transform.ts\nvar transform_default = (tag, node) => {\n  const args = node.arguments;\n  let graph;\n  Array.from(args.keys()).forEach((arg, i) => node[`${arg}`] = args.get(arg).state);\n  const originalOperator = node.operator;\n  if (typeof originalOperator === \"function\") {\n    node.operator = function(...argsArr) {\n      let updatedArgs = [];\n      let i = 0;\n      args.forEach((o, k) => {\n        const argO = args.get(k);\n        const proxy = `${k}`;\n        const currentArg = argO.spread ? argsArr.slice(i) : argsArr[i];\n        const target = graph.node ?? graph;\n        let update = currentArg !== void 0 ? currentArg : target[proxy];\n        target[proxy] = update;\n        if (!argO.spread)\n          update = [update];\n        updatedArgs.push(...update);\n        i++;\n      });\n      return originalOperator.call(this ?? node, ...updatedArgs);\n    };\n  } else {\n    console.error(\"Operator is not a function for\", node.tag, node, originalOperator);\n    node.operator = (...args2) => args2;\n  }\n  graph = new Graph({}, tag, node);\n  return graph;\n};\n\n// src/parse.js\nvar ARGUMENT_NAMES = /([^,]*)/g;\nfunction getFnParamInfo(fn) {\n  var fstr = fn.toString();\n  const openPar = fstr.indexOf(\"(\");\n  const closePar = fstr.indexOf(\")\");\n  const getFirstBracket = (str, offset = 0) => {\n    const fb = offset + str.indexOf(\"{\");\n    if (fb < closePar && fb > openPar) {\n      return getFirstBracket(str.slice(fb), offset + fb);\n    } else\n      return fb;\n  };\n  const firstBracket = getFirstBracket(fstr);\n  let innerMatch;\n  if (firstBracket === -1 || closePar < firstBracket)\n    innerMatch = fstr.slice(fstr.indexOf(\"(\") + 1, fstr.indexOf(\")\"));\n  else\n    innerMatch = fstr.match(/([a-zA-Z]\\w*|\\([a-zA-Z]\\w*(,\\s*[a-zA-Z]\\w*)*\\)) =>/)?.[1];\n  if (!innerMatch)\n    return void 0;\n  const matches = innerMatch.match(ARGUMENT_NAMES).filter((e) => !!e);\n  const info = /* @__PURE__ */ new Map();\n  matches.forEach((v) => {\n    let [name, value] = v.split(\"=\");\n    name = name.trim();\n    name = name.replace(/\\d+$/, \"\");\n    const spread = name.includes(\"...\");\n    name = name.replace(\"...\", \"\");\n    try {\n      if (name)\n        info.set(name, {\n          state: value ? (0, eval)(`(${value})`) : value,\n          spread\n        });\n    } catch (e) {\n      info.set(name, {});\n      console.warn(`Argument ${name} could not be parsed for`, fn.toString(), value);\n    }\n  });\n  return info;\n}\nvar parse_default = getFnParamInfo;\n\n// src/index.js\nvar isNode = \"process\" in globalThis;\nvar ESPlugin = class {\n  #initial;\n  #options;\n  #instance;\n  #graph;\n  #router;\n  #cache = {};\n  #plugins = {};\n  #active = false;\n  plugins = {};\n  #toRun = false;\n  #runProps = true;\n  get initial() {\n    return this.#initial;\n  }\n  get instance() {\n    return this.#instance;\n  }\n  get graph() {\n    return this.#graph;\n  }\n  set graph(v) {\n    this.#graph = v;\n  }\n  constructor(node, options = {}) {\n    this.#initial = node;\n    this.#options = options;\n    this.#router = options._router ? options._router : options._router = new Router({\n      linkServices: false,\n      includeClassName: false\n    });\n    do {\n      this.#initial = this.initial.initial ?? this.initial;\n    } while (this.initial instanceof ESPlugin);\n    const isFunction = typeof this.initial === \"function\";\n    const hasDefault = \"default\" in this.initial;\n    let hasGraph = !!node.graph;\n    if (!hasDefault && !hasGraph) {\n      let newNode = { graph: { nodes: {} } };\n      for (let namedExport in node)\n        newNode.graph.nodes[namedExport] = { default: node[namedExport] };\n      this.#initial = newNode;\n      hasGraph = true;\n      this.#runProps = false;\n    }\n    if (hasDefault || isFunction) {\n      this.graph = this.#create(options.tag ?? \"defaultESPluginTag\", this.initial);\n    }\n    if (hasGraph) {\n      const toNotify = [];\n      const nodes = this.initial.graph.nodes;\n      for (let tag in nodes) {\n        const node2 = nodes[tag];\n        if (!(node2 instanceof ESPlugin)) {\n          const clonedOptions = Object.assign({}, Object.assign(options));\n          const plugin = new ESPlugin(node2, Object.assign(clonedOptions, { tag }));\n          this.#plugins[tag] = plugin;\n          toNotify.push(plugin);\n        } else\n          this.#cache[tag] = this.#plugins[tag] = node2;\n      }\n      const thisTag = this.#options.tag;\n      toNotify.forEach((o) => {\n        let tag = o.#options.tag;\n        if (thisTag)\n          tag = `${thisTag}.${tag}`;\n        this.plugins[o.#options.tag] = o;\n        if (typeof options.onPlugin === \"function\")\n          options.onPlugin(tag, o);\n      });\n    }\n    Object.defineProperty(this, \"tag\", {\n      get: () => this.graph?.tag,\n      enumerable: true\n    });\n  }\n  #createTree = () => {\n    let tree = {};\n    for (let tag in this.#plugins) {\n      let thisNode = this.#plugins[tag].graph;\n      if (this.#cache[tag]) {\n        let gs = this.#cache[tag].graph;\n        const ref = gs.node ? gs.node : gs;\n        thisNode = {};\n        for (let key in ref._initial)\n          thisNode[key] = ref[key];\n        thisNode.tag = tag;\n        gs.state.triggers = {};\n      }\n      tree[tag] = this.#create(tag, thisNode);\n    }\n    let listeningFor = {};\n    let quickLookup = {};\n    let resolve = (path) => {\n      if (quickLookup[path] === void 0) {\n        const splitEdge = path.split(\".\");\n        const first = splitEdge.shift();\n        const lastKey = splitEdge.pop();\n        let last = tree[first];\n        if (last) {\n          splitEdge.forEach((str) => last = last.nodes.get(str));\n          const resolved = lastKey ? last.nodes.get(lastKey) : last;\n          quickLookup[path] = { resolved, last, lastKey };\n        } else\n          console.error(`Target associated with ${path} was not found`);\n      }\n      return quickLookup[path];\n    };\n    let activate = async (edges2, data) => {\n      for (let input in edges2) {\n        let { resolved, last, lastKey } = resolve(input);\n        if (resolved) {\n          const target = resolved.node ?? resolved;\n          if (Array.isArray(data))\n            target.run(...data);\n          else\n            target.run(data);\n        } else {\n          const target = last.node ?? last;\n          let res;\n          if (typeof target[lastKey] === \"function\") {\n            if (Array.isArray(data))\n              res = await target[lastKey](...data);\n            else\n              res = await target[lastKey](data);\n          } else\n            res = target[lastKey] = data;\n          if (listeningFor[input])\n            activate(listeningFor[input], res);\n        }\n      }\n    };\n    const edges = this.initial.graph.edges;\n    for (let output in edges) {\n      let { resolved } = resolve(output);\n      if (resolved) {\n        if (!resolved.children)\n          resolved.children = {};\n        const callback = (data) => {\n          activate(edges[output], data);\n        };\n        if (resolved instanceof GraphNode)\n          resolved.subscribe(callback);\n        else\n          this.#router.state.subscribeTrigger(resolved.tag, callback);\n      } else\n        listeningFor[output] = edges[output];\n    }\n    return tree;\n  };\n  #activate = () => {\n    if (this.initial.graph) {\n      let tree = this.#createTree();\n      const props = this.#instance ?? this.initial;\n      this.graph = isNode ? new Graph(tree, this.#options.tag, props) : new DOMService({ routes: tree, name: this.#options.tag, props: this.#runProps ? props : void 0 }, this.#options.parentNode);\n      this.#router.load(this.graph);\n      for (let tag in this.#plugins) {\n        const cache = this.#cache[tag];\n        if (cache)\n          cache.graph = tree[tag];\n      }\n    }\n  };\n  start = async (defer) => {\n    if (this.#active === false) {\n      this.#active = true;\n      const activateFuncs = [];\n      for (let key in this.plugins) {\n        const o = this.plugins[key];\n        await o.start((f2) => {\n          activateFuncs.push(f2);\n        });\n      }\n      this.#activate();\n      const f = async () => {\n        for (let f2 of activateFuncs)\n          await f2();\n        if (this.#toRun)\n          await this.run();\n      };\n      const graph = this.initial.graph;\n      if (graph) {\n        const ports = graph.ports;\n        let firstNode, lastNode;\n        if (ports) {\n          firstNode = await this.graph.get(ports.input);\n          lastNode = this.graph.get(ports.output);\n        } else {\n          const nodes = Array.from(this.graph.nodes.values());\n          firstNode = nodes[0];\n          lastNode = nodes.slice(-1)[0];\n        }\n        if (lastNode)\n          lastNode.subscribe((...args) => {\n            for (let tag in lastNode.graph.children)\n              this.#runGraph(lastNode.graph.children[tag], ...args);\n          });\n        if (firstNode)\n          this.#initial.operator = async function(...args) {\n            await firstNode.run(...args);\n          };\n      }\n      if (typeof defer === \"function\")\n        defer(f);\n      else\n        await f();\n    }\n  };\n  stop = () => {\n    if (this.#active === true) {\n      for (let k in this.nested)\n        this.nested[k].stop();\n      if (this.graph)\n        this.graph.nodes.forEach((n) => {\n          this.graph.removeTree(n);\n          n.stopNode();\n          this.graph.state.triggers = {};\n        });\n      this.#active = false;\n    }\n  };\n  #create = (tag, info) => {\n    if (typeof info === \"function\")\n      info = { default: info };\n    if (!(\"default\" in info) || info instanceof Graph)\n      return info;\n    else {\n      let activeInfo;\n      if (info instanceof ESPlugin) {\n        activeInfo = info.instance;\n        info = info.initial;\n      }\n      const args = parse_default(info.default) ?? /* @__PURE__ */ new Map();\n      if (args.size === 0)\n        args.set(\"default\", {});\n      let argsArray = Array.from(args.entries());\n      const input = argsArray[0][0];\n      if (info.arguments) {\n        const isArray = Array.isArray(info.arguments);\n        let i = 0;\n        for (let key in info.arguments) {\n          const v = info.arguments[key];\n          if (isArray) {\n            argsArray[i].state = v;\n            if (i == 0)\n              this.#toRun = true;\n          } else {\n            args.get(key).state = v;\n            if (input === key)\n              this.#toRun = true;\n          }\n          i++;\n        }\n      }\n      const gsIn = {\n        arguments: args,\n        operator: info.default,\n        tag,\n        default: info.default\n      };\n      var props = Object.getOwnPropertyNames(info);\n      const onActive = [\"arguments\", \"default\", \"tag\", \"operator\"];\n      props.forEach((key) => {\n        if (!onActive.includes(key))\n          gsIn[key] = info[key];\n      });\n      if (activeInfo) {\n        for (let key in activeInfo) {\n          if (!onActive.includes(key))\n            gsIn[key] = activeInfo[key];\n        }\n      }\n      this.#instance = gsIn;\n      return transform_default(tag, gsIn);\n    }\n  };\n  #runGraph = async (graph = this.graph, ...args) => {\n    if (graph instanceof Graph) {\n      if (graph.node)\n        return graph.node.run(...args);\n      else {\n        if (args.length === 0)\n          return this.#runDefault(graph);\n        else if (graph.nodes.has(args[0]))\n          return graph.run(...args);\n        else\n          return this.#runDefault(graph, ...args);\n      }\n    } else\n      return await graph.run(...args);\n  };\n  #runDefault = (graph, ...args) => graph.run(graph.nodes.values().next().value, ...args);\n  run = async (...args) => this.#runGraph(this.graph, ...args);\n};\nvar src_default = ESPlugin;\nexport {\n  src_default as default\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaM,yBAA0B,KAAW;AAC1C,MAAI,CAAC,UAAU,KAAK,GAAG,GAAG;AACzB,UAAM,IAAI,UACT,kEAAkE;;AAKpE,QAAM,IAAI,QAAQ,UAAU,EAAE;AAG9B,QAAM,aAAa,IAAI,QAAQ,GAAG;AAClC,MAAI,eAAe,MAAM,cAAc,GAAG;AACzC,UAAM,IAAI,UAAU,qBAAqB;;AAI1C,QAAM,OAAO,IAAI,UAAU,GAAG,UAAU,EAAE,MAAM,GAAG;AAEnD,MAAI,UAAU;AACd,MAAI,SAAS;AACb,QAAM,OAAO,KAAK,MAAM;AACxB,MAAI,WAAW;AACf,WAAS,KAAI,GAAG,KAAI,KAAK,QAAQ,MAAK;AACrC,QAAI,KAAK,QAAO,UAAU;AACzB,eAAS;WACH;AACN,kBAAY,IAAM,KAAK;AACvB,UAAI,KAAK,IAAG,QAAQ,UAAU,MAAM,GAAG;AACtC,kBAAU,KAAK,IAAG,UAAU,CAAC;;;;AAKhC,MAAI,CAAC,KAAK,MAAM,CAAC,QAAQ,QAAQ;AAChC,gBAAY;AACZ,cAAU;;AAIX,QAAM,WAAW,SAAS,WAAW;AACrC,QAAM,OAAO,SAAS,IAAI,UAAU,aAAa,CAAC,CAAC;AACnD,QAAM,SAAS,OAAO,KAAK,MAAM,QAAQ;AAGzC,SAAO,OAAO;AACd,SAAO,WAAW;AAGlB,SAAO,UAAU;AAEjB,SAAO;AACR;AA3DA,IA6DA;AA7DA;;AA6DA,IAAA,eAAe;;;;;;;;;;;ACjEf,YAAM,iBACJ,OAAO,WAAW,cAAc,OAAO,OAAO,aAAa,WACzD,SACA,iBAAe,UAAU;uBCHT;AAClB,eAAO;MACT;AAEA,4BAAmB;AACjB,YAAI,OAAO,SAAS,aAAa;AAC/B,iBAAO;mBACE,OAAO,WAAW,aAAa;AACxC,iBAAO;mBACE,OAAO,WAAW,aAAa;AACxC,iBAAO;;AAET,eAAO;MACT;AAEO,YAAM,UAAU,WAAU;4BCdJ,IAAM;AACjC,eAAQ,OAAO,OAAM,YAAY,OAAM,QAAS,OAAO,OAAM;MAC/D;AAEO,YAAM,iCAUP;ACbN,YAAM,kBAAkB;AACxB,YAAM,sBAAsB,QAAQ,UAAU;AAC9C,YAAM,yBAAyB,QAAQ,QAAQ,KAAK,eAAe;AACnE,YAAM,wBAAwB,QAAQ,OAAO,KAAK,eAAe;0BAEnC,UAGrB;AACP,eAAO,IAAI,gBAAgB,QAAQ;MACrC;mCAEuC,OAAyB;AAC9D,eAAO,uBAAuB,KAAK;MACrC;mCAE+C,QAAW;AACxD,eAAO,sBAAsB,MAAM;MACrC;kCAGE,SACA,aACA,YAA8D;AAG9D,eAAO,oBAAoB,KAAK,SAAS,aAAa,UAAU;MAClE;2BAGE,SACA,aACA,YAAsD;AACtD,2BACE,mBAAmB,SAAS,aAAa,UAAU,GACnD,QACA,8BAA8B;MAElC;+BAEmC,SAAqB,aAAmD;AACzG,oBAAY,SAAS,WAAW;MAClC;6BAE8B,SAA2B,YAAqD;AAC5G,oBAAY,SAAS,QAAW,UAAU;MAC5C;oCAGE,SACA,oBACA,kBAAoE;AACpE,eAAO,mBAAmB,SAAS,oBAAoB,gBAAgB;MACzE;yCAE0C,SAAyB;AACjE,2BAAmB,SAAS,QAAW,8BAA8B;MACvE;AAEO,YAAM,iBAA4C,OAAA;AACvD,cAAM,uBAAuB,WAAW,QAAQ;AAChD,YAAI,OAAO,yBAAyB,YAAY;AAC9C,iBAAO;;AAGT,cAAM,kBAAkB,oBAAoB,MAAS;AACrD,eAAO,CAAC,OAAmB,mBAAmB,iBAAiB,EAAE;MACnE,GAAC;2BAEkD,IAAiC,GAAM,MAAO;AAC/F,YAAI,OAAO,OAAM,YAAY;AAC3B,gBAAM,IAAI,UAAU,4BAA4B;;AAElD,eAAO,SAAS,UAAU,MAAM,KAAK,IAAG,GAAG,IAAI;MACjD;2BAEmD,IACA,GACA,MAAO;AAIxD,YAAI;AACF,iBAAO,oBAAoB,YAAY,IAAG,GAAG,IAAI,CAAC;iBAC3C,OAAP;AACA,iBAAO,oBAAoB,KAAK;;MAEpC;ACtFA,YAAM,uBAAuB;YAahB,YAAW;QAMtB,cAAA;AAHQ,eAAA,UAAU;AACV,eAAA,QAAQ;AAId,eAAK,SAAS;YACZ,WAAW,CAAA;YACX,OAAO;;AAET,eAAK,QAAQ,KAAK;AAIlB,eAAK,UAAU;AAEf,eAAK,QAAQ;;QAGf,IAAI,SAAM;AACR,iBAAO,KAAK;;QAOd,KAAK,SAAU;AACb,gBAAM,UAAU,KAAK;AACrB,cAAI,UAAU;AAEd,cAAI,QAAQ,UAAU,WAAW,uBAAuB,GAAG;AACzD,sBAAU;cACR,WAAW,CAAA;cACX,OAAO;;;AAMX,kBAAQ,UAAU,KAAK,OAAO;AAC9B,cAAI,YAAY,SAAS;AACvB,iBAAK,QAAQ;AACb,oBAAQ,QAAQ;;AAElB,YAAE,KAAK;;QAKT,QAAK;AAGH,gBAAM,WAAW,KAAK;AACtB,cAAI,WAAW;AACf,gBAAM,YAAY,KAAK;AACvB,cAAI,YAAY,YAAY;AAE5B,gBAAM,WAAW,SAAS;AAC1B,gBAAM,UAAU,SAAS;AAEzB,cAAI,cAAc,sBAAsB;AAGtC,uBAAW,SAAS;AACpB,wBAAY;;AAId,YAAE,KAAK;AACP,eAAK,UAAU;AACf,cAAI,aAAa,UAAU;AACzB,iBAAK,SAAS;;AAIhB,mBAAS,aAAa;AAEtB,iBAAO;;QAWT,QAAQ,UAA8B;AACpC,cAAI,KAAI,KAAK;AACb,cAAI,OAAO,KAAK;AAChB,cAAI,WAAW,KAAK;AACpB,iBAAO,OAAM,SAAS,UAAU,KAAK,UAAU,QAAW;AACxD,gBAAI,OAAM,SAAS,QAAQ;AAGzB,qBAAO,KAAK;AACZ,yBAAW,KAAK;AAChB,mBAAI;AACJ,kBAAI,SAAS,WAAW,GAAG;AACzB;;;AAGJ,qBAAS,SAAS,GAAE;AACpB,cAAE;;;QAMN,OAAI;AAGF,gBAAM,QAAQ,KAAK;AACnB,gBAAM,SAAS,KAAK;AACpB,iBAAO,MAAM,UAAU;;;qDCpI8B,QAAiC,QAAyB;AACjH,eAAO,uBAAuB;AAC9B,eAAO,UAAU;AAEjB,YAAI,OAAO,WAAW,YAAY;AAChC,+CAAqC,MAAM;mBAClC,OAAO,WAAW,UAAU;AACrC,yDAA+C,MAAM;eAChD;AAGL,yDAA+C,QAAQ,OAAO,YAAY;;MAE9E;iDAKkD,QAAmC,QAAW;AAC9F,cAAM,SAAS,OAAO;AAEtB,eAAO,qBAAqB,QAAQ,MAAM;MAC5C;kDAEmD,QAAiC;AAIlF,YAAI,OAAO,qBAAqB,WAAW,YAAY;AACrD,2CACE,QACA,IAAI,UAAU,kFAAkF,CAAC;eAC9F;AACL,oDACE,QACA,IAAI,UAAU,kFAAkF,CAAC;;AAGrG,eAAO,qBAAqB,UAAU;AACtC,eAAO,uBAAuB;MAChC;mCAIoC,OAAY;AAC9C,eAAO,IAAI,UAAU,YAAY,QAAO,mCAAmC;MAC7E;oDAIqD,QAAiC;AACpF,eAAO,iBAAiB,WAAW,CAAC,UAAS,WAAM;AACjD,iBAAO,yBAAyB;AAChC,iBAAO,wBAAwB;SAChC;MACH;8DAE+D,QAAmC,QAAW;AAC3G,6CAAqC,MAAM;AAC3C,yCAAiC,QAAQ,MAAM;MACjD;8DAE+D,QAAiC;AAC9F,6CAAqC,MAAM;AAC3C,0CAAkC,MAAM;MAC1C;gDAEiD,QAAmC,QAAW;AAC7F,YAAI,OAAO,0BAA0B,QAAW;AAC9C;;AAGF,kCAA0B,OAAO,cAAc;AAC/C,eAAO,sBAAsB,MAAM;AACnC,eAAO,yBAAyB;AAChC,eAAO,wBAAwB;MACjC;yDAE0D,QAAmC,QAAW;AAItG,uDAA+C,QAAQ,MAAM;MAC/D;iDAEkD,QAAiC;AACjF,YAAI,OAAO,2BAA2B,QAAW;AAC/C;;AAGF,eAAO,uBAAuB,MAAS;AACvC,eAAO,yBAAyB;AAChC,eAAO,wBAAwB;MACjC;ACjGO,YAAM,aAAa,eAAO,gBAAgB;AAC1C,YAAM,aAAa,eAAO,gBAAgB;AAC1C,YAAM,cAAc,eAAO,iBAAiB;AAC5C,YAAM,YAAY,eAAO,eAAe;ACA/C,YAAM,iBAAyC,OAAO,YAAY,SAAU,IAAC;AAC3E,eAAO,OAAO,OAAM,YAAY,SAAS,EAAC;MAC5C;ACFA,YAAM,YAA+B,KAAK,SAAS,SAAU,GAAC;AAC5D,eAAO,IAAI,IAAI,KAAK,KAAK,CAAC,IAAI,KAAK,MAAM,CAAC;MAC5C;4BCD6B,IAAM;AACjC,eAAO,OAAO,OAAM,YAAY,OAAO,OAAM;MAC/C;gCAEiC,KACA,SAAe;AAC9C,YAAI,QAAQ,UAAa,CAAC,aAAa,GAAG,GAAG;AAC3C,gBAAM,IAAI,UAAU,GAAG,2BAA2B;;MAEtD;8BAK+B,IAAY,SAAe;AACxD,YAAI,OAAO,OAAM,YAAY;AAC3B,gBAAM,IAAI,UAAU,GAAG,4BAA4B;;MAEvD;wBAGyB,IAAM;AAC7B,eAAQ,OAAO,OAAM,YAAY,OAAM,QAAS,OAAO,OAAM;MAC/D;4BAE6B,IACA,SAAe;AAC1C,YAAI,CAAC,SAAS,EAAC,GAAG;AAChB,gBAAM,IAAI,UAAU,GAAG,2BAA2B;;MAEtD;sCAEsD,IACA,UACA,SAAe;AACnE,YAAI,OAAM,QAAW;AACnB,gBAAM,IAAI,UAAU,aAAa,4BAA4B,WAAW;;MAE5E;mCAEmD,IACA,OACA,SAAe;AAChE,YAAI,OAAM,QAAW;AACnB,gBAAM,IAAI,UAAU,GAAG,yBAAyB,WAAW;;MAE/D;yCAG0C,OAAc;AACtD,eAAO,OAAO,KAAK;MACrB;AAEA,kCAA4B,IAAS;AACnC,eAAO,OAAM,IAAI,IAAI;MACvB;AAEA,2BAAqB,IAAS;AAC5B,eAAO,mBAAmB,UAAU,EAAC,CAAC;MACxC;uDAGwD,OAAgB,SAAe;AACrF,cAAM,aAAa;AACnB,cAAM,aAAa,OAAO;AAE1B,YAAI,KAAI,OAAO,KAAK;AACpB,aAAI,mBAAmB,EAAC;AAExB,YAAI,CAAC,eAAe,EAAC,GAAG;AACtB,gBAAM,IAAI,UAAU,GAAG,gCAAgC;;AAGzD,aAAI,YAAY,EAAC;AAEjB,YAAI,KAAI,cAAc,KAAI,YAAY;AACpC,gBAAM,IAAI,UAAU,GAAG,4CAA4C,iBAAiB,uBAAuB;;AAG7G,YAAI,CAAC,eAAe,EAAC,KAAK,OAAM,GAAG;AACjC,iBAAO;;AAQT,eAAO;MACT;oCC3FqC,IAAY,SAAe;AAC9D,YAAI,CAAC,iBAAiB,EAAC,GAAG;AACxB,gBAAM,IAAI,UAAU,GAAG,kCAAkC;;MAE7D;kDCwBsD,QAAsB;AAC1E,eAAO,IAAI,4BAA4B,MAAM;MAC/C;4CAIgD,QACA,aAA2B;AAIxE,eAAO,QAA4C,cAAc,KAAK,WAAW;MACpF;gDAEoD,QAA2B,OAAsB,MAAa;AAChH,cAAM,SAAS,OAAO;AAItB,cAAM,cAAc,OAAO,cAAc,MAAK;AAC9C,YAAI,MAAM;AACR,sBAAY,YAAW;eAClB;AACL,sBAAY,YAAY,KAAM;;MAElC;gDAEoD,QAAyB;AAC3E,eAAQ,OAAO,QAA2C,cAAc;MAC1E;8CAE+C,QAAsB;AACnE,cAAM,SAAS,OAAO;AAEtB,YAAI,WAAW,QAAW;AACxB,iBAAO;;AAGT,YAAI,CAAC,8BAA8B,MAAM,GAAG;AAC1C,iBAAO;;AAGT,eAAO;MACT;YAiBa,4BAA2B;QAYtC,YAAY,QAAyB;AACnC,iCAAuB,QAAQ,GAAG,6BAA6B;AAC/D,+BAAqB,QAAQ,iBAAiB;AAE9C,cAAI,uBAAuB,MAAM,GAAG;AAClC,kBAAM,IAAI,UAAU,6EAA6E;;AAGnG,gDAAsC,MAAM,MAAM;AAElD,eAAK,gBAAgB,IAAI,YAAW;;QAOtC,IAAI,SAAM;AACR,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,iCAAiC,QAAQ,CAAC;;AAGvE,iBAAO,KAAK;;QAMd,OAAO,SAAc,QAAS;AAC5B,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,iCAAiC,QAAQ,CAAC;;AAGvE,cAAI,KAAK,yBAAyB,QAAW;AAC3C,mBAAO,oBAAoB,oBAAoB,QAAQ,CAAC;;AAG1D,iBAAO,kCAAkC,MAAM,MAAM;;QAQvD,OAAI;AACF,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,iCAAiC,MAAM,CAAC;;AAGrE,cAAI,KAAK,yBAAyB,QAAW;AAC3C,mBAAO,oBAAoB,oBAAoB,WAAW,CAAC;;AAG7D,cAAI;AACJ,cAAI;AACJ,gBAAM,UAAU,WAA+C,CAAC,UAAS,WAAM;AAC7E,6BAAiB;AACjB,4BAAgB;WACjB;AACD,gBAAM,cAA8B;YAClC,aAAa,WAAS,eAAe,EAAE,OAAO,OAAO,MAAM,MAAK,CAAE;YAClE,aAAa,MAAM,eAAe,EAAE,OAAO,QAAW,MAAM,KAAI,CAAE;YAClE,aAAa,QAAK,cAAc,EAAC;;AAEnC,0CAAgC,MAAM,WAAW;AACjD,iBAAO;;QAYT,cAAW;AACT,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,kBAAM,iCAAiC,aAAa;;AAGtD,cAAI,KAAK,yBAAyB,QAAW;AAC3C;;AAGF,cAAI,KAAK,cAAc,SAAS,GAAG;AACjC,kBAAM,IAAI,UAAU,qFAAqF;;AAG3G,6CAAmC,IAAI;;;AAI3C,aAAO,iBAAiB,4BAA4B,WAAW;QAC7D,QAAQ,EAAE,YAAY,KAAI;QAC1B,MAAM,EAAE,YAAY,KAAI;QACxB,aAAa,EAAE,YAAY,KAAI;QAC/B,QAAQ,EAAE,YAAY,KAAI;OAC3B;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,4BAA4B,WAAW,eAAO,aAAa;UAC/E,OAAO;UACP,cAAc;SACf;;6CAKoD,IAAM;AAC3D,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,eAAe,GAAG;AAC7D,iBAAO;;AAGT,eAAO,cAAa;MACtB;+CAEmD,QACA,aAA2B;AAC5E,cAAM,SAAS,OAAO;AAItB,eAAO,aAAa;AAEpB,YAAI,OAAO,WAAW,UAAU;AAC9B,sBAAY,YAAW;mBACd,OAAO,WAAW,WAAW;AACtC,sBAAY,YAAY,OAAO,YAAY;eACtC;AAEL,iBAAO,0BAA0B,WAAW,WAA+B;;MAE/E;AAIA,gDAA0C,OAAY;AACpD,eAAO,IAAI,UACT,yCAAyC,yDAAwD;MACrG;ACpPO,YAAM,yBACX,OAAO,eAAe,OAAO,eAAe,mBAAA;MAAA,CAAiD,EAAE,SAAS;YCiC7F,gCAA+B;QAM1C,YAAY,QAAwC,eAAsB;AAHlE,eAAA,kBAA2E;AAC3E,eAAA,cAAc;AAGpB,eAAK,UAAU;AACf,eAAK,iBAAiB;;QAGxB,OAAI;AACF,gBAAM,YAAY,MAAM,KAAK,WAAU;AACvC,eAAK,kBAAkB,KAAK,kBAC1B,qBAAqB,KAAK,iBAAiB,WAAW,SAAS,IAC/D,UAAS;AACX,iBAAO,KAAK;;QAGd,OAAO,OAAU;AACf,gBAAM,cAAc,MAAM,KAAK,aAAa,KAAK;AACjD,iBAAO,KAAK,kBACV,qBAAqB,KAAK,iBAAiB,aAAa,WAAW,IACnE,YAAW;;QAGP,aAAU;AAChB,cAAI,KAAK,aAAa;AACpB,mBAAO,QAAQ,QAAQ,EAAE,OAAO,QAAW,MAAM,KAAI,CAAE;;AAGzD,gBAAM,SAAS,KAAK;AACpB,cAAI,OAAO,yBAAyB,QAAW;AAC7C,mBAAO,oBAAoB,oBAAoB,SAAS,CAAC;;AAG3D,cAAI;AACJ,cAAI;AACJ,gBAAM,UAAU,WAA+C,CAAC,UAAS,WAAM;AAC7E,6BAAiB;AACjB,4BAAgB;WACjB;AACD,gBAAM,cAA8B;YAClC,aAAa,WAAK;AAChB,mBAAK,kBAAkB;AAGvB,6BAAe,MAAM,eAAe,EAAE,OAAO,OAAO,MAAM,MAAK,CAAE,CAAC;;YAEpE,aAAa,MAAA;AACX,mBAAK,kBAAkB;AACvB,mBAAK,cAAc;AACnB,iDAAmC,MAAM;AACzC,6BAAe,EAAE,OAAO,QAAW,MAAM,KAAI,CAAE;;YAEjD,aAAa,YAAM;AACjB,mBAAK,kBAAkB;AACvB,mBAAK,cAAc;AACnB,iDAAmC,MAAM;AACzC,4BAAc,MAAM;;;AAGxB,0CAAgC,QAAQ,WAAW;AACnD,iBAAO;;QAGD,aAAa,OAAU;AAC7B,cAAI,KAAK,aAAa;AACpB,mBAAO,QAAQ,QAAQ,EAAE,OAAO,MAAM,KAAI,CAAE;;AAE9C,eAAK,cAAc;AAEnB,gBAAM,SAAS,KAAK;AACpB,cAAI,OAAO,yBAAyB,QAAW;AAC7C,mBAAO,oBAAoB,oBAAoB,kBAAkB,CAAC;;AAKpE,cAAI,CAAC,KAAK,gBAAgB;AACxB,kBAAM,SAAS,kCAAkC,QAAQ,KAAK;AAC9D,+CAAmC,MAAM;AACzC,mBAAO,qBAAqB,QAAQ,MAAO,GAAE,OAAO,MAAM,KAAI,EAAG;;AAGnE,6CAAmC,MAAM;AACzC,iBAAO,oBAAoB,EAAE,OAAO,MAAM,KAAI,CAAE;;;AAapD,YAAM,uCAAiF;QACrF,OAAI;AACF,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,uCAAuC,MAAM,CAAC;;AAE3E,iBAAO,KAAK,mBAAmB,KAAI;;QAGrC,OAAuD,OAAU;AAC/D,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,uCAAuC,QAAQ,CAAC;;AAE7E,iBAAO,KAAK,mBAAmB,OAAO,KAAK;;;AAG/C,UAAI,2BAA2B,QAAW;AACxC,eAAO,eAAe,sCAAsC,sBAAsB;;kDAK9B,QACA,eAAsB;AAC1E,cAAM,SAAS,mCAAsC,MAAM;AAC3D,cAAM,OAAO,IAAI,gCAAgC,QAAQ,aAAa;AACtE,cAAM,WAAmD,OAAO,OAAO,oCAAoC;AAC3G,iBAAS,qBAAqB;AAC9B,eAAO;MACT;AAEA,6CAAgD,IAAM;AACpD,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,oBAAoB,GAAG;AAClE,iBAAO;;AAGT,YAAI;AAEF,iBAAQ,GAA+C,8BACrD;iBACF,IAAA;AACA,iBAAO;;MAEX;AAIA,sDAAgD,OAAY;AAC1D,eAAO,IAAI,UAAU,+BAA+B,wDAAuD;MAC7G;ACzLA,YAAM,cAAmC,OAAO,SAAS,SAAU,IAAC;AAElE,eAAO,OAAM;MACf;mCCNqD,UAAW;AAG9D,eAAO,SAAS,MAAK;MACvB;kCAEmC,MACA,YACA,KACA,WACA,GAAS;AAC1C,YAAI,WAAW,IAAI,EAAE,IAAI,IAAI,WAAW,KAAK,WAAW,CAAC,GAAG,UAAU;MACxE;mCAG+D,GAAI;AACjE,eAAO;MACT;gCAUiC,GAAkB;AACjD,eAAO;MACT;gCAEiC,QAAyB,OAAe,KAAW;AAGlF,YAAI,OAAO,OAAO;AAChB,iBAAO,OAAO,MAAM,OAAO,GAAG;;AAEhC,cAAM,SAAS,MAAM;AACrB,cAAM,QAAQ,IAAI,YAAY,MAAM;AACpC,2BAAmB,OAAO,GAAG,QAAQ,OAAO,MAAM;AAClD,eAAO;MACT;mCCtCoC,GAAS;AAC3C,YAAI,OAAO,MAAM,UAAU;AACzB,iBAAO;;AAGT,YAAI,YAAY,CAAC,GAAG;AAClB,iBAAO;;AAGT,YAAI,IAAI,GAAG;AACT,iBAAO;;AAGT,eAAO;MACT;iCAEkC,GAAkB;AAClD,cAAM,SAAS,iBAAiB,EAAE,QAAQ,EAAE,YAAY,EAAE,aAAa,EAAE,UAAU;AACnF,eAAO,IAAI,WAAW,MAAM;MAC9B;4BCRgC,WAAuC;AAIrE,cAAM,OAAO,UAAU,OAAO,MAAK;AACnC,kBAAU,mBAAmB,KAAK;AAClC,YAAI,UAAU,kBAAkB,GAAG;AACjC,oBAAU,kBAAkB;;AAG9B,eAAO,KAAK;MACd;oCAEwC,WAAyC,OAAU,MAAY;AAGrG,YAAI,CAAC,oBAAoB,IAAI,KAAK,SAAS,UAAU;AACnD,gBAAM,IAAI,WAAW,sDAAsD;;AAG7E,kBAAU,OAAO,KAAK,EAAE,OAAO,KAAI,CAAE;AACrC,kBAAU,mBAAmB;MAC/B;8BAEkC,WAAuC;AAIvE,cAAM,OAAO,UAAU,OAAO,KAAI;AAClC,eAAO,KAAK;MACd;0BAE8B,WAA4B;AAGxD,kBAAU,SAAS,IAAI,YAAW;AAClC,kBAAU,kBAAkB;MAC9B;YCTa,0BAAyB;QAMpC,cAAA;AACE,gBAAM,IAAI,UAAU,qBAAqB;;QAM3C,IAAI,OAAI;AACN,cAAI,CAAC,4BAA4B,IAAI,GAAG;AACtC,kBAAM,+BAA+B,MAAM;;AAG7C,iBAAO,KAAK;;QAWd,QAAQ,cAAgC;AACtC,cAAI,CAAC,4BAA4B,IAAI,GAAG;AACtC,kBAAM,+BAA+B,SAAS;;AAEhD,iCAAuB,cAAc,GAAG,SAAS;AACjD,yBAAe,wCAAwC,cAAc,iBAAiB;AAEtF,cAAI,KAAK,4CAA4C,QAAW;AAC9D,kBAAM,IAAI,UAAU,wCAAwC;;AAG9D,cAAI,iBAAiB,KAAK,MAAO,MAAM;AAAG;AAO1C,8CAAoC,KAAK,yCAAyC,YAAY;;QAWhG,mBAAmB,MAAiC;AAClD,cAAI,CAAC,4BAA4B,IAAI,GAAG;AACtC,kBAAM,+BAA+B,oBAAoB;;AAE3D,iCAAuB,MAAM,GAAG,oBAAoB;AAEpD,cAAI,CAAC,YAAY,OAAO,IAAI,GAAG;AAC7B,kBAAM,IAAI,UAAU,8CAA8C;;AAGpE,cAAI,KAAK,4CAA4C,QAAW;AAC9D,kBAAM,IAAI,UAAU,wCAAwC;;AAG9D,cAAI,iBAAiB,KAAK,MAAM;AAAG;AAInC,yDAA+C,KAAK,yCAAyC,IAAI;;;AAIrG,aAAO,iBAAiB,0BAA0B,WAAW;QAC3D,SAAS,EAAE,YAAY,KAAI;QAC3B,oBAAoB,EAAE,YAAY,KAAI;QACtC,MAAM,EAAE,YAAY,KAAI;OACzB;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,0BAA0B,WAAW,eAAO,aAAa;UAC7E,OAAO;UACP,cAAc;SACf;;YA+CU,6BAA4B;QA4BvC,cAAA;AACE,gBAAM,IAAI,UAAU,qBAAqB;;QAM3C,IAAI,cAAW;AACb,cAAI,CAAC,+BAA+B,IAAI,GAAG;AACzC,kBAAM,wCAAwC,aAAa;;AAG7D,iBAAO,2CAA2C,IAAI;;QAOxD,IAAI,cAAW;AACb,cAAI,CAAC,+BAA+B,IAAI,GAAG;AACzC,kBAAM,wCAAwC,aAAa;;AAG7D,iBAAO,2CAA2C,IAAI;;QAOxD,QAAK;AACH,cAAI,CAAC,+BAA+B,IAAI,GAAG;AACzC,kBAAM,wCAAwC,OAAO;;AAGvD,cAAI,KAAK,iBAAiB;AACxB,kBAAM,IAAI,UAAU,4DAA4D;;AAGlF,gBAAM,SAAQ,KAAK,8BAA8B;AACjD,cAAI,WAAU,YAAY;AACxB,kBAAM,IAAI,UAAU,kBAAkB,iEAAgE;;AAGxG,4CAAkC,IAAI;;QAQxC,QAAQ,OAAkC;AACxC,cAAI,CAAC,+BAA+B,IAAI,GAAG;AACzC,kBAAM,wCAAwC,SAAS;;AAGzD,iCAAuB,OAAO,GAAG,SAAS;AAC1C,cAAI,CAAC,YAAY,OAAO,KAAK,GAAG;AAC9B,kBAAM,IAAI,UAAU,oCAAoC;;AAE1D,cAAI,MAAM,eAAe,GAAG;AAC1B,kBAAM,IAAI,UAAU,qCAAqC;;AAE3D,cAAI,MAAM,OAAO,eAAe,GAAG;AACjC,kBAAM,IAAI,UAAU,8CAA8C;;AAGpE,cAAI,KAAK,iBAAiB;AACxB,kBAAM,IAAI,UAAU,8BAA8B;;AAGpD,gBAAM,SAAQ,KAAK,8BAA8B;AACjD,cAAI,WAAU,YAAY;AACxB,kBAAM,IAAI,UAAU,kBAAkB,sEAAqE;;AAG7G,8CAAoC,MAAM,KAAK;;QAMjD,MAAM,KAAS,QAAS;AACtB,cAAI,CAAC,+BAA+B,IAAI,GAAG;AACzC,kBAAM,wCAAwC,OAAO;;AAGvD,4CAAkC,MAAM,EAAC;;QAI3C,CAAC,aAAa,QAAW;AACvB,4DAAkD,IAAI;AAEtD,qBAAW,IAAI;AAEf,gBAAM,SAAS,KAAK,iBAAiB,MAAM;AAC3C,sDAA4C,IAAI;AAChD,iBAAO;;QAIT,CAAC,WAAW,aAAoC;AAC9C,gBAAM,SAAS,KAAK;AAGpB,cAAI,KAAK,kBAAkB,GAAG;AAG5B,kBAAM,QAAQ,KAAK,OAAO,MAAK;AAC/B,iBAAK,mBAAmB,MAAM;AAE9B,yDAA6C,IAAI;AAEjD,kBAAM,OAAO,IAAI,WAAW,MAAM,QAAQ,MAAM,YAAY,MAAM,UAAU;AAE5E,wBAAY,YAAY,IAAI;AAC5B;;AAGF,gBAAM,wBAAwB,KAAK;AACnC,cAAI,0BAA0B,QAAW;AACvC,gBAAI;AACJ,gBAAI;AACF,uBAAS,IAAI,YAAY,qBAAqB;qBACvC,SAAP;AACA,0BAAY,YAAY,OAAO;AAC/B;;AAGF,kBAAM,qBAAgD;cACpD;cACA,kBAAkB;cAClB,YAAY;cACZ,YAAY;cACZ,aAAa;cACb,aAAa;cACb,iBAAiB;cACjB,YAAY;;AAGd,iBAAK,kBAAkB,KAAK,kBAAkB;;AAGhD,uCAA6B,QAAQ,WAAW;AAChD,uDAA6C,IAAI;;;AAIrD,aAAO,iBAAiB,6BAA6B,WAAW;QAC9D,OAAO,EAAE,YAAY,KAAI;QACzB,SAAS,EAAE,YAAY,KAAI;QAC3B,OAAO,EAAE,YAAY,KAAI;QACzB,aAAa,EAAE,YAAY,KAAI;QAC/B,aAAa,EAAE,YAAY,KAAI;OAChC;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,6BAA6B,WAAW,eAAO,aAAa;UAChF,OAAO;UACP,cAAc;SACf;;8CAK4C,IAAM;AACnD,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,+BAA+B,GAAG;AAC7E,iBAAO;;AAGT,eAAO,cAAa;MACtB;AAEA,2CAAqC,IAAM;AACzC,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,yCAAyC,GAAG;AACvF,iBAAO;;AAGT,eAAO,cAAa;MACtB;AAEA,4DAAsD,YAAwC;AAC5F,cAAM,aAAa,2CAA2C,UAAU;AACxE,YAAI,CAAC,YAAY;AACf;;AAGF,YAAI,WAAW,UAAU;AACvB,qBAAW,aAAa;AACxB;;AAKF,mBAAW,WAAW;AAGtB,cAAM,cAAc,WAAW,eAAc;AAC7C,oBACE,aACA,MAAA;AACE,qBAAW,WAAW;AAEtB,cAAI,WAAW,YAAY;AACzB,uBAAW,aAAa;AACxB,yDAA6C,UAAU;;WAG3D,QAAC;AACC,4CAAkC,YAAY,EAAC;SAChD;MAEL;AAEA,iEAA2D,YAAwC;AACjG,0DAAkD,UAAU;AAC5D,mBAAW,oBAAoB,IAAI,YAAW;MAChD;AAEA,oEACE,QACA,oBAAyC;AAIzC,YAAI,OAAO;AACX,YAAI,OAAO,WAAW,UAAU;AAE9B,iBAAO;;AAGT,cAAM,aAAa,sDAAyD,kBAAkB;AAC9F,YAAI,mBAAmB,eAAe,WAAW;AAC/C,2CAAiC,QAAQ,YAAqC,IAAI;eAC7E;AAEL,+CAAqC,QAAQ,YAAY,IAAI;;MAEjE;AAEA,qEACE,oBAAyC;AAEzC,cAAM,cAAc,mBAAmB;AACvC,cAAM,cAAc,mBAAmB;AAKvC,eAAO,IAAI,mBAAmB,gBAC5B,mBAAmB,QAAQ,mBAAmB,YAAY,cAAc,WAAW;MACvF;AAEA,+DAAyD,YACA,QACA,YACA,YAAkB;AACzE,mBAAW,OAAO,KAAK,EAAE,QAAQ,YAAY,WAAU,CAAE;AACzD,mBAAW,mBAAmB;MAChC;AAEA,2EAAqE,YACA,oBAAsC;AACzG,cAAM,cAAc,mBAAmB;AAEvC,cAAM,sBAAsB,mBAAmB,cAAc,mBAAmB,cAAc;AAE9F,cAAM,iBAAiB,KAAK,IAAI,WAAW,iBACX,mBAAmB,aAAa,mBAAmB,WAAW;AAC9F,cAAM,iBAAiB,mBAAmB,cAAc;AACxD,cAAM,kBAAkB,iBAAiB,iBAAiB;AAE1D,YAAI,4BAA4B;AAChC,YAAI,SAAQ;AACZ,YAAI,kBAAkB,qBAAqB;AACzC,sCAA4B,kBAAkB,mBAAmB;AACjE,mBAAQ;;AAGV,cAAM,QAAQ,WAAW;AAEzB,eAAO,4BAA4B,GAAG;AACpC,gBAAM,cAAc,MAAM,KAAI;AAE9B,gBAAM,cAAc,KAAK,IAAI,2BAA2B,YAAY,UAAU;AAE9E,gBAAM,YAAY,mBAAmB,aAAa,mBAAmB;AACrE,6BAAmB,mBAAmB,QAAQ,WAAW,YAAY,QAAQ,YAAY,YAAY,WAAW;AAEhH,cAAI,YAAY,eAAe,aAAa;AAC1C,kBAAM,MAAK;iBACN;AACL,wBAAY,cAAc;AAC1B,wBAAY,cAAc;;AAE5B,qBAAW,mBAAmB;AAE9B,iEAAuD,YAAY,aAAa,kBAAkB;AAElG,uCAA6B;;AAS/B,eAAO;MACT;AAEA,sEAAgE,YACA,MACA,oBAAsC;AAGpG,2BAAmB,eAAe;MACpC;AAEA,4DAAsD,YAAwC;AAG5F,YAAI,WAAW,oBAAoB,KAAK,WAAW,iBAAiB;AAClE,sDAA4C,UAAU;AACtD,8BAAoB,WAAW,6BAA6B;eACvD;AACL,uDAA6C,UAAU;;MAE3D;AAEA,iEAA2D,YAAwC;AACjG,YAAI,WAAW,iBAAiB,MAAM;AACpC;;AAGF,mBAAW,aAAa,0CAA0C;AAClE,mBAAW,aAAa,QAAQ;AAChC,mBAAW,eAAe;MAC5B;AAEA,gFAA0E,YAAwC;AAGhH,eAAO,WAAW,kBAAkB,SAAS,GAAG;AAC9C,cAAI,WAAW,oBAAoB,GAAG;AACpC;;AAGF,gBAAM,qBAAqB,WAAW,kBAAkB,KAAI;AAE5D,cAAI,4DAA4D,YAAY,kBAAkB,GAAG;AAC/F,6DAAiD,UAAU;AAE3D,iEACE,WAAW,+BACX,kBAAkB;;;MAI1B;oDAGE,YACA,MACA,iBAAmC;AAEnC,cAAM,SAAS,WAAW;AAE1B,YAAI,cAAc;AAClB,YAAI,KAAK,gBAAgB,UAAU;AACjC,wBAAe,KAAK,YAA8C;;AAGpE,cAAM,OAAO,KAAK;AAGlB,cAAM,SAAS,oBAAoB,KAAK,MAAM;AAM9C,cAAM,qBAAgD;UACpD;UACA,kBAAkB,OAAO;UACzB,YAAY,KAAK;UACjB,YAAY,KAAK;UACjB,aAAa;UACb;UACA,iBAAiB;UACjB,YAAY;;AAGd,YAAI,WAAW,kBAAkB,SAAS,GAAG;AAC3C,qBAAW,kBAAkB,KAAK,kBAAkB;AAMpD,2CAAiC,QAAQ,eAAe;AACxD;;AAGF,YAAI,OAAO,WAAW,UAAU;AAC9B,gBAAM,YAAY,IAAI,KAAK,mBAAmB,QAAQ,mBAAmB,YAAY,CAAC;AACtF,0BAAgB,YAAY,SAAS;AACrC;;AAGF,YAAI,WAAW,kBAAkB,GAAG;AAClC,cAAI,4DAA4D,YAAY,kBAAkB,GAAG;AAC/F,kBAAM,aAAa,sDAAyD,kBAAkB;AAE9F,yDAA6C,UAAU;AAEvD,4BAAgB,YAAY,UAAU;AACtC;;AAGF,cAAI,WAAW,iBAAiB;AAC9B,kBAAM,KAAI,IAAI,UAAU,yDAAyD;AACjF,8CAAkC,YAAY,EAAC;AAE/C,4BAAgB,YAAY,EAAC;AAC7B;;;AAIJ,mBAAW,kBAAkB,KAAK,kBAAkB;AAEpD,yCAAoC,QAAQ,eAAe;AAC3D,qDAA6C,UAAU;MACzD;AAEA,gEAA0D,YACA,iBAAmC;AAG3F,cAAM,SAAS,WAAW;AAC1B,YAAI,4BAA4B,MAAM,GAAG;AACvC,iBAAO,qCAAqC,MAAM,IAAI,GAAG;AACvD,kBAAM,qBAAqB,iDAAiD,UAAU;AACtF,iEAAqD,QAAQ,kBAAkB;;;MAGrF;AAEA,kEAA4D,YACA,cACA,oBAAsC;AAGhG,+DAAuD,YAAY,cAAc,kBAAkB;AAEnG,YAAI,mBAAmB,cAAc,mBAAmB,aAAa;AACnE;;AAGF,yDAAiD,UAAU;AAE3D,cAAM,gBAAgB,mBAAmB,cAAc,mBAAmB;AAC1E,YAAI,gBAAgB,GAAG;AACrB,gBAAM,MAAM,mBAAmB,aAAa,mBAAmB;AAC/D,gBAAM,YAAY,iBAAiB,mBAAmB,QAAQ,MAAM,eAAe,GAAG;AACtF,0DAAgD,YAAY,WAAW,GAAG,UAAU,UAAU;;AAGhG,2BAAmB,eAAe;AAClC,6DAAqD,WAAW,+BAA+B,kBAAkB;AAEjH,yEAAiE,UAAU;MAC7E;AAEA,2DAAqD,YAA0C,cAAoB;AACjH,cAAM,kBAAkB,WAAW,kBAAkB,KAAI;AAGzD,0DAAkD,UAAU;AAE5D,cAAM,SAAQ,WAAW,8BAA8B;AACvD,YAAI,WAAU,UAAU;AAEtB,2DAAiD,UAA2B;eACvE;AAGL,6DAAmD,YAAY,cAAc,eAAe;;AAG9F,qDAA6C,UAAU;MACzD;AAEA,gEACE,YAAwC;AAGxC,cAAM,aAAa,WAAW,kBAAkB,MAAK;AACrD,eAAO;MACT;AAEA,0DAAoD,YAAwC;AAC1F,cAAM,SAAS,WAAW;AAE1B,YAAI,OAAO,WAAW,YAAY;AAChC,iBAAO;;AAGT,YAAI,WAAW,iBAAiB;AAC9B,iBAAO;;AAGT,YAAI,CAAC,WAAW,UAAU;AACxB,iBAAO;;AAGT,YAAI,+BAA+B,MAAM,KAAK,iCAAiC,MAAM,IAAI,GAAG;AAC1F,iBAAO;;AAGT,YAAI,4BAA4B,MAAM,KAAK,qCAAqC,MAAM,IAAI,GAAG;AAC3F,iBAAO;;AAGT,cAAM,cAAc,2CAA2C,UAAU;AAEzE,YAAI,cAAe,GAAG;AACpB,iBAAO;;AAGT,eAAO;MACT;AAEA,2DAAqD,YAAwC;AAC3F,mBAAW,iBAAiB;AAC5B,mBAAW,mBAAmB;MAChC;iDAIkD,YAAwC;AACxF,cAAM,SAAS,WAAW;AAE1B,YAAI,WAAW,mBAAmB,OAAO,WAAW,YAAY;AAC9D;;AAGF,YAAI,WAAW,kBAAkB,GAAG;AAClC,qBAAW,kBAAkB;AAE7B;;AAGF,YAAI,WAAW,kBAAkB,SAAS,GAAG;AAC3C,gBAAM,uBAAuB,WAAW,kBAAkB,KAAI;AAC9D,cAAI,qBAAqB,cAAc,GAAG;AACxC,kBAAM,KAAI,IAAI,UAAU,yDAAyD;AACjF,8CAAkC,YAAY,EAAC;AAE/C,kBAAM;;;AAIV,oDAA4C,UAAU;AACtD,4BAAoB,MAAM;MAC5B;mDAEoD,YAA0C,OAAsB;AAClH,cAAM,SAAS,WAAW;AAE1B,YAAI,WAAW,mBAAmB,OAAO,WAAW,YAAY;AAC9D;;AAGF,cAAM,SAAS,MAAM;AACrB,cAAM,aAAa,MAAM;AACzB,cAAM,aAAa,MAAM;AAIzB,cAAM,oBAAoB,oBAAoB,MAAM;AAEpD,YAAI,WAAW,kBAAkB,SAAS,GAAG;AAC3C,gBAAM,uBAAuB,WAAW,kBAAkB,KAAI;AAC9D,cAAI,iBAAiB,qBAAqB,MAAM;AAAG;AAKnD,+BAAqB,SAAS,oBAAoB,qBAAqB,MAAM;;AAG/E,0DAAkD,UAAU;AAE5D,YAAI,+BAA+B,MAAM,GAAG;AAC1C,cAAI,iCAAiC,MAAM,MAAM,GAAG;AAElD,4DAAgD,YAAY,mBAAmB,YAAY,UAAU;iBAChG;AAEL,gBAAI,WAAW,kBAAkB,SAAS,GAAG;AAE3C,+DAAiD,UAAU;;AAE7D,kBAAM,kBAAkB,IAAI,WAAW,mBAAmB,YAAY,UAAU;AAChF,6CAAiC,QAAQ,iBAAiB,KAAK;;mBAExD,4BAA4B,MAAM,GAAG;AAE9C,0DAAgD,YAAY,mBAAmB,YAAY,UAAU;AACrG,2EAAiE,UAAU;eACtE;AAEL,0DAAgD,YAAY,mBAAmB,YAAY,UAAU;;AAGvG,qDAA6C,UAAU;MACzD;iDAEkD,YAA0C,IAAM;AAChG,cAAM,SAAS,WAAW;AAE1B,YAAI,OAAO,WAAW,YAAY;AAChC;;AAGF,0DAAkD,UAAU;AAE5D,mBAAW,UAAU;AACrB,oDAA4C,UAAU;AACtD,4BAAoB,QAAQ,EAAC;MAC/B;0DAGE,YAAwC;AAExC,YAAI,WAAW,iBAAiB,QAAQ,WAAW,kBAAkB,SAAS,GAAG;AAC/E,gBAAM,kBAAkB,WAAW,kBAAkB,KAAI;AACzD,gBAAM,OAAO,IAAI,WAAW,gBAAgB,QAChB,gBAAgB,aAAa,gBAAgB,aAC7C,gBAAgB,aAAa,gBAAgB,WAAW;AAEpF,gBAAM,cAAyC,OAAO,OAAO,0BAA0B,SAAS;AAChG,yCAA+B,aAAa,YAAY,IAAI;AAC5D,qBAAW,eAAe;;AAE5B,eAAO,WAAW;MACpB;AAEA,0DAAoD,YAAwC;AAC1F,cAAM,SAAQ,WAAW,8BAA8B;AAEvD,YAAI,WAAU,WAAW;AACvB,iBAAO;;AAET,YAAI,WAAU,UAAU;AACtB,iBAAO;;AAGT,eAAO,WAAW,eAAe,WAAW;MAC9C;mDAEoD,YAA0C,cAAoB;AAGhH,cAAM,kBAAkB,WAAW,kBAAkB,KAAI;AACzD,cAAM,SAAQ,WAAW,8BAA8B;AAEvD,YAAI,WAAU,UAAU;AACtB,cAAI,iBAAiB,GAAG;AACtB,kBAAM,IAAI,UAAU,kEAAkE;;eAEnF;AAEL,cAAI,iBAAiB,GAAG;AACtB,kBAAM,IAAI,UAAU,iFAAiF;;AAEvG,cAAI,gBAAgB,cAAc,eAAe,gBAAgB,YAAY;AAC3E,kBAAM,IAAI,WAAW,2BAA2B;;;AAIpD,wBAAgB,SAAS,oBAAoB,gBAAgB,MAAM;AAEnE,oDAA4C,YAAY,YAAY;MACtE;8DAE+D,YACA,MAAqB;AAIlF,cAAM,kBAAkB,WAAW,kBAAkB,KAAI;AACzD,cAAM,SAAQ,WAAW,8BAA8B;AAEvD,YAAI,WAAU,UAAU;AACtB,cAAI,KAAK,eAAe,GAAG;AACzB,kBAAM,IAAI,UAAU,kFAAmF;;eAEpG;AAEL,cAAI,KAAK,eAAe,GAAG;AACzB,kBAAM,IAAI,UACR,iGAAkG;;;AAKxG,YAAI,gBAAgB,aAAa,gBAAgB,gBAAgB,KAAK,YAAY;AAChF,gBAAM,IAAI,WAAW,yDAAyD;;AAEhF,YAAI,gBAAgB,qBAAqB,KAAK,OAAO,YAAY;AAC/D,gBAAM,IAAI,WAAW,4DAA4D;;AAEnF,YAAI,gBAAgB,cAAc,KAAK,aAAa,gBAAgB,YAAY;AAC9E,gBAAM,IAAI,WAAW,yDAAyD;;AAGhF,cAAM,iBAAiB,KAAK;AAC5B,wBAAgB,SAAS,oBAAoB,KAAK,MAAM;AACxD,oDAA4C,YAAY,cAAc;MACxE;iDAEkD,QACA,YACA,gBACA,eACA,iBACA,eACA,uBAAyC;AAOzF,mBAAW,gCAAgC;AAE3C,mBAAW,aAAa;AACxB,mBAAW,WAAW;AAEtB,mBAAW,eAAe;AAG1B,mBAAW,SAAS,WAAW,kBAAkB;AACjD,mBAAW,UAAU;AAErB,mBAAW,kBAAkB;AAC7B,mBAAW,WAAW;AAEtB,mBAAW,eAAe;AAE1B,mBAAW,iBAAiB;AAC5B,mBAAW,mBAAmB;AAE9B,mBAAW,yBAAyB;AAEpC,mBAAW,oBAAoB,IAAI,YAAW;AAE9C,eAAO,4BAA4B;AAEnC,cAAM,cAAc,eAAc;AAClC,oBACE,oBAAoB,WAAW,GAC/B,MAAA;AACE,qBAAW,WAAW;AAKtB,uDAA6C,UAAU;WAEzD,QAAC;AACC,4CAAkC,YAAY,EAAC;SAChD;MAEL;qEAGE,QACA,sBACA,eAAqB;AAErB,cAAM,aAA2C,OAAO,OAAO,6BAA6B,SAAS;AAErG,YAAI,iBAAiD,MAAM;AAC3D,YAAI,gBAAqC,MAAM,oBAAoB,MAAS;AAC5E,YAAI,kBAAkD,MAAM,oBAAoB,MAAS;AAEzF,YAAI,qBAAqB,UAAU,QAAW;AAC5C,2BAAiB,MAAM,qBAAqB,MAAO,UAAU;;AAE/D,YAAI,qBAAqB,SAAS,QAAW;AAC3C,0BAAgB,MAAM,qBAAqB,KAAM,UAAU;;AAE7D,YAAI,qBAAqB,WAAW,QAAW;AAC7C,4BAAkB,YAAU,qBAAqB,OAAQ,MAAM;;AAGjE,cAAM,wBAAwB,qBAAqB;AACnD,YAAI,0BAA0B,GAAG;AAC/B,gBAAM,IAAI,UAAU,8CAA8C;;AAGpE,0CACE,QAAQ,YAAY,gBAAgB,eAAe,iBAAiB,eAAe,qBAAqB;MAE5G;AAEA,8CAAwC,SACA,YACA,MAAqB;AAK3D,gBAAQ,0CAA0C;AAClD,gBAAQ,QAAQ;MAClB;AAIA,8CAAwC,OAAY;AAClD,eAAO,IAAI,UACT,uCAAuC,uDAAsD;MACjG;AAIA,uDAAiD,OAAY;AAC3D,eAAO,IAAI,UACT,0CAA0C,0DAAyD;MACvG;+CCr/BgD,QAA0B;AACxE,eAAO,IAAI,yBAAyB,MAAM;MAC5C;gDAI4E,QACA,iBAAmC;AAI5G,eAAO,QAAsC,kBAAkB,KAAK,eAAe;MACtF;oDAEqD,QACA,OACA,MAAa;AAChE,cAAM,SAAS,OAAO;AAItB,cAAM,kBAAkB,OAAO,kBAAkB,MAAK;AACtD,YAAI,MAAM;AACR,0BAAgB,YAAY,KAAK;eAC5B;AACL,0BAAgB,YAAY,KAAK;;MAErC;oDAEqD,QAA0B;AAC7E,eAAQ,OAAO,QAAqC,kBAAkB;MACxE;2CAE4C,QAA0B;AACpE,cAAM,SAAS,OAAO;AAEtB,YAAI,WAAW,QAAW;AACxB,iBAAO;;AAGT,YAAI,CAAC,2BAA2B,MAAM,GAAG;AACvC,iBAAO;;AAGT,eAAO;MACT;YAiBa,yBAAwB;QAYnC,YAAY,QAA0B;AACpC,iCAAuB,QAAQ,GAAG,0BAA0B;AAC5D,+BAAqB,QAAQ,iBAAiB;AAE9C,cAAI,uBAAuB,MAAM,GAAG;AAClC,kBAAM,IAAI,UAAU,6EAA6E;;AAGnG,cAAI,CAAC,+BAA+B,OAAO,yBAAyB,GAAG;AACrE,kBAAM,IAAI,UAAU,6FACV;;AAGZ,gDAAsC,MAAM,MAAM;AAElD,eAAK,oBAAoB,IAAI,YAAW;;QAO1C,IAAI,SAAM;AACR,cAAI,CAAC,2BAA2B,IAAI,GAAG;AACrC,mBAAO,oBAAoB,8BAA8B,QAAQ,CAAC;;AAGpE,iBAAO,KAAK;;QAMd,OAAO,SAAc,QAAS;AAC5B,cAAI,CAAC,2BAA2B,IAAI,GAAG;AACrC,mBAAO,oBAAoB,8BAA8B,QAAQ,CAAC;;AAGpE,cAAI,KAAK,yBAAyB,QAAW;AAC3C,mBAAO,oBAAoB,oBAAoB,QAAQ,CAAC;;AAG1D,iBAAO,kCAAkC,MAAM,MAAM;;QAQvD,KAAgC,MAAO;AACrC,cAAI,CAAC,2BAA2B,IAAI,GAAG;AACrC,mBAAO,oBAAoB,8BAA8B,MAAM,CAAC;;AAGlE,cAAI,CAAC,YAAY,OAAO,IAAI,GAAG;AAC7B,mBAAO,oBAAoB,IAAI,UAAU,mCAAmC,CAAC;;AAE/E,cAAI,KAAK,eAAe,GAAG;AACzB,mBAAO,oBAAoB,IAAI,UAAU,oCAAoC,CAAC;;AAEhF,cAAI,KAAK,OAAO,eAAe,GAAG;AAChC,mBAAO,oBAAoB,IAAI,UAAU,6CAA6C,CAAC;;AAEzF,cAAI,iBAAiB,KAAK,MAAM;AAAG;AAInC,cAAI,KAAK,yBAAyB,QAAW;AAC3C,mBAAO,oBAAoB,oBAAoB,WAAW,CAAC;;AAG7D,cAAI;AACJ,cAAI;AACJ,gBAAM,UAAU,WAA4C,CAAC,UAAS,WAAM;AAC1E,6BAAiB;AACjB,4BAAgB;WACjB;AACD,gBAAM,kBAAsC;YAC1C,aAAa,WAAS,eAAe,EAAE,OAAO,OAAO,MAAM,MAAK,CAAE;YAClE,aAAa,WAAS,eAAe,EAAE,OAAO,OAAO,MAAM,KAAI,CAAE;YACjE,aAAa,QAAK,cAAc,EAAC;;AAEnC,uCAA6B,MAAM,MAAM,eAAe;AACxD,iBAAO;;QAYT,cAAW;AACT,cAAI,CAAC,2BAA2B,IAAI,GAAG;AACrC,kBAAM,8BAA8B,aAAa;;AAGnD,cAAI,KAAK,yBAAyB,QAAW;AAC3C;;AAGF,cAAI,KAAK,kBAAkB,SAAS,GAAG;AACrC,kBAAM,IAAI,UAAU,qFAAqF;;AAG3G,6CAAmC,IAAI;;;AAI3C,aAAO,iBAAiB,yBAAyB,WAAW;QAC1D,QAAQ,EAAE,YAAY,KAAI;QAC1B,MAAM,EAAE,YAAY,KAAI;QACxB,aAAa,EAAE,YAAY,KAAI;QAC/B,QAAQ,EAAE,YAAY,KAAI;OAC3B;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,yBAAyB,WAAW,eAAO,aAAa;UAC5E,OAAO;UACP,cAAc;SACf;;0CAKwC,IAAM;AAC/C,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,mBAAmB,GAAG;AACjE,iBAAO;;AAGT,eAAO,cAAa;MACtB;4CAGE,QACA,MACA,iBAAmC;AAEnC,cAAM,SAAS,OAAO;AAItB,eAAO,aAAa;AAEpB,YAAI,OAAO,WAAW,WAAW;AAC/B,0BAAgB,YAAY,OAAO,YAAY;eAC1C;AACL,+CACE,OAAO,2BACP,MACA,eAAe;;MAGrB;AAIA,6CAAuC,OAAY;AACjD,eAAO,IAAI,UACT,sCAAsC,sDAAqD;MAC/F;oCCjRqC,UAA2B,YAAkB;AAChF,cAAM,EAAE,kBAAkB;AAE1B,YAAI,kBAAkB,QAAW;AAC/B,iBAAO;;AAGT,YAAI,YAAY,aAAa,KAAK,gBAAgB,GAAG;AACnD,gBAAM,IAAI,WAAW,uBAAuB;;AAG9C,eAAO;MACT;oCAEwC,UAA4B;AAClE,cAAM,EAAE,SAAS;AAEjB,YAAI,CAAC,MAAM;AACT,iBAAO,MAAM;;AAGf,eAAO;MACT;sCCtB0C,MACA,SAAe;AACvD,yBAAiB,MAAM,OAAO;AAC9B,cAAM,gBAAgB,SAAI,QAAJ,SAAI,SAAA,SAAJ,KAAM;AAC5B,cAAM,OAAO,SAAI,QAAJ,SAAI,SAAA,SAAJ,KAAM;AACnB,eAAO;UACL,eAAe,kBAAkB,SAAY,SAAY,0BAA0B,aAAa;UAChG,MAAM,SAAS,SAAY,SAAY,2BAA2B,MAAM,GAAG,gCAAgC;;MAE/G;AAEA,0CAAuC,IACA,SAAe;AACpD,uBAAe,IAAI,OAAO;AAC1B,eAAO,WAAS,0BAA0B,GAAG,KAAK,CAAC;MACrD;qCCNyC,UACA,SAAe;AACtD,yBAAiB,UAAU,OAAO;AAClC,cAAM,QAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACxB,cAAM,QAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACxB,cAAM,QAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACxB,cAAM,OAAO,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACvB,cAAM,QAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACxB,eAAO;UACL,OAAO,UAAU,SACf,SACA,mCAAmC,OAAO,UAAW,GAAG,iCAAiC;UAC3F,OAAO,UAAU,SACf,SACA,mCAAmC,OAAO,UAAW,GAAG,iCAAiC;UAC3F,OAAO,UAAU,SACf,SACA,mCAAmC,OAAO,UAAW,GAAG,iCAAiC;UAC3F,OAAO,UAAU,SACf,SACA,mCAAmC,OAAO,UAAW,GAAG,iCAAiC;UAC3F;;MAEJ;AAEA,kDACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,WAAgB,YAAY,IAAI,UAAU,CAAC,MAAM,CAAC;MAC5D;AAEA,kDACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,MAAM,YAAY,IAAI,UAAU,CAAA,CAAE;MAC3C;AAEA,kDACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,eAAgD,YAAY,IAAI,UAAU,CAAC,UAAU,CAAC;MAChG;AAEA,kDACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,OAAU,eAAgD,YAAY,IAAI,UAAU,CAAC,OAAO,UAAU,CAAC;MACjH;oCCrEqC,IAAY,SAAe;AAC9D,YAAI,CAAC,iBAAiB,EAAC,GAAG;AACxB,gBAAM,IAAI,UAAU,GAAG,kCAAkC;;MAE7D;8BCsB8B,OAAc;AAC1C,YAAI,OAAO,UAAU,YAAY,UAAU,MAAM;AAC/C,iBAAO;;AAET,YAAI;AACF,iBAAO,OAAQ,MAAsB,YAAY;iBACjD,IAAA;AAEA,iBAAO;;MAEX;AAsBA,YAAM,0BAA0B,OAAQ,oBAA4B;uCAO/B;AACnC,YAAI,yBAAyB;AAC3B,iBAAO,IAAK,gBAA8C;;AAE5D,eAAO;MACT;ACdA,YAAM,eAAc;QAuBlB,YAAY,oBAA0D,CAAA,GAC1D,cAAqD,CAAA,GAAE;AACjE,cAAI,sBAAsB,QAAW;AACnC,gCAAoB;iBACf;AACL,yBAAa,mBAAmB,iBAAiB;;AAGnD,gBAAM,WAAW,uBAAuB,aAAa,kBAAkB;AACvE,gBAAM,iBAAiB,sBAAsB,mBAAmB,iBAAiB;AAEjF,mCAAyB,IAAI;AAE7B,gBAAM,OAAO,eAAe;AAC5B,cAAI,SAAS,QAAW;AACtB,kBAAM,IAAI,WAAW,2BAA2B;;AAGlD,gBAAM,gBAAgB,qBAAqB,QAAQ;AACnD,gBAAM,gBAAgB,qBAAqB,UAAU,CAAC;AAEtD,iEAAuD,MAAM,gBAAgB,eAAe,aAAa;;QAM3G,IAAI,SAAM;AACR,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,kBAAM,4BAA0B,QAAQ;;AAG1C,iBAAO,uBAAuB,IAAI;;QAYpC,MAAM,SAAc,QAAS;AAC3B,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,mBAAO,oBAAoB,4BAA0B,OAAO,CAAC;;AAG/D,cAAI,uBAAuB,IAAI,GAAG;AAChC,mBAAO,oBAAoB,IAAI,UAAU,iDAAiD,CAAC;;AAG7F,iBAAO,oBAAoB,MAAM,MAAM;;QAWzC,QAAK;AACH,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,mBAAO,oBAAoB,4BAA0B,OAAO,CAAC;;AAG/D,cAAI,uBAAuB,IAAI,GAAG;AAChC,mBAAO,oBAAoB,IAAI,UAAU,iDAAiD,CAAC;;AAG7F,cAAI,oCAAoC,IAAI,GAAG;AAC7C,mBAAO,oBAAoB,IAAI,UAAU,wCAAwC,CAAC;;AAGpF,iBAAO,oBAAoB,IAAI;;QAWjC,YAAS;AACP,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,kBAAM,4BAA0B,WAAW;;AAG7C,iBAAO,mCAAmC,IAAI;;;AAIlD,aAAO,iBAAiB,eAAe,WAAW;QAChD,OAAO,EAAE,YAAY,KAAI;QACzB,OAAO,EAAE,YAAY,KAAI;QACzB,WAAW,EAAE,YAAY,KAAI;QAC7B,QAAQ,EAAE,YAAY,KAAI;OAC3B;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,eAAe,WAAW,eAAO,aAAa;UAClE,OAAO;UACP,cAAc;SACf;;AAwBH,kDAA+C,QAAyB;AACtE,eAAO,IAAI,4BAA4B,MAAM;MAC/C;AAGA,oCAAiC,gBACA,gBACA,gBACA,gBACA,gBAAgB,GAChB,gBAAgD,MAAM,GAAC;AAGtF,cAAM,SAA4B,OAAO,OAAO,eAAe,SAAS;AACxE,iCAAyB,MAAM;AAE/B,cAAM,aAAiD,OAAO,OAAO,gCAAgC,SAAS;AAE9G,6CAAqC,QAAQ,YAAY,gBAAgB,gBAAgB,gBACpD,gBAAgB,eAAe,aAAa;AACjF,eAAO;MACT;AAEA,wCAAqC,QAAyB;AAC5D,eAAO,SAAS;AAIhB,eAAO,eAAe;AAEtB,eAAO,UAAU;AAIjB,eAAO,4BAA4B;AAInC,eAAO,iBAAiB,IAAI,YAAW;AAIvC,eAAO,wBAAwB;AAI/B,eAAO,gBAAgB;AAIvB,eAAO,wBAAwB;AAG/B,eAAO,uBAAuB;AAG9B,eAAO,gBAAgB;MACzB;AAEA,gCAA0B,IAAU;AAClC,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,2BAA2B,GAAG;AACzE,iBAAO;;AAGT,eAAO,cAAa;MACtB;AAEA,sCAAgC,QAAsB;AAGpD,YAAI,OAAO,YAAY,QAAW;AAChC,iBAAO;;AAGT,eAAO;MACT;AAEA,mCAA6B,QAAwB,QAAW;;AAC9D,YAAI,OAAO,WAAW,YAAY,OAAO,WAAW,WAAW;AAC7D,iBAAO,oBAAoB,MAAS;;AAEtC,eAAO,0BAA0B,eAAe;AAChD,QAAA,MAAA,OAAO,0BAA0B,sBAAgB,QAAA,OAAA,SAAA,SAAA,GAAE,MAAK;AAKxD,cAAM,SAAQ,OAAO;AAErB,YAAI,WAAU,YAAY,WAAU,WAAW;AAC7C,iBAAO,oBAAoB,MAAS;;AAEtC,YAAI,OAAO,yBAAyB,QAAW;AAC7C,iBAAO,OAAO,qBAAqB;;AAKrC,YAAI,qBAAqB;AACzB,YAAI,WAAU,YAAY;AACxB,+BAAqB;AAErB,mBAAS;;AAGX,cAAM,UAAU,WAAsB,CAAC,UAAS,WAAM;AACpD,iBAAO,uBAAuB;YAC5B,UAAU;YACV,UAAU;YACV,SAAS;YACT,SAAS;YACT,qBAAqB;;SAExB;AACD,eAAO,qBAAsB,WAAW;AAExC,YAAI,CAAC,oBAAoB;AACvB,sCAA4B,QAAQ,MAAM;;AAG5C,eAAO;MACT;AAEA,mCAA6B,QAA2B;AACtD,cAAM,SAAQ,OAAO;AACrB,YAAI,WAAU,YAAY,WAAU,WAAW;AAC7C,iBAAO,oBAAoB,IAAI,UAC7B,kBAAkB,iEAAgE,CAAC;;AAMvF,cAAM,UAAU,WAAsB,CAAC,UAAS,WAAM;AACpD,gBAAM,eAA6B;YACjC,UAAU;YACV,SAAS;;AAGX,iBAAO,gBAAgB;SACxB;AAED,cAAM,SAAS,OAAO;AACtB,YAAI,WAAW,UAAa,OAAO,iBAAiB,WAAU,YAAY;AACxE,2CAAiC,MAAM;;AAGzC,6CAAqC,OAAO,yBAAyB;AAErE,eAAO;MACT;AAIA,6CAAuC,QAAsB;AAI3D,cAAM,UAAU,WAAsB,CAAC,UAAS,WAAM;AACpD,gBAAM,eAA6B;YACjC,UAAU;YACV,SAAS;;AAGX,iBAAO,eAAe,KAAK,YAAY;SACxC;AAED,eAAO;MACT;AAEA,+CAAyC,QAAwB,OAAU;AACzE,cAAM,SAAQ,OAAO;AAErB,YAAI,WAAU,YAAY;AACxB,sCAA4B,QAAQ,KAAK;AACzC;;AAIF,qCAA6B,MAAM;MACrC;AAEA,2CAAqC,QAAwB,QAAW;AAItE,cAAM,aAAa,OAAO;AAG1B,eAAO,SAAS;AAChB,eAAO,eAAe;AACtB,cAAM,SAAS,OAAO;AACtB,YAAI,WAAW,QAAW;AACxB,gEAAsD,QAAQ,MAAM;;AAGtE,YAAI,CAAC,yCAAyC,MAAM,KAAK,WAAW,UAAU;AAC5E,uCAA6B,MAAM;;MAEvC;AAEA,4CAAsC,QAAsB;AAG1D,eAAO,SAAS;AAChB,eAAO,0BAA0B,YAAW;AAE5C,cAAM,cAAc,OAAO;AAC3B,eAAO,eAAe,QAAQ,kBAAY;AACxC,uBAAa,QAAQ,WAAW;SACjC;AACD,eAAO,iBAAiB,IAAI,YAAW;AAEvC,YAAI,OAAO,yBAAyB,QAAW;AAC7C,4DAAkD,MAAM;AACxD;;AAGF,cAAM,eAAe,OAAO;AAC5B,eAAO,uBAAuB;AAE9B,YAAI,aAAa,qBAAqB;AACpC,uBAAa,QAAQ,WAAW;AAChC,4DAAkD,MAAM;AACxD;;AAGF,cAAM,UAAU,OAAO,0BAA0B,YAAY,aAAa,OAAO;AACjF,oBACE,SACA,MAAA;AACE,uBAAa,SAAQ;AACrB,4DAAkD,MAAM;WAE1D,CAAC,WAAW;AACV,uBAAa,QAAQ,MAAM;AAC3B,4DAAkD,MAAM;SACzD;MACL;AAEA,iDAA2C,QAAsB;AAE/D,eAAO,sBAAuB,SAAS,MAAS;AAChD,eAAO,wBAAwB;MACjC;AAEA,0DAAoD,QAAwB,OAAU;AAEpF,eAAO,sBAAuB,QAAQ,KAAK;AAC3C,eAAO,wBAAwB;AAI/B,wCAAgC,QAAQ,KAAK;MAC/C;AAEA,iDAA2C,QAAsB;AAE/D,eAAO,sBAAuB,SAAS,MAAS;AAChD,eAAO,wBAAwB;AAE/B,cAAM,SAAQ,OAAO;AAIrB,YAAI,WAAU,YAAY;AAExB,iBAAO,eAAe;AACtB,cAAI,OAAO,yBAAyB,QAAW;AAC7C,mBAAO,qBAAqB,SAAQ;AACpC,mBAAO,uBAAuB;;;AAIlC,eAAO,SAAS;AAEhB,cAAM,SAAS,OAAO;AACtB,YAAI,WAAW,QAAW;AACxB,4CAAkC,MAAM;;MAK5C;AAEA,0DAAoD,QAAwB,OAAU;AAEpF,eAAO,sBAAuB,QAAQ,KAAK;AAC3C,eAAO,wBAAwB;AAK/B,YAAI,OAAO,yBAAyB,QAAW;AAC7C,iBAAO,qBAAqB,QAAQ,KAAK;AACzC,iBAAO,uBAAuB;;AAEhC,wCAAgC,QAAQ,KAAK;MAC/C;AAGA,mDAA6C,QAAsB;AACjE,YAAI,OAAO,kBAAkB,UAAa,OAAO,0BAA0B,QAAW;AACpF,iBAAO;;AAGT,eAAO;MACT;AAEA,wDAAkD,QAAsB;AACtE,YAAI,OAAO,0BAA0B,UAAa,OAAO,0BAA0B,QAAW;AAC5F,iBAAO;;AAGT,eAAO;MACT;AAEA,sDAAgD,QAAsB;AAGpE,eAAO,wBAAwB,OAAO;AACtC,eAAO,gBAAgB;MACzB;AAEA,2DAAqD,QAAsB;AAGzE,eAAO,wBAAwB,OAAO,eAAe,MAAK;MAC5D;AAEA,iEAA2D,QAAsB;AAE/E,YAAI,OAAO,kBAAkB,QAAW;AAGtC,iBAAO,cAAc,QAAQ,OAAO,YAAY;AAChD,iBAAO,gBAAgB;;AAEzB,cAAM,SAAS,OAAO;AACtB,YAAI,WAAW,QAAW;AACxB,2CAAiC,QAAQ,OAAO,YAAY;;MAEhE;AAEA,gDAA0C,QAAwB,cAAqB;AAIrF,cAAM,SAAS,OAAO;AACtB,YAAI,WAAW,UAAa,iBAAiB,OAAO,eAAe;AACjE,cAAI,cAAc;AAChB,2CAA+B,MAAM;iBAChC;AAGL,6CAAiC,MAAM;;;AAI3C,eAAO,gBAAgB;MACzB;YAOa,4BAA2B;QAoBtC,YAAY,QAAyB;AACnC,iCAAuB,QAAQ,GAAG,6BAA6B;AAC/D,+BAAqB,QAAQ,iBAAiB;AAE9C,cAAI,uBAAuB,MAAM,GAAG;AAClC,kBAAM,IAAI,UAAU,6EAA6E;;AAGnG,eAAK,uBAAuB;AAC5B,iBAAO,UAAU;AAEjB,gBAAM,SAAQ,OAAO;AAErB,cAAI,WAAU,YAAY;AACxB,gBAAI,CAAC,oCAAoC,MAAM,KAAK,OAAO,eAAe;AACxE,kDAAoC,IAAI;mBACnC;AACL,4DAA8C,IAAI;;AAGpD,iDAAqC,IAAI;qBAChC,WAAU,YAAY;AAC/B,0DAA8C,MAAM,OAAO,YAAY;AACvE,iDAAqC,IAAI;qBAChC,WAAU,UAAU;AAC7B,0DAA8C,IAAI;AAClD,2DAA+C,IAAI;iBAC9C;AAGL,kBAAM,cAAc,OAAO;AAC3B,0DAA8C,MAAM,WAAW;AAC/D,2DAA+C,MAAM,WAAW;;;QAQpE,IAAI,SAAM;AACR,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,iCAAiC,QAAQ,CAAC;;AAGvE,iBAAO,KAAK;;QAWd,IAAI,cAAW;AACb,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,kBAAM,iCAAiC,aAAa;;AAGtD,cAAI,KAAK,yBAAyB,QAAW;AAC3C,kBAAM,2BAA2B,aAAa;;AAGhD,iBAAO,0CAA0C,IAAI;;QAWvD,IAAI,QAAK;AACP,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,iCAAiC,OAAO,CAAC;;AAGtE,iBAAO,KAAK;;QAMd,MAAM,SAAc,QAAS;AAC3B,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,iCAAiC,OAAO,CAAC;;AAGtE,cAAI,KAAK,yBAAyB,QAAW;AAC3C,mBAAO,oBAAoB,2BAA2B,OAAO,CAAC;;AAGhE,iBAAO,iCAAiC,MAAM,MAAM;;QAMtD,QAAK;AACH,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,iCAAiC,OAAO,CAAC;;AAGtE,gBAAM,SAAS,KAAK;AAEpB,cAAI,WAAW,QAAW;AACxB,mBAAO,oBAAoB,2BAA2B,OAAO,CAAC;;AAGhE,cAAI,oCAAoC,MAAM,GAAG;AAC/C,mBAAO,oBAAoB,IAAI,UAAU,wCAAwC,CAAC;;AAGpF,iBAAO,iCAAiC,IAAI;;QAa9C,cAAW;AACT,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,kBAAM,iCAAiC,aAAa;;AAGtD,gBAAM,SAAS,KAAK;AAEpB,cAAI,WAAW,QAAW;AACxB;;AAKF,6CAAmC,IAAI;;QAazC,MAAM,QAAW,QAAU;AACzB,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,iCAAiC,OAAO,CAAC;;AAGtE,cAAI,KAAK,yBAAyB,QAAW;AAC3C,mBAAO,oBAAoB,2BAA2B,UAAU,CAAC;;AAGnE,iBAAO,iCAAiC,MAAM,KAAK;;;AAIvD,aAAO,iBAAiB,4BAA4B,WAAW;QAC7D,OAAO,EAAE,YAAY,KAAI;QACzB,OAAO,EAAE,YAAY,KAAI;QACzB,aAAa,EAAE,YAAY,KAAI;QAC/B,OAAO,EAAE,YAAY,KAAI;QACzB,QAAQ,EAAE,YAAY,KAAI;QAC1B,aAAa,EAAE,YAAY,KAAI;QAC/B,OAAO,EAAE,YAAY,KAAI;OAC1B;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,4BAA4B,WAAW,eAAO,aAAa;UAC/E,OAAO;UACP,cAAc;SACf;;AAKH,6CAAgD,IAAM;AACpD,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,sBAAsB,GAAG;AACpE,iBAAO;;AAGT,eAAO,cAAa;MACtB;AAIA,gDAA0C,QAAqC,QAAW;AACxF,cAAM,SAAS,OAAO;AAItB,eAAO,oBAAoB,QAAQ,MAAM;MAC3C;AAEA,gDAA0C,QAAmC;AAC3E,cAAM,SAAS,OAAO;AAItB,eAAO,oBAAoB,MAAM;MACnC;AAEA,oEAA8D,QAAmC;AAC/F,cAAM,SAAS,OAAO;AAItB,cAAM,SAAQ,OAAO;AACrB,YAAI,oCAAoC,MAAM,KAAK,WAAU,UAAU;AACrE,iBAAO,oBAAoB,MAAS;;AAGtC,YAAI,WAAU,WAAW;AACvB,iBAAO,oBAAoB,OAAO,YAAY;;AAKhD,eAAO,iCAAiC,MAAM;MAChD;AAEA,sEAAgE,QAAqC,OAAU;AAC7G,YAAI,OAAO,wBAAwB,WAAW;AAC5C,2CAAiC,QAAQ,KAAK;eACzC;AACL,oDAA0C,QAAQ,KAAK;;MAE3D;AAEA,qEAA+D,QAAqC,OAAU;AAC5G,YAAI,OAAO,uBAAuB,WAAW;AAC3C,0CAAgC,QAAQ,KAAK;eACxC;AACL,mDAAyC,QAAQ,KAAK;;MAE1D;AAEA,yDAAmD,QAAmC;AACpF,cAAM,SAAS,OAAO;AACtB,cAAM,SAAQ,OAAO;AAErB,YAAI,WAAU,aAAa,WAAU,YAAY;AAC/C,iBAAO;;AAGT,YAAI,WAAU,UAAU;AACtB,iBAAO;;AAGT,eAAO,8CAA8C,OAAO,yBAAyB;MACvF;AAEA,kDAA4C,QAAmC;AAC7E,cAAM,SAAS,OAAO;AAItB,cAAM,gBAAgB,IAAI,UACxB,kFAAkF;AAEpF,8DAAsD,QAAQ,aAAa;AAI3E,+DAAuD,QAAQ,aAAa;AAE5E,eAAO,UAAU;AACjB,eAAO,uBAAuB;MAChC;AAEA,gDAA6C,QAAwC,OAAQ;AAC3F,cAAM,SAAS,OAAO;AAItB,cAAM,aAAa,OAAO;AAE1B,cAAM,YAAY,4CAA4C,YAAY,KAAK;AAE/E,YAAI,WAAW,OAAO,sBAAsB;AAC1C,iBAAO,oBAAoB,2BAA2B,UAAU,CAAC;;AAGnE,cAAM,SAAQ,OAAO;AACrB,YAAI,WAAU,WAAW;AACvB,iBAAO,oBAAoB,OAAO,YAAY;;AAEhD,YAAI,oCAAoC,MAAM,KAAK,WAAU,UAAU;AACrE,iBAAO,oBAAoB,IAAI,UAAU,0DAA0D,CAAC;;AAEtG,YAAI,WAAU,YAAY;AACxB,iBAAO,oBAAoB,OAAO,YAAY;;AAKhD,cAAM,UAAU,8BAA8B,MAAM;AAEpD,6CAAqC,YAAY,OAAO,SAAS;AAEjE,eAAO;MACT;AAEA,YAAM,gBAA+B,CAAA;YASxB,gCAA+B;QAwB1C,cAAA;AACE,gBAAM,IAAI,UAAU,qBAAqB;;QAU3C,IAAI,cAAW;AACb,cAAI,CAAC,kCAAkC,IAAI,GAAG;AAC5C,kBAAM,uCAAqC,aAAa;;AAE1D,iBAAO,KAAK;;QAMd,IAAI,SAAM;AACR,cAAI,CAAC,kCAAkC,IAAI,GAAG;AAC5C,kBAAM,uCAAqC,QAAQ;;AAErD,cAAI,KAAK,qBAAqB,QAAW;AAIvC,kBAAM,IAAI,UAAU,mEAAmE;;AAEzF,iBAAO,KAAK,iBAAiB;;QAU/B,MAAM,KAAS,QAAS;AACtB,cAAI,CAAC,kCAAkC,IAAI,GAAG;AAC5C,kBAAM,uCAAqC,OAAO;;AAEpD,gBAAM,SAAQ,KAAK,0BAA0B;AAC7C,cAAI,WAAU,YAAY;AAGxB;;AAGF,+CAAqC,MAAM,EAAC;;QAI9C,CAAC,YAAY,QAAW;AACtB,gBAAM,SAAS,KAAK,gBAAgB,MAAM;AAC1C,yDAA+C,IAAI;AACnD,iBAAO;;QAIT,CAAC,cAAW;AACV,qBAAW,IAAI;;;AAInB,aAAO,iBAAiB,gCAAgC,WAAW;QACjE,aAAa,EAAE,YAAY,KAAI;QAC/B,QAAQ,EAAE,YAAY,KAAI;QAC1B,OAAO,EAAE,YAAY,KAAI;OAC1B;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,gCAAgC,WAAW,eAAO,aAAa;UACnF,OAAO;UACP,cAAc;SACf;;AAKH,iDAA2C,IAAM;AAC/C,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,2BAA2B,GAAG;AACzE,iBAAO;;AAGT,eAAO,cAAa;MACtB;AAEA,oDAAiD,QACA,YACA,gBACA,gBACA,gBACA,gBACA,eACA,eAA6C;AAI5F,mBAAW,4BAA4B;AACvC,eAAO,4BAA4B;AAGnC,mBAAW,SAAS;AACpB,mBAAW,kBAAkB;AAC7B,mBAAW,UAAU;AAErB,mBAAW,eAAe;AAC1B,mBAAW,mBAAmB,sBAAqB;AACnD,mBAAW,WAAW;AAEtB,mBAAW,yBAAyB;AACpC,mBAAW,eAAe;AAE1B,mBAAW,kBAAkB;AAC7B,mBAAW,kBAAkB;AAC7B,mBAAW,kBAAkB;AAE7B,cAAM,eAAe,+CAA+C,UAAU;AAC9E,yCAAiC,QAAQ,YAAY;AAErD,cAAM,cAAc,eAAc;AAClC,cAAM,eAAe,oBAAoB,WAAW;AACpD,oBACE,cACA,MAAA;AAEE,qBAAW,WAAW;AACtB,8DAAoD,UAAU;WAEhE,QAAC;AAEC,qBAAW,WAAW;AACtB,0CAAgC,QAAQ,EAAC;SAC1C;MAEL;AAEA,sEAAmE,QACA,gBACA,eACA,eAA6C;AAC9G,cAAM,aAAa,OAAO,OAAO,gCAAgC,SAAS;AAE1E,YAAI,iBAAiD,MAAM;AAC3D,YAAI,iBAA8C,MAAM,oBAAoB,MAAS;AACrF,YAAI,iBAAsC,MAAM,oBAAoB,MAAS;AAC7E,YAAI,iBAAiD,MAAM,oBAAoB,MAAS;AAExF,YAAI,eAAe,UAAU,QAAW;AACtC,2BAAiB,MAAM,eAAe,MAAO,UAAU;;AAEzD,YAAI,eAAe,UAAU,QAAW;AACtC,2BAAiB,WAAS,eAAe,MAAO,OAAO,UAAU;;AAEnE,YAAI,eAAe,UAAU,QAAW;AACtC,2BAAiB,MAAM,eAAe,MAAM;;AAE9C,YAAI,eAAe,UAAU,QAAW;AACtC,2BAAiB,YAAU,eAAe,MAAO,MAAM;;AAGzD,6CACE,QAAQ,YAAY,gBAAgB,gBAAgB,gBAAgB,gBAAgB,eAAe,aAAa;MAEpH;AAGA,8DAAwD,YAAgD;AACtG,mBAAW,kBAAkB;AAC7B,mBAAW,kBAAkB;AAC7B,mBAAW,kBAAkB;AAC7B,mBAAW,yBAAyB;MACtC;AAEA,oDAAiD,YAA8C;AAC7F,6BAAqB,YAAY,eAAe,CAAC;AACjD,4DAAoD,UAAU;MAChE;AAEA,2DAAwD,YACA,OAAQ;AAC9D,YAAI;AACF,iBAAO,WAAW,uBAAuB,KAAK;iBACvC,YAAP;AACA,uDAA6C,YAAY,UAAU;AACnE,iBAAO;;MAEX;AAEA,6DAAuD,YAAgD;AACrG,eAAO,WAAW,eAAe,WAAW;MAC9C;AAEA,oDAAiD,YACA,OACA,WAAiB;AAChE,YAAI;AACF,+BAAqB,YAAY,OAAO,SAAS;iBAC1C,UAAP;AACA,uDAA6C,YAAY,QAAQ;AACjE;;AAGF,cAAM,SAAS,WAAW;AAC1B,YAAI,CAAC,oCAAoC,MAAM,KAAK,OAAO,WAAW,YAAY;AAChF,gBAAM,eAAe,+CAA+C,UAAU;AAC9E,2CAAiC,QAAQ,YAAY;;AAGvD,4DAAoD,UAAU;MAChE;AAIA,mEAAgE,YAA8C;AAC5G,cAAM,SAAS,WAAW;AAE1B,YAAI,CAAC,WAAW,UAAU;AACxB;;AAGF,YAAI,OAAO,0BAA0B,QAAW;AAC9C;;AAGF,cAAM,SAAQ,OAAO;AAErB,YAAI,WAAU,YAAY;AACxB,uCAA6B,MAAM;AACnC;;AAGF,YAAI,WAAW,OAAO,WAAW,GAAG;AAClC;;AAGF,cAAM,QAAQ,eAAe,UAAU;AACvC,YAAI,UAAU,eAAe;AAC3B,sDAA4C,UAAU;eACjD;AACL,sDAA4C,YAAY,KAAK;;MAEjE;AAEA,4DAAsD,YAAkD,OAAU;AAChH,YAAI,WAAW,0BAA0B,WAAW,YAAY;AAC9D,+CAAqC,YAAY,KAAK;;MAE1D;AAEA,2DAAqD,YAAgD;AACnG,cAAM,SAAS,WAAW;AAE1B,+CAAuC,MAAM;AAE7C,qBAAa,UAAU;AAGvB,cAAM,mBAAmB,WAAW,gBAAe;AACnD,uDAA+C,UAAU;AACzD,oBACE,kBACA,MAAA;AACE,4CAAkC,MAAM;WAE1C,YAAM;AACJ,qDAA2C,QAAQ,MAAM;SAC1D;MAEL;AAEA,2DAAwD,YAAgD,OAAQ;AAC9G,cAAM,SAAS,WAAW;AAE1B,oDAA4C,MAAM;AAElD,cAAM,mBAAmB,WAAW,gBAAgB,KAAK;AACzD,oBACE,kBACA,MAAA;AACE,4CAAkC,MAAM;AAExC,gBAAM,SAAQ,OAAO;AAGrB,uBAAa,UAAU;AAEvB,cAAI,CAAC,oCAAoC,MAAM,KAAK,WAAU,YAAY;AACxE,kBAAM,eAAe,+CAA+C,UAAU;AAC9E,6CAAiC,QAAQ,YAAY;;AAGvD,8DAAoD,UAAU;WAEhE,YAAM;AACJ,cAAI,OAAO,WAAW,YAAY;AAChC,2DAA+C,UAAU;;AAE3D,qDAA2C,QAAQ,MAAM;SAC1D;MAEL;AAEA,8DAAwD,YAAgD;AACtG,cAAM,cAAc,8CAA8C,UAAU;AAC5E,eAAO,eAAe;MACxB;AAIA,oDAA8C,YAAkD,OAAU;AACxG,cAAM,SAAS,WAAW;AAI1B,uDAA+C,UAAU;AACzD,oCAA4B,QAAQ,KAAK;MAC3C;AAIA,2CAAmC,OAAY;AAC7C,eAAO,IAAI,UAAU,4BAA4B,4CAA2C;MAC9F;AAIA,sDAA8C,OAAY;AACxD,eAAO,IAAI,UACT,6CAA6C,6DAA4D;MAC7G;AAKA,gDAA0C,OAAY;AACpD,eAAO,IAAI,UACT,yCAAyC,yDAAwD;MACrG;AAEA,0CAAoC,OAAY;AAC9C,eAAO,IAAI,UAAU,YAAY,QAAO,mCAAmC;MAC7E;AAEA,oDAA8C,QAAmC;AAC/E,eAAO,iBAAiB,WAAW,CAAC,UAAS,WAAM;AACjD,iBAAO,yBAAyB;AAChC,iBAAO,wBAAwB;AAC/B,iBAAO,sBAAsB;SAC9B;MACH;AAEA,8DAAwD,QAAqC,QAAW;AACtG,6CAAqC,MAAM;AAC3C,yCAAiC,QAAQ,MAAM;MACjD;AAEA,8DAAwD,QAAmC;AACzF,6CAAqC,MAAM;AAC3C,0CAAkC,MAAM;MAC1C;AAEA,gDAA0C,QAAqC,QAAW;AACxF,YAAI,OAAO,0BAA0B,QAAW;AAC9C;;AAIF,kCAA0B,OAAO,cAAc;AAC/C,eAAO,sBAAsB,MAAM;AACnC,eAAO,yBAAyB;AAChC,eAAO,wBAAwB;AAC/B,eAAO,sBAAsB;MAC/B;AAEA,yDAAmD,QAAqC,QAAW;AAKjG,uDAA+C,QAAQ,MAAM;MAC/D;AAEA,iDAA2C,QAAmC;AAC5E,YAAI,OAAO,2BAA2B,QAAW;AAC/C;;AAIF,eAAO,uBAAuB,MAAS;AACvC,eAAO,yBAAyB;AAChC,eAAO,wBAAwB;AAC/B,eAAO,sBAAsB;MAC/B;AAEA,mDAA6C,QAAmC;AAC9E,eAAO,gBAAgB,WAAW,CAAC,UAAS,WAAM;AAChD,iBAAO,wBAAwB;AAC/B,iBAAO,uBAAuB;SAC/B;AACD,eAAO,qBAAqB;MAC9B;AAEA,6DAAuD,QAAqC,QAAW;AACrG,4CAAoC,MAAM;AAC1C,wCAAgC,QAAQ,MAAM;MAChD;AAEA,6DAAuD,QAAmC;AACxF,4CAAoC,MAAM;AAC1C,yCAAiC,MAAM;MACzC;AAEA,+CAAyC,QAAqC,QAAW;AACvF,YAAI,OAAO,yBAAyB,QAAW;AAC7C;;AAGF,kCAA0B,OAAO,aAAa;AAC9C,eAAO,qBAAqB,MAAM;AAClC,eAAO,wBAAwB;AAC/B,eAAO,uBAAuB;AAC9B,eAAO,qBAAqB;MAC9B;AAEA,8CAAwC,QAAmC;AAIzE,4CAAoC,MAAM;MAC5C;AAEA,wDAAkD,QAAqC,QAAW;AAIhG,sDAA8C,QAAQ,MAAM;MAC9D;AAEA,gDAA0C,QAAmC;AAC3E,YAAI,OAAO,0BAA0B,QAAW;AAC9C;;AAGF,eAAO,sBAAsB,MAAS;AACtC,eAAO,wBAAwB;AAC/B,eAAO,uBAAuB;AAC9B,eAAO,qBAAqB;MAC9B;ACh4CO,YAAM,qBACX,OAAO,iBAAiB,cAAc,eAAe;ACWvD,yCAAmC,MAAa;AAC9C,YAAI,CAAE,QAAO,SAAS,cAAc,OAAO,SAAS,WAAW;AAC7D,iBAAO;;AAET,YAAI;AACF,cAAK,KAAgC;AACrC,iBAAO;iBACP,IAAA;AACA,iBAAO;;MAEX;AAEA,4CAAmC;AAEjC,cAAM,OAAO,uBAA0C,SAAkB,OAAa;AACpF,eAAK,UAAU,WAAW;AAC1B,eAAK,OAAO,SAAQ;AACpB,cAAI,MAAM,mBAAmB;AAC3B,kBAAM,kBAAkB,MAAM,KAAK,WAAW;;;AAGlD,aAAK,YAAY,OAAO,OAAO,MAAM,SAAS;AAC9C,eAAO,eAAe,KAAK,WAAW,eAAe,EAAE,OAAO,MAAM,UAAU,MAAM,cAAc,KAAI,CAAE;AACxG,eAAO;MACT;AAGA,YAAM,iBACJ,0BAA0B,kBAAkB,IAAI,qBAAqB,2BAA0B;oCCbzD,QACA,MACA,cACA,cACA,eACA,QAA+B;AAUrE,cAAM,SAAS,mCAAsC,MAAM;AAC3D,cAAM,SAAS,mCAAsC,IAAI;AAEzD,eAAO,aAAa;AAEpB,YAAI,eAAe;AAGnB,YAAI,eAAe,oBAA0B,MAAS;AAEtD,eAAO,WAAW,CAAC,UAAS,WAAM;AAChC,cAAI;AACJ,cAAI,WAAW,QAAW;AACxB,6BAAiB,MAAA;AACf,oBAAM,QAAQ,IAAI,eAAa,WAAW,YAAY;AACtD,oBAAM,UAAsC,CAAA;AAC5C,kBAAI,CAAC,cAAc;AACjB,wBAAQ,KAAK,MAAA;AACX,sBAAI,KAAK,WAAW,YAAY;AAC9B,2BAAO,oBAAoB,MAAM,KAAK;;AAExC,yBAAO,oBAAoB,MAAS;iBACrC;;AAEH,kBAAI,CAAC,eAAe;AAClB,wBAAQ,KAAK,MAAA;AACX,sBAAI,OAAO,WAAW,YAAY;AAChC,2BAAO,qBAAqB,QAAQ,KAAK;;AAE3C,yBAAO,oBAAoB,MAAS;iBACrC;;AAEH,iCAAmB,MAAM,QAAQ,IAAI,QAAQ,IAAI,YAAU,OAAM,CAAE,CAAC,GAAG,MAAM,KAAK;;AAGpF,gBAAI,OAAO,SAAS;AAClB,6BAAc;AACd;;AAGF,mBAAO,iBAAiB,SAAS,cAAc;;AAMjD,8BAAiB;AACf,mBAAO,WAAiB,CAAC,aAAa,eAAU;AAC9C,4BAAc,MAAa;AACzB,oBAAI,MAAM;AACR,8BAAW;uBACN;AAGL,qCAAmB,SAAQ,GAAI,MAAM,UAAU;;;AAInD,mBAAK,KAAK;aACX;;AAGH,8BAAiB;AACf,gBAAI,cAAc;AAChB,qBAAO,oBAAoB,IAAI;;AAGjC,mBAAO,mBAAmB,OAAO,eAAe,MAAA;AAC9C,qBAAO,WAAoB,CAAC,aAAa,eAAU;AACjD,gDACE,QACA;kBACE,aAAa,WAAK;AAChB,mCAAe,mBAAmB,iCAAiC,QAAQ,KAAK,GAAG,QAAW,KAAI;AAClG,gCAAY,KAAK;;kBAEnB,aAAa,MAAM,YAAY,IAAI;kBACnC,aAAa;iBACd;eAEJ;aACF;;AAIH,6BAAmB,QAAQ,OAAO,gBAAgB,iBAAW;AAC3D,gBAAI,CAAC,cAAc;AACjB,iCAAmB,MAAM,oBAAoB,MAAM,WAAW,GAAG,MAAM,WAAW;mBAC7E;AACL,uBAAS,MAAM,WAAW;;WAE7B;AAGD,6BAAmB,MAAM,OAAO,gBAAgB,iBAAW;AACzD,gBAAI,CAAC,eAAe;AAClB,iCAAmB,MAAM,qBAAqB,QAAQ,WAAW,GAAG,MAAM,WAAW;mBAChF;AACL,uBAAS,MAAM,WAAW;;WAE7B;AAGD,4BAAkB,QAAQ,OAAO,gBAAgB,MAAA;AAC/C,gBAAI,CAAC,cAAc;AACjB,iCAAmB,MAAM,qDAAqD,MAAM,CAAC;mBAChF;AACL,uBAAQ;;WAEX;AAGD,cAAI,oCAAoC,IAAI,KAAK,KAAK,WAAW,UAAU;AACzE,kBAAM,aAAa,IAAI,UAAU,6EAA6E;AAE9G,gBAAI,CAAC,eAAe;AAClB,iCAAmB,MAAM,qBAAqB,QAAQ,UAAU,GAAG,MAAM,UAAU;mBAC9E;AACL,uBAAS,MAAM,UAAU;;;AAI7B,oCAA0B,SAAQ,CAAE;AAEpC,2CAA8B;AAG5B,kBAAM,kBAAkB;AACxB,mBAAO,mBACL,cACA,MAAM,oBAAoB,eAAe,sBAAqB,IAAK,MAAS;;AAIhF,sCAA4B,QACA,SACA,QAA6B;AACvD,gBAAI,OAAO,WAAW,WAAW;AAC/B,qBAAO,OAAO,YAAY;mBACrB;AACL,4BAAc,SAAS,MAAM;;;AAIjC,qCAA2B,QAAyC,SAAwB,QAAkB;AAC5G,gBAAI,OAAO,WAAW,UAAU;AAC9B,qBAAM;mBACD;AACL,8BAAgB,SAAS,MAAM;;;AAInC,sCAA4B,QAAgC,iBAA2B,eAAmB;AACxG,gBAAI,cAAc;AAChB;;AAEF,2BAAe;AAEf,gBAAI,KAAK,WAAW,cAAc,CAAC,oCAAoC,IAAI,GAAG;AAC5E,8BAAgB,sBAAqB,GAAI,SAAS;mBAC7C;AACL,wBAAS;;AAGX,iCAAkB;AAChB,0BACE,OAAM,GACN,MAAM,SAAS,iBAAiB,aAAa,GAC7C,cAAY,SAAS,MAAM,QAAQ,CAAC;;;AAK1C,4BAAkB,SAAmB,OAAW;AAC9C,gBAAI,cAAc;AAChB;;AAEF,2BAAe;AAEf,gBAAI,KAAK,WAAW,cAAc,CAAC,oCAAoC,IAAI,GAAG;AAC5E,8BAAgB,sBAAqB,GAAI,MAAM,SAAS,SAAS,KAAK,CAAC;mBAClE;AACL,uBAAS,SAAS,KAAK;;;AAI3B,4BAAkB,SAAmB,OAAW;AAC9C,+CAAmC,MAAM;AACzC,+CAAmC,MAAM;AAEzC,gBAAI,WAAW,QAAW;AACxB,qBAAO,oBAAoB,SAAS,cAAc;;AAEpD,gBAAI,SAAS;AACX,qBAAO,KAAK;mBACP;AACL,uBAAQ,MAAS;;;SAGtB;MACH;YC9Na,gCAA+B;QAwB1C,cAAA;AACE,gBAAM,IAAI,UAAU,qBAAqB;;QAO3C,IAAI,cAAW;AACb,cAAI,CAAC,kCAAkC,IAAI,GAAG;AAC5C,kBAAM,uCAAqC,aAAa;;AAG1D,iBAAO,8CAA8C,IAAI;;QAO3D,QAAK;AACH,cAAI,CAAC,kCAAkC,IAAI,GAAG;AAC5C,kBAAM,uCAAqC,OAAO;;AAGpD,cAAI,CAAC,iDAAiD,IAAI,GAAG;AAC3D,kBAAM,IAAI,UAAU,iDAAiD;;AAGvE,+CAAqC,IAAI;;QAO3C,QAAQ,QAAW,QAAU;AAC3B,cAAI,CAAC,kCAAkC,IAAI,GAAG;AAC5C,kBAAM,uCAAqC,SAAS;;AAGtD,cAAI,CAAC,iDAAiD,IAAI,GAAG;AAC3D,kBAAM,IAAI,UAAU,mDAAmD;;AAGzE,iBAAO,uCAAuC,MAAM,KAAK;;QAM3D,MAAM,KAAS,QAAS;AACtB,cAAI,CAAC,kCAAkC,IAAI,GAAG;AAC5C,kBAAM,uCAAqC,OAAO;;AAGpD,+CAAqC,MAAM,EAAC;;QAI9C,CAAC,aAAa,QAAW;AACvB,qBAAW,IAAI;AACf,gBAAM,SAAS,KAAK,iBAAiB,MAAM;AAC3C,yDAA+C,IAAI;AACnD,iBAAO;;QAIT,CAAC,WAAW,aAA2B;AACrC,gBAAM,SAAS,KAAK;AAEpB,cAAI,KAAK,OAAO,SAAS,GAAG;AAC1B,kBAAM,QAAQ,aAAa,IAAI;AAE/B,gBAAI,KAAK,mBAAmB,KAAK,OAAO,WAAW,GAAG;AACpD,6DAA+C,IAAI;AACnD,kCAAoB,MAAM;mBACrB;AACL,8DAAgD,IAAI;;AAGtD,wBAAY,YAAY,KAAK;iBACxB;AACL,yCAA6B,QAAQ,WAAW;AAChD,4DAAgD,IAAI;;;;AAK1D,aAAO,iBAAiB,gCAAgC,WAAW;QACjE,OAAO,EAAE,YAAY,KAAI;QACzB,SAAS,EAAE,YAAY,KAAI;QAC3B,OAAO,EAAE,YAAY,KAAI;QACzB,aAAa,EAAE,YAAY,KAAI;OAChC;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,gCAAgC,WAAW,eAAO,aAAa;UACnF,OAAO;UACP,cAAc;SACf;;AAKH,iDAAoD,IAAM;AACxD,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,2BAA2B,GAAG;AACzE,iBAAO;;AAGT,eAAO,cAAa;MACtB;AAEA,+DAAyD,YAAgD;AACvG,cAAM,aAAa,8CAA8C,UAAU;AAC3E,YAAI,CAAC,YAAY;AACf;;AAGF,YAAI,WAAW,UAAU;AACvB,qBAAW,aAAa;AACxB;;AAKF,mBAAW,WAAW;AAEtB,cAAM,cAAc,WAAW,eAAc;AAC7C,oBACE,aACA,MAAA;AACE,qBAAW,WAAW;AAEtB,cAAI,WAAW,YAAY;AACzB,uBAAW,aAAa;AACxB,4DAAgD,UAAU;;WAG9D,QAAC;AACC,+CAAqC,YAAY,EAAC;SACnD;MAEL;AAEA,6DAAuD,YAAgD;AACrG,cAAM,SAAS,WAAW;AAE1B,YAAI,CAAC,iDAAiD,UAAU,GAAG;AACjE,iBAAO;;AAGT,YAAI,CAAC,WAAW,UAAU;AACxB,iBAAO;;AAGT,YAAI,uBAAuB,MAAM,KAAK,iCAAiC,MAAM,IAAI,GAAG;AAClF,iBAAO;;AAGT,cAAM,cAAc,8CAA8C,UAAU;AAE5E,YAAI,cAAe,GAAG;AACpB,iBAAO;;AAGT,eAAO;MACT;AAEA,8DAAwD,YAAgD;AACtG,mBAAW,iBAAiB;AAC5B,mBAAW,mBAAmB;AAC9B,mBAAW,yBAAyB;MACtC;oDAIqD,YAAgD;AACnG,YAAI,CAAC,iDAAiD,UAAU,GAAG;AACjE;;AAGF,cAAM,SAAS,WAAW;AAE1B,mBAAW,kBAAkB;AAE7B,YAAI,WAAW,OAAO,WAAW,GAAG;AAClC,yDAA+C,UAAU;AACzD,8BAAoB,MAAM;;MAE9B;sDAGE,YACA,OAAQ;AAER,YAAI,CAAC,iDAAiD,UAAU,GAAG;AACjE;;AAGF,cAAM,SAAS,WAAW;AAE1B,YAAI,uBAAuB,MAAM,KAAK,iCAAiC,MAAM,IAAI,GAAG;AAClF,2CAAiC,QAAQ,OAAO,KAAK;eAChD;AACL,cAAI;AACJ,cAAI;AACF,wBAAY,WAAW,uBAAuB,KAAK;mBAC5C,YAAP;AACA,iDAAqC,YAAY,UAAU;AAC3D,kBAAM;;AAGR,cAAI;AACF,iCAAqB,YAAY,OAAO,SAAS;mBAC1C,UAAP;AACA,iDAAqC,YAAY,QAAQ;AACzD,kBAAM;;;AAIV,wDAAgD,UAAU;MAC5D;oDAEqD,YAAkD,IAAM;AAC3G,cAAM,SAAS,WAAW;AAE1B,YAAI,OAAO,WAAW,YAAY;AAChC;;AAGF,mBAAW,UAAU;AAErB,uDAA+C,UAAU;AACzD,4BAAoB,QAAQ,EAAC;MAC/B;6DAGE,YAAgD;AAEhD,cAAM,SAAQ,WAAW,0BAA0B;AAEnD,YAAI,WAAU,WAAW;AACvB,iBAAO;;AAET,YAAI,WAAU,UAAU;AACtB,iBAAO;;AAGT,eAAO,WAAW,eAAe,WAAW;MAC9C;8DAIE,YAAgD;AAEhD,YAAI,8CAA8C,UAAU,GAAG;AAC7D,iBAAO;;AAGT,eAAO;MACT;gEAGE,YAAgD;AAEhD,cAAM,SAAQ,WAAW,0BAA0B;AAEnD,YAAI,CAAC,WAAW,mBAAmB,WAAU,YAAY;AACvD,iBAAO;;AAGT,eAAO;MACT;oDAEwD,QACA,YACA,gBACA,eACA,iBACA,eACA,eAA6C;AAGnG,mBAAW,4BAA4B;AAEvC,mBAAW,SAAS;AACpB,mBAAW,kBAAkB;AAC7B,mBAAW,UAAU;AAErB,mBAAW,WAAW;AACtB,mBAAW,kBAAkB;AAC7B,mBAAW,aAAa;AACxB,mBAAW,WAAW;AAEtB,mBAAW,yBAAyB;AACpC,mBAAW,eAAe;AAE1B,mBAAW,iBAAiB;AAC5B,mBAAW,mBAAmB;AAE9B,eAAO,4BAA4B;AAEnC,cAAM,cAAc,eAAc;AAClC,oBACE,oBAAoB,WAAW,GAC/B,MAAA;AACE,qBAAW,WAAW;AAKtB,0DAAgD,UAAU;WAE5D,QAAC;AACC,+CAAqC,YAAY,EAAC;SACnD;MAEL;wEAGE,QACA,kBACA,eACA,eAA6C;AAE7C,cAAM,aAAiD,OAAO,OAAO,gCAAgC,SAAS;AAE9G,YAAI,iBAAiD,MAAM;AAC3D,YAAI,gBAAqC,MAAM,oBAAoB,MAAS;AAC5E,YAAI,kBAAkD,MAAM,oBAAoB,MAAS;AAEzF,YAAI,iBAAiB,UAAU,QAAW;AACxC,2BAAiB,MAAM,iBAAiB,MAAO,UAAU;;AAE3D,YAAI,iBAAiB,SAAS,QAAW;AACvC,0BAAgB,MAAM,iBAAiB,KAAM,UAAU;;AAEzD,YAAI,iBAAiB,WAAW,QAAW;AACzC,4BAAkB,YAAU,iBAAiB,OAAQ,MAAM;;AAG7D,6CACE,QAAQ,YAAY,gBAAgB,eAAe,iBAAiB,eAAe,aAAa;MAEpG;AAIA,sDAA8C,OAAY;AACxD,eAAO,IAAI,UACT,6CAA6C,6DAA4D;MAC7G;iCCtWqC,QACA,iBAAwB;AAG3D,YAAI,+BAA+B,OAAO,yBAAyB,GAAG;AACpE,iBAAO,sBAAsB,MAAuC;;AAGtE,eAAO,yBAAyB,MAAuB;MACzD;wCAE4C,QACA,iBAAwB;AAIlE,cAAM,SAAS,mCAAsC,MAAM;AAE3D,YAAI,UAAU;AACd,YAAI,YAAY;AAChB,YAAI,YAAY;AAChB,YAAI,YAAY;AAChB,YAAI;AACJ,YAAI;AACJ,YAAI;AACJ,YAAI;AAEJ,YAAI;AACJ,cAAM,gBAAgB,WAAsB,cAAO;AACjD,iCAAuB;SACxB;AAED,iCAAsB;AACpB,cAAI,SAAS;AACX,wBAAY;AACZ,mBAAO,oBAAoB,MAAS;;AAGtC,oBAAU;AAEV,gBAAM,cAA8B;YAClC,aAAa,WAAK;AAIhB,6BAAe,MAAA;AACb,4BAAY;AACZ,sBAAM,SAAS;AACf,sBAAM,SAAS;AAQf,oBAAI,CAAC,WAAW;AACd,yDACE,QAAQ,2BACR,MAAM;;AAGV,oBAAI,CAAC,WAAW;AACd,yDACE,QAAQ,2BACR,MAAM;;AAIV,0BAAU;AACV,oBAAI,WAAW;AACb,gCAAa;;eAEhB;;YAEH,aAAa,MAAA;AACX,wBAAU;AACV,kBAAI,CAAC,WAAW;AACd,qDAAqC,QAAQ,yBAA+D;;AAE9G,kBAAI,CAAC,WAAW;AACd,qDAAqC,QAAQ,yBAA+D;;AAG9G,kBAAI,CAAC,aAAa,CAAC,WAAW;AAC5B,qCAAqB,MAAS;;;YAGlC,aAAa,MAAA;AACX,wBAAU;;;AAGd,0CAAgC,QAAQ,WAAW;AAEnD,iBAAO,oBAAoB,MAAS;;AAGtC,kCAA0B,QAAW;AACnC,sBAAY;AACZ,oBAAU;AACV,cAAI,WAAW;AACb,kBAAM,kBAAkB,oBAAoB,CAAC,SAAS,OAAO,CAAC;AAC9D,kBAAM,eAAe,qBAAqB,QAAQ,eAAe;AACjE,iCAAqB,YAAY;;AAEnC,iBAAO;;AAGT,kCAA0B,QAAW;AACnC,sBAAY;AACZ,oBAAU;AACV,cAAI,WAAW;AACb,kBAAM,kBAAkB,oBAAoB,CAAC,SAAS,OAAO,CAAC;AAC9D,kBAAM,eAAe,qBAAqB,QAAQ,eAAe;AACjE,iCAAqB,YAAY;;AAEnC,iBAAO;;AAGT,kCAAuB;;AAIvB,kBAAU,qBAAqB,gBAAgB,eAAe,gBAAgB;AAC9E,kBAAU,qBAAqB,gBAAgB,eAAe,gBAAgB;AAE9E,sBAAc,OAAO,gBAAgB,CAAC,OAAM;AAC1C,+CAAqC,QAAQ,2BAAiE,EAAC;AAC/G,+CAAqC,QAAQ,2BAAiE,EAAC;AAC/G,cAAI,CAAC,aAAa,CAAC,WAAW;AAC5B,iCAAqB,MAAS;;SAEjC;AAED,eAAO,CAAC,SAAS,OAAO;MAC1B;qCAEsC,QAA0B;AAI9D,YAAI,SAA2C,mCAAmC,MAAM;AACxF,YAAI,UAAU;AACd,YAAI,sBAAsB;AAC1B,YAAI,sBAAsB;AAC1B,YAAI,YAAY;AAChB,YAAI,YAAY;AAChB,YAAI;AACJ,YAAI;AACJ,YAAI;AACJ,YAAI;AAEJ,YAAI;AACJ,cAAM,gBAAgB,WAAiB,cAAO;AAC5C,iCAAuB;SACxB;AAED,oCAA4B,YAA4C;AACtE,wBAAc,WAAW,gBAAgB,QAAC;AACxC,gBAAI,eAAe,QAAQ;AACzB;;AAEF,8CAAkC,QAAQ,2BAA2B,EAAC;AACtE,8CAAkC,QAAQ,2BAA2B,EAAC;AACtE,gBAAI,CAAC,aAAa,CAAC,WAAW;AAC5B,mCAAqB,MAAS;;WAEjC;;AAGH,yCAA8B;AAC5B,cAAI,2BAA2B,MAAM,GAAG;AAEtC,+CAAmC,MAAM;AAEzC,qBAAS,mCAAmC,MAAM;AAClD,+BAAmB,MAAM;;AAG3B,gBAAM,cAAuC;YAC3C,aAAa,WAAK;AAIhB,6BAAe,MAAA;AACb,sCAAsB;AACtB,sCAAsB;AAEtB,sBAAM,SAAS;AACf,oBAAI,SAAS;AACb,oBAAI,CAAC,aAAa,CAAC,WAAW;AAC5B,sBAAI;AACF,6BAAS,kBAAkB,KAAK;2BACzB,QAAP;AACA,sDAAkC,QAAQ,2BAA2B,MAAM;AAC3E,sDAAkC,QAAQ,2BAA2B,MAAM;AAC3E,yCAAqB,qBAAqB,QAAQ,MAAM,CAAC;AACzD;;;AAIJ,oBAAI,CAAC,WAAW;AACd,sDAAoC,QAAQ,2BAA2B,MAAM;;AAE/E,oBAAI,CAAC,WAAW;AACd,sDAAoC,QAAQ,2BAA2B,MAAM;;AAG/E,0BAAU;AACV,oBAAI,qBAAqB;AACvB,iCAAc;2BACL,qBAAqB;AAC9B,iCAAc;;eAEjB;;YAEH,aAAa,MAAA;AACX,wBAAU;AACV,kBAAI,CAAC,WAAW;AACd,kDAAkC,QAAQ,yBAAyB;;AAErE,kBAAI,CAAC,WAAW;AACd,kDAAkC,QAAQ,yBAAyB;;AAErE,kBAAI,QAAQ,0BAA0B,kBAAkB,SAAS,GAAG;AAClE,oDAAoC,QAAQ,2BAA2B,CAAC;;AAE1E,kBAAI,QAAQ,0BAA0B,kBAAkB,SAAS,GAAG;AAClE,oDAAoC,QAAQ,2BAA2B,CAAC;;AAE1E,kBAAI,CAAC,aAAa,CAAC,WAAW;AAC5B,qCAAqB,MAAS;;;YAGlC,aAAa,MAAA;AACX,wBAAU;;;AAGd,0CAAgC,QAAQ,WAAW;;AAGrD,oCAA4B,MAAuB,YAAmB;AACpE,cAAI,8BAA0C,MAAM,GAAG;AAErD,+CAAmC,MAAM;AAEzC,qBAAS,gCAAgC,MAAM;AAC/C,+BAAmB,MAAM;;AAG3B,gBAAM,aAAa,aAAa,UAAU;AAC1C,gBAAM,cAAc,aAAa,UAAU;AAE3C,gBAAM,kBAAoD;YACxD,aAAa,WAAK;AAIhB,6BAAe,MAAA;AACb,sCAAsB;AACtB,sCAAsB;AAEtB,sBAAM,eAAe,aAAa,YAAY;AAC9C,sBAAM,gBAAgB,aAAa,YAAY;AAE/C,oBAAI,CAAC,eAAe;AAClB,sBAAI;AACJ,sBAAI;AACF,kCAAc,kBAAkB,KAAK;2BAC9B,QAAP;AACA,sDAAkC,WAAW,2BAA2B,MAAM;AAC9E,sDAAkC,YAAY,2BAA2B,MAAM;AAC/E,yCAAqB,qBAAqB,QAAQ,MAAM,CAAC;AACzD;;AAEF,sBAAI,CAAC,cAAc;AACjB,mEAA+C,WAAW,2BAA2B,KAAK;;AAE5F,sDAAoC,YAAY,2BAA2B,WAAW;2BAC7E,CAAC,cAAc;AACxB,iEAA+C,WAAW,2BAA2B,KAAK;;AAG5F,0BAAU;AACV,oBAAI,qBAAqB;AACvB,iCAAc;2BACL,qBAAqB;AAC9B,iCAAc;;eAEjB;;YAEH,aAAa,WAAK;AAChB,wBAAU;AAEV,oBAAM,eAAe,aAAa,YAAY;AAC9C,oBAAM,gBAAgB,aAAa,YAAY;AAE/C,kBAAI,CAAC,cAAc;AACjB,kDAAkC,WAAW,yBAAyB;;AAExE,kBAAI,CAAC,eAAe;AAClB,kDAAkC,YAAY,yBAAyB;;AAGzE,kBAAI,UAAU,QAAW;AAGvB,oBAAI,CAAC,cAAc;AACjB,iEAA+C,WAAW,2BAA2B,KAAK;;AAE5F,oBAAI,CAAC,iBAAiB,YAAY,0BAA0B,kBAAkB,SAAS,GAAG;AACxF,sDAAoC,YAAY,2BAA2B,CAAC;;;AAIhF,kBAAI,CAAC,gBAAgB,CAAC,eAAe;AACnC,qCAAqB,MAAS;;;YAGlC,aAAa,MAAA;AACX,wBAAU;;;AAGd,uCAA6B,QAAQ,MAAM,eAAe;;AAG5D,kCAAuB;AACrB,cAAI,SAAS;AACX,kCAAsB;AACtB,mBAAO,oBAAoB,MAAS;;AAGtC,oBAAU;AAEV,gBAAM,cAAc,2CAA2C,QAAQ,yBAAyB;AAChG,cAAI,gBAAgB,MAAM;AACxB,kCAAqB;iBAChB;AACL,+BAAmB,YAAY,OAAQ,KAAK;;AAG9C,iBAAO,oBAAoB,MAAS;;AAGtC,kCAAuB;AACrB,cAAI,SAAS;AACX,kCAAsB;AACtB,mBAAO,oBAAoB,MAAS;;AAGtC,oBAAU;AAEV,gBAAM,cAAc,2CAA2C,QAAQ,yBAAyB;AAChG,cAAI,gBAAgB,MAAM;AACxB,kCAAqB;iBAChB;AACL,+BAAmB,YAAY,OAAQ,IAAI;;AAG7C,iBAAO,oBAAoB,MAAS;;AAGtC,kCAA0B,QAAW;AACnC,sBAAY;AACZ,oBAAU;AACV,cAAI,WAAW;AACb,kBAAM,kBAAkB,oBAAoB,CAAC,SAAS,OAAO,CAAC;AAC9D,kBAAM,eAAe,qBAAqB,QAAQ,eAAe;AACjE,iCAAqB,YAAY;;AAEnC,iBAAO;;AAGT,kCAA0B,QAAW;AACnC,sBAAY;AACZ,oBAAU;AACV,cAAI,WAAW;AACb,kBAAM,kBAAkB,oBAAoB,CAAC,SAAS,OAAO,CAAC;AAC9D,kBAAM,eAAe,qBAAqB,QAAQ,eAAe;AACjE,iCAAqB,YAAY;;AAEnC,iBAAO;;AAGT,kCAAuB;AACrB;;AAGF,kBAAU,yBAAyB,gBAAgB,gBAAgB,gBAAgB;AACnF,kBAAU,yBAAyB,gBAAgB,gBAAgB,gBAAgB;AAEnF,2BAAmB,MAAM;AAEzB,eAAO,CAAC,SAAS,OAAO;MAC1B;oDCtaE,QACA,SAAe;AAEf,yBAAiB,QAAQ,OAAO;AAChC,cAAM,WAAW;AACjB,cAAM,wBAAwB,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACxC,cAAM,SAAS,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACzB,cAAM,OAAO,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACvB,cAAM,QAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACxB,cAAM,OAAO,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACvB,eAAO;UACL,uBAAuB,0BAA0B,SAC/C,SACA,wCACE,uBACA,GAAG,iDAAiD;UAExD,QAAQ,WAAW,SACjB,SACA,sCAAsC,QAAQ,UAAW,GAAG,kCAAkC;UAChG,MAAM,SAAS,SACb,SACA,oCAAoC,MAAM,UAAW,GAAG,gCAAgC;UAC1F,OAAO,UAAU,SACf,SACA,qCAAqC,OAAO,UAAW,GAAG,iCAAiC;UAC7F,MAAM,SAAS,SAAY,SAAY,0BAA0B,MAAM,GAAG,gCAAgC;;MAE9G;AAEA,qDACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,WAAgB,YAAY,IAAI,UAAU,CAAC,MAAM,CAAC;MAC5D;AAEA,mDACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,eAA4C,YAAY,IAAI,UAAU,CAAC,UAAU,CAAC;MAC5F;AAEA,oDACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,eAA4C,YAAY,IAAI,UAAU,CAAC,UAAU,CAAC;MAC5F;AAEA,yCAAmC,MAAc,SAAe;AAC9D,eAAO,GAAG;AACV,YAAI,SAAS,SAAS;AACpB,gBAAM,IAAI,UAAU,GAAG,YAAY,+DAA+D;;AAEpG,eAAO;MACT;oCC1EqC,SACA,SAAe;AAClD,yBAAiB,SAAS,OAAO;AACjC,cAAM,OAAO,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS;AACtB,eAAO;UACL,MAAM,SAAS,SAAY,SAAY,gCAAgC,MAAM,GAAG,gCAAgC;;MAEpH;AAEA,+CAAyC,MAAc,SAAe;AACpE,eAAO,GAAG;AACV,YAAI,SAAS,QAAQ;AACnB,gBAAM,IAAI,UAAU,GAAG,YAAY,qEAAqE;;AAE1G,eAAO;MACT;sCCZuC,SACA,SAAe;AACpD,yBAAiB,SAAS,OAAO;AACjC,cAAM,gBAAgB,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS;AAC/B,eAAO,EAAE,eAAe,QAAQ,aAAa,EAAC;MAChD;kCCPmC,SACA,SAAe;AAChD,yBAAiB,SAAS,OAAO;AACjC,cAAM,eAAe,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS;AAC9B,cAAM,gBAAgB,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS;AAC/B,cAAM,eAAe,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS;AAC9B,cAAM,SAAS,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS;AACxB,YAAI,WAAW,QAAW;AACxB,4BAAkB,QAAQ,GAAG,kCAAkC;;AAEjE,eAAO;UACL,cAAc,QAAQ,YAAY;UAClC,eAAe,QAAQ,aAAa;UACpC,cAAc,QAAQ,YAAY;UAClC;;MAEJ;AAEA,iCAA2B,QAAiB,SAAe;AACzD,YAAI,CAAC,eAAc,MAAM,GAAG;AAC1B,gBAAM,IAAI,UAAU,GAAG,gCAAgC;;MAE3D;2CCnBE,MACA,SAAe;AAEf,yBAAiB,MAAM,OAAO;AAE9B,cAAM,WAAW,SAAI,QAAJ,SAAI,SAAA,SAAJ,KAAM;AACvB,4BAAoB,UAAU,YAAY,sBAAsB;AAChE,6BAAqB,UAAU,GAAG,oCAAoC;AAEtE,cAAM,WAAW,SAAI,QAAJ,SAAI,SAAA,SAAJ,KAAM;AACvB,4BAAoB,UAAU,YAAY,sBAAsB;AAChE,6BAAqB,UAAU,GAAG,oCAAoC;AAEtE,eAAO,EAAE,UAAU,SAAQ;MAC7B;YCsDa,gBAAc;QAczB,YAAY,sBAAqF,CAAA,GACrF,cAAqD,CAAA,GAAE;AACjE,cAAI,wBAAwB,QAAW;AACrC,kCAAsB;iBACjB;AACL,yBAAa,qBAAqB,iBAAiB;;AAGrD,gBAAM,WAAW,uBAAuB,aAAa,kBAAkB;AACvE,gBAAM,mBAAmB,qCAAqC,qBAAqB,iBAAiB;AAEpG,mCAAyB,IAAI;AAE7B,cAAI,iBAAiB,SAAS,SAAS;AACrC,gBAAI,SAAS,SAAS,QAAW;AAC/B,oBAAM,IAAI,WAAW,4DAA4D;;AAEnF,kBAAM,gBAAgB,qBAAqB,UAAU,CAAC;AACtD,kEACE,MACA,kBACA,aAAa;iBAEV;AAEL,kBAAM,gBAAgB,qBAAqB,QAAQ;AACnD,kBAAM,gBAAgB,qBAAqB,UAAU,CAAC;AACtD,qEACE,MACA,kBACA,eACA,aAAa;;;QAQnB,IAAI,SAAM;AACR,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,kBAAM,4BAA0B,QAAQ;;AAG1C,iBAAO,uBAAuB,IAAI;;QASpC,OAAO,SAAc,QAAS;AAC5B,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,mBAAO,oBAAoB,4BAA0B,QAAQ,CAAC;;AAGhE,cAAI,uBAAuB,IAAI,GAAG;AAChC,mBAAO,oBAAoB,IAAI,UAAU,kDAAkD,CAAC;;AAG9F,iBAAO,qBAAqB,MAAM,MAAM;;QAsB1C,UACE,aAAgE,QAAS;AAEzE,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,kBAAM,4BAA0B,WAAW;;AAG7C,gBAAM,UAAU,qBAAqB,YAAY,iBAAiB;AAElE,cAAI,QAAQ,SAAS,QAAW;AAC9B,mBAAO,mCAAmC,IAAI;;AAIhD,iBAAO,gCAAgC,IAAqC;;QAc9E,YACE,cACA,aAAmD,CAAA,GAAE;AAErD,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,kBAAM,4BAA0B,aAAa;;AAE/C,iCAAuB,cAAc,GAAG,aAAa;AAErD,gBAAM,YAAY,4BAA4B,cAAc,iBAAiB;AAC7E,gBAAM,UAAU,mBAAmB,YAAY,kBAAkB;AAEjE,cAAI,uBAAuB,IAAI,GAAG;AAChC,kBAAM,IAAI,UAAU,gFAAgF;;AAEtG,cAAI,uBAAuB,UAAU,QAAQ,GAAG;AAC9C,kBAAM,IAAI,UAAU,gFAAgF;;AAGtG,gBAAM,UAAU,qBACd,MAAM,UAAU,UAAU,QAAQ,cAAc,QAAQ,cAAc,QAAQ,eAAe,QAAQ,MAAM;AAG7G,oCAA0B,OAAO;AAEjC,iBAAO,UAAU;;QAWnB,OAAO,aACA,aAAmD,CAAA,GAAE;AAC1D,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,mBAAO,oBAAoB,4BAA0B,QAAQ,CAAC;;AAGhE,cAAI,gBAAgB,QAAW;AAC7B,mBAAO,oBAAoB,sCAAsC;;AAEnE,cAAI,CAAC,iBAAiB,WAAW,GAAG;AAClC,mBAAO,oBACL,IAAI,UAAU,2EAA2E,CAAC;;AAI9F,cAAI;AACJ,cAAI;AACF,sBAAU,mBAAmB,YAAY,kBAAkB;mBACpD,IAAP;AACA,mBAAO,oBAAoB,EAAC;;AAG9B,cAAI,uBAAuB,IAAI,GAAG;AAChC,mBAAO,oBACL,IAAI,UAAU,2EAA2E,CAAC;;AAG9F,cAAI,uBAAuB,WAAW,GAAG;AACvC,mBAAO,oBACL,IAAI,UAAU,2EAA2E,CAAC;;AAI9F,iBAAO,qBACL,MAAM,aAAa,QAAQ,cAAc,QAAQ,cAAc,QAAQ,eAAe,QAAQ,MAAM;;QAexG,MAAG;AACD,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,kBAAM,4BAA0B,KAAK;;AAGvC,gBAAM,WAAW,kBAAkB,IAAW;AAC9C,iBAAO,oBAAoB,QAAQ;;QAerC,OAAO,aAA+D,QAAS;AAC7E,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,kBAAM,4BAA0B,QAAQ;;AAG1C,gBAAM,UAAU,uBAAuB,YAAY,iBAAiB;AACpE,iBAAO,mCAAsC,MAAM,QAAQ,aAAa;;;AAS5E,aAAO,iBAAiB,gBAAe,WAAW;QAChD,QAAQ,EAAE,YAAY,KAAI;QAC1B,WAAW,EAAE,YAAY,KAAI;QAC7B,aAAa,EAAE,YAAY,KAAI;QAC/B,QAAQ,EAAE,YAAY,KAAI;QAC1B,KAAK,EAAE,YAAY,KAAI;QACvB,QAAQ,EAAE,YAAY,KAAI;QAC1B,QAAQ,EAAE,YAAY,KAAI;OAC3B;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,gBAAe,WAAW,eAAO,aAAa;UAClE,OAAO;UACP,cAAc;SACf;;AAEH,UAAI,OAAO,eAAO,kBAAkB,UAAU;AAC5C,eAAO,eAAe,gBAAe,WAAW,eAAO,eAAe;UACpE,OAAO,gBAAe,UAAU;UAChC,UAAU;UACV,cAAc;SACf;;oCAsBqC,gBACA,eACA,iBACA,gBAAgB,GAChB,gBAAgD,MAAM,GAAC;AAG7F,cAAM,SAA4B,OAAO,OAAO,gBAAe,SAAS;AACxE,iCAAyB,MAAM;AAE/B,cAAM,aAAiD,OAAO,OAAO,gCAAgC,SAAS;AAC9G,6CACE,QAAQ,YAAY,gBAAgB,eAAe,iBAAiB,eAAe,aAAa;AAGlG,eAAO;MACT;wCAIE,gBACA,eACA,iBAA+C;AAE/C,cAAM,SAA6B,OAAO,OAAO,gBAAe,SAAS;AACzE,iCAAyB,MAAM;AAE/B,cAAM,aAA2C,OAAO,OAAO,6BAA6B,SAAS;AACrG,0CAAkC,QAAQ,YAAY,gBAAgB,eAAe,iBAAiB,GAAG,MAAS;AAElH,eAAO;MACT;AAEA,wCAAkC,QAAsB;AACtD,eAAO,SAAS;AAChB,eAAO,UAAU;AACjB,eAAO,eAAe;AACtB,eAAO,aAAa;MACtB;gCAEiC,IAAU;AACzC,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,2BAA2B,GAAG;AACzE,iBAAO;;AAGT,eAAO,cAAa;MACtB;sCAQuC,QAAsB;AAG3D,YAAI,OAAO,YAAY,QAAW;AAChC,iBAAO;;AAGT,eAAO;MACT;oCAIwC,QAA2B,QAAW;AAC5E,eAAO,aAAa;AAEpB,YAAI,OAAO,WAAW,UAAU;AAC9B,iBAAO,oBAAoB,MAAS;;AAEtC,YAAI,OAAO,WAAW,WAAW;AAC/B,iBAAO,oBAAoB,OAAO,YAAY;;AAGhD,4BAAoB,MAAM;AAE1B,cAAM,SAAS,OAAO;AACtB,YAAI,WAAW,UAAa,2BAA2B,MAAM,GAAG;AAC9D,iBAAO,kBAAkB,QAAQ,qBAAe;AAC9C,4BAAgB,YAAY,MAAS;WACtC;AACD,iBAAO,oBAAoB,IAAI,YAAW;;AAG5C,cAAM,sBAAsB,OAAO,0BAA0B,aAAa,MAAM;AAChF,eAAO,qBAAqB,qBAAqB,KAAI;MACvD;mCAEuC,QAAyB;AAG9D,eAAO,SAAS;AAEhB,cAAM,SAAS,OAAO;AAEtB,YAAI,WAAW,QAAW;AACxB;;AAGF,0CAAkC,MAAM;AAExC,YAAI,8BAAiC,MAAM,GAAG;AAC5C,iBAAO,cAAc,QAAQ,iBAAW;AACtC,wBAAY,YAAW;WACxB;AACD,iBAAO,gBAAgB,IAAI,YAAW;;MAE1C;mCAEuC,QAA2B,IAAM;AAItE,eAAO,SAAS;AAChB,eAAO,eAAe;AAEtB,cAAM,SAAS,OAAO;AAEtB,YAAI,WAAW,QAAW;AACxB;;AAGF,yCAAiC,QAAQ,EAAC;AAE1C,YAAI,8BAAiC,MAAM,GAAG;AAC5C,iBAAO,cAAc,QAAQ,iBAAW;AACtC,wBAAY,YAAY,EAAC;WAC1B;AAED,iBAAO,gBAAgB,IAAI,YAAW;eACjC;AAGL,iBAAO,kBAAkB,QAAQ,qBAAe;AAC9C,4BAAgB,YAAY,EAAC;WAC9B;AAED,iBAAO,oBAAoB,IAAI,YAAW;;MAE9C;AAqBA,2CAAmC,OAAY;AAC7C,eAAO,IAAI,UAAU,4BAA4B,4CAA2C;MAC9F;0CCjhB2C,MACA,SAAe;AACxD,yBAAiB,MAAM,OAAO;AAC9B,cAAM,gBAAgB,SAAI,QAAJ,SAAI,SAAA,SAAJ,KAAM;AAC5B,4BAAoB,eAAe,iBAAiB,qBAAqB;AACzE,eAAO;UACL,eAAe,0BAA0B,aAAa;;MAE1D;ACLA,YAAM,yBAAyB,CAAC,UAAsB;AACpD,eAAO,MAAM;MACf;AACA,UAAI;AACF,eAAO,eAAe,wBAAwB,QAAQ;UACpD,OAAO;UACP,cAAc;SACf;eACD,IAAA;;YAUmB,0BAAyB;QAI5C,YAAY,SAA4B;AACtC,iCAAuB,SAAS,GAAG,2BAA2B;AAC9D,oBAAU,2BAA2B,SAAS,iBAAiB;AAC/D,eAAK,0CAA0C,QAAQ;;QAMzD,IAAI,gBAAa;AACf,cAAI,CAAC,4BAA4B,IAAI,GAAG;AACtC,kBAAM,8BAA8B,eAAe;;AAErD,iBAAO,KAAK;;QAMd,IAAI,OAAI;AACN,cAAI,CAAC,4BAA4B,IAAI,GAAG;AACtC,kBAAM,8BAA8B,MAAM;;AAE5C,iBAAO;;;AAIX,aAAO,iBAAiB,0BAA0B,WAAW;QAC3D,eAAe,EAAE,YAAY,KAAI;QACjC,MAAM,EAAE,YAAY,KAAI;OACzB;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,0BAA0B,WAAW,eAAO,aAAa;UAC7E,OAAO;UACP,cAAc;SACf;;AAKH,6CAAuC,OAAY;AACjD,eAAO,IAAI,UAAU,uCAAuC,uDAAsD;MACpH;2CAE4C,IAAM;AAChD,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,yCAAyC,GAAG;AACvF,iBAAO;;AAGT,eAAO,cAAa;MACtB;AC5EA,YAAM,oBAAoB,MAAA;AACxB,eAAO;MACT;AACA,UAAI;AACF,eAAO,eAAe,mBAAmB,QAAQ;UAC/C,OAAO;UACP,cAAc;SACf;eACD,IAAA;;YAUmB,qBAAoB;QAIvC,YAAY,SAA4B;AACtC,iCAAuB,SAAS,GAAG,sBAAsB;AACzD,oBAAU,2BAA2B,SAAS,iBAAiB;AAC/D,eAAK,qCAAqC,QAAQ;;QAMpD,IAAI,gBAAa;AACf,cAAI,CAAC,uBAAuB,IAAI,GAAG;AACjC,kBAAM,yBAAyB,eAAe;;AAEhD,iBAAO,KAAK;;QAOd,IAAI,OAAI;AACN,cAAI,CAAC,uBAAuB,IAAI,GAAG;AACjC,kBAAM,yBAAyB,MAAM;;AAEvC,iBAAO;;;AAIX,aAAO,iBAAiB,qBAAqB,WAAW;QACtD,eAAe,EAAE,YAAY,KAAI;QACjC,MAAM,EAAE,YAAY,KAAI;OACzB;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,qBAAqB,WAAW,eAAO,aAAa;UACxE,OAAO;UACP,cAAc;SACf;;AAKH,wCAAkC,OAAY;AAC5C,eAAO,IAAI,UAAU,kCAAkC,kDAAiD;MAC1G;sCAEuC,IAAM;AAC3C,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,oCAAoC,GAAG;AAClF,iBAAO;;AAGT,eAAO,cAAa;MACtB;kCCxEyC,UACA,SAAe;AACtD,yBAAiB,UAAU,OAAO;AAClC,cAAM,QAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACxB,cAAM,eAAe,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AAC/B,cAAM,QAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACxB,cAAM,YAAY,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AAC5B,cAAM,eAAe,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AAC/B,eAAO;UACL,OAAO,UAAU,SACf,SACA,gCAAgC,OAAO,UAAW,GAAG,iCAAiC;UACxF;UACA,OAAO,UAAU,SACf,SACA,gCAAgC,OAAO,UAAW,GAAG,iCAAiC;UACxF,WAAW,cAAc,SACvB,SACA,oCAAoC,WAAW,UAAW,GAAG,qCAAqC;UACpG;;MAEJ;AAEA,+CACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,eAAoD,YAAY,IAAI,UAAU,CAAC,UAAU,CAAC;MACpG;AAEA,+CACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,eAAoD,YAAY,IAAI,UAAU,CAAC,UAAU,CAAC;MACpG;AAEA,mDACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,OAAU,eAAoD,YAAY,IAAI,UAAU,CAAC,OAAO,UAAU,CAAC;MACrH;YCvBa,gBAAe;QAmB1B,YAAY,iBAAuD,CAAA,GACvD,sBAA6D,CAAA,GAC7D,sBAA6D,CAAA,GAAE;AACzE,cAAI,mBAAmB,QAAW;AAChC,6BAAiB;;AAGnB,gBAAM,mBAAmB,uBAAuB,qBAAqB,kBAAkB;AACvF,gBAAM,mBAAmB,uBAAuB,qBAAqB,iBAAiB;AAEtF,gBAAM,cAAc,mBAAmB,gBAAgB,iBAAiB;AACxE,cAAI,YAAY,iBAAiB,QAAW;AAC1C,kBAAM,IAAI,WAAW,gCAAgC;;AAEvD,cAAI,YAAY,iBAAiB,QAAW;AAC1C,kBAAM,IAAI,WAAW,gCAAgC;;AAGvD,gBAAM,wBAAwB,qBAAqB,kBAAkB,CAAC;AACtE,gBAAM,wBAAwB,qBAAqB,gBAAgB;AACnE,gBAAM,wBAAwB,qBAAqB,kBAAkB,CAAC;AACtE,gBAAM,wBAAwB,qBAAqB,gBAAgB;AAEnE,cAAI;AACJ,gBAAM,eAAe,WAAiB,cAAO;AAC3C,mCAAuB;WACxB;AAED,oCACE,MAAM,cAAc,uBAAuB,uBAAuB,uBAAuB,qBAAqB;AAEhH,+DAAqD,MAAM,WAAW;AAEtE,cAAI,YAAY,UAAU,QAAW;AACnC,iCAAqB,YAAY,MAAM,KAAK,0BAA0B,CAAC;iBAClE;AACL,iCAAqB,MAAS;;;QAOlC,IAAI,WAAQ;AACV,cAAI,CAAC,kBAAkB,IAAI,GAAG;AAC5B,kBAAM,0BAA0B,UAAU;;AAG5C,iBAAO,KAAK;;QAMd,IAAI,WAAQ;AACV,cAAI,CAAC,kBAAkB,IAAI,GAAG;AAC5B,kBAAM,0BAA0B,UAAU;;AAG5C,iBAAO,KAAK;;;AAIhB,aAAO,iBAAiB,gBAAgB,WAAW;QACjD,UAAU,EAAE,YAAY,KAAI;QAC5B,UAAU,EAAE,YAAY,KAAI;OAC7B;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,gBAAgB,WAAW,eAAO,aAAa;UACnE,OAAO;UACP,cAAc;SACf;;AAyCH,yCAAyC,QACA,cACA,uBACA,uBACA,uBACA,uBAAqD;AAC5F,kCAAuB;AACrB,iBAAO;;AAGT,gCAAwB,OAAQ;AAC9B,iBAAO,yCAAyC,QAAQ,KAAK;;AAG/D,gCAAwB,QAAW;AACjC,iBAAO,yCAAyC,QAAQ,MAAM;;AAGhE,kCAAuB;AACrB,iBAAO,yCAAyC,MAAM;;AAGxD,eAAO,YAAY,qBAAqB,gBAAgB,gBAAgB,gBAAgB,gBAChD,uBAAuB,qBAAqB;AAEpF,iCAAsB;AACpB,iBAAO,0CAA0C,MAAM;;AAGzD,iCAAyB,QAAW;AAClC,sDAA4C,QAAQ,MAAM;AAC1D,iBAAO,oBAAoB,MAAS;;AAGtC,eAAO,YAAY,qBAAqB,gBAAgB,eAAe,iBAAiB,uBAChD,qBAAqB;AAG7D,eAAO,gBAAgB;AACvB,eAAO,6BAA6B;AACpC,eAAO,qCAAqC;AAC5C,uCAA+B,QAAQ,IAAI;AAE3C,eAAO,6BAA6B;MACtC;AAEA,iCAA2B,IAAU;AACnC,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,4BAA4B,GAAG;AAC1E,iBAAO;;AAGT,eAAO,cAAa;MACtB;AAGA,oCAA8B,QAAyB,IAAM;AAC3D,6CACE,OAAO,UAAU,2BACjB,EAAC;AAEH,oDAA4C,QAAQ,EAAC;MACvD;AAEA,2DAAqD,QAAyB,IAAM;AAClF,wDAAgD,OAAO,0BAA0B;AACjF,qDAA6C,OAAO,UAAU,2BAA2B,EAAC;AAC1F,YAAI,OAAO,eAAe;AAIxB,yCAA+B,QAAQ,KAAK;;MAEhD;AAEA,8CAAwC,QAAyB,cAAqB;AAIpF,YAAI,OAAO,+BAA+B,QAAW;AACnD,iBAAO,mCAAkC;;AAG3C,eAAO,6BAA6B,WAAW,cAAO;AACpD,iBAAO,qCAAqC;SAC7C;AAED,eAAO,gBAAgB;MACzB;YASa,iCAAgC;QAQ3C,cAAA;AACE,gBAAM,IAAI,UAAU,qBAAqB;;QAM3C,IAAI,cAAW;AACb,cAAI,CAAC,mCAAmC,IAAI,GAAG;AAC7C,kBAAM,qCAAqC,aAAa;;AAG1D,gBAAM,qBAAqB,KAAK,2BAA2B,UAAU;AACrE,iBAAO,8CAA8C,kBAAwD;;QAO/G,QAAQ,QAAW,QAAU;AAC3B,cAAI,CAAC,mCAAmC,IAAI,GAAG;AAC7C,kBAAM,qCAAqC,SAAS;;AAGtD,kDAAwC,MAAM,KAAK;;QAOrD,MAAM,SAAc,QAAS;AAC3B,cAAI,CAAC,mCAAmC,IAAI,GAAG;AAC7C,kBAAM,qCAAqC,OAAO;;AAGpD,gDAAsC,MAAM,MAAM;;QAOpD,YAAS;AACP,cAAI,CAAC,mCAAmC,IAAI,GAAG;AAC7C,kBAAM,qCAAqC,WAAW;;AAGxD,oDAA0C,IAAI;;;AAIlD,aAAO,iBAAiB,iCAAiC,WAAW;QAClE,SAAS,EAAE,YAAY,KAAI;QAC3B,OAAO,EAAE,YAAY,KAAI;QACzB,WAAW,EAAE,YAAY,KAAI;QAC7B,aAAa,EAAE,YAAY,KAAI;OAChC;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,iCAAiC,WAAW,eAAO,aAAa;UACpF,OAAO;UACP,cAAc;SACf;;AAKH,kDAAqD,IAAM;AACzD,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,4BAA4B,GAAG;AAC1E,iBAAO;;AAGT,eAAO,cAAa;MACtB;AAEA,qDAAqD,QACA,YACA,oBACA,gBAAmC;AAItF,mBAAW,6BAA6B;AACxC,eAAO,6BAA6B;AAEpC,mBAAW,sBAAsB;AACjC,mBAAW,kBAAkB;MAC/B;AAEA,oEAAoE,QACA,aAAuC;AACzG,cAAM,aAAkD,OAAO,OAAO,iCAAiC,SAAS;AAEhH,YAAI,qBAAqB,CAAC,UAAQ;AAChC,cAAI;AACF,oDAAwC,YAAY,KAAqB;AACzE,mBAAO,oBAAoB,MAAS;mBAC7B,kBAAP;AACA,mBAAO,oBAAoB,gBAAgB;;;AAI/C,YAAI,iBAAsC,MAAM,oBAAoB,MAAS;AAE7E,YAAI,YAAY,cAAc,QAAW;AACvC,+BAAqB,WAAS,YAAY,UAAW,OAAO,UAAU;;AAExE,YAAI,YAAY,UAAU,QAAW;AACnC,2BAAiB,MAAM,YAAY,MAAO,UAAU;;AAGtD,8CAAsC,QAAQ,YAAY,oBAAoB,cAAc;MAC9F;AAEA,+DAAyD,YAAiD;AACxG,mBAAW,sBAAsB;AACjC,mBAAW,kBAAkB;MAC/B;AAEA,uDAAoD,YAAiD,OAAQ;AAC3G,cAAM,SAAS,WAAW;AAC1B,cAAM,qBAAqB,OAAO,UAAU;AAC5C,YAAI,CAAC,iDAAiD,kBAAkB,GAAG;AACzE,gBAAM,IAAI,UAAU,sDAAsD;;AAM5E,YAAI;AACF,iDAAuC,oBAAoB,KAAK;iBACzD,IAAP;AAEA,sDAA4C,QAAQ,EAAC;AAErD,gBAAM,OAAO,UAAU;;AAGzB,cAAM,eAAe,+CAA+C,kBAAkB;AACtF,YAAI,iBAAiB,OAAO,eAAe;AAEzC,yCAA+B,QAAQ,IAAI;;MAE/C;AAEA,qDAA+C,YAAmD,IAAM;AACtG,6BAAqB,WAAW,4BAA4B,EAAC;MAC/D;AAEA,gEAAgE,YACA,OAAQ;AACtE,cAAM,mBAAmB,WAAW,oBAAoB,KAAK;AAC7D,eAAO,qBAAqB,kBAAkB,QAAW,QAAC;AACxD,+BAAqB,WAAW,4BAA4B,EAAC;AAC7D,gBAAM;SACP;MACH;AAEA,yDAAsD,YAA+C;AACnG,cAAM,SAAS,WAAW;AAC1B,cAAM,qBAAqB,OAAO,UAAU;AAE5C,6CAAqC,kBAAkB;AAEvD,cAAM,QAAQ,IAAI,UAAU,4BAA4B;AACxD,oDAA4C,QAAQ,KAAK;MAC3D;AAIA,wDAAwD,QAA+B,OAAQ;AAG7F,cAAM,aAAa,OAAO;AAE1B,YAAI,OAAO,eAAe;AACxB,gBAAM,4BAA4B,OAAO;AAEzC,iBAAO,qBAAqB,2BAA2B,MAAA;AACrD,kBAAM,WAAW,OAAO;AACxB,kBAAM,SAAQ,SAAS;AACvB,gBAAI,WAAU,YAAY;AACxB,oBAAM,SAAS;;AAGjB,mBAAO,iDAAuD,YAAY,KAAK;WAChF;;AAGH,eAAO,iDAAuD,YAAY,KAAK;MACjF;AAEA,wDAAkD,QAAyB,QAAW;AAGpF,6BAAqB,QAAQ,MAAM;AACnC,eAAO,oBAAoB,MAAS;MACtC;AAEA,wDAAwD,QAA6B;AAEnF,cAAM,WAAW,OAAO;AAExB,cAAM,aAAa,OAAO;AAC1B,cAAM,eAAe,WAAW,gBAAe;AAC/C,wDAAgD,UAAU;AAG1D,eAAO,qBAAqB,cAAc,MAAA;AACxC,cAAI,SAAS,WAAW,WAAW;AACjC,kBAAM,SAAS;;AAEjB,+CAAqC,SAAS,yBAA+D;WAC5G,QAAC;AACF,+BAAqB,QAAQ,EAAC;AAC9B,gBAAM,SAAS;SAChB;MACH;AAIA,yDAAmD,QAAuB;AAMxE,uCAA+B,QAAQ,KAAK;AAG5C,eAAO,OAAO;MAChB;AAIA,oDAA8C,OAAY;AACxD,eAAO,IAAI,UACT,8CAA8C,8DAA6D;MAC/G;AAIA,yCAAmC,OAAY;AAC7C,eAAO,IAAI,UACT,6BAA6B,6CAA4C;MAC7E;;;;;;;;;;;;;;;;;;;;AC7gBA;AAAA;AAEA,QAAM,aAAY;AAElB,QAAI,CAAC,WAAW,gBAAgB;AAI9B,UAAI;AACF,cAAM,WAAU,QAAQ;AACxB,cAAM,EAAE,gBAAgB;AACxB,YAAI;AACF,mBAAQ,cAAc,MAAM;AAAA,UAAC;AAC7B,iBAAO,OAAO,YAAY,QAAQ,kBAAkB;AACpD,mBAAQ,cAAc;AAAA,QACxB,SAAS,OAAP;AACA,mBAAQ,cAAc;AACtB,gBAAM;AAAA,QACR;AAAA,MACF,SAAS,OAAP;AAEA,eAAO,OAAO,YAAY,yBAAuD;AAAA,MACnF;AAAA,IACF;AAEA,QAAI;AAGF,YAAM,EAAE,gBAAS,QAAQ;AACzB,UAAI,SAAQ,CAAC,MAAK,UAAU,QAAQ;AAClC,cAAK,UAAU,SAAS,eAAe,QAAQ;AAC7C,cAAI,WAAW;AACf,gBAAM,OAAO;AAEb,iBAAO,IAAI,eAAe;AAAA,YACxB,MAAM;AAAA,YACN,MAAM,KAAM,MAAM;AAChB,oBAAM,QAAQ,KAAK,MAAM,UAAU,KAAK,IAAI,KAAK,MAAM,WAAW,UAAS,CAAC;AAC5E,oBAAM,SAAS,MAAM,MAAM,YAAY;AACvC,0BAAY,OAAO;AACnB,mBAAK,QAAQ,IAAI,WAAW,MAAM,CAAC;AAEnC,kBAAI,aAAa,KAAK,MAAM;AAC1B,qBAAK,MAAM;AAAA,cACb;AAAA,YACF;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF,SAAS,OAAP;AAAA,IAAe;AAAA;AAAA;;;ACtCjB,2BAA6B,OAAO,SAAQ,MAAM;AAChD,aAAW,QAAQ,OAAO;AACxB,QAAI,YAAY,MAAM;AACpB,aAA2D,KAAK,OAAO;AAAA,IACzE,WAAW,YAAY,OAAO,IAAI,GAAG;AACnC,UAAI,QAAO;AACT,YAAI,WAAW,KAAK;AACpB,cAAM,MAAM,KAAK,aAAa,KAAK;AACnC,eAAO,aAAa,KAAK;AACvB,gBAAM,OAAO,KAAK,IAAI,MAAM,UAAU,SAAS;AAC/C,gBAAM,QAAQ,KAAK,OAAO,MAAM,UAAU,WAAW,IAAI;AACzD,sBAAY,MAAM;AAClB,gBAAM,IAAI,WAAW,KAAK;AAAA,QAC5B;AAAA,MACF,OAAO;AACL,cAAM;AAAA,MACR;AAAA,IAEF,OAAO;AAEL,UAAI,WAAW,GAAG,IAA0B;AAC5C,aAAO,aAAa,EAAE,MAAM;AAC1B,cAAM,QAAQ,EAAE,MAAM,UAAU,KAAK,IAAI,EAAE,MAAM,WAAW,SAAS,CAAC;AACtE,cAAM,SAAS,MAAM,MAAM,YAAY;AACvC,oBAAY,OAAO;AACnB,cAAM,IAAI,WAAW,MAAM;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AACF;AAxCA,IAKA,gBAGM,WAkCA,OA8MO,OACN;AAzPP;AAAA;AAKA,qBAAO;AALP,AAQA,IAAM,YAAY;AAkClB,IAAM,QAAQ,MAAM,MAAK;AAAA,MAEvB,SAAS,CAAC;AAAA,MACV,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,WAAW;AAAA,MAUX,YAAa,YAAY,CAAC,GAAG,UAAU,CAAC,GAAG;AACzC,YAAI,OAAO,cAAc,YAAY,cAAc,MAAM;AACvD,gBAAM,IAAI,UAAU,mFAAqF;AAAA,QAC3G;AAEA,YAAI,OAAO,UAAU,OAAO,cAAc,YAAY;AACpD,gBAAM,IAAI,UAAU,kFAAoF;AAAA,QAC1G;AAEA,YAAI,OAAO,YAAY,YAAY,OAAO,YAAY,YAAY;AAChE,gBAAM,IAAI,UAAU,uEAAyE;AAAA,QAC/F;AAEA,YAAI,YAAY;AAAM,oBAAU,CAAC;AAEjC,cAAM,UAAU,IAAI,YAAY;AAChC,mBAAW,WAAW,WAAW;AAC/B,cAAI;AACJ,cAAI,YAAY,OAAO,OAAO,GAAG;AAC/B,mBAAO,IAAI,WAAW,QAAQ,OAAO,MAAM,QAAQ,YAAY,QAAQ,aAAa,QAAQ,UAAU,CAAC;AAAA,UACzG,WAAW,mBAAmB,aAAa;AACzC,mBAAO,IAAI,WAAW,QAAQ,MAAM,CAAC,CAAC;AAAA,UACxC,WAAW,mBAAmB,OAAM;AAClC,mBAAO;AAAA,UACT,OAAO;AACL,mBAAO,QAAQ,OAAO,GAAG,SAAS;AAAA,UACpC;AAEA,eAAK,SAAS,YAAY,OAAO,IAAI,IAAI,KAAK,aAAa,KAAK;AAChE,eAAK,OAAO,KAAK,IAAI;AAAA,QACvB;AAEA,aAAK,WAAW,GAAG,QAAQ,YAAY,SAAY,gBAAgB,QAAQ;AAC3E,cAAM,OAAO,QAAQ,SAAS,SAAY,KAAK,OAAO,QAAQ,IAAI;AAClE,aAAK,QAAQ,iBAAiB,KAAK,IAAI,IAAI,OAAO;AAAA,MACpD;AAAA,MAMA,IAAI,OAAQ;AACV,eAAO,KAAK;AAAA,MACd;AAAA,MAKA,IAAI,OAAQ;AACV,eAAO,KAAK;AAAA,MACd;AAAA,MASA,MAAM,OAAQ;AAGZ,cAAM,UAAU,IAAI,YAAY;AAChC,YAAI,MAAM;AACV,yBAAiB,QAAQ,WAAW,KAAK,QAAQ,KAAK,GAAG;AACvD,iBAAO,QAAQ,OAAO,MAAM,EAAE,QAAQ,KAAK,CAAC;AAAA,QAC9C;AAEA,eAAO,QAAQ,OAAO;AACtB,eAAO;AAAA,MACT;AAAA,MASA,MAAM,cAAe;AAMnB,cAAM,OAAO,IAAI,WAAW,KAAK,IAAI;AACrC,YAAI,SAAS;AACb,yBAAiB,SAAS,WAAW,KAAK,QAAQ,KAAK,GAAG;AACxD,eAAK,IAAI,OAAO,MAAM;AACtB,oBAAU,MAAM;AAAA,QAClB;AAEA,eAAO,KAAK;AAAA,MACd;AAAA,MAEA,SAAU;AACR,cAAM,KAAK,WAAW,KAAK,QAAQ,IAAI;AAEvC,eAAO,IAAI,WAAW,eAAe;AAAA,UAEnC,MAAM;AAAA,UACN,MAAM,KAAM,MAAM;AAChB,kBAAM,QAAQ,MAAM,GAAG,KAAK;AAC5B,kBAAM,OAAO,KAAK,MAAM,IAAI,KAAK,QAAQ,MAAM,KAAK;AAAA,UACtD;AAAA,UAEA,MAAM,SAAU;AACd,kBAAM,GAAG,OAAO;AAAA,UAClB;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MAWA,MAAO,QAAQ,GAAG,MAAM,KAAK,MAAM,OAAO,IAAI;AAC5C,cAAM,EAAE,SAAS;AAEjB,YAAI,gBAAgB,QAAQ,IAAI,KAAK,IAAI,OAAO,OAAO,CAAC,IAAI,KAAK,IAAI,OAAO,IAAI;AAChF,YAAI,cAAc,MAAM,IAAI,KAAK,IAAI,OAAO,KAAK,CAAC,IAAI,KAAK,IAAI,KAAK,IAAI;AAExE,cAAM,OAAO,KAAK,IAAI,cAAc,eAAe,CAAC;AACpD,cAAM,QAAQ,KAAK;AACnB,cAAM,YAAY,CAAC;AACnB,YAAI,QAAQ;AAEZ,mBAAW,QAAQ,OAAO;AAExB,cAAI,SAAS,MAAM;AACjB;AAAA,UACF;AAEA,gBAAM,QAAO,YAAY,OAAO,IAAI,IAAI,KAAK,aAAa,KAAK;AAC/D,cAAI,iBAAiB,SAAQ,eAAe;AAG1C,6BAAiB;AACjB,2BAAe;AAAA,UACjB,OAAO;AACL,gBAAI;AACJ,gBAAI,YAAY,OAAO,IAAI,GAAG;AAC5B,sBAAQ,KAAK,SAAS,eAAe,KAAK,IAAI,OAAM,WAAW,CAAC;AAChE,uBAAS,MAAM;AAAA,YACjB,OAAO;AACL,sBAAQ,KAAK,MAAM,eAAe,KAAK,IAAI,OAAM,WAAW,CAAC;AAC7D,uBAAS,MAAM;AAAA,YACjB;AACA,2BAAe;AACf,sBAAU,KAAK,KAAK;AACpB,4BAAgB;AAAA,UAClB;AAAA,QACF;AAEA,cAAM,OAAO,IAAI,MAAK,CAAC,GAAG,EAAE,MAAM,OAAO,IAAI,EAAE,YAAY,EAAE,CAAC;AAC9D,aAAK,QAAQ;AACb,aAAK,SAAS;AAEd,eAAO;AAAA,MACT;AAAA,MAEA,KAAK,OAAO,eAAgB;AAC1B,eAAO;AAAA,MACT;AAAA,MAEA,QAAQ,OAAO,aAAc,QAAQ;AACnC,eACE,UACA,OAAO,WAAW,YAClB,OAAO,OAAO,gBAAgB,cAE5B,QAAO,OAAO,WAAW,cACzB,OAAO,OAAO,gBAAgB,eAEhC,gBAAgB,KAAK,OAAO,OAAO,YAAY;AAAA,MAEnD;AAAA,IACF;AAEA,WAAO,iBAAiB,MAAM,WAAW;AAAA,MACvC,MAAM,EAAE,YAAY,KAAK;AAAA,MACzB,MAAM,EAAE,YAAY,KAAK;AAAA,MACzB,OAAO,EAAE,YAAY,KAAK;AAAA,IAC5B,CAAC;AAGM,IAAM,QAAO;AACpB,IAAO,qBAAQ;AAAA;AAAA;;;ACzPf,IAEM,OA6CO,OACN;AAhDP;AAAA;AAAA;AAEA,IAAM,QAAQ,MAAM,aAAa,mBAAK;AAAA,MACpC,gBAAgB;AAAA,MAChB,QAAQ;AAAA,MAOR,YAAa,UAAU,UAAU,UAAU,CAAC,GAAG;AAC7C,YAAI,UAAU,SAAS,GAAG;AACxB,gBAAM,IAAI,UAAU,8DAA8D,UAAU,iBAAiB;AAAA,QAC/G;AACA,cAAM,UAAU,OAAO;AAEvB,YAAI,YAAY;AAAM,oBAAU,CAAC;AAGjC,cAAM,eAAe,QAAQ,iBAAiB,SAAY,KAAK,IAAI,IAAI,OAAO,QAAQ,YAAY;AAClG,YAAI,CAAC,OAAO,MAAM,YAAY,GAAG;AAC/B,eAAK,gBAAgB;AAAA,QACvB;AAEA,aAAK,QAAQ,OAAO,QAAQ;AAAA,MAC9B;AAAA,MAEA,IAAI,OAAQ;AACV,eAAO,KAAK;AAAA,MACd;AAAA,MAEA,IAAI,eAAgB;AAClB,eAAO,KAAK;AAAA,MACd;AAAA,MAEA,KAAK,OAAO,eAAgB;AAC1B,eAAO;AAAA,MACT;AAAA,MAEA,QAAQ,OAAO,aAAc,QAAQ;AACnC,eAAO,CAAC,CAAC,UAAU,kBAAkB,sBACnC,WAAW,KAAK,OAAO,OAAO,YAAY;AAAA,MAC9C;AAAA,IACF;AAGO,IAAM,QAAO;AACpB,IAAO,eAAQ;AAAA;AAAA;;;ACfR,wBAAyB,IAAE,IAAE,oBAAE;AACtC,MAAI,IAAE,GAAG,EAAE,IAAI,EAAE,IAAI,QAAQ,OAAO,EAAE,EAAE,MAAM,GAAG,EAAE,SAAS,IAAI,GAAG,GAAE,IAAE,CAAC,GAAE,IAAE,KAAK;AAAA;AACjF,KAAE,QAAQ,CAAC,GAAE,MAAI,OAAO,KAAG,WAC1B,EAAE,KAAK,IAAE,EAAE,CAAC,IAAE;AAAA;AAAA,EAAY,EAAE,QAAQ,uBAAuB,MAAM;AAAA,CAAO,IACxE,EAAE,KAAK,IAAE,EAAE,CAAC,IAAE,gBAAgB,EAAE,EAAE,MAAM,CAAC;AAAA,gBAAuB,EAAE,QAAM;AAAA;AAAA,GAAsC,GAAG,MAAM,CAAC;AACzH,IAAE,KAAK,KAAK,KAAK;AACjB,SAAO,IAAI,EAAE,GAAE,EAAC,MAAK,mCAAiC,EAAC,CAAC;AAAC;AAvCzD,IAKiB,GAAW,GAAc,GAC1C,GACA,GACA,GACA,GACA,GAKa;AAfb;AAAA;AAEA;AACA;AAHA,AAKA,IAAI,GALJ,AAKK,aAAY,GALjB,AAKmB,UAAS,GAL5B,AAK8B,aAAY,MAAG;AAA7C,IACA,IAAE,KAAK;AADP,IAEA,IAAE,uEAAuE,MAAM,GAAG;AAFlF,IAGA,IAAE,CAAC,GAAE,GAAE,MAAK,MAAG,IAAG,gBAAgB,KAAK,KAAK,EAAE,EAAE,IAAE,CAAE,KAAE,MAAI,SAAO,IAAE,KAAG,EAAE,MAAI,SAAO,EAAE,OAAK,QAAO,IAAG,EAAE,SAAO,KAAG,EAAE,MAAI,SAAO,IAAI,aAAE,CAAC,CAAC,GAAE,GAAE,CAAC,IAAE,CAAC,IAAE,CAAC,GAAE,IAAE,EAAE;AAHtJ,IAIA,IAAE,CAAC,GAAE,OAAK,MAAE,IAAE,EAAE,QAAQ,aAAY,MAAM,GAAG,QAAQ,OAAM,KAAK,EAAE,QAAQ,OAAM,KAAK,EAAE,QAAQ,MAAK,KAAK;AAJzG,IAKA,IAAE,CAAC,GAAG,GAAG,OAAI;AAAC,UAAG,EAAE,SAAO,IAAE;AAAC,cAAM,IAAI,UAAU,sBAAsB,qBAAqB,mCAAkC,EAAE,iBAAiB;AAAA,MAAC;AAAA,IAAC;AAK5I,IAAM,WAAW,MAAM,UAAS;AAAA,MACvC,KAAG,CAAC;AAAA,MACJ,eAAe,GAAE;AAAC,YAAG,EAAE;AAAO,gBAAM,IAAI,UAAU,+EAA+E;AAAA,MAAC;AAAA,MAClI,KAAK,KAAK;AAAC,eAAO;AAAA,MAAU;AAAA,MAC5B,CAAC,KAAI;AAAC,eAAO,KAAK,QAAQ;AAAA,MAAC;AAAA,MAC3B,QAAQ,GAAG,GAAG;AAAC,eAAO,KAAG,OAAO,MAAI,YAAU,EAAE,OAAK,cAAY,CAAC,EAAE,KAAK,QAAG,OAAO,EAAE,OAAI,UAAU;AAAA,MAAC;AAAA,MACpG,UAAU,GAAE;AAAC,UAAE,UAAS,WAAU,CAAC;AAAE,aAAK,GAAG,KAAK,EAAE,GAAG,CAAC,CAAC;AAAA,MAAC;AAAA,MAC1D,OAAO,GAAE;AAAC,UAAE,UAAS,WAAU,CAAC;AAAE,aAAG;AAAG,aAAK,KAAG,KAAK,GAAG,OAAO,CAAC,CAAC,OAAK,MAAI,CAAC;AAAA,MAAC;AAAA,MAC5E,IAAI,GAAE;AAAC,UAAE,OAAM,WAAU,CAAC;AAAE,aAAG;AAAG,iBAAQ,IAAE,KAAK,IAAG,IAAE,EAAE,QAAO,IAAE,GAAE,IAAE,GAAE;AAAI,cAAG,EAAE,GAAG,OAAK;AAAE,mBAAO,EAAE,GAAG;AAAG,eAAO;AAAA,MAAI;AAAA,MACpH,OAAO,GAAE,GAAE;AAAC,UAAE,UAAS,WAAU,CAAC;AAAE,YAAE,CAAC;AAAE,aAAG;AAAG,aAAK,GAAG,QAAQ,OAAG,EAAE,OAAK,KAAG,EAAE,KAAK,EAAE,EAAE,CAAC;AAAE,eAAO;AAAA,MAAC;AAAA,MAClG,IAAI,GAAE;AAAC,UAAE,OAAM,WAAU,CAAC;AAAE,aAAG;AAAG,eAAO,KAAK,GAAG,KAAK,OAAG,EAAE,OAAK,CAAC;AAAA,MAAC;AAAA,MAClE,QAAQ,GAAE,GAAE;AAAC,UAAE,WAAU,WAAU,CAAC;AAAE,iBAAQ,CAAC,GAAE,MAAK;AAAK,YAAE,KAAK,GAAE,GAAE,GAAE,IAAI;AAAA,MAAC;AAAA,MAC7E,OAAO,GAAE;AAAC,UAAE,OAAM,WAAU,CAAC;AAAE,YAAI,IAAE,CAAC,GAAE,IAAE;AAAG,YAAE,EAAE,GAAG,CAAC;AAAE,aAAK,GAAG,QAAQ,OAAG;AAAC,YAAE,OAAK,EAAE,KAAG,KAAI,KAAE,CAAC,EAAE,KAAK,CAAC,KAAG,EAAE,KAAK,CAAC;AAAA,QAAC,CAAC;AAAE,aAAG,EAAE,KAAK,CAAC;AAAE,aAAK,KAAG;AAAA,MAAC;AAAA,MAC3I,CAAC,UAAS;AAAC,eAAM,KAAK;AAAA,MAAE;AAAA,MACxB,CAAC,OAAM;AAAC,iBAAO,CAAC,MAAK;AAAK,gBAAM;AAAA,MAAC;AAAA,MACjC,CAAC,SAAQ;AAAC,iBAAO,CAAC,EAAC,MAAK;AAAK,gBAAM;AAAA,MAAC;AAAA,IAAC;AAAA;AAAA;;;AC9BrC,IAAa;AAAb;AAAA;AAAO,IAAM,iBAAN,cAA6B,MAAM;AAAA,MACzC,YAAY,SAAS,MAAM;AAC1B,cAAM,OAAO;AAEb,cAAM,kBAAkB,MAAM,KAAK,WAAW;AAE9C,aAAK,OAAO;AAAA,MACb;AAAA,MAEA,IAAI,OAAO;AACV,eAAO,KAAK,YAAY;AAAA,MACzB;AAAA,MAEA,KAAK,OAAO,eAAe;AAC1B,eAAO,KAAK,YAAY;AAAA,MACzB;AAAA,IACD;AAAA;AAAA;;;AChBA,IAUa;AAVb;AAAA;AACA;AASO,IAAM,aAAN,cAAyB,eAAe;AAAA,MAM9C,YAAY,SAAS,MAAM,aAAa;AACvC,cAAM,SAAS,IAAI;AAEnB,YAAI,aAAa;AAEhB,eAAK,OAAO,KAAK,QAAQ,YAAY;AACrC,eAAK,iBAAiB,YAAY;AAAA,QACnC;AAAA,MACD;AAAA,IACD;AAAA;AAAA;;;ACzBA,IAMM,MAQO,uBAmBA,QAiBA,eAiBA,qBAcA;AAjFb;AAAA;AAMA,IAAM,OAAO,OAAO;AAQb,IAAM,wBAAwB,YAAU;AAC9C,aACC,OAAO,WAAW,YAClB,OAAO,OAAO,WAAW,cACzB,OAAO,OAAO,WAAW,cACzB,OAAO,OAAO,QAAQ,cACtB,OAAO,OAAO,WAAW,cACzB,OAAO,OAAO,QAAQ,cACtB,OAAO,OAAO,QAAQ,cACtB,OAAO,OAAO,SAAS,cACvB,OAAO,UAAU;AAAA,IAEnB;AAOO,IAAM,SAAS,YAAU;AAC/B,aACC,UACA,OAAO,WAAW,YAClB,OAAO,OAAO,gBAAgB,cAC9B,OAAO,OAAO,SAAS,YACvB,OAAO,OAAO,WAAW,cACzB,OAAO,OAAO,gBAAgB,cAC9B,gBAAgB,KAAK,OAAO,KAAK;AAAA,IAEnC;AAOO,IAAM,gBAAgB,YAAU;AACtC,aACC,OAAO,WAAW,YACjB,QAAO,UAAU,iBACjB,OAAO,UAAU;AAAA,IAGpB;AAUO,IAAM,sBAAsB,CAAC,aAAa,aAAa;AAC7D,YAAM,OAAO,IAAI,IAAI,QAAQ,EAAE;AAC/B,YAAM,OAAO,IAAI,IAAI,WAAW,EAAE;AAElC,aAAO,SAAS,QAAQ,KAAK,SAAS,IAAI,MAAM;AAAA,IACjD;AASO,IAAM,iBAAiB,CAAC,aAAa,aAAa;AACxD,YAAM,OAAO,IAAI,IAAI,QAAQ,EAAE;AAC/B,YAAM,OAAO,IAAI,IAAI,WAAW,EAAE;AAElC,aAAO,SAAS;AAAA,IACjB;AAAA;AAAA;;;ACtFA;AAAA;AAEA,QAAI,CAAC,WAAW,cAAc;AAC5B,UAAI;AACF,cAAM,EAAE,mBAAmB,QAAQ,mBACnC,OAAO,IAAI,eAAe,EAAE,OAC5B,KAAK,IAAI,YAAY;AACrB,aAAK,YAAY,IAAI,CAAC,IAAI,EAAE,CAAC;AAAA,MAC/B,SAAS,KAAP;AACA,YAAI,YAAY,SAAS,kBACvB,YAAW,eAAe,IAAI;AAAA,MAElC;AAAA,IACF;AAEA,YAAO,UAAU,WAAW;AAAA;AAAA;;;ACf5B,oBACA,kBACA,0BAKQ,MAMF,cAOA,UAOA,UAMA,cAGA,UAQA,UAcA;AA1DN;AAAA;AAAA,qBAA2D;AAC3D,uBAAyB;AACzB,+BAAyB;AAEzB;AACA;AAEA,IAAM,GAPN,AAOQ,SAAS;AAMjB,IAAM,eAAe,CAAC,MAAM,SAAS,SAAS,6BAAS,IAAI,GAAG,MAAM,IAAI;AAOxE,IAAM,WAAW,CAAC,MAAM,SAAS,KAAK,IAAI,EAAE,KAAK,WAAQ,SAAS,OAAM,MAAM,IAAI,CAAC;AAOnF,IAAM,WAAW,CAAC,MAAM,SAAS,KAAK,IAAI,EAAE,KAAK,WAAQ,SAAS,OAAM,MAAM,IAAI,CAAC;AAMnF,IAAM,eAAe,CAAC,MAAM,SAAS,SAAS,6BAAS,IAAI,GAAG,MAAM,IAAI;AAGxE,IAAM,WAAW,CAAC,OAAM,MAAM,OAAO,OAAO,IAAI,mBAAK,CAAC,IAAI,aAAa;AAAA,MACrE;AAAA,MACA,MAAM,MAAK;AAAA,MACX,cAAc,MAAK;AAAA,MACnB,OAAO;AAAA,IACT,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC;AAGb,IAAM,WAAW,CAAC,OAAM,MAAM,OAAO,OAAO,IAAI,aAAK,CAAC,IAAI,aAAa;AAAA,MACrE;AAAA,MACA,MAAM,MAAK;AAAA,MACX,cAAc,MAAK;AAAA,MACnB,OAAO;AAAA,IACT,CAAC,CAAC,GAAG,+BAAS,IAAI,GAAG,EAAE,MAAM,cAAc,MAAK,QAAQ,CAAC;AASzD,IAAM,eAAN,MAAmB;AAAA,MACjB;AAAA,MACA;AAAA,MAEA,YAAa,SAAS;AACpB,aAAK,QAAQ,QAAQ;AACrB,aAAK,SAAS,QAAQ;AACtB,aAAK,OAAO,QAAQ;AACpB,aAAK,eAAe,QAAQ;AAAA,MAC9B;AAAA,MAMA,MAAO,OAAO,KAAK;AACjB,eAAO,IAAI,aAAa;AAAA,UACtB,MAAM,KAAK;AAAA,UACX,cAAc,KAAK;AAAA,UACnB,MAAM,MAAM;AAAA,UACZ,OAAO,KAAK,SAAS;AAAA,QACvB,CAAC;AAAA,MACH;AAAA,MAEA,OAAQ,SAAU;AAChB,cAAM,EAAE,YAAY,MAAM,KAAK,KAAK,KAAK;AACzC,YAAI,UAAU,KAAK,cAAc;AAC/B,gBAAM,IAAI,iCAAa,2IAA2I,kBAAkB;AAAA,QACtL;AACA,eAAQ,qCAAiB,KAAK,OAAO;AAAA,UACnC,OAAO,KAAK;AAAA,UACZ,KAAK,KAAK,SAAS,KAAK,OAAO;AAAA,QACjC,CAAC;AAAA,MACH;AAAA,MAEA,KAAK,OAAO,eAAgB;AAC1B,eAAO;AAAA,MACT;AAAA,IACF;AAAA;AAAA;;;AChGA;AAAA;AAAA;AAAA;AA+TA,mBAAmB,aAAa;AAE/B,QAAM,KAAI,YAAY,MAAM,4DAA4D;AACxF,MAAI,CAAC,IAAG;AACP;AAAA,EACD;AAEA,QAAM,QAAQ,GAAE,MAAM,GAAE,MAAM;AAC9B,MAAI,WAAW,MAAM,MAAM,MAAM,YAAY,IAAI,IAAI,CAAC;AACtD,aAAW,SAAS,QAAQ,QAAQ,GAAG;AACvC,aAAW,SAAS,QAAQ,eAAe,CAAC,IAAG,SAAS;AACvD,WAAO,OAAO,aAAa,IAAI;AAAA,EAChC,CAAC;AACD,SAAO;AACR;AAEA,0BAAiC,OAAM,IAAI;AAC1C,MAAI,CAAC,aAAa,KAAK,EAAE,GAAG;AAC3B,UAAM,IAAI,UAAU,iBAAiB;AAAA,EACtC;AAEA,QAAM,KAAI,GAAG,MAAM,iCAAiC;AAEpD,MAAI,CAAC,IAAG;AACP,UAAM,IAAI,UAAU,sDAAsD;AAAA,EAC3E;AAEA,QAAM,SAAS,IAAI,gBAAgB,GAAE,MAAM,GAAE,EAAE;AAE/C,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,QAAM,cAAc,CAAC;AACrB,QAAM,WAAW,IAAI,SAAS;AAE9B,QAAM,aAAa,UAAQ;AAC1B,kBAAc,QAAQ,OAAO,MAAM,EAAC,QAAQ,KAAI,CAAC;AAAA,EAClD;AAEA,QAAM,eAAe,UAAQ;AAC5B,gBAAY,KAAK,IAAI;AAAA,EACtB;AAEA,QAAM,uBAAuB,MAAM;AAClC,UAAM,OAAO,IAAI,aAAK,aAAa,UAAU,EAAC,MAAM,YAAW,CAAC;AAChE,aAAS,OAAO,WAAW,IAAI;AAAA,EAChC;AAEA,QAAM,wBAAwB,MAAM;AACnC,aAAS,OAAO,WAAW,UAAU;AAAA,EACtC;AAEA,QAAM,UAAU,IAAI,YAAY,OAAO;AACvC,UAAQ,OAAO;AAEf,SAAO,cAAc,WAAY;AAChC,WAAO,aAAa;AACpB,WAAO,YAAY;AAEnB,kBAAc;AACd,kBAAc;AACd,iBAAa;AACb,gBAAY;AACZ,kBAAc;AACd,eAAW;AACX,gBAAY,SAAS;AAAA,EACtB;AAEA,SAAO,gBAAgB,SAAU,MAAM;AACtC,mBAAe,QAAQ,OAAO,MAAM,EAAC,QAAQ,KAAI,CAAC;AAAA,EACnD;AAEA,SAAO,gBAAgB,SAAU,MAAM;AACtC,mBAAe,QAAQ,OAAO,MAAM,EAAC,QAAQ,KAAI,CAAC;AAAA,EACnD;AAEA,SAAO,cAAc,WAAY;AAChC,mBAAe,QAAQ,OAAO;AAC9B,kBAAc,YAAY,YAAY;AAEtC,QAAI,gBAAgB,uBAAuB;AAE1C,YAAM,KAAI,YAAY,MAAM,mDAAmD;AAE/E,UAAI,IAAG;AACN,oBAAY,GAAE,MAAM,GAAE,MAAM;AAAA,MAC7B;AAEA,iBAAW,UAAU,WAAW;AAEhC,UAAI,UAAU;AACb,eAAO,aAAa;AACpB,eAAO,YAAY;AAAA,MACpB;AAAA,IACD,WAAW,gBAAgB,gBAAgB;AAC1C,oBAAc;AAAA,IACf;AAEA,kBAAc;AACd,kBAAc;AAAA,EACf;AAEA,mBAAiB,SAAS,OAAM;AAC/B,WAAO,MAAM,KAAK;AAAA,EACnB;AAEA,SAAO,IAAI;AAEX,SAAO;AACR;AA/aA,IAGI,GACE,GAaF,IACE,GAKA,IACA,IACA,OACA,QACA,OACA,GACA,GAEA,OAEA,MAEA;AAnCN;AAAA;AAAA;AACA;AAEA,IAAI,IAAI;AACR,IAAM,IAAI;AAAA,MACT,gBAAgB;AAAA,MAChB,oBAAoB;AAAA,MACpB,cAAc;AAAA,MACd,oBAAoB;AAAA,MACpB,cAAc;AAAA,MACd,0BAA0B;AAAA,MAC1B,qBAAqB;AAAA,MACrB,iBAAiB;AAAA,MACjB,WAAW;AAAA,MACX,KAAK;AAAA,IACN;AAEA,IAAI,KAAI;AACR,IAAM,IAAI;AAAA,MACT,eAAe;AAAA,MACf,eAAe,MAAK;AAAA,IACrB;AAEA,IAAM,KAAK;AACX,IAAM,KAAK;AACX,IAAM,QAAQ;AACd,IAAM,SAAS;AACf,IAAM,QAAQ;AACd,IAAM,IAAI;AACV,IAAM,IAAI;AAEV,IAAM,QAAQ,OAAK,IAAI;AAEvB,IAAM,OAAO,MAAM;AAAA,IAAC;AAEpB,IAAM,kBAAN,MAAsB;AAAA,MAIrB,YAAY,UAAU;AACrB,aAAK,QAAQ;AACb,aAAK,QAAQ;AAEb,aAAK,cAAc;AACnB,aAAK,gBAAgB;AACrB,aAAK,eAAe;AACpB,aAAK,gBAAgB;AACrB,aAAK,cAAc;AACnB,aAAK,aAAa;AAClB,aAAK,YAAY;AAEjB,aAAK,gBAAgB,CAAC;AAEtB,mBAAW,WAAW;AACtB,cAAM,OAAO,IAAI,WAAW,SAAS,MAAM;AAC3C,iBAAS,KAAI,GAAG,KAAI,SAAS,QAAQ,MAAK;AACzC,eAAK,MAAK,SAAS,WAAW,EAAC;AAC/B,eAAK,cAAc,KAAK,OAAM;AAAA,QAC/B;AAEA,aAAK,WAAW;AAChB,aAAK,aAAa,IAAI,WAAW,KAAK,SAAS,SAAS,CAAC;AACzD,aAAK,QAAQ,EAAE;AAAA,MAChB;AAAA,MAKA,MAAM,MAAM;AACX,YAAI,KAAI;AACR,cAAM,UAAU,KAAK;AACrB,YAAI,gBAAgB,KAAK;AACzB,YAAI,EAAC,YAAY,UAAU,eAAe,OAAO,eAAO,UAAS;AACjE,cAAM,iBAAiB,KAAK,SAAS;AACrC,cAAM,cAAc,iBAAiB;AACrC,cAAM,eAAe,KAAK;AAC1B,YAAI;AACJ,YAAI;AAEJ,cAAM,OAAO,WAAQ;AACpB,eAAK,QAAO,UAAU;AAAA,QACvB;AAEA,cAAM,QAAQ,WAAQ;AACrB,iBAAO,KAAK,QAAO;AAAA,QACpB;AAEA,cAAM,WAAW,CAAC,gBAAgB,OAAO,KAAK,SAAS;AACtD,cAAI,UAAU,UAAa,UAAU,KAAK;AACzC,iBAAK,gBAAgB,QAAQ,KAAK,SAAS,OAAO,GAAG,CAAC;AAAA,UACvD;AAAA,QACD;AAEA,cAAM,eAAe,CAAC,OAAM,WAAU;AACrC,gBAAM,aAAa,QAAO;AAC1B,cAAI,CAAE,eAAc,OAAO;AAC1B;AAAA,UACD;AAEA,cAAI,QAAO;AACV,qBAAS,OAAM,KAAK,aAAa,IAAG,IAAI;AACxC,mBAAO,KAAK;AAAA,UACb,OAAO;AACN,qBAAS,OAAM,KAAK,aAAa,KAAK,QAAQ,IAAI;AAClD,iBAAK,cAAc;AAAA,UACpB;AAAA,QACD;AAEA,aAAK,KAAI,GAAG,KAAI,SAAS,MAAK;AAC7B,cAAI,KAAK;AAET,kBAAQ;AAAA,iBACF,EAAE;AACN,kBAAI,UAAU,SAAS,SAAS,GAAG;AAClC,oBAAI,MAAM,QAAQ;AACjB,2BAAS,EAAE;AAAA,gBACZ,WAAW,MAAM,IAAI;AACpB;AAAA,gBACD;AAEA;AACA;AAAA,cACD,WAAW,QAAQ,MAAM,SAAS,SAAS,GAAG;AAC7C,oBAAI,QAAQ,EAAE,iBAAiB,MAAM,QAAQ;AAC5C,2BAAQ,EAAE;AACV,0BAAQ;AAAA,gBACT,WAAW,CAAE,SAAQ,EAAE,kBAAkB,MAAM,IAAI;AAClD,0BAAQ;AACR,2BAAS,aAAa;AACtB,2BAAQ,EAAE;AAAA,gBACX,OAAO;AACN;AAAA,gBACD;AAEA;AAAA,cACD;AAEA,kBAAI,MAAM,SAAS,QAAQ,IAAI;AAC9B,wBAAQ;AAAA,cACT;AAEA,kBAAI,MAAM,SAAS,QAAQ,IAAI;AAC9B;AAAA,cACD;AAEA;AAAA,iBACI,EAAE;AACN,uBAAQ,EAAE;AACV,mBAAK,eAAe;AACpB,sBAAQ;AAAA,iBAEJ,EAAE;AACN,kBAAI,MAAM,IAAI;AACb,sBAAM,eAAe;AACrB,yBAAQ,EAAE;AACV;AAAA,cACD;AAEA;AACA,kBAAI,MAAM,QAAQ;AACjB;AAAA,cACD;AAEA,kBAAI,MAAM,OAAO;AAChB,oBAAI,UAAU,GAAG;AAEhB;AAAA,gBACD;AAEA,6BAAa,iBAAiB,IAAI;AAClC,yBAAQ,EAAE;AACV;AAAA,cACD;AAEA,mBAAK,MAAM,CAAC;AACZ,kBAAI,KAAK,KAAK,KAAK,GAAG;AACrB;AAAA,cACD;AAEA;AAAA,iBACI,EAAE;AACN,kBAAI,MAAM,OAAO;AAChB;AAAA,cACD;AAEA,mBAAK,eAAe;AACpB,uBAAQ,EAAE;AAAA,iBAEN,EAAE;AACN,kBAAI,MAAM,IAAI;AACb,6BAAa,iBAAiB,IAAI;AAClC,yBAAS,aAAa;AACtB,yBAAQ,EAAE;AAAA,cACX;AAEA;AAAA,iBACI,EAAE;AACN,kBAAI,MAAM,IAAI;AACb;AAAA,cACD;AAEA,uBAAQ,EAAE;AACV;AAAA,iBACI,EAAE;AACN,kBAAI,MAAM,IAAI;AACb;AAAA,cACD;AAEA,uBAAS,cAAc;AACvB,uBAAQ,EAAE;AACV;AAAA,iBACI,EAAE;AACN,uBAAQ,EAAE;AACV,mBAAK,YAAY;AAAA,iBAEb,EAAE;AACN,8BAAgB;AAEhB,kBAAI,UAAU,GAAG;AAEhB,sBAAK;AACL,uBAAO,KAAI,gBAAgB,CAAE,MAAK,OAAM,gBAAgB;AACvD,wBAAK;AAAA,gBACN;AAEA,sBAAK;AACL,oBAAI,KAAK;AAAA,cACV;AAEA,kBAAI,QAAQ,SAAS,QAAQ;AAC5B,oBAAI,SAAS,WAAW,GAAG;AAC1B,sBAAI,UAAU,GAAG;AAChB,iCAAa,cAAc,IAAI;AAAA,kBAChC;AAEA;AAAA,gBACD,OAAO;AACN,0BAAQ;AAAA,gBACT;AAAA,cACD,WAAW,UAAU,SAAS,QAAQ;AACrC;AACA,oBAAI,MAAM,IAAI;AAEb,2BAAS,EAAE;AAAA,gBACZ,WAAW,MAAM,QAAQ;AAExB,2BAAS,EAAE;AAAA,gBACZ,OAAO;AACN,0BAAQ;AAAA,gBACT;AAAA,cACD,WAAW,QAAQ,MAAM,SAAS,QAAQ;AACzC,oBAAI,QAAQ,EAAE,eAAe;AAC5B,0BAAQ;AACR,sBAAI,MAAM,IAAI;AAEb,6BAAS,CAAC,EAAE;AACZ,6BAAS,WAAW;AACpB,6BAAS,aAAa;AACtB,6BAAQ,EAAE;AACV;AAAA,kBACD;AAAA,gBACD,WAAW,QAAQ,EAAE,eAAe;AACnC,sBAAI,MAAM,QAAQ;AACjB,6BAAS,WAAW;AACpB,6BAAQ,EAAE;AACV,4BAAQ;AAAA,kBACT,OAAO;AACN,4BAAQ;AAAA,kBACT;AAAA,gBACD,OAAO;AACN,0BAAQ;AAAA,gBACT;AAAA,cACD;AAEA,kBAAI,QAAQ,GAAG;AAGd,2BAAW,QAAQ,KAAK;AAAA,cACzB,WAAW,gBAAgB,GAAG;AAG7B,sBAAM,cAAc,IAAI,WAAW,WAAW,QAAQ,WAAW,YAAY,WAAW,UAAU;AAClG,yBAAS,cAAc,GAAG,eAAe,WAAW;AACpD,gCAAgB;AAChB,qBAAK,YAAY;AAIjB;AAAA,cACD;AAEA;AAAA,iBACI,EAAE;AACN;AAAA;AAEA,oBAAM,IAAI,MAAM,6BAA6B,QAAO;AAAA;AAAA,QAEvD;AAEA,qBAAa,eAAe;AAC5B,qBAAa,eAAe;AAC5B,qBAAa,YAAY;AAGzB,aAAK,QAAQ;AACb,aAAK,QAAQ;AACb,aAAK,QAAQ;AAAA,MACd;AAAA,MAEA,MAAM;AACL,YAAK,KAAK,UAAU,EAAE,sBAAsB,KAAK,UAAU,KACzD,KAAK,UAAU,EAAE,aAAa,KAAK,UAAU,KAAK,SAAS,QAAS;AACrE,eAAK,UAAU;AAAA,QAChB,WAAW,KAAK,UAAU,EAAE,KAAK;AAChC,gBAAM,IAAI,MAAM,kDAAkD;AAAA,QACnE;AAAA,MACD;AAAA,IACD;AAAA;AAAA;;;AC5HA,2BAA2B,MAAM;AAChC,MAAI,KAAK,WAAW,WAAW;AAC9B,UAAM,IAAI,UAAU,0BAA0B,KAAK,KAAK;AAAA,EACzD;AAEA,OAAK,WAAW,YAAY;AAE5B,MAAI,KAAK,WAAW,OAAO;AAC1B,UAAM,KAAK,WAAW;AAAA,EACvB;AAEA,QAAM,EAAC,SAAQ;AAGf,MAAI,SAAS,MAAM;AAClB,WAAO,0BAAO,MAAM,CAAC;AAAA,EACtB;AAGA,MAAI,CAAE,iBAAgB,6BAAS;AAC9B,WAAO,0BAAO,MAAM,CAAC;AAAA,EACtB;AAIA,QAAM,QAAQ,CAAC;AACf,MAAI,aAAa;AAEjB,MAAI;AACH,qBAAiB,SAAS,MAAM;AAC/B,UAAI,KAAK,OAAO,KAAK,aAAa,MAAM,SAAS,KAAK,MAAM;AAC3D,cAAM,QAAQ,IAAI,WAAW,mBAAmB,KAAK,mBAAmB,KAAK,QAAQ,UAAU;AAC/F,aAAK,QAAQ,KAAK;AAClB,cAAM;AAAA,MACP;AAEA,oBAAc,MAAM;AACpB,YAAM,KAAK,KAAK;AAAA,IACjB;AAAA,EACD,SAAS,OAAP;AACD,UAAM,SAAS,iBAAiB,iBAAiB,QAAQ,IAAI,WAAW,+CAA+C,KAAK,QAAQ,MAAM,WAAW,UAAU,KAAK;AACpK,UAAM;AAAA,EACP;AAEA,MAAI,KAAK,kBAAkB,QAAQ,KAAK,eAAe,UAAU,MAAM;AACtE,QAAI;AACH,UAAI,MAAM,MAAM,OAAK,OAAO,MAAM,QAAQ,GAAG;AAC5C,eAAO,0BAAO,KAAK,MAAM,KAAK,EAAE,CAAC;AAAA,MAClC;AAEA,aAAO,0BAAO,OAAO,OAAO,UAAU;AAAA,IACvC,SAAS,OAAP;AACD,YAAM,IAAI,WAAW,kDAAkD,KAAK,QAAQ,MAAM,WAAW,UAAU,KAAK;AAAA,IACrH;AAAA,EACD,OAAO;AACN,UAAM,IAAI,WAAW,4DAA4D,KAAK,KAAK;AAAA,EAC5F;AACD;AA1PA,IAOA,oBACA,kBACA,oBASM,UACA,WAWe,MAqOR,OA0BP,4BAgBO,oBAqDA,eAkCA;AApYb;AAAA;AAOA,yBAAkC;AAClC,uBAA0C;AAC1C,yBAAqB;AAErB;AACA;AAEA;AACA;AACA;AAEA,IAAM,WAAW,gCAAU,2BAAO,QAAQ;AAC1C,IAAM,YAAY,OAAO,gBAAgB;AAWzC,IAAqB,OAArB,MAA0B;AAAA,MACzB,YAAY,MAAM;AAAA,QACjB,OAAO;AAAA,UACJ,CAAC,GAAG;AACP,YAAI,WAAW;AAEf,YAAI,SAAS,MAAM;AAElB,iBAAO;AAAA,QACR,WAAW,sBAAsB,IAAI,GAAG;AAEvC,iBAAO,0BAAO,KAAK,KAAK,SAAS,CAAC;AAAA,QACnC,WAAW,OAAO,IAAI,GAAG;AAAA,QAEzB,WAAW,0BAAO,SAAS,IAAI,GAAG;AAAA,QAElC,WAAW,uBAAM,iBAAiB,IAAI,GAAG;AAExC,iBAAO,0BAAO,KAAK,IAAI;AAAA,QACxB,WAAW,YAAY,OAAO,IAAI,GAAG;AAEpC,iBAAO,0BAAO,KAAK,KAAK,QAAQ,KAAK,YAAY,KAAK,UAAU;AAAA,QACjE,WAAW,gBAAgB,4BAAQ;AAAA,QAEnC,WAAW,gBAAgB,UAAU;AAEpC,iBAAO,eAAe,IAAI;AAC1B,qBAAW,KAAK,KAAK,MAAM,GAAG,EAAE;AAAA,QACjC,OAAO;AAGN,iBAAO,0BAAO,KAAK,OAAO,IAAI,CAAC;AAAA,QAChC;AAEA,YAAI,SAAS;AAEb,YAAI,0BAAO,SAAS,IAAI,GAAG;AAC1B,mBAAS,2BAAO,SAAS,KAAK,IAAI;AAAA,QACnC,WAAW,OAAO,IAAI,GAAG;AACxB,mBAAS,2BAAO,SAAS,KAAK,KAAK,OAAO,CAAC;AAAA,QAC5C;AAEA,aAAK,aAAa;AAAA,UACjB;AAAA,UACA;AAAA,UACA;AAAA,UACA,WAAW;AAAA,UACX,OAAO;AAAA,QACR;AACA,aAAK,OAAO;AAEZ,YAAI,gBAAgB,4BAAQ;AAC3B,eAAK,GAAG,SAAS,YAAU;AAC1B,kBAAM,QAAQ,kBAAkB,iBAC/B,SACA,IAAI,WAAW,+CAA+C,KAAK,QAAQ,OAAO,WAAW,UAAU,MAAM;AAC9G,iBAAK,WAAW,QAAQ;AAAA,UACzB,CAAC;AAAA,QACF;AAAA,MACD;AAAA,MAEA,IAAI,OAAO;AACV,eAAO,KAAK,WAAW;AAAA,MACxB;AAAA,MAEA,IAAI,WAAW;AACd,eAAO,KAAK,WAAW;AAAA,MACxB;AAAA,MAOA,MAAM,cAAc;AACnB,cAAM,EAAC,QAAQ,YAAY,eAAc,MAAM,YAAY,IAAI;AAC/D,eAAO,OAAO,MAAM,YAAY,aAAa,UAAU;AAAA,MACxD;AAAA,MAEA,MAAM,WAAW;AAChB,cAAM,KAAK,KAAK,QAAQ,IAAI,cAAc;AAE1C,YAAI,GAAG,WAAW,mCAAmC,GAAG;AACvD,gBAAM,WAAW,IAAI,SAAS;AAC9B,gBAAM,aAAa,IAAI,gBAAgB,MAAM,KAAK,KAAK,CAAC;AAExD,qBAAW,CAAC,OAAM,UAAU,YAAY;AACvC,qBAAS,OAAO,OAAM,KAAK;AAAA,UAC5B;AAEA,iBAAO;AAAA,QACR;AAEA,cAAM,EAAC,4BAAc,MAAM;AAC3B,eAAO,YAAW,KAAK,MAAM,EAAE;AAAA,MAChC;AAAA,MAOA,MAAM,OAAO;AACZ,cAAM,KAAM,KAAK,WAAW,KAAK,QAAQ,IAAI,cAAc,KAAO,KAAK,WAAW,QAAQ,KAAK,WAAW,KAAK,QAAS;AACxH,cAAM,MAAM,MAAM,KAAK,YAAY;AAEnC,eAAO,IAAI,mBAAK,CAAC,GAAG,GAAG;AAAA,UACtB,MAAM;AAAA,QACP,CAAC;AAAA,MACF;AAAA,MAOA,MAAM,OAAO;AACZ,cAAM,OAAO,MAAM,KAAK,KAAK;AAC7B,eAAO,KAAK,MAAM,IAAI;AAAA,MACvB;AAAA,MAOA,MAAM,OAAO;AACZ,cAAM,SAAS,MAAM,YAAY,IAAI;AACrC,eAAO,IAAI,YAAY,EAAE,OAAO,MAAM;AAAA,MACvC;AAAA,MAOA,SAAS;AACR,eAAO,YAAY,IAAI;AAAA,MACxB;AAAA,IACD;AAEA,SAAK,UAAU,SAAS,gCAAU,KAAK,UAAU,QAAQ,sEAA0E,mBAAmB;AAGtJ,WAAO,iBAAiB,KAAK,WAAW;AAAA,MACvC,MAAM,EAAC,YAAY,KAAI;AAAA,MACvB,UAAU,EAAC,YAAY,KAAI;AAAA,MAC3B,aAAa,EAAC,YAAY,KAAI;AAAA,MAC9B,MAAM,EAAC,YAAY,KAAI;AAAA,MACvB,MAAM,EAAC,YAAY,KAAI;AAAA,MACvB,MAAM,EAAC,YAAY,KAAI;AAAA,MACvB,MAAM,EAAC,KAAK,gCAAU,MAAM;AAAA,MAAC,GAC5B,0EACA,iEAAiE,EAAC;AAAA,IACpE,CAAC;AA2EM,IAAM,QAAQ,CAAC,UAAU,kBAAkB;AACjD,UAAI;AACJ,UAAI;AACJ,UAAI,EAAC,SAAQ,SAAS;AAGtB,UAAI,SAAS,UAAU;AACtB,cAAM,IAAI,MAAM,oCAAoC;AAAA,MACrD;AAIA,UAAK,gBAAgB,8BAAY,OAAO,KAAK,gBAAgB,YAAa;AAEzE,aAAK,IAAI,+BAAY,EAAC,cAAa,CAAC;AACpC,aAAK,IAAI,+BAAY,EAAC,cAAa,CAAC;AACpC,aAAK,KAAK,EAAE;AACZ,aAAK,KAAK,EAAE;AAEZ,iBAAS,WAAW,SAAS;AAC7B,eAAO;AAAA,MACR;AAEA,aAAO;AAAA,IACR;AAEA,IAAM,6BAA6B,gCAClC,UAAQ,KAAK,YAAY,GACzB,6FACA,sDACD;AAYO,IAAM,qBAAqB,CAAC,MAAM,YAAY;AAEpD,UAAI,SAAS,MAAM;AAClB,eAAO;AAAA,MACR;AAGA,UAAI,OAAO,SAAS,UAAU;AAC7B,eAAO;AAAA,MACR;AAGA,UAAI,sBAAsB,IAAI,GAAG;AAChC,eAAO;AAAA,MACR;AAGA,UAAI,OAAO,IAAI,GAAG;AACjB,eAAO,KAAK,QAAQ;AAAA,MACrB;AAGA,UAAI,0BAAO,SAAS,IAAI,KAAK,uBAAM,iBAAiB,IAAI,KAAK,YAAY,OAAO,IAAI,GAAG;AACtF,eAAO;AAAA,MACR;AAEA,UAAI,gBAAgB,UAAU;AAC7B,eAAO,iCAAiC,QAAQ,WAAW;AAAA,MAC5D;AAGA,UAAI,QAAQ,OAAO,KAAK,gBAAgB,YAAY;AACnD,eAAO,gCAAgC,2BAA2B,IAAI;AAAA,MACvE;AAGA,UAAI,gBAAgB,4BAAQ;AAC3B,eAAO;AAAA,MACR;AAGA,aAAO;AAAA,IACR;AAWO,IAAM,gBAAgB,aAAW;AACvC,YAAM,EAAC,SAAQ,QAAQ;AAGvB,UAAI,SAAS,MAAM;AAClB,eAAO;AAAA,MACR;AAGA,UAAI,OAAO,IAAI,GAAG;AACjB,eAAO,KAAK;AAAA,MACb;AAGA,UAAI,0BAAO,SAAS,IAAI,GAAG;AAC1B,eAAO,KAAK;AAAA,MACb;AAGA,UAAI,QAAQ,OAAO,KAAK,kBAAkB,YAAY;AACrD,eAAO,KAAK,kBAAkB,KAAK,eAAe,IAAI,KAAK,cAAc,IAAI;AAAA,MAC9E;AAGA,aAAO;AAAA,IACR;AASO,IAAM,gBAAgB,OAAO,MAAM,EAAC,WAAU;AACpD,UAAI,SAAS,MAAM;AAElB,aAAK,IAAI;AAAA,MACV,OAAO;AAEN,cAAM,SAAS,MAAM,IAAI;AAAA,MAC1B;AAAA,IACD;AAAA;AAAA;;;ACxJO,wBAAwB,UAAU,CAAC,GAAG;AAC5C,SAAO,IAAI,QACV,QAEE,OAAO,CAAC,QAAQ,OAAO,OAAO,UAAU;AACxC,QAAI,QAAQ,MAAM,GAAG;AACpB,aAAO,KAAK,MAAM,MAAM,OAAO,QAAQ,CAAC,CAAC;AAAA,IAC1C;AAEA,WAAO;AAAA,EACR,GAAG,CAAC,CAAC,EACJ,OAAO,CAAC,CAAC,OAAM,WAAW;AAC1B,QAAI;AACH,yBAAmB,KAAI;AACvB,0BAAoB,OAAM,OAAO,KAAK,CAAC;AACvC,aAAO;AAAA,IACR,QAAE;AACD,aAAO;AAAA,IACR;AAAA,EACD,CAAC,CAEH;AACD;AA1QA,IAMA,mBACA,kBAGM,oBAWA,qBAsBe;AA3CrB;AAAA;AAMA,wBAAoB;AACpB,uBAAiB;AAGjB,IAAM,qBAAqB,OAAO,yBAAK,uBAAuB,aAC7D,yBAAK,qBACL,WAAQ;AACP,UAAI,CAAC,0BAA0B,KAAK,KAAI,GAAG;AAC1C,cAAM,QAAQ,IAAI,UAAU,2CAA2C,QAAO;AAC9E,eAAO,eAAe,OAAO,QAAQ,EAAC,OAAO,yBAAwB,CAAC;AACtE,cAAM;AAAA,MACP;AAAA,IACD;AAGD,IAAM,sBAAsB,OAAO,yBAAK,wBAAwB,aAC/D,yBAAK,sBACL,CAAC,OAAM,UAAU;AAChB,UAAI,kCAAkC,KAAK,KAAK,GAAG;AAClD,cAAM,QAAQ,IAAI,UAAU,yCAAyC,SAAQ;AAC7E,eAAO,eAAe,OAAO,QAAQ,EAAC,OAAO,mBAAkB,CAAC;AAChE,cAAM;AAAA,MACP;AAAA,IACD;AAcD,IAAqB,UAArB,cAAqC,gBAAgB;AAAA,MAOpD,YAAY,MAAM;AAGjB,YAAI,SAAS,CAAC;AACd,YAAI,gBAAgB,SAAS;AAC5B,gBAAM,MAAM,KAAK,IAAI;AACrB,qBAAW,CAAC,OAAM,WAAW,OAAO,QAAQ,GAAG,GAAG;AACjD,mBAAO,KAAK,GAAG,OAAO,IAAI,WAAS,CAAC,OAAM,KAAK,CAAC,CAAC;AAAA,UAClD;AAAA,QACD,WAAW,QAAQ,MAAM;AAAA,QAEzB,WAAW,OAAO,SAAS,YAAY,CAAC,wBAAM,iBAAiB,IAAI,GAAG;AACrE,gBAAM,SAAS,KAAK,OAAO;AAE3B,cAAI,UAAU,MAAM;AAEnB,mBAAO,KAAK,GAAG,OAAO,QAAQ,IAAI,CAAC;AAAA,UACpC,OAAO;AACN,gBAAI,OAAO,WAAW,YAAY;AACjC,oBAAM,IAAI,UAAU,+BAA+B;AAAA,YACpD;AAIA,qBAAS,CAAC,GAAG,IAAI,EACf,IAAI,UAAQ;AACZ,kBACC,OAAO,SAAS,YAAY,wBAAM,iBAAiB,IAAI,GACtD;AACD,sBAAM,IAAI,UAAU,6CAA6C;AAAA,cAClE;AAEA,qBAAO,CAAC,GAAG,IAAI;AAAA,YAChB,CAAC,EAAE,IAAI,UAAQ;AACd,kBAAI,KAAK,WAAW,GAAG;AACtB,sBAAM,IAAI,UAAU,6CAA6C;AAAA,cAClE;AAEA,qBAAO,CAAC,GAAG,IAAI;AAAA,YAChB,CAAC;AAAA,UACH;AAAA,QACD,OAAO;AACN,gBAAM,IAAI,UAAU,sIAAyI;AAAA,QAC9J;AAGA,iBACC,OAAO,SAAS,IACf,OAAO,IAAI,CAAC,CAAC,OAAM,WAAW;AAC7B,6BAAmB,KAAI;AACvB,8BAAoB,OAAM,OAAO,KAAK,CAAC;AACvC,iBAAO,CAAC,OAAO,KAAI,EAAE,YAAY,GAAG,OAAO,KAAK,CAAC;AAAA,QAClD,CAAC,IACD;AAEF,cAAM,MAAM;AAIZ,eAAO,IAAI,MAAM,MAAM;AAAA,UACtB,IAAI,QAAQ,GAAG,UAAU;AACxB,oBAAQ;AAAA,mBACF;AAAA,mBACA;AACJ,uBAAO,CAAC,OAAM,UAAU;AACvB,qCAAmB,KAAI;AACvB,sCAAoB,OAAM,OAAO,KAAK,CAAC;AACvC,yBAAO,gBAAgB,UAAU,GAAG,KACnC,QACA,OAAO,KAAI,EAAE,YAAY,GACzB,OAAO,KAAK,CACb;AAAA,gBACD;AAAA,mBAEI;AAAA,mBACA;AAAA,mBACA;AACJ,uBAAO,WAAQ;AACd,qCAAmB,KAAI;AACvB,yBAAO,gBAAgB,UAAU,GAAG,KACnC,QACA,OAAO,KAAI,EAAE,YAAY,CAC1B;AAAA,gBACD;AAAA,mBAEI;AACJ,uBAAO,MAAM;AACZ,yBAAO,KAAK;AACZ,yBAAO,IAAI,IAAI,gBAAgB,UAAU,KAAK,KAAK,MAAM,CAAC,EAAE,KAAK;AAAA,gBAClE;AAAA;AAGA,uBAAO,QAAQ,IAAI,QAAQ,GAAG,QAAQ;AAAA;AAAA,UAEzC;AAAA,QACD,CAAC;AAAA,MAEF;AAAA,MAEA,KAAK,OAAO,eAAe;AAC1B,eAAO,KAAK,YAAY;AAAA,MACzB;AAAA,MAEA,WAAW;AACV,eAAO,OAAO,UAAU,SAAS,KAAK,IAAI;AAAA,MAC3C;AAAA,MAEA,IAAI,OAAM;AACT,cAAM,SAAS,KAAK,OAAO,KAAI;AAC/B,YAAI,OAAO,WAAW,GAAG;AACxB,iBAAO;AAAA,QACR;AAEA,YAAI,QAAQ,OAAO,KAAK,IAAI;AAC5B,YAAI,sBAAsB,KAAK,KAAI,GAAG;AACrC,kBAAQ,MAAM,YAAY;AAAA,QAC3B;AAEA,eAAO;AAAA,MACR;AAAA,MAEA,QAAQ,UAAU,UAAU,QAAW;AACtC,mBAAW,SAAQ,KAAK,KAAK,GAAG;AAC/B,kBAAQ,MAAM,UAAU,SAAS,CAAC,KAAK,IAAI,KAAI,GAAG,OAAM,IAAI,CAAC;AAAA,QAC9D;AAAA,MACD;AAAA,MAEA,CAAE,SAAS;AACV,mBAAW,SAAQ,KAAK,KAAK,GAAG;AAC/B,gBAAM,KAAK,IAAI,KAAI;AAAA,QACpB;AAAA,MACD;AAAA,MAKA,CAAE,UAAU;AACX,mBAAW,SAAQ,KAAK,KAAK,GAAG;AAC/B,gBAAM,CAAC,OAAM,KAAK,IAAI,KAAI,CAAC;AAAA,QAC5B;AAAA,MACD;AAAA,MAEA,CAAC,OAAO,YAAY;AACnB,eAAO,KAAK,QAAQ;AAAA,MACrB;AAAA,MAOA,MAAM;AACL,eAAO,CAAC,GAAG,KAAK,KAAK,CAAC,EAAE,OAAO,CAAC,QAAQ,QAAQ;AAC/C,iBAAO,OAAO,KAAK,OAAO,GAAG;AAC7B,iBAAO;AAAA,QACR,GAAG,CAAC,CAAC;AAAA,MACN;AAAA,MAKA,CAAC,OAAO,IAAI,4BAA4B,KAAK;AAC5C,eAAO,CAAC,GAAG,KAAK,KAAK,CAAC,EAAE,OAAO,CAAC,QAAQ,QAAQ;AAC/C,gBAAM,SAAS,KAAK,OAAO,GAAG;AAG9B,cAAI,QAAQ,QAAQ;AACnB,mBAAO,OAAO,OAAO;AAAA,UACtB,OAAO;AACN,mBAAO,OAAO,OAAO,SAAS,IAAI,SAAS,OAAO;AAAA,UACnD;AAEA,iBAAO;AAAA,QACR,GAAG,CAAC,CAAC;AAAA,MACN;AAAA,IACD;AAMA,WAAO,iBACN,QAAQ,WACR,CAAC,OAAO,WAAW,WAAW,QAAQ,EAAE,OAAO,CAAC,QAAQ,aAAa;AACpE,aAAO,YAAY,EAAC,YAAY,KAAI;AACpC,aAAO;AAAA,IACR,GAAG,CAAC,CAAC,CACN;AAAA;AAAA;;;AC7OA,IAAM,gBAQO;AARb;AAAA;AAAA,IAAM,iBAAiB,oBAAI,IAAI,CAAC,KAAK,KAAK,KAAK,KAAK,GAAG,CAAC;AAQjD,IAAM,aAAa,UAAQ;AACjC,aAAO,eAAe,IAAI,IAAI;AAAA,IAC/B;AAAA;AAAA;;;ACVA,IAUM,YAWe;AArBrB;AAAA;AAMA;AACA;AACA;AAEA,IAAM,aAAY,OAAO,oBAAoB;AAW7C,IAAqB,WAArB,cAAsC,KAAK;AAAA,MAC1C,YAAY,OAAO,MAAM,UAAU,CAAC,GAAG;AACtC,cAAM,MAAM,OAAO;AAGnB,cAAM,SAAS,QAAQ,UAAU,OAAO,QAAQ,SAAS;AAEzD,cAAM,UAAU,IAAI,QAAQ,QAAQ,OAAO;AAE3C,YAAI,SAAS,QAAQ,CAAC,QAAQ,IAAI,cAAc,GAAG;AAClD,gBAAM,cAAc,mBAAmB,MAAM,IAAI;AACjD,cAAI,aAAa;AAChB,oBAAQ,OAAO,gBAAgB,WAAW;AAAA,UAC3C;AAAA,QACD;AAEA,aAAK,cAAa;AAAA,UACjB,MAAM;AAAA,UACN,KAAK,QAAQ;AAAA,UACb;AAAA,UACA,YAAY,QAAQ,cAAc;AAAA,UAClC;AAAA,UACA,SAAS,QAAQ;AAAA,UACjB,eAAe,QAAQ;AAAA,QACxB;AAAA,MACD;AAAA,MAEA,IAAI,OAAO;AACV,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAEA,IAAI,MAAM;AACT,eAAO,KAAK,YAAW,OAAO;AAAA,MAC/B;AAAA,MAEA,IAAI,SAAS;AACZ,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAKA,IAAI,KAAK;AACR,eAAO,KAAK,YAAW,UAAU,OAAO,KAAK,YAAW,SAAS;AAAA,MAClE;AAAA,MAEA,IAAI,aAAa;AAChB,eAAO,KAAK,YAAW,UAAU;AAAA,MAClC;AAAA,MAEA,IAAI,aAAa;AAChB,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAEA,IAAI,UAAU;AACb,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAEA,IAAI,gBAAgB;AACnB,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAOA,QAAQ;AACP,eAAO,IAAI,SAAS,MAAM,MAAM,KAAK,aAAa,GAAG;AAAA,UACpD,MAAM,KAAK;AAAA,UACX,KAAK,KAAK;AAAA,UACV,QAAQ,KAAK;AAAA,UACb,YAAY,KAAK;AAAA,UACjB,SAAS,KAAK;AAAA,UACd,IAAI,KAAK;AAAA,UACT,YAAY,KAAK;AAAA,UACjB,MAAM,KAAK;AAAA,UACX,eAAe,KAAK;AAAA,QACrB,CAAC;AAAA,MACF;AAAA,MAOA,OAAO,SAAS,KAAK,SAAS,KAAK;AAClC,YAAI,CAAC,WAAW,MAAM,GAAG;AACxB,gBAAM,IAAI,WAAW,iEAAiE;AAAA,QACvF;AAEA,eAAO,IAAI,SAAS,MAAM;AAAA,UACzB,SAAS;AAAA,YACR,UAAU,IAAI,IAAI,GAAG,EAAE,SAAS;AAAA,UACjC;AAAA,UACA;AAAA,QACD,CAAC;AAAA,MACF;AAAA,MAEA,OAAO,QAAQ;AACd,cAAM,WAAW,IAAI,SAAS,MAAM,EAAC,QAAQ,GAAG,YAAY,GAAE,CAAC;AAC/D,iBAAS,YAAW,OAAO;AAC3B,eAAO;AAAA,MACR;AAAA,MAEA,KAAK,OAAO,eAAe;AAC1B,eAAO;AAAA,MACR;AAAA,IACD;AAEA,WAAO,iBAAiB,SAAS,WAAW;AAAA,MAC3C,MAAM,EAAC,YAAY,KAAI;AAAA,MACvB,KAAK,EAAC,YAAY,KAAI;AAAA,MACtB,QAAQ,EAAC,YAAY,KAAI;AAAA,MACzB,IAAI,EAAC,YAAY,KAAI;AAAA,MACrB,YAAY,EAAC,YAAY,KAAI;AAAA,MAC7B,YAAY,EAAC,YAAY,KAAI;AAAA,MAC7B,SAAS,EAAC,YAAY,KAAI;AAAA,MAC1B,OAAO,EAAC,YAAY,KAAI;AAAA,IACzB,CAAC;AAAA;AAAA;;;AC5ID,IAAa;AAAb;AAAA;AAAO,IAAM,YAAY,eAAa;AACrC,UAAI,UAAU,QAAQ;AACrB,eAAO,UAAU;AAAA,MAClB;AAEA,YAAM,aAAa,UAAU,KAAK,SAAS;AAC3C,YAAM,OAAO,UAAU,QAAS,WAAU,KAAK,gBAAgB,MAAM,MAAM;AAC3E,aAAO,UAAU,KAAK,aAAa,KAAK,YAAY,MAAM,MAAM;AAAA,IACjE;AAAA;AAAA;;;ACSO,mCAAmC,KAAK,aAAa,OAAO;AAElE,MAAI,OAAO,MAAM;AAChB,WAAO;AAAA,EACR;AAEA,QAAM,IAAI,IAAI,GAAG;AAGjB,MAAI,uBAAuB,KAAK,IAAI,QAAQ,GAAG;AAC9C,WAAO;AAAA,EACR;AAGA,MAAI,WAAW;AAIf,MAAI,WAAW;AAIf,MAAI,OAAO;AAGX,MAAI,YAAY;AAGf,QAAI,WAAW;AAIf,QAAI,SAAS;AAAA,EACd;AAGA,SAAO;AACR;AA2BO,gCAAgC,gBAAgB;AACtD,MAAI,CAAC,eAAe,IAAI,cAAc,GAAG;AACxC,UAAM,IAAI,UAAU,2BAA2B,gBAAgB;AAAA,EAChE;AAEA,SAAO;AACR;AAOO,wCAAwC,KAAK;AAQnD,MAAI,gBAAgB,KAAK,IAAI,QAAQ,GAAG;AACvC,WAAO;AAAA,EACR;AAGA,QAAM,SAAS,IAAI,KAAK,QAAQ,eAAe,EAAE;AACjD,QAAM,gBAAgB,0BAAK,MAAM;AAEjC,MAAI,kBAAkB,KAAK,SAAS,KAAK,MAAM,GAAG;AACjD,WAAO;AAAA,EACR;AAEA,MAAI,kBAAkB,KAAK,mCAAmC,KAAK,MAAM,GAAG;AAC3E,WAAO;AAAA,EACR;AAKA,MAAI,IAAI,SAAS,eAAe,IAAI,KAAK,SAAS,YAAY,GAAG;AAChE,WAAO;AAAA,EACR;AAGA,MAAI,IAAI,aAAa,SAAS;AAC7B,WAAO;AAAA,EACR;AASA,SAAO;AACR;AAOO,qCAAqC,KAAK;AAEhD,MAAI,yBAAyB,KAAK,GAAG,GAAG;AACvC,WAAO;AAAA,EACR;AAGA,MAAI,IAAI,aAAa,SAAS;AAC7B,WAAO;AAAA,EACR;AAKA,MAAI,uBAAuB,KAAK,IAAI,QAAQ,GAAG;AAC9C,WAAO;AAAA,EACR;AAGA,SAAO,+BAA+B,GAAG;AAC1C;AA0BO,mCAAmC,SAAS,EAAC,qBAAqB,2BAA0B,CAAC,GAAG;AAMtG,MAAI,QAAQ,aAAa,iBAAiB,QAAQ,mBAAmB,IAAI;AACxE,WAAO;AAAA,EACR;AAGA,QAAM,SAAS,QAAQ;AAMvB,MAAI,QAAQ,aAAa,gBAAgB;AACxC,WAAO;AAAA,EACR;AAGA,QAAM,iBAAiB,QAAQ;AAG/B,MAAI,cAAc,0BAA0B,cAAc;AAI1D,MAAI,iBAAiB,0BAA0B,gBAAgB,IAAI;AAInE,MAAI,YAAY,SAAS,EAAE,SAAS,MAAM;AACzC,kBAAc;AAAA,EACf;AAMA,MAAI,qBAAqB;AACxB,kBAAc,oBAAoB,WAAW;AAAA,EAC9C;AAEA,MAAI,wBAAwB;AAC3B,qBAAiB,uBAAuB,cAAc;AAAA,EACvD;AAGA,QAAM,aAAa,IAAI,IAAI,QAAQ,GAAG;AAEtC,UAAQ;AAAA,SACF;AACJ,aAAO;AAAA,SAEH;AACJ,aAAO;AAAA,SAEH;AACJ,aAAO;AAAA,SAEH;AAGJ,UAAI,4BAA4B,WAAW,KAAK,CAAC,4BAA4B,UAAU,GAAG;AACzF,eAAO;AAAA,MACR;AAGA,aAAO,eAAe,SAAS;AAAA,SAE3B;AAGJ,UAAI,YAAY,WAAW,WAAW,QAAQ;AAC7C,eAAO;AAAA,MACR;AAIA,UAAI,4BAA4B,WAAW,KAAK,CAAC,4BAA4B,UAAU,GAAG;AACzF,eAAO;AAAA,MACR;AAGA,aAAO;AAAA,SAEH;AAGJ,UAAI,YAAY,WAAW,WAAW,QAAQ;AAC7C,eAAO;AAAA,MACR;AAGA,aAAO;AAAA,SAEH;AAGJ,UAAI,YAAY,WAAW,WAAW,QAAQ;AAC7C,eAAO;AAAA,MACR;AAGA,aAAO;AAAA,SAEH;AAGJ,UAAI,4BAA4B,WAAW,KAAK,CAAC,4BAA4B,UAAU,GAAG;AACzF,eAAO;AAAA,MACR;AAGA,aAAO;AAAA;AAGP,YAAM,IAAI,UAAU,2BAA2B,QAAQ;AAAA;AAE1D;AAOO,uCAAuC,SAAS;AAGtD,QAAM,eAAgB,SAAQ,IAAI,iBAAiB,KAAK,IAAI,MAAM,QAAQ;AAG1E,MAAI,SAAS;AAMb,aAAW,SAAS,cAAc;AACjC,QAAI,SAAS,eAAe,IAAI,KAAK,GAAG;AACvC,eAAS;AAAA,IACV;AAAA,EACD;AAGA,SAAO;AACR;AAnVA,qBA2Da,gBAeA;AA1Eb;AAAA;AAAA,sBAAmB;AA2DZ,IAAM,iBAAiB,oBAAI,IAAI;AAAA,MACrC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD,CAAC;AAKM,IAAM,0BAA0B;AAAA;AAAA;;;AC1EvC,IAQA,iBACA,mBASM,YAQA,WAOA,eAae,SAmLR;AAjOb;AAAA;AAQA,sBAAkC;AAClC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AAIA,IAAM,aAAY,OAAO,mBAAmB;AAQ5C,IAAM,YAAY,YAAU;AAC3B,aACC,OAAO,WAAW,YAClB,OAAO,OAAO,gBAAe;AAAA,IAE/B;AAEA,IAAM,gBAAgB,iCAAU,MAAM;AAAA,IAAC,GACtC,gEACA,gEAAgE;AAWjE,IAAqB,UAArB,cAAqC,KAAK;AAAA,MACzC,YAAY,OAAO,OAAO,CAAC,GAAG;AAC7B,YAAI;AAGJ,YAAI,UAAU,KAAK,GAAG;AACrB,sBAAY,IAAI,IAAI,MAAM,GAAG;AAAA,QAC9B,OAAO;AACN,sBAAY,IAAI,IAAI,KAAK;AACzB,kBAAQ,CAAC;AAAA,QACV;AAEA,YAAI,UAAU,aAAa,MAAM,UAAU,aAAa,IAAI;AAC3D,gBAAM,IAAI,UAAU,GAAG,gDAAgD;AAAA,QACxE;AAEA,YAAI,SAAS,KAAK,UAAU,MAAM,UAAU;AAC5C,YAAI,wCAAwC,KAAK,MAAM,GAAG;AACzD,mBAAS,OAAO,YAAY;AAAA,QAC7B;AAEA,YAAI,CAAC,UAAU,IAAI,KAAK,UAAU,MAAM;AACvC,wBAAc;AAAA,QACf;AAGA,YAAK,MAAK,QAAQ,QAAS,UAAU,KAAK,KAAK,MAAM,SAAS,SAC5D,YAAW,SAAS,WAAW,SAAS;AACzC,gBAAM,IAAI,UAAU,+CAA+C;AAAA,QACpE;AAEA,cAAM,YAAY,KAAK,OACtB,KAAK,OACJ,UAAU,KAAK,KAAK,MAAM,SAAS,OACnC,MAAM,KAAK,IACX;AAEF,cAAM,WAAW;AAAA,UAChB,MAAM,KAAK,QAAQ,MAAM,QAAQ;AAAA,QAClC,CAAC;AAED,cAAM,UAAU,IAAI,QAAQ,KAAK,WAAW,MAAM,WAAW,CAAC,CAAC;AAE/D,YAAI,cAAc,QAAQ,CAAC,QAAQ,IAAI,cAAc,GAAG;AACvD,gBAAM,cAAc,mBAAmB,WAAW,IAAI;AACtD,cAAI,aAAa;AAChB,oBAAQ,IAAI,gBAAgB,WAAW;AAAA,UACxC;AAAA,QACD;AAEA,YAAI,SAAS,UAAU,KAAK,IAC3B,MAAM,SACN;AACD,YAAI,YAAY,MAAM;AACrB,mBAAS,KAAK;AAAA,QACf;AAGA,YAAI,UAAU,QAAQ,CAAC,cAAc,MAAM,GAAG;AAC7C,gBAAM,IAAI,UAAU,gEAAgE;AAAA,QACrF;AAIA,YAAI,WAAW,KAAK,YAAY,OAAO,MAAM,WAAW,KAAK;AAC7D,YAAI,aAAa,IAAI;AAEpB,qBAAW;AAAA,QACZ,WAAW,UAAU;AAEpB,gBAAM,iBAAiB,IAAI,IAAI,QAAQ;AAEvC,qBAAW,wBAAwB,KAAK,cAAc,IAAI,WAAW;AAAA,QACtE,OAAO;AACN,qBAAW;AAAA,QACZ;AAEA,aAAK,cAAa;AAAA,UACjB;AAAA,UACA,UAAU,KAAK,YAAY,MAAM,YAAY;AAAA,UAC7C;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AAGA,aAAK,SAAS,KAAK,WAAW,SAAa,MAAM,WAAW,SAAY,KAAK,MAAM,SAAU,KAAK;AAClG,aAAK,WAAW,KAAK,aAAa,SAAa,MAAM,aAAa,SAAY,OAAO,MAAM,WAAY,KAAK;AAC5G,aAAK,UAAU,KAAK,WAAW,MAAM,WAAW;AAChD,aAAK,QAAQ,KAAK,SAAS,MAAM;AACjC,aAAK,gBAAgB,KAAK,iBAAiB,MAAM,iBAAiB;AAClE,aAAK,qBAAqB,KAAK,sBAAsB,MAAM,sBAAsB;AAIjF,aAAK,iBAAiB,KAAK,kBAAkB,MAAM,kBAAkB;AAAA,MACtE;AAAA,MAGA,IAAI,SAAS;AACZ,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAGA,IAAI,MAAM;AACT,eAAO,4BAAU,KAAK,YAAW,SAAS;AAAA,MAC3C;AAAA,MAGA,IAAI,UAAU;AACb,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAEA,IAAI,WAAW;AACd,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAGA,IAAI,SAAS;AACZ,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAGA,IAAI,WAAW;AACd,YAAI,KAAK,YAAW,aAAa,eAAe;AAC/C,iBAAO;AAAA,QACR;AAEA,YAAI,KAAK,YAAW,aAAa,UAAU;AAC1C,iBAAO;AAAA,QACR;AAEA,YAAI,KAAK,YAAW,UAAU;AAC7B,iBAAO,KAAK,YAAW,SAAS,SAAS;AAAA,QAC1C;AAEA,eAAO;AAAA,MACR;AAAA,MAEA,IAAI,iBAAiB;AACpB,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAEA,IAAI,eAAe,gBAAgB;AAClC,aAAK,YAAW,iBAAiB,uBAAuB,cAAc;AAAA,MACvE;AAAA,MAOA,QAAQ;AACP,eAAO,IAAI,QAAQ,IAAI;AAAA,MACxB;AAAA,MAEA,KAAK,OAAO,eAAe;AAC1B,eAAO;AAAA,MACR;AAAA,IACD;AAEA,WAAO,iBAAiB,QAAQ,WAAW;AAAA,MAC1C,QAAQ,EAAC,YAAY,KAAI;AAAA,MACzB,KAAK,EAAC,YAAY,KAAI;AAAA,MACtB,SAAS,EAAC,YAAY,KAAI;AAAA,MAC1B,UAAU,EAAC,YAAY,KAAI;AAAA,MAC3B,OAAO,EAAC,YAAY,KAAI;AAAA,MACxB,QAAQ,EAAC,YAAY,KAAI;AAAA,MACzB,UAAU,EAAC,YAAY,KAAI;AAAA,MAC3B,gBAAgB,EAAC,YAAY,KAAI;AAAA,IAClC,CAAC;AAQM,IAAM,wBAAwB,aAAW;AAC/C,YAAM,EAAC,cAAa,QAAQ;AAC5B,YAAM,UAAU,IAAI,QAAQ,QAAQ,YAAW,OAAO;AAGtD,UAAI,CAAC,QAAQ,IAAI,QAAQ,GAAG;AAC3B,gBAAQ,IAAI,UAAU,KAAK;AAAA,MAC5B;AAGA,UAAI,qBAAqB;AACzB,UAAI,QAAQ,SAAS,QAAQ,gBAAgB,KAAK,QAAQ,MAAM,GAAG;AAClE,6BAAqB;AAAA,MACtB;AAEA,UAAI,QAAQ,SAAS,MAAM;AAC1B,cAAM,aAAa,cAAc,OAAO;AAExC,YAAI,OAAO,eAAe,YAAY,CAAC,OAAO,MAAM,UAAU,GAAG;AAChE,+BAAqB,OAAO,UAAU;AAAA,QACvC;AAAA,MACD;AAEA,UAAI,oBAAoB;AACvB,gBAAQ,IAAI,kBAAkB,kBAAkB;AAAA,MACjD;AAKA,UAAI,QAAQ,mBAAmB,IAAI;AAClC,gBAAQ,iBAAiB;AAAA,MAC1B;AAKA,UAAI,QAAQ,YAAY,QAAQ,aAAa,eAAe;AAC3D,gBAAQ,YAAW,WAAW,0BAA0B,OAAO;AAAA,MAChE,OAAO;AACN,gBAAQ,YAAW,WAAW;AAAA,MAC/B;AAKA,UAAI,QAAQ,YAAW,oBAAoB,KAAK;AAC/C,gBAAQ,IAAI,WAAW,QAAQ,QAAQ;AAAA,MACxC;AAGA,UAAI,CAAC,QAAQ,IAAI,YAAY,GAAG;AAC/B,gBAAQ,IAAI,cAAc,YAAY;AAAA,MACvC;AAGA,UAAI,QAAQ,YAAY,CAAC,QAAQ,IAAI,iBAAiB,GAAG;AACxD,gBAAQ,IAAI,mBAAmB,mBAAmB;AAAA,MACnD;AAEA,UAAI,EAAC,UAAS;AACd,UAAI,OAAO,UAAU,YAAY;AAChC,gBAAQ,MAAM,SAAS;AAAA,MACxB;AAEA,UAAI,CAAC,QAAQ,IAAI,YAAY,KAAK,CAAC,OAAO;AACzC,gBAAQ,IAAI,cAAc,OAAO;AAAA,MAClC;AAKA,YAAM,SAAS,UAAU,SAAS;AAIlC,YAAM,UAAU;AAAA,QAEf,MAAM,UAAU,WAAW;AAAA,QAE3B,QAAQ,QAAQ;AAAA,QAChB,SAAS,QAAQ,OAAO,IAAI,4BAA4B,GAAG;AAAA,QAC3D,oBAAoB,QAAQ;AAAA,QAC5B;AAAA,MACD;AAEA,aAAO;AAAA,QAEN;AAAA,QACA;AAAA,MACD;AAAA,IACD;AAAA;AAAA;;;AC5TA,IAKa;AALb;AAAA;AAAA;AAKO,IAAM,aAAN,cAAyB,eAAe;AAAA,MAC9C,YAAY,SAAS,OAAO,WAAW;AACtC,cAAM,SAAS,IAAI;AAAA,MACpB;AAAA,IACD;AAAA;AAAA;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+CA,sBAAoC,KAAK,UAAU;AAClD,SAAO,IAAI,QAAQ,CAAC,UAAS,WAAW;AAEvC,UAAM,UAAU,IAAI,QAAQ,KAAK,QAAQ;AACzC,UAAM,EAAC,WAAW,YAAW,sBAAsB,OAAO;AAC1D,QAAI,CAAC,iBAAiB,IAAI,UAAU,QAAQ,GAAG;AAC9C,YAAM,IAAI,UAAU,0BAA0B,oBAAoB,UAAU,SAAS,QAAQ,MAAM,EAAE,sBAAsB;AAAA,IAC5H;AAEA,QAAI,UAAU,aAAa,SAAS;AACnC,YAAM,OAAO,aAAgB,QAAQ,GAAG;AACxC,YAAM,YAAW,IAAI,SAAS,MAAM,EAAC,SAAS,EAAC,gBAAgB,KAAK,SAAQ,EAAC,CAAC;AAC9E,eAAQ,SAAQ;AAChB;AAAA,IACD;AAGA,UAAM,OAAQ,WAAU,aAAa,WAAW,4BAAQ,2BAAM;AAC9D,UAAM,EAAC,WAAU;AACjB,QAAI,WAAW;AAEf,UAAM,QAAQ,MAAM;AACnB,YAAM,QAAQ,IAAI,WAAW,4BAA4B;AACzD,aAAO,KAAK;AACZ,UAAI,QAAQ,QAAQ,QAAQ,gBAAgB,4BAAO,UAAU;AAC5D,gBAAQ,KAAK,QAAQ,KAAK;AAAA,MAC3B;AAEA,UAAI,CAAC,YAAY,CAAC,SAAS,MAAM;AAChC;AAAA,MACD;AAEA,eAAS,KAAK,KAAK,SAAS,KAAK;AAAA,IAClC;AAEA,QAAI,UAAU,OAAO,SAAS;AAC7B,YAAM;AACN;AAAA,IACD;AAEA,UAAM,mBAAmB,MAAM;AAC9B,YAAM;AACN,eAAS;AAAA,IACV;AAGA,UAAM,WAAW,KAAK,UAAU,SAAS,GAAG,OAAO;AAEnD,QAAI,QAAQ;AACX,aAAO,iBAAiB,SAAS,gBAAgB;AAAA,IAClD;AAEA,UAAM,WAAW,MAAM;AACtB,eAAS,MAAM;AACf,UAAI,QAAQ;AACX,eAAO,oBAAoB,SAAS,gBAAgB;AAAA,MACrD;AAAA,IACD;AAEA,aAAS,GAAG,SAAS,WAAS;AAC7B,aAAO,IAAI,WAAW,cAAc,QAAQ,uBAAuB,MAAM,WAAW,UAAU,KAAK,CAAC;AACpG,eAAS;AAAA,IACV,CAAC;AAED,wCAAoC,UAAU,WAAS;AACtD,UAAI,YAAY,SAAS,MAAM;AAC9B,iBAAS,KAAK,QAAQ,KAAK;AAAA,MAC5B;AAAA,IACD,CAAC;AAGD,QAAI,QAAQ,UAAU,OAAO;AAG5B,eAAS,GAAG,UAAU,QAAK;AAC1B,YAAI;AACJ,WAAE,gBAAgB,OAAO,MAAM;AAC9B,iCAAuB,GAAE;AAAA,QAC1B,CAAC;AACD,WAAE,gBAAgB,SAAS,cAAY;AAEtC,cAAI,YAAY,uBAAuB,GAAE,gBAAgB,CAAC,UAAU;AACnE,kBAAM,QAAQ,IAAI,MAAM,iBAAiB;AACzC,kBAAM,OAAO;AACb,qBAAS,KAAK,KAAK,SAAS,KAAK;AAAA,UAClC;AAAA,QACD,CAAC;AAAA,MACF,CAAC;AAAA,IACF;AAEA,aAAS,GAAG,YAAY,eAAa;AACpC,eAAS,WAAW,CAAC;AACrB,YAAM,UAAU,eAAe,UAAU,UAAU;AAGnD,UAAI,WAAW,UAAU,UAAU,GAAG;AAErC,cAAM,WAAW,QAAQ,IAAI,UAAU;AAGvC,YAAI,cAAc;AAClB,YAAI;AACH,wBAAc,aAAa,OAAO,OAAO,IAAI,IAAI,UAAU,QAAQ,GAAG;AAAA,QACvE,QAAE;AAID,cAAI,QAAQ,aAAa,UAAU;AAClC,mBAAO,IAAI,WAAW,wDAAwD,YAAY,kBAAkB,CAAC;AAC7G,qBAAS;AACT;AAAA,UACD;AAAA,QACD;AAGA,gBAAQ,QAAQ;AAAA,eACV;AACJ,mBAAO,IAAI,WAAW,0EAA0E,QAAQ,OAAO,aAAa,CAAC;AAC7H,qBAAS;AACT;AAAA,eACI;AAEJ;AAAA,eACI,UAAU;AAEd,gBAAI,gBAAgB,MAAM;AACzB;AAAA,YACD;AAGA,gBAAI,QAAQ,WAAW,QAAQ,QAAQ;AACtC,qBAAO,IAAI,WAAW,gCAAgC,QAAQ,OAAO,cAAc,CAAC;AACpF,uBAAS;AACT;AAAA,YACD;AAIA,kBAAM,iBAAiB;AAAA,cACtB,SAAS,IAAI,QAAQ,QAAQ,OAAO;AAAA,cACpC,QAAQ,QAAQ;AAAA,cAChB,SAAS,QAAQ,UAAU;AAAA,cAC3B,OAAO,QAAQ;AAAA,cACf,UAAU,QAAQ;AAAA,cAClB,QAAQ,QAAQ;AAAA,cAChB,MAAM,MAAM,OAAO;AAAA,cACnB,QAAQ,QAAQ;AAAA,cAChB,MAAM,QAAQ;AAAA,cACd,UAAU,QAAQ;AAAA,cAClB,gBAAgB,QAAQ;AAAA,YACzB;AAWA,gBAAI,CAAC,oBAAoB,QAAQ,KAAK,WAAW,KAAK,CAAC,eAAe,QAAQ,KAAK,WAAW,GAAG;AAChG,yBAAW,SAAQ,CAAC,iBAAiB,oBAAoB,UAAU,SAAS,GAAG;AAC9E,+BAAe,QAAQ,OAAO,KAAI;AAAA,cACnC;AAAA,YACD;AAGA,gBAAI,UAAU,eAAe,OAAO,QAAQ,QAAQ,SAAS,gBAAgB,4BAAO,UAAU;AAC7F,qBAAO,IAAI,WAAW,4DAA4D,sBAAsB,CAAC;AACzG,uBAAS;AACT;AAAA,YACD;AAGA,gBAAI,UAAU,eAAe,OAAS,WAAU,eAAe,OAAO,UAAU,eAAe,QAAQ,QAAQ,WAAW,QAAS;AAClI,6BAAe,SAAS;AACxB,6BAAe,OAAO;AACtB,6BAAe,QAAQ,OAAO,gBAAgB;AAAA,YAC/C;AAGA,kBAAM,yBAAyB,8BAA8B,OAAO;AACpE,gBAAI,wBAAwB;AAC3B,6BAAe,iBAAiB;AAAA,YACjC;AAGA,qBAAQ,OAAM,IAAI,QAAQ,aAAa,cAAc,CAAC,CAAC;AACvD,qBAAS;AACT;AAAA,UACD;AAAA;AAGC,mBAAO,OAAO,IAAI,UAAU,oBAAoB,QAAQ,mDAAmD,CAAC;AAAA;AAAA,MAE/G;AAGA,UAAI,QAAQ;AACX,kBAAU,KAAK,OAAO,MAAM;AAC3B,iBAAO,oBAAoB,SAAS,gBAAgB;AAAA,QACrD,CAAC;AAAA,MACF;AAEA,UAAI,OAAO,kCAAK,WAAW,IAAI,gCAAY,GAAG,WAAS;AACtD,YAAI,OAAO;AACV,iBAAO,KAAK;AAAA,QACb;AAAA,MACD,CAAC;AAGD,UAAI,QAAQ,UAAU,UAAU;AAC/B,kBAAU,GAAG,WAAW,gBAAgB;AAAA,MACzC;AAEA,YAAM,kBAAkB;AAAA,QACvB,KAAK,QAAQ;AAAA,QACb,QAAQ,UAAU;AAAA,QAClB,YAAY,UAAU;AAAA,QACtB;AAAA,QACA,MAAM,QAAQ;AAAA,QACd,SAAS,QAAQ;AAAA,QACjB,eAAe,QAAQ;AAAA,MACxB;AAGA,YAAM,UAAU,QAAQ,IAAI,kBAAkB;AAU9C,UAAI,CAAC,QAAQ,YAAY,QAAQ,WAAW,UAAU,YAAY,QAAQ,UAAU,eAAe,OAAO,UAAU,eAAe,KAAK;AACvI,mBAAW,IAAI,SAAS,MAAM,eAAe;AAC7C,iBAAQ,QAAQ;AAChB;AAAA,MACD;AAOA,YAAM,cAAc;AAAA,QACnB,OAAO,yBAAK;AAAA,QACZ,aAAa,yBAAK;AAAA,MACnB;AAGA,UAAI,YAAY,UAAU,YAAY,UAAU;AAC/C,eAAO,kCAAK,MAAM,yBAAK,aAAa,WAAW,GAAG,WAAS;AAC1D,cAAI,OAAO;AACV,mBAAO,KAAK;AAAA,UACb;AAAA,QACD,CAAC;AACD,mBAAW,IAAI,SAAS,MAAM,eAAe;AAC7C,iBAAQ,QAAQ;AAChB;AAAA,MACD;AAGA,UAAI,YAAY,aAAa,YAAY,aAAa;AAGrD,cAAM,MAAM,kCAAK,WAAW,IAAI,gCAAY,GAAG,WAAS;AACvD,cAAI,OAAO;AACV,mBAAO,KAAK;AAAA,UACb;AAAA,QACD,CAAC;AACD,YAAI,KAAK,QAAQ,WAAS;AAEzB,cAAK,OAAM,KAAK,QAAU,GAAM;AAC/B,mBAAO,kCAAK,MAAM,yBAAK,cAAc,GAAG,WAAS;AAChD,kBAAI,OAAO;AACV,uBAAO,KAAK;AAAA,cACb;AAAA,YACD,CAAC;AAAA,UACF,OAAO;AACN,mBAAO,kCAAK,MAAM,yBAAK,iBAAiB,GAAG,WAAS;AACnD,kBAAI,OAAO;AACV,uBAAO,KAAK;AAAA,cACb;AAAA,YACD,CAAC;AAAA,UACF;AAEA,qBAAW,IAAI,SAAS,MAAM,eAAe;AAC7C,mBAAQ,QAAQ;AAAA,QACjB,CAAC;AACD,YAAI,KAAK,OAAO,MAAM;AAGrB,cAAI,CAAC,UAAU;AACd,uBAAW,IAAI,SAAS,MAAM,eAAe;AAC7C,qBAAQ,QAAQ;AAAA,UACjB;AAAA,QACD,CAAC;AACD;AAAA,MACD;AAGA,UAAI,YAAY,MAAM;AACrB,eAAO,kCAAK,MAAM,yBAAK,uBAAuB,GAAG,WAAS;AACzD,cAAI,OAAO;AACV,mBAAO,KAAK;AAAA,UACb;AAAA,QACD,CAAC;AACD,mBAAW,IAAI,SAAS,MAAM,eAAe;AAC7C,iBAAQ,QAAQ;AAChB;AAAA,MACD;AAGA,iBAAW,IAAI,SAAS,MAAM,eAAe;AAC7C,eAAQ,QAAQ;AAAA,IACjB,CAAC;AAGD,kBAAc,UAAU,OAAO,EAAE,MAAM,MAAM;AAAA,EAC9C,CAAC;AACF;AAEA,6CAA6C,SAAS,eAAe;AACpE,QAAM,aAAa,2BAAO,KAAK,WAAW;AAE1C,MAAI,oBAAoB;AACxB,MAAI,0BAA0B;AAC9B,MAAI;AAEJ,UAAQ,GAAG,YAAY,cAAY;AAClC,UAAM,EAAC,YAAW;AAClB,wBAAoB,QAAQ,yBAAyB,aAAa,CAAC,QAAQ;AAAA,EAC5E,CAAC;AAED,UAAQ,GAAG,UAAU,YAAU;AAC9B,UAAM,gBAAgB,MAAM;AAC3B,UAAI,qBAAqB,CAAC,yBAAyB;AAClD,cAAM,QAAQ,IAAI,MAAM,iBAAiB;AACzC,cAAM,OAAO;AACb,sBAAc,KAAK;AAAA,MACpB;AAAA,IACD;AAEA,UAAM,SAAS,SAAO;AACrB,gCAA0B,2BAAO,QAAQ,IAAI,MAAM,EAAE,GAAG,UAAU,MAAM;AAGxE,UAAI,CAAC,2BAA2B,eAAe;AAC9C,kCACC,2BAAO,QAAQ,cAAc,MAAM,EAAE,GAAG,WAAW,MAAM,GAAG,CAAC,CAAC,MAAM,KACpE,2BAAO,QAAQ,IAAI,MAAM,EAAE,GAAG,WAAW,MAAM,CAAC,CAAC,MAAM;AAAA,MAEzD;AAEA,sBAAgB;AAAA,IACjB;AAEA,WAAO,gBAAgB,SAAS,aAAa;AAC7C,WAAO,GAAG,QAAQ,MAAM;AAExB,YAAQ,GAAG,SAAS,MAAM;AACzB,aAAO,eAAe,SAAS,aAAa;AAC5C,aAAO,eAAe,QAAQ,MAAM;AAAA,IACrC,CAAC;AAAA,EACF,CAAC;AACF;AAhaA,IAQA,mBACA,mBACA,kBACA,qBACA,qBA0BM;AAtCN;AAAA;AAQA,wBAAiB;AACjB,wBAAkB;AAClB,uBAAiB;AACjB,0BAAoD;AACpD,0BAAqB;AAErB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA,IAAM,mBAAmB,oBAAI,IAAI,CAAC,SAAS,SAAS,QAAQ,CAAC;AAAA;AAAA;;;ACtC7D;AAAA;AAAA;AAAA;AAAA,IAEO;AAFP;AAAA;AAAA;AAEA,IAAO,qBAAQ;AAAA;AAAA;;;ACWT,0BAA0B,KAAW;AAC1C,MAAI,CAAC,UAAU,KAAK,GAAG,GAAG;AACzB,UAAM,IAAI,UACT,kEAAkE;;AAKpE,QAAM,IAAI,QAAQ,UAAU,EAAE;AAG9B,QAAM,aAAa,IAAI,QAAQ,GAAG;AAClC,MAAI,eAAe,MAAM,cAAc,GAAG;AACzC,UAAM,IAAI,UAAU,qBAAqB;;AAI1C,QAAM,OAAO,IAAI,UAAU,GAAG,UAAU,EAAE,MAAM,GAAG;AAEnD,MAAI,UAAU;AACd,MAAI,SAAS;AACb,QAAM,OAAO,KAAK,MAAM;AACxB,MAAI,WAAW;AACf,WAAS,KAAI,GAAG,KAAI,KAAK,QAAQ,MAAK;AACrC,QAAI,KAAK,QAAO,UAAU;AACzB,eAAS;WACH;AACN,kBAAY,IAAM,KAAK;AACvB,UAAI,KAAK,IAAG,QAAQ,UAAU,MAAM,GAAG;AACtC,kBAAU,KAAK,IAAG,UAAU,CAAC;;;;AAKhC,MAAI,CAAC,KAAK,MAAM,CAAC,QAAQ,QAAQ;AAChC,gBAAY;AACZ,cAAU;;AAIX,QAAM,WAAW,SAAS,WAAW;AACrC,QAAM,OAAO,SAAS,IAAI,UAAU,aAAa,CAAC,CAAC;AACnD,QAAM,SAAS,OAAO,KAAK,MAAM,QAAQ;AAGzC,SAAO,OAAO;AACd,SAAO,WAAW;AAGlB,SAAO,UAAU;AAEjB,SAAO;AACR;AA3DA,IA6DA;AA7DA;;AA6DA,IAAA,gBAAe;;;;;;;;;;;ACjEf,YAAM,iBACJ,OAAO,WAAW,cAAc,OAAO,OAAO,aAAa,WACzD,SACA,iBAAe,UAAU;uBCHT;AAClB,eAAO;MACT;AAEA,4BAAmB;AACjB,YAAI,OAAO,SAAS,aAAa;AAC/B,iBAAO;mBACE,OAAO,WAAW,aAAa;AACxC,iBAAO;mBACE,OAAO,WAAW,aAAa;AACxC,iBAAO;;AAET,eAAO;MACT;AAEO,YAAM,UAAU,WAAU;4BCdJ,IAAM;AACjC,eAAQ,OAAO,OAAM,YAAY,OAAM,QAAS,OAAO,OAAM;MAC/D;AAEO,YAAM,iCAUP;ACbN,YAAM,kBAAkB;AACxB,YAAM,sBAAsB,QAAQ,UAAU;AAC9C,YAAM,yBAAyB,QAAQ,QAAQ,KAAK,eAAe;AACnE,YAAM,wBAAwB,QAAQ,OAAO,KAAK,eAAe;0BAEnC,UAGrB;AACP,eAAO,IAAI,gBAAgB,QAAQ;MACrC;mCAEuC,OAAyB;AAC9D,eAAO,uBAAuB,KAAK;MACrC;mCAE+C,QAAW;AACxD,eAAO,sBAAsB,MAAM;MACrC;kCAGE,SACA,aACA,YAA8D;AAG9D,eAAO,oBAAoB,KAAK,SAAS,aAAa,UAAU;MAClE;2BAGE,SACA,aACA,YAAsD;AACtD,2BACE,mBAAmB,SAAS,aAAa,UAAU,GACnD,QACA,8BAA8B;MAElC;+BAEmC,SAAqB,aAAmD;AACzG,oBAAY,SAAS,WAAW;MAClC;6BAE8B,SAA2B,YAAqD;AAC5G,oBAAY,SAAS,QAAW,UAAU;MAC5C;oCAGE,SACA,oBACA,kBAAoE;AACpE,eAAO,mBAAmB,SAAS,oBAAoB,gBAAgB;MACzE;yCAE0C,SAAyB;AACjE,2BAAmB,SAAS,QAAW,8BAA8B;MACvE;AAEO,YAAM,iBAA4C,OAAA;AACvD,cAAM,uBAAuB,WAAW,QAAQ;AAChD,YAAI,OAAO,yBAAyB,YAAY;AAC9C,iBAAO;;AAGT,cAAM,kBAAkB,oBAAoB,MAAS;AACrD,eAAO,CAAC,OAAmB,mBAAmB,iBAAiB,EAAE;MACnE,GAAC;2BAEkD,IAAiC,GAAM,MAAO;AAC/F,YAAI,OAAO,OAAM,YAAY;AAC3B,gBAAM,IAAI,UAAU,4BAA4B;;AAElD,eAAO,SAAS,UAAU,MAAM,KAAK,IAAG,GAAG,IAAI;MACjD;2BAEmD,IACA,GACA,MAAO;AAIxD,YAAI;AACF,iBAAO,oBAAoB,YAAY,IAAG,GAAG,IAAI,CAAC;iBAC3C,OAAP;AACA,iBAAO,oBAAoB,KAAK;;MAEpC;ACtFA,YAAM,uBAAuB;YAahB,YAAW;QAMtB,cAAA;AAHQ,eAAA,UAAU;AACV,eAAA,QAAQ;AAId,eAAK,SAAS;YACZ,WAAW,CAAA;YACX,OAAO;;AAET,eAAK,QAAQ,KAAK;AAIlB,eAAK,UAAU;AAEf,eAAK,QAAQ;;QAGf,IAAI,SAAM;AACR,iBAAO,KAAK;;QAOd,KAAK,SAAU;AACb,gBAAM,UAAU,KAAK;AACrB,cAAI,UAAU;AAEd,cAAI,QAAQ,UAAU,WAAW,uBAAuB,GAAG;AACzD,sBAAU;cACR,WAAW,CAAA;cACX,OAAO;;;AAMX,kBAAQ,UAAU,KAAK,OAAO;AAC9B,cAAI,YAAY,SAAS;AACvB,iBAAK,QAAQ;AACb,oBAAQ,QAAQ;;AAElB,YAAE,KAAK;;QAKT,QAAK;AAGH,gBAAM,WAAW,KAAK;AACtB,cAAI,WAAW;AACf,gBAAM,YAAY,KAAK;AACvB,cAAI,YAAY,YAAY;AAE5B,gBAAM,WAAW,SAAS;AAC1B,gBAAM,UAAU,SAAS;AAEzB,cAAI,cAAc,sBAAsB;AAGtC,uBAAW,SAAS;AACpB,wBAAY;;AAId,YAAE,KAAK;AACP,eAAK,UAAU;AACf,cAAI,aAAa,UAAU;AACzB,iBAAK,SAAS;;AAIhB,mBAAS,aAAa;AAEtB,iBAAO;;QAWT,QAAQ,UAA8B;AACpC,cAAI,KAAI,KAAK;AACb,cAAI,OAAO,KAAK;AAChB,cAAI,WAAW,KAAK;AACpB,iBAAO,OAAM,SAAS,UAAU,KAAK,UAAU,QAAW;AACxD,gBAAI,OAAM,SAAS,QAAQ;AAGzB,qBAAO,KAAK;AACZ,yBAAW,KAAK;AAChB,mBAAI;AACJ,kBAAI,SAAS,WAAW,GAAG;AACzB;;;AAGJ,qBAAS,SAAS,GAAE;AACpB,cAAE;;;QAMN,OAAI;AAGF,gBAAM,QAAQ,KAAK;AACnB,gBAAM,SAAS,KAAK;AACpB,iBAAO,MAAM,UAAU;;;qDCpI8B,QAAiC,QAAyB;AACjH,eAAO,uBAAuB;AAC9B,eAAO,UAAU;AAEjB,YAAI,OAAO,WAAW,YAAY;AAChC,+CAAqC,MAAM;mBAClC,OAAO,WAAW,UAAU;AACrC,yDAA+C,MAAM;eAChD;AAGL,yDAA+C,QAAQ,OAAO,YAAY;;MAE9E;iDAKkD,QAAmC,QAAW;AAC9F,cAAM,SAAS,OAAO;AAEtB,eAAO,qBAAqB,QAAQ,MAAM;MAC5C;kDAEmD,QAAiC;AAIlF,YAAI,OAAO,qBAAqB,WAAW,YAAY;AACrD,2CACE,QACA,IAAI,UAAU,kFAAkF,CAAC;eAC9F;AACL,oDACE,QACA,IAAI,UAAU,kFAAkF,CAAC;;AAGrG,eAAO,qBAAqB,UAAU;AACtC,eAAO,uBAAuB;MAChC;mCAIoC,OAAY;AAC9C,eAAO,IAAI,UAAU,YAAY,QAAO,mCAAmC;MAC7E;oDAIqD,QAAiC;AACpF,eAAO,iBAAiB,WAAW,CAAC,UAAS,WAAM;AACjD,iBAAO,yBAAyB;AAChC,iBAAO,wBAAwB;SAChC;MACH;8DAE+D,QAAmC,QAAW;AAC3G,6CAAqC,MAAM;AAC3C,yCAAiC,QAAQ,MAAM;MACjD;8DAE+D,QAAiC;AAC9F,6CAAqC,MAAM;AAC3C,0CAAkC,MAAM;MAC1C;gDAEiD,QAAmC,QAAW;AAC7F,YAAI,OAAO,0BAA0B,QAAW;AAC9C;;AAGF,kCAA0B,OAAO,cAAc;AAC/C,eAAO,sBAAsB,MAAM;AACnC,eAAO,yBAAyB;AAChC,eAAO,wBAAwB;MACjC;yDAE0D,QAAmC,QAAW;AAItG,uDAA+C,QAAQ,MAAM;MAC/D;iDAEkD,QAAiC;AACjF,YAAI,OAAO,2BAA2B,QAAW;AAC/C;;AAGF,eAAO,uBAAuB,MAAS;AACvC,eAAO,yBAAyB;AAChC,eAAO,wBAAwB;MACjC;ACjGO,YAAM,aAAa,eAAO,gBAAgB;AAC1C,YAAM,aAAa,eAAO,gBAAgB;AAC1C,YAAM,cAAc,eAAO,iBAAiB;AAC5C,YAAM,YAAY,eAAO,eAAe;ACA/C,YAAM,iBAAyC,OAAO,YAAY,SAAU,IAAC;AAC3E,eAAO,OAAO,OAAM,YAAY,SAAS,EAAC;MAC5C;ACFA,YAAM,YAA+B,KAAK,SAAS,SAAU,GAAC;AAC5D,eAAO,IAAI,IAAI,KAAK,KAAK,CAAC,IAAI,KAAK,MAAM,CAAC;MAC5C;4BCD6B,IAAM;AACjC,eAAO,OAAO,OAAM,YAAY,OAAO,OAAM;MAC/C;gCAEiC,KACA,SAAe;AAC9C,YAAI,QAAQ,UAAa,CAAC,aAAa,GAAG,GAAG;AAC3C,gBAAM,IAAI,UAAU,GAAG,2BAA2B;;MAEtD;8BAK+B,IAAY,SAAe;AACxD,YAAI,OAAO,OAAM,YAAY;AAC3B,gBAAM,IAAI,UAAU,GAAG,4BAA4B;;MAEvD;wBAGyB,IAAM;AAC7B,eAAQ,OAAO,OAAM,YAAY,OAAM,QAAS,OAAO,OAAM;MAC/D;4BAE6B,IACA,SAAe;AAC1C,YAAI,CAAC,SAAS,EAAC,GAAG;AAChB,gBAAM,IAAI,UAAU,GAAG,2BAA2B;;MAEtD;sCAEsD,IACA,UACA,SAAe;AACnE,YAAI,OAAM,QAAW;AACnB,gBAAM,IAAI,UAAU,aAAa,4BAA4B,WAAW;;MAE5E;mCAEmD,IACA,OACA,SAAe;AAChE,YAAI,OAAM,QAAW;AACnB,gBAAM,IAAI,UAAU,GAAG,yBAAyB,WAAW;;MAE/D;yCAG0C,OAAc;AACtD,eAAO,OAAO,KAAK;MACrB;AAEA,kCAA4B,IAAS;AACnC,eAAO,OAAM,IAAI,IAAI;MACvB;AAEA,2BAAqB,IAAS;AAC5B,eAAO,mBAAmB,UAAU,EAAC,CAAC;MACxC;uDAGwD,OAAgB,SAAe;AACrF,cAAM,aAAa;AACnB,cAAM,aAAa,OAAO;AAE1B,YAAI,KAAI,OAAO,KAAK;AACpB,aAAI,mBAAmB,EAAC;AAExB,YAAI,CAAC,eAAe,EAAC,GAAG;AACtB,gBAAM,IAAI,UAAU,GAAG,gCAAgC;;AAGzD,aAAI,YAAY,EAAC;AAEjB,YAAI,KAAI,cAAc,KAAI,YAAY;AACpC,gBAAM,IAAI,UAAU,GAAG,4CAA4C,iBAAiB,uBAAuB;;AAG7G,YAAI,CAAC,eAAe,EAAC,KAAK,OAAM,GAAG;AACjC,iBAAO;;AAQT,eAAO;MACT;oCC3FqC,IAAY,SAAe;AAC9D,YAAI,CAAC,iBAAiB,EAAC,GAAG;AACxB,gBAAM,IAAI,UAAU,GAAG,kCAAkC;;MAE7D;kDCwBsD,QAAsB;AAC1E,eAAO,IAAI,4BAA4B,MAAM;MAC/C;4CAIgD,QACA,aAA2B;AAIxE,eAAO,QAA4C,cAAc,KAAK,WAAW;MACpF;gDAEoD,QAA2B,OAAsB,MAAa;AAChH,cAAM,SAAS,OAAO;AAItB,cAAM,cAAc,OAAO,cAAc,MAAK;AAC9C,YAAI,MAAM;AACR,sBAAY,YAAW;eAClB;AACL,sBAAY,YAAY,KAAM;;MAElC;gDAEoD,QAAyB;AAC3E,eAAQ,OAAO,QAA2C,cAAc;MAC1E;8CAE+C,QAAsB;AACnE,cAAM,SAAS,OAAO;AAEtB,YAAI,WAAW,QAAW;AACxB,iBAAO;;AAGT,YAAI,CAAC,8BAA8B,MAAM,GAAG;AAC1C,iBAAO;;AAGT,eAAO;MACT;YAiBa,4BAA2B;QAYtC,YAAY,QAAyB;AACnC,iCAAuB,QAAQ,GAAG,6BAA6B;AAC/D,+BAAqB,QAAQ,iBAAiB;AAE9C,cAAI,uBAAuB,MAAM,GAAG;AAClC,kBAAM,IAAI,UAAU,6EAA6E;;AAGnG,gDAAsC,MAAM,MAAM;AAElD,eAAK,gBAAgB,IAAI,YAAW;;QAOtC,IAAI,SAAM;AACR,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,iCAAiC,QAAQ,CAAC;;AAGvE,iBAAO,KAAK;;QAMd,OAAO,SAAc,QAAS;AAC5B,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,iCAAiC,QAAQ,CAAC;;AAGvE,cAAI,KAAK,yBAAyB,QAAW;AAC3C,mBAAO,oBAAoB,oBAAoB,QAAQ,CAAC;;AAG1D,iBAAO,kCAAkC,MAAM,MAAM;;QAQvD,OAAI;AACF,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,iCAAiC,MAAM,CAAC;;AAGrE,cAAI,KAAK,yBAAyB,QAAW;AAC3C,mBAAO,oBAAoB,oBAAoB,WAAW,CAAC;;AAG7D,cAAI;AACJ,cAAI;AACJ,gBAAM,UAAU,WAA+C,CAAC,UAAS,WAAM;AAC7E,6BAAiB;AACjB,4BAAgB;WACjB;AACD,gBAAM,cAA8B;YAClC,aAAa,WAAS,eAAe,EAAE,OAAO,OAAO,MAAM,MAAK,CAAE;YAClE,aAAa,MAAM,eAAe,EAAE,OAAO,QAAW,MAAM,KAAI,CAAE;YAClE,aAAa,QAAK,cAAc,EAAC;;AAEnC,0CAAgC,MAAM,WAAW;AACjD,iBAAO;;QAYT,cAAW;AACT,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,kBAAM,iCAAiC,aAAa;;AAGtD,cAAI,KAAK,yBAAyB,QAAW;AAC3C;;AAGF,cAAI,KAAK,cAAc,SAAS,GAAG;AACjC,kBAAM,IAAI,UAAU,qFAAqF;;AAG3G,6CAAmC,IAAI;;;AAI3C,aAAO,iBAAiB,4BAA4B,WAAW;QAC7D,QAAQ,EAAE,YAAY,KAAI;QAC1B,MAAM,EAAE,YAAY,KAAI;QACxB,aAAa,EAAE,YAAY,KAAI;QAC/B,QAAQ,EAAE,YAAY,KAAI;OAC3B;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,4BAA4B,WAAW,eAAO,aAAa;UAC/E,OAAO;UACP,cAAc;SACf;;6CAKoD,IAAM;AAC3D,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,eAAe,GAAG;AAC7D,iBAAO;;AAGT,eAAO,cAAa;MACtB;+CAEmD,QACA,aAA2B;AAC5E,cAAM,SAAS,OAAO;AAItB,eAAO,aAAa;AAEpB,YAAI,OAAO,WAAW,UAAU;AAC9B,sBAAY,YAAW;mBACd,OAAO,WAAW,WAAW;AACtC,sBAAY,YAAY,OAAO,YAAY;eACtC;AAEL,iBAAO,0BAA0B,WAAW,WAA+B;;MAE/E;AAIA,gDAA0C,OAAY;AACpD,eAAO,IAAI,UACT,yCAAyC,yDAAwD;MACrG;ACpPO,YAAM,yBACX,OAAO,eAAe,OAAO,eAAe,mBAAA;MAAA,CAAiD,EAAE,SAAS;YCiC7F,gCAA+B;QAM1C,YAAY,QAAwC,eAAsB;AAHlE,eAAA,kBAA2E;AAC3E,eAAA,cAAc;AAGpB,eAAK,UAAU;AACf,eAAK,iBAAiB;;QAGxB,OAAI;AACF,gBAAM,YAAY,MAAM,KAAK,WAAU;AACvC,eAAK,kBAAkB,KAAK,kBAC1B,qBAAqB,KAAK,iBAAiB,WAAW,SAAS,IAC/D,UAAS;AACX,iBAAO,KAAK;;QAGd,OAAO,OAAU;AACf,gBAAM,cAAc,MAAM,KAAK,aAAa,KAAK;AACjD,iBAAO,KAAK,kBACV,qBAAqB,KAAK,iBAAiB,aAAa,WAAW,IACnE,YAAW;;QAGP,aAAU;AAChB,cAAI,KAAK,aAAa;AACpB,mBAAO,QAAQ,QAAQ,EAAE,OAAO,QAAW,MAAM,KAAI,CAAE;;AAGzD,gBAAM,SAAS,KAAK;AACpB,cAAI,OAAO,yBAAyB,QAAW;AAC7C,mBAAO,oBAAoB,oBAAoB,SAAS,CAAC;;AAG3D,cAAI;AACJ,cAAI;AACJ,gBAAM,UAAU,WAA+C,CAAC,UAAS,WAAM;AAC7E,6BAAiB;AACjB,4BAAgB;WACjB;AACD,gBAAM,cAA8B;YAClC,aAAa,WAAK;AAChB,mBAAK,kBAAkB;AAGvB,6BAAe,MAAM,eAAe,EAAE,OAAO,OAAO,MAAM,MAAK,CAAE,CAAC;;YAEpE,aAAa,MAAA;AACX,mBAAK,kBAAkB;AACvB,mBAAK,cAAc;AACnB,iDAAmC,MAAM;AACzC,6BAAe,EAAE,OAAO,QAAW,MAAM,KAAI,CAAE;;YAEjD,aAAa,YAAM;AACjB,mBAAK,kBAAkB;AACvB,mBAAK,cAAc;AACnB,iDAAmC,MAAM;AACzC,4BAAc,MAAM;;;AAGxB,0CAAgC,QAAQ,WAAW;AACnD,iBAAO;;QAGD,aAAa,OAAU;AAC7B,cAAI,KAAK,aAAa;AACpB,mBAAO,QAAQ,QAAQ,EAAE,OAAO,MAAM,KAAI,CAAE;;AAE9C,eAAK,cAAc;AAEnB,gBAAM,SAAS,KAAK;AACpB,cAAI,OAAO,yBAAyB,QAAW;AAC7C,mBAAO,oBAAoB,oBAAoB,kBAAkB,CAAC;;AAKpE,cAAI,CAAC,KAAK,gBAAgB;AACxB,kBAAM,SAAS,kCAAkC,QAAQ,KAAK;AAC9D,+CAAmC,MAAM;AACzC,mBAAO,qBAAqB,QAAQ,MAAO,GAAE,OAAO,MAAM,KAAI,EAAG;;AAGnE,6CAAmC,MAAM;AACzC,iBAAO,oBAAoB,EAAE,OAAO,MAAM,KAAI,CAAE;;;AAapD,YAAM,uCAAiF;QACrF,OAAI;AACF,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,uCAAuC,MAAM,CAAC;;AAE3E,iBAAO,KAAK,mBAAmB,KAAI;;QAGrC,OAAuD,OAAU;AAC/D,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,uCAAuC,QAAQ,CAAC;;AAE7E,iBAAO,KAAK,mBAAmB,OAAO,KAAK;;;AAG/C,UAAI,2BAA2B,QAAW;AACxC,eAAO,eAAe,sCAAsC,sBAAsB;;kDAK9B,QACA,eAAsB;AAC1E,cAAM,SAAS,mCAAsC,MAAM;AAC3D,cAAM,OAAO,IAAI,gCAAgC,QAAQ,aAAa;AACtE,cAAM,WAAmD,OAAO,OAAO,oCAAoC;AAC3G,iBAAS,qBAAqB;AAC9B,eAAO;MACT;AAEA,6CAAgD,IAAM;AACpD,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,oBAAoB,GAAG;AAClE,iBAAO;;AAGT,YAAI;AAEF,iBAAQ,GAA+C,8BACrD;iBACF,IAAA;AACA,iBAAO;;MAEX;AAIA,sDAAgD,OAAY;AAC1D,eAAO,IAAI,UAAU,+BAA+B,wDAAuD;MAC7G;ACzLA,YAAM,cAAmC,OAAO,SAAS,SAAU,IAAC;AAElE,eAAO,OAAM;MACf;mCCNqD,UAAW;AAG9D,eAAO,SAAS,MAAK;MACvB;kCAEmC,MACA,YACA,KACA,WACA,GAAS;AAC1C,YAAI,WAAW,IAAI,EAAE,IAAI,IAAI,WAAW,KAAK,WAAW,CAAC,GAAG,UAAU;MACxE;mCAG+D,GAAI;AACjE,eAAO;MACT;gCAUiC,GAAkB;AACjD,eAAO;MACT;gCAEiC,QAAyB,OAAe,KAAW;AAGlF,YAAI,OAAO,OAAO;AAChB,iBAAO,OAAO,MAAM,OAAO,GAAG;;AAEhC,cAAM,SAAS,MAAM;AACrB,cAAM,QAAQ,IAAI,YAAY,MAAM;AACpC,2BAAmB,OAAO,GAAG,QAAQ,OAAO,MAAM;AAClD,eAAO;MACT;mCCtCoC,GAAS;AAC3C,YAAI,OAAO,MAAM,UAAU;AACzB,iBAAO;;AAGT,YAAI,YAAY,CAAC,GAAG;AAClB,iBAAO;;AAGT,YAAI,IAAI,GAAG;AACT,iBAAO;;AAGT,eAAO;MACT;iCAEkC,GAAkB;AAClD,cAAM,SAAS,iBAAiB,EAAE,QAAQ,EAAE,YAAY,EAAE,aAAa,EAAE,UAAU;AACnF,eAAO,IAAI,WAAW,MAAM;MAC9B;4BCRgC,WAAuC;AAIrE,cAAM,OAAO,UAAU,OAAO,MAAK;AACnC,kBAAU,mBAAmB,KAAK;AAClC,YAAI,UAAU,kBAAkB,GAAG;AACjC,oBAAU,kBAAkB;;AAG9B,eAAO,KAAK;MACd;oCAEwC,WAAyC,OAAU,MAAY;AAGrG,YAAI,CAAC,oBAAoB,IAAI,KAAK,SAAS,UAAU;AACnD,gBAAM,IAAI,WAAW,sDAAsD;;AAG7E,kBAAU,OAAO,KAAK,EAAE,OAAO,KAAI,CAAE;AACrC,kBAAU,mBAAmB;MAC/B;8BAEkC,WAAuC;AAIvE,cAAM,OAAO,UAAU,OAAO,KAAI;AAClC,eAAO,KAAK;MACd;0BAE8B,WAA4B;AAGxD,kBAAU,SAAS,IAAI,YAAW;AAClC,kBAAU,kBAAkB;MAC9B;YCTa,0BAAyB;QAMpC,cAAA;AACE,gBAAM,IAAI,UAAU,qBAAqB;;QAM3C,IAAI,OAAI;AACN,cAAI,CAAC,4BAA4B,IAAI,GAAG;AACtC,kBAAM,+BAA+B,MAAM;;AAG7C,iBAAO,KAAK;;QAWd,QAAQ,cAAgC;AACtC,cAAI,CAAC,4BAA4B,IAAI,GAAG;AACtC,kBAAM,+BAA+B,SAAS;;AAEhD,iCAAuB,cAAc,GAAG,SAAS;AACjD,yBAAe,wCAAwC,cAAc,iBAAiB;AAEtF,cAAI,KAAK,4CAA4C,QAAW;AAC9D,kBAAM,IAAI,UAAU,wCAAwC;;AAG9D,cAAI,iBAAiB,KAAK,MAAO,MAAM;AAAG;AAO1C,8CAAoC,KAAK,yCAAyC,YAAY;;QAWhG,mBAAmB,MAAiC;AAClD,cAAI,CAAC,4BAA4B,IAAI,GAAG;AACtC,kBAAM,+BAA+B,oBAAoB;;AAE3D,iCAAuB,MAAM,GAAG,oBAAoB;AAEpD,cAAI,CAAC,YAAY,OAAO,IAAI,GAAG;AAC7B,kBAAM,IAAI,UAAU,8CAA8C;;AAGpE,cAAI,KAAK,4CAA4C,QAAW;AAC9D,kBAAM,IAAI,UAAU,wCAAwC;;AAG9D,cAAI,iBAAiB,KAAK,MAAM;AAAG;AAInC,yDAA+C,KAAK,yCAAyC,IAAI;;;AAIrG,aAAO,iBAAiB,0BAA0B,WAAW;QAC3D,SAAS,EAAE,YAAY,KAAI;QAC3B,oBAAoB,EAAE,YAAY,KAAI;QACtC,MAAM,EAAE,YAAY,KAAI;OACzB;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,0BAA0B,WAAW,eAAO,aAAa;UAC7E,OAAO;UACP,cAAc;SACf;;YA+CU,6BAA4B;QA4BvC,cAAA;AACE,gBAAM,IAAI,UAAU,qBAAqB;;QAM3C,IAAI,cAAW;AACb,cAAI,CAAC,+BAA+B,IAAI,GAAG;AACzC,kBAAM,wCAAwC,aAAa;;AAG7D,iBAAO,2CAA2C,IAAI;;QAOxD,IAAI,cAAW;AACb,cAAI,CAAC,+BAA+B,IAAI,GAAG;AACzC,kBAAM,wCAAwC,aAAa;;AAG7D,iBAAO,2CAA2C,IAAI;;QAOxD,QAAK;AACH,cAAI,CAAC,+BAA+B,IAAI,GAAG;AACzC,kBAAM,wCAAwC,OAAO;;AAGvD,cAAI,KAAK,iBAAiB;AACxB,kBAAM,IAAI,UAAU,4DAA4D;;AAGlF,gBAAM,SAAQ,KAAK,8BAA8B;AACjD,cAAI,WAAU,YAAY;AACxB,kBAAM,IAAI,UAAU,kBAAkB,iEAAgE;;AAGxG,4CAAkC,IAAI;;QAQxC,QAAQ,OAAkC;AACxC,cAAI,CAAC,+BAA+B,IAAI,GAAG;AACzC,kBAAM,wCAAwC,SAAS;;AAGzD,iCAAuB,OAAO,GAAG,SAAS;AAC1C,cAAI,CAAC,YAAY,OAAO,KAAK,GAAG;AAC9B,kBAAM,IAAI,UAAU,oCAAoC;;AAE1D,cAAI,MAAM,eAAe,GAAG;AAC1B,kBAAM,IAAI,UAAU,qCAAqC;;AAE3D,cAAI,MAAM,OAAO,eAAe,GAAG;AACjC,kBAAM,IAAI,UAAU,8CAA8C;;AAGpE,cAAI,KAAK,iBAAiB;AACxB,kBAAM,IAAI,UAAU,8BAA8B;;AAGpD,gBAAM,SAAQ,KAAK,8BAA8B;AACjD,cAAI,WAAU,YAAY;AACxB,kBAAM,IAAI,UAAU,kBAAkB,sEAAqE;;AAG7G,8CAAoC,MAAM,KAAK;;QAMjD,MAAM,KAAS,QAAS;AACtB,cAAI,CAAC,+BAA+B,IAAI,GAAG;AACzC,kBAAM,wCAAwC,OAAO;;AAGvD,4CAAkC,MAAM,EAAC;;QAI3C,CAAC,aAAa,QAAW;AACvB,4DAAkD,IAAI;AAEtD,qBAAW,IAAI;AAEf,gBAAM,SAAS,KAAK,iBAAiB,MAAM;AAC3C,sDAA4C,IAAI;AAChD,iBAAO;;QAIT,CAAC,WAAW,aAAoC;AAC9C,gBAAM,SAAS,KAAK;AAGpB,cAAI,KAAK,kBAAkB,GAAG;AAG5B,kBAAM,QAAQ,KAAK,OAAO,MAAK;AAC/B,iBAAK,mBAAmB,MAAM;AAE9B,yDAA6C,IAAI;AAEjD,kBAAM,OAAO,IAAI,WAAW,MAAM,QAAQ,MAAM,YAAY,MAAM,UAAU;AAE5E,wBAAY,YAAY,IAAI;AAC5B;;AAGF,gBAAM,wBAAwB,KAAK;AACnC,cAAI,0BAA0B,QAAW;AACvC,gBAAI;AACJ,gBAAI;AACF,uBAAS,IAAI,YAAY,qBAAqB;qBACvC,SAAP;AACA,0BAAY,YAAY,OAAO;AAC/B;;AAGF,kBAAM,qBAAgD;cACpD;cACA,kBAAkB;cAClB,YAAY;cACZ,YAAY;cACZ,aAAa;cACb,aAAa;cACb,iBAAiB;cACjB,YAAY;;AAGd,iBAAK,kBAAkB,KAAK,kBAAkB;;AAGhD,uCAA6B,QAAQ,WAAW;AAChD,uDAA6C,IAAI;;;AAIrD,aAAO,iBAAiB,6BAA6B,WAAW;QAC9D,OAAO,EAAE,YAAY,KAAI;QACzB,SAAS,EAAE,YAAY,KAAI;QAC3B,OAAO,EAAE,YAAY,KAAI;QACzB,aAAa,EAAE,YAAY,KAAI;QAC/B,aAAa,EAAE,YAAY,KAAI;OAChC;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,6BAA6B,WAAW,eAAO,aAAa;UAChF,OAAO;UACP,cAAc;SACf;;8CAK4C,IAAM;AACnD,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,+BAA+B,GAAG;AAC7E,iBAAO;;AAGT,eAAO,cAAa;MACtB;AAEA,2CAAqC,IAAM;AACzC,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,yCAAyC,GAAG;AACvF,iBAAO;;AAGT,eAAO,cAAa;MACtB;AAEA,4DAAsD,YAAwC;AAC5F,cAAM,aAAa,2CAA2C,UAAU;AACxE,YAAI,CAAC,YAAY;AACf;;AAGF,YAAI,WAAW,UAAU;AACvB,qBAAW,aAAa;AACxB;;AAKF,mBAAW,WAAW;AAGtB,cAAM,cAAc,WAAW,eAAc;AAC7C,oBACE,aACA,MAAA;AACE,qBAAW,WAAW;AAEtB,cAAI,WAAW,YAAY;AACzB,uBAAW,aAAa;AACxB,yDAA6C,UAAU;;WAG3D,QAAC;AACC,4CAAkC,YAAY,EAAC;SAChD;MAEL;AAEA,iEAA2D,YAAwC;AACjG,0DAAkD,UAAU;AAC5D,mBAAW,oBAAoB,IAAI,YAAW;MAChD;AAEA,oEACE,QACA,oBAAyC;AAIzC,YAAI,OAAO;AACX,YAAI,OAAO,WAAW,UAAU;AAE9B,iBAAO;;AAGT,cAAM,aAAa,sDAAyD,kBAAkB;AAC9F,YAAI,mBAAmB,eAAe,WAAW;AAC/C,2CAAiC,QAAQ,YAAqC,IAAI;eAC7E;AAEL,+CAAqC,QAAQ,YAAY,IAAI;;MAEjE;AAEA,qEACE,oBAAyC;AAEzC,cAAM,cAAc,mBAAmB;AACvC,cAAM,cAAc,mBAAmB;AAKvC,eAAO,IAAI,mBAAmB,gBAC5B,mBAAmB,QAAQ,mBAAmB,YAAY,cAAc,WAAW;MACvF;AAEA,+DAAyD,YACA,QACA,YACA,YAAkB;AACzE,mBAAW,OAAO,KAAK,EAAE,QAAQ,YAAY,WAAU,CAAE;AACzD,mBAAW,mBAAmB;MAChC;AAEA,2EAAqE,YACA,oBAAsC;AACzG,cAAM,cAAc,mBAAmB;AAEvC,cAAM,sBAAsB,mBAAmB,cAAc,mBAAmB,cAAc;AAE9F,cAAM,iBAAiB,KAAK,IAAI,WAAW,iBACX,mBAAmB,aAAa,mBAAmB,WAAW;AAC9F,cAAM,iBAAiB,mBAAmB,cAAc;AACxD,cAAM,kBAAkB,iBAAiB,iBAAiB;AAE1D,YAAI,4BAA4B;AAChC,YAAI,SAAQ;AACZ,YAAI,kBAAkB,qBAAqB;AACzC,sCAA4B,kBAAkB,mBAAmB;AACjE,mBAAQ;;AAGV,cAAM,QAAQ,WAAW;AAEzB,eAAO,4BAA4B,GAAG;AACpC,gBAAM,cAAc,MAAM,KAAI;AAE9B,gBAAM,cAAc,KAAK,IAAI,2BAA2B,YAAY,UAAU;AAE9E,gBAAM,YAAY,mBAAmB,aAAa,mBAAmB;AACrE,6BAAmB,mBAAmB,QAAQ,WAAW,YAAY,QAAQ,YAAY,YAAY,WAAW;AAEhH,cAAI,YAAY,eAAe,aAAa;AAC1C,kBAAM,MAAK;iBACN;AACL,wBAAY,cAAc;AAC1B,wBAAY,cAAc;;AAE5B,qBAAW,mBAAmB;AAE9B,iEAAuD,YAAY,aAAa,kBAAkB;AAElG,uCAA6B;;AAS/B,eAAO;MACT;AAEA,sEAAgE,YACA,MACA,oBAAsC;AAGpG,2BAAmB,eAAe;MACpC;AAEA,4DAAsD,YAAwC;AAG5F,YAAI,WAAW,oBAAoB,KAAK,WAAW,iBAAiB;AAClE,sDAA4C,UAAU;AACtD,8BAAoB,WAAW,6BAA6B;eACvD;AACL,uDAA6C,UAAU;;MAE3D;AAEA,iEAA2D,YAAwC;AACjG,YAAI,WAAW,iBAAiB,MAAM;AACpC;;AAGF,mBAAW,aAAa,0CAA0C;AAClE,mBAAW,aAAa,QAAQ;AAChC,mBAAW,eAAe;MAC5B;AAEA,gFAA0E,YAAwC;AAGhH,eAAO,WAAW,kBAAkB,SAAS,GAAG;AAC9C,cAAI,WAAW,oBAAoB,GAAG;AACpC;;AAGF,gBAAM,qBAAqB,WAAW,kBAAkB,KAAI;AAE5D,cAAI,4DAA4D,YAAY,kBAAkB,GAAG;AAC/F,6DAAiD,UAAU;AAE3D,iEACE,WAAW,+BACX,kBAAkB;;;MAI1B;oDAGE,YACA,MACA,iBAAmC;AAEnC,cAAM,SAAS,WAAW;AAE1B,YAAI,cAAc;AAClB,YAAI,KAAK,gBAAgB,UAAU;AACjC,wBAAe,KAAK,YAA8C;;AAGpE,cAAM,OAAO,KAAK;AAGlB,cAAM,SAAS,oBAAoB,KAAK,MAAM;AAM9C,cAAM,qBAAgD;UACpD;UACA,kBAAkB,OAAO;UACzB,YAAY,KAAK;UACjB,YAAY,KAAK;UACjB,aAAa;UACb;UACA,iBAAiB;UACjB,YAAY;;AAGd,YAAI,WAAW,kBAAkB,SAAS,GAAG;AAC3C,qBAAW,kBAAkB,KAAK,kBAAkB;AAMpD,2CAAiC,QAAQ,eAAe;AACxD;;AAGF,YAAI,OAAO,WAAW,UAAU;AAC9B,gBAAM,YAAY,IAAI,KAAK,mBAAmB,QAAQ,mBAAmB,YAAY,CAAC;AACtF,0BAAgB,YAAY,SAAS;AACrC;;AAGF,YAAI,WAAW,kBAAkB,GAAG;AAClC,cAAI,4DAA4D,YAAY,kBAAkB,GAAG;AAC/F,kBAAM,aAAa,sDAAyD,kBAAkB;AAE9F,yDAA6C,UAAU;AAEvD,4BAAgB,YAAY,UAAU;AACtC;;AAGF,cAAI,WAAW,iBAAiB;AAC9B,kBAAM,KAAI,IAAI,UAAU,yDAAyD;AACjF,8CAAkC,YAAY,EAAC;AAE/C,4BAAgB,YAAY,EAAC;AAC7B;;;AAIJ,mBAAW,kBAAkB,KAAK,kBAAkB;AAEpD,yCAAoC,QAAQ,eAAe;AAC3D,qDAA6C,UAAU;MACzD;AAEA,gEAA0D,YACA,iBAAmC;AAG3F,cAAM,SAAS,WAAW;AAC1B,YAAI,4BAA4B,MAAM,GAAG;AACvC,iBAAO,qCAAqC,MAAM,IAAI,GAAG;AACvD,kBAAM,qBAAqB,iDAAiD,UAAU;AACtF,iEAAqD,QAAQ,kBAAkB;;;MAGrF;AAEA,kEAA4D,YACA,cACA,oBAAsC;AAGhG,+DAAuD,YAAY,cAAc,kBAAkB;AAEnG,YAAI,mBAAmB,cAAc,mBAAmB,aAAa;AACnE;;AAGF,yDAAiD,UAAU;AAE3D,cAAM,gBAAgB,mBAAmB,cAAc,mBAAmB;AAC1E,YAAI,gBAAgB,GAAG;AACrB,gBAAM,MAAM,mBAAmB,aAAa,mBAAmB;AAC/D,gBAAM,YAAY,iBAAiB,mBAAmB,QAAQ,MAAM,eAAe,GAAG;AACtF,0DAAgD,YAAY,WAAW,GAAG,UAAU,UAAU;;AAGhG,2BAAmB,eAAe;AAClC,6DAAqD,WAAW,+BAA+B,kBAAkB;AAEjH,yEAAiE,UAAU;MAC7E;AAEA,2DAAqD,YAA0C,cAAoB;AACjH,cAAM,kBAAkB,WAAW,kBAAkB,KAAI;AAGzD,0DAAkD,UAAU;AAE5D,cAAM,SAAQ,WAAW,8BAA8B;AACvD,YAAI,WAAU,UAAU;AAEtB,2DAAiD,UAA2B;eACvE;AAGL,6DAAmD,YAAY,cAAc,eAAe;;AAG9F,qDAA6C,UAAU;MACzD;AAEA,gEACE,YAAwC;AAGxC,cAAM,aAAa,WAAW,kBAAkB,MAAK;AACrD,eAAO;MACT;AAEA,0DAAoD,YAAwC;AAC1F,cAAM,SAAS,WAAW;AAE1B,YAAI,OAAO,WAAW,YAAY;AAChC,iBAAO;;AAGT,YAAI,WAAW,iBAAiB;AAC9B,iBAAO;;AAGT,YAAI,CAAC,WAAW,UAAU;AACxB,iBAAO;;AAGT,YAAI,+BAA+B,MAAM,KAAK,iCAAiC,MAAM,IAAI,GAAG;AAC1F,iBAAO;;AAGT,YAAI,4BAA4B,MAAM,KAAK,qCAAqC,MAAM,IAAI,GAAG;AAC3F,iBAAO;;AAGT,cAAM,cAAc,2CAA2C,UAAU;AAEzE,YAAI,cAAe,GAAG;AACpB,iBAAO;;AAGT,eAAO;MACT;AAEA,2DAAqD,YAAwC;AAC3F,mBAAW,iBAAiB;AAC5B,mBAAW,mBAAmB;MAChC;iDAIkD,YAAwC;AACxF,cAAM,SAAS,WAAW;AAE1B,YAAI,WAAW,mBAAmB,OAAO,WAAW,YAAY;AAC9D;;AAGF,YAAI,WAAW,kBAAkB,GAAG;AAClC,qBAAW,kBAAkB;AAE7B;;AAGF,YAAI,WAAW,kBAAkB,SAAS,GAAG;AAC3C,gBAAM,uBAAuB,WAAW,kBAAkB,KAAI;AAC9D,cAAI,qBAAqB,cAAc,GAAG;AACxC,kBAAM,KAAI,IAAI,UAAU,yDAAyD;AACjF,8CAAkC,YAAY,EAAC;AAE/C,kBAAM;;;AAIV,oDAA4C,UAAU;AACtD,4BAAoB,MAAM;MAC5B;mDAEoD,YAA0C,OAAsB;AAClH,cAAM,SAAS,WAAW;AAE1B,YAAI,WAAW,mBAAmB,OAAO,WAAW,YAAY;AAC9D;;AAGF,cAAM,SAAS,MAAM;AACrB,cAAM,aAAa,MAAM;AACzB,cAAM,aAAa,MAAM;AAIzB,cAAM,oBAAoB,oBAAoB,MAAM;AAEpD,YAAI,WAAW,kBAAkB,SAAS,GAAG;AAC3C,gBAAM,uBAAuB,WAAW,kBAAkB,KAAI;AAC9D,cAAI,iBAAiB,qBAAqB,MAAM;AAAG;AAKnD,+BAAqB,SAAS,oBAAoB,qBAAqB,MAAM;;AAG/E,0DAAkD,UAAU;AAE5D,YAAI,+BAA+B,MAAM,GAAG;AAC1C,cAAI,iCAAiC,MAAM,MAAM,GAAG;AAElD,4DAAgD,YAAY,mBAAmB,YAAY,UAAU;iBAChG;AAEL,gBAAI,WAAW,kBAAkB,SAAS,GAAG;AAE3C,+DAAiD,UAAU;;AAE7D,kBAAM,kBAAkB,IAAI,WAAW,mBAAmB,YAAY,UAAU;AAChF,6CAAiC,QAAQ,iBAAiB,KAAK;;mBAExD,4BAA4B,MAAM,GAAG;AAE9C,0DAAgD,YAAY,mBAAmB,YAAY,UAAU;AACrG,2EAAiE,UAAU;eACtE;AAEL,0DAAgD,YAAY,mBAAmB,YAAY,UAAU;;AAGvG,qDAA6C,UAAU;MACzD;iDAEkD,YAA0C,IAAM;AAChG,cAAM,SAAS,WAAW;AAE1B,YAAI,OAAO,WAAW,YAAY;AAChC;;AAGF,0DAAkD,UAAU;AAE5D,mBAAW,UAAU;AACrB,oDAA4C,UAAU;AACtD,4BAAoB,QAAQ,EAAC;MAC/B;0DAGE,YAAwC;AAExC,YAAI,WAAW,iBAAiB,QAAQ,WAAW,kBAAkB,SAAS,GAAG;AAC/E,gBAAM,kBAAkB,WAAW,kBAAkB,KAAI;AACzD,gBAAM,OAAO,IAAI,WAAW,gBAAgB,QAChB,gBAAgB,aAAa,gBAAgB,aAC7C,gBAAgB,aAAa,gBAAgB,WAAW;AAEpF,gBAAM,cAAyC,OAAO,OAAO,0BAA0B,SAAS;AAChG,yCAA+B,aAAa,YAAY,IAAI;AAC5D,qBAAW,eAAe;;AAE5B,eAAO,WAAW;MACpB;AAEA,0DAAoD,YAAwC;AAC1F,cAAM,SAAQ,WAAW,8BAA8B;AAEvD,YAAI,WAAU,WAAW;AACvB,iBAAO;;AAET,YAAI,WAAU,UAAU;AACtB,iBAAO;;AAGT,eAAO,WAAW,eAAe,WAAW;MAC9C;mDAEoD,YAA0C,cAAoB;AAGhH,cAAM,kBAAkB,WAAW,kBAAkB,KAAI;AACzD,cAAM,SAAQ,WAAW,8BAA8B;AAEvD,YAAI,WAAU,UAAU;AACtB,cAAI,iBAAiB,GAAG;AACtB,kBAAM,IAAI,UAAU,kEAAkE;;eAEnF;AAEL,cAAI,iBAAiB,GAAG;AACtB,kBAAM,IAAI,UAAU,iFAAiF;;AAEvG,cAAI,gBAAgB,cAAc,eAAe,gBAAgB,YAAY;AAC3E,kBAAM,IAAI,WAAW,2BAA2B;;;AAIpD,wBAAgB,SAAS,oBAAoB,gBAAgB,MAAM;AAEnE,oDAA4C,YAAY,YAAY;MACtE;8DAE+D,YACA,MAAqB;AAIlF,cAAM,kBAAkB,WAAW,kBAAkB,KAAI;AACzD,cAAM,SAAQ,WAAW,8BAA8B;AAEvD,YAAI,WAAU,UAAU;AACtB,cAAI,KAAK,eAAe,GAAG;AACzB,kBAAM,IAAI,UAAU,kFAAmF;;eAEpG;AAEL,cAAI,KAAK,eAAe,GAAG;AACzB,kBAAM,IAAI,UACR,iGAAkG;;;AAKxG,YAAI,gBAAgB,aAAa,gBAAgB,gBAAgB,KAAK,YAAY;AAChF,gBAAM,IAAI,WAAW,yDAAyD;;AAEhF,YAAI,gBAAgB,qBAAqB,KAAK,OAAO,YAAY;AAC/D,gBAAM,IAAI,WAAW,4DAA4D;;AAEnF,YAAI,gBAAgB,cAAc,KAAK,aAAa,gBAAgB,YAAY;AAC9E,gBAAM,IAAI,WAAW,yDAAyD;;AAGhF,cAAM,iBAAiB,KAAK;AAC5B,wBAAgB,SAAS,oBAAoB,KAAK,MAAM;AACxD,oDAA4C,YAAY,cAAc;MACxE;iDAEkD,QACA,YACA,gBACA,eACA,iBACA,eACA,uBAAyC;AAOzF,mBAAW,gCAAgC;AAE3C,mBAAW,aAAa;AACxB,mBAAW,WAAW;AAEtB,mBAAW,eAAe;AAG1B,mBAAW,SAAS,WAAW,kBAAkB;AACjD,mBAAW,UAAU;AAErB,mBAAW,kBAAkB;AAC7B,mBAAW,WAAW;AAEtB,mBAAW,eAAe;AAE1B,mBAAW,iBAAiB;AAC5B,mBAAW,mBAAmB;AAE9B,mBAAW,yBAAyB;AAEpC,mBAAW,oBAAoB,IAAI,YAAW;AAE9C,eAAO,4BAA4B;AAEnC,cAAM,cAAc,eAAc;AAClC,oBACE,oBAAoB,WAAW,GAC/B,MAAA;AACE,qBAAW,WAAW;AAKtB,uDAA6C,UAAU;WAEzD,QAAC;AACC,4CAAkC,YAAY,EAAC;SAChD;MAEL;qEAGE,QACA,sBACA,eAAqB;AAErB,cAAM,aAA2C,OAAO,OAAO,6BAA6B,SAAS;AAErG,YAAI,iBAAiD,MAAM;AAC3D,YAAI,gBAAqC,MAAM,oBAAoB,MAAS;AAC5E,YAAI,kBAAkD,MAAM,oBAAoB,MAAS;AAEzF,YAAI,qBAAqB,UAAU,QAAW;AAC5C,2BAAiB,MAAM,qBAAqB,MAAO,UAAU;;AAE/D,YAAI,qBAAqB,SAAS,QAAW;AAC3C,0BAAgB,MAAM,qBAAqB,KAAM,UAAU;;AAE7D,YAAI,qBAAqB,WAAW,QAAW;AAC7C,4BAAkB,YAAU,qBAAqB,OAAQ,MAAM;;AAGjE,cAAM,wBAAwB,qBAAqB;AACnD,YAAI,0BAA0B,GAAG;AAC/B,gBAAM,IAAI,UAAU,8CAA8C;;AAGpE,0CACE,QAAQ,YAAY,gBAAgB,eAAe,iBAAiB,eAAe,qBAAqB;MAE5G;AAEA,8CAAwC,SACA,YACA,MAAqB;AAK3D,gBAAQ,0CAA0C;AAClD,gBAAQ,QAAQ;MAClB;AAIA,8CAAwC,OAAY;AAClD,eAAO,IAAI,UACT,uCAAuC,uDAAsD;MACjG;AAIA,uDAAiD,OAAY;AAC3D,eAAO,IAAI,UACT,0CAA0C,0DAAyD;MACvG;+CCr/BgD,QAA0B;AACxE,eAAO,IAAI,yBAAyB,MAAM;MAC5C;gDAI4E,QACA,iBAAmC;AAI5G,eAAO,QAAsC,kBAAkB,KAAK,eAAe;MACtF;oDAEqD,QACA,OACA,MAAa;AAChE,cAAM,SAAS,OAAO;AAItB,cAAM,kBAAkB,OAAO,kBAAkB,MAAK;AACtD,YAAI,MAAM;AACR,0BAAgB,YAAY,KAAK;eAC5B;AACL,0BAAgB,YAAY,KAAK;;MAErC;oDAEqD,QAA0B;AAC7E,eAAQ,OAAO,QAAqC,kBAAkB;MACxE;2CAE4C,QAA0B;AACpE,cAAM,SAAS,OAAO;AAEtB,YAAI,WAAW,QAAW;AACxB,iBAAO;;AAGT,YAAI,CAAC,2BAA2B,MAAM,GAAG;AACvC,iBAAO;;AAGT,eAAO;MACT;YAiBa,yBAAwB;QAYnC,YAAY,QAA0B;AACpC,iCAAuB,QAAQ,GAAG,0BAA0B;AAC5D,+BAAqB,QAAQ,iBAAiB;AAE9C,cAAI,uBAAuB,MAAM,GAAG;AAClC,kBAAM,IAAI,UAAU,6EAA6E;;AAGnG,cAAI,CAAC,+BAA+B,OAAO,yBAAyB,GAAG;AACrE,kBAAM,IAAI,UAAU,6FACV;;AAGZ,gDAAsC,MAAM,MAAM;AAElD,eAAK,oBAAoB,IAAI,YAAW;;QAO1C,IAAI,SAAM;AACR,cAAI,CAAC,2BAA2B,IAAI,GAAG;AACrC,mBAAO,oBAAoB,8BAA8B,QAAQ,CAAC;;AAGpE,iBAAO,KAAK;;QAMd,OAAO,SAAc,QAAS;AAC5B,cAAI,CAAC,2BAA2B,IAAI,GAAG;AACrC,mBAAO,oBAAoB,8BAA8B,QAAQ,CAAC;;AAGpE,cAAI,KAAK,yBAAyB,QAAW;AAC3C,mBAAO,oBAAoB,oBAAoB,QAAQ,CAAC;;AAG1D,iBAAO,kCAAkC,MAAM,MAAM;;QAQvD,KAAgC,MAAO;AACrC,cAAI,CAAC,2BAA2B,IAAI,GAAG;AACrC,mBAAO,oBAAoB,8BAA8B,MAAM,CAAC;;AAGlE,cAAI,CAAC,YAAY,OAAO,IAAI,GAAG;AAC7B,mBAAO,oBAAoB,IAAI,UAAU,mCAAmC,CAAC;;AAE/E,cAAI,KAAK,eAAe,GAAG;AACzB,mBAAO,oBAAoB,IAAI,UAAU,oCAAoC,CAAC;;AAEhF,cAAI,KAAK,OAAO,eAAe,GAAG;AAChC,mBAAO,oBAAoB,IAAI,UAAU,6CAA6C,CAAC;;AAEzF,cAAI,iBAAiB,KAAK,MAAM;AAAG;AAInC,cAAI,KAAK,yBAAyB,QAAW;AAC3C,mBAAO,oBAAoB,oBAAoB,WAAW,CAAC;;AAG7D,cAAI;AACJ,cAAI;AACJ,gBAAM,UAAU,WAA4C,CAAC,UAAS,WAAM;AAC1E,6BAAiB;AACjB,4BAAgB;WACjB;AACD,gBAAM,kBAAsC;YAC1C,aAAa,WAAS,eAAe,EAAE,OAAO,OAAO,MAAM,MAAK,CAAE;YAClE,aAAa,WAAS,eAAe,EAAE,OAAO,OAAO,MAAM,KAAI,CAAE;YACjE,aAAa,QAAK,cAAc,EAAC;;AAEnC,uCAA6B,MAAM,MAAM,eAAe;AACxD,iBAAO;;QAYT,cAAW;AACT,cAAI,CAAC,2BAA2B,IAAI,GAAG;AACrC,kBAAM,8BAA8B,aAAa;;AAGnD,cAAI,KAAK,yBAAyB,QAAW;AAC3C;;AAGF,cAAI,KAAK,kBAAkB,SAAS,GAAG;AACrC,kBAAM,IAAI,UAAU,qFAAqF;;AAG3G,6CAAmC,IAAI;;;AAI3C,aAAO,iBAAiB,yBAAyB,WAAW;QAC1D,QAAQ,EAAE,YAAY,KAAI;QAC1B,MAAM,EAAE,YAAY,KAAI;QACxB,aAAa,EAAE,YAAY,KAAI;QAC/B,QAAQ,EAAE,YAAY,KAAI;OAC3B;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,yBAAyB,WAAW,eAAO,aAAa;UAC5E,OAAO;UACP,cAAc;SACf;;0CAKwC,IAAM;AAC/C,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,mBAAmB,GAAG;AACjE,iBAAO;;AAGT,eAAO,cAAa;MACtB;4CAGE,QACA,MACA,iBAAmC;AAEnC,cAAM,SAAS,OAAO;AAItB,eAAO,aAAa;AAEpB,YAAI,OAAO,WAAW,WAAW;AAC/B,0BAAgB,YAAY,OAAO,YAAY;eAC1C;AACL,+CACE,OAAO,2BACP,MACA,eAAe;;MAGrB;AAIA,6CAAuC,OAAY;AACjD,eAAO,IAAI,UACT,sCAAsC,sDAAqD;MAC/F;oCCjRqC,UAA2B,YAAkB;AAChF,cAAM,EAAE,kBAAkB;AAE1B,YAAI,kBAAkB,QAAW;AAC/B,iBAAO;;AAGT,YAAI,YAAY,aAAa,KAAK,gBAAgB,GAAG;AACnD,gBAAM,IAAI,WAAW,uBAAuB;;AAG9C,eAAO;MACT;oCAEwC,UAA4B;AAClE,cAAM,EAAE,SAAS;AAEjB,YAAI,CAAC,MAAM;AACT,iBAAO,MAAM;;AAGf,eAAO;MACT;sCCtB0C,MACA,SAAe;AACvD,yBAAiB,MAAM,OAAO;AAC9B,cAAM,gBAAgB,SAAI,QAAJ,SAAI,SAAA,SAAJ,KAAM;AAC5B,cAAM,OAAO,SAAI,QAAJ,SAAI,SAAA,SAAJ,KAAM;AACnB,eAAO;UACL,eAAe,kBAAkB,SAAY,SAAY,0BAA0B,aAAa;UAChG,MAAM,SAAS,SAAY,SAAY,2BAA2B,MAAM,GAAG,gCAAgC;;MAE/G;AAEA,0CAAuC,IACA,SAAe;AACpD,uBAAe,IAAI,OAAO;AAC1B,eAAO,WAAS,0BAA0B,GAAG,KAAK,CAAC;MACrD;qCCNyC,UACA,SAAe;AACtD,yBAAiB,UAAU,OAAO;AAClC,cAAM,QAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACxB,cAAM,QAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACxB,cAAM,QAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACxB,cAAM,OAAO,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACvB,cAAM,QAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACxB,eAAO;UACL,OAAO,UAAU,SACf,SACA,mCAAmC,OAAO,UAAW,GAAG,iCAAiC;UAC3F,OAAO,UAAU,SACf,SACA,mCAAmC,OAAO,UAAW,GAAG,iCAAiC;UAC3F,OAAO,UAAU,SACf,SACA,mCAAmC,OAAO,UAAW,GAAG,iCAAiC;UAC3F,OAAO,UAAU,SACf,SACA,mCAAmC,OAAO,UAAW,GAAG,iCAAiC;UAC3F;;MAEJ;AAEA,kDACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,WAAgB,YAAY,IAAI,UAAU,CAAC,MAAM,CAAC;MAC5D;AAEA,kDACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,MAAM,YAAY,IAAI,UAAU,CAAA,CAAE;MAC3C;AAEA,kDACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,eAAgD,YAAY,IAAI,UAAU,CAAC,UAAU,CAAC;MAChG;AAEA,kDACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,OAAU,eAAgD,YAAY,IAAI,UAAU,CAAC,OAAO,UAAU,CAAC;MACjH;oCCrEqC,IAAY,SAAe;AAC9D,YAAI,CAAC,iBAAiB,EAAC,GAAG;AACxB,gBAAM,IAAI,UAAU,GAAG,kCAAkC;;MAE7D;8BCsB8B,OAAc;AAC1C,YAAI,OAAO,UAAU,YAAY,UAAU,MAAM;AAC/C,iBAAO;;AAET,YAAI;AACF,iBAAO,OAAQ,MAAsB,YAAY;iBACjD,IAAA;AAEA,iBAAO;;MAEX;AAsBA,YAAM,0BAA0B,OAAQ,oBAA4B;uCAO/B;AACnC,YAAI,yBAAyB;AAC3B,iBAAO,IAAK,gBAA8C;;AAE5D,eAAO;MACT;ACdA,YAAM,eAAc;QAuBlB,YAAY,oBAA0D,CAAA,GAC1D,cAAqD,CAAA,GAAE;AACjE,cAAI,sBAAsB,QAAW;AACnC,gCAAoB;iBACf;AACL,yBAAa,mBAAmB,iBAAiB;;AAGnD,gBAAM,WAAW,uBAAuB,aAAa,kBAAkB;AACvE,gBAAM,iBAAiB,sBAAsB,mBAAmB,iBAAiB;AAEjF,mCAAyB,IAAI;AAE7B,gBAAM,OAAO,eAAe;AAC5B,cAAI,SAAS,QAAW;AACtB,kBAAM,IAAI,WAAW,2BAA2B;;AAGlD,gBAAM,gBAAgB,qBAAqB,QAAQ;AACnD,gBAAM,gBAAgB,qBAAqB,UAAU,CAAC;AAEtD,iEAAuD,MAAM,gBAAgB,eAAe,aAAa;;QAM3G,IAAI,SAAM;AACR,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,kBAAM,4BAA0B,QAAQ;;AAG1C,iBAAO,uBAAuB,IAAI;;QAYpC,MAAM,SAAc,QAAS;AAC3B,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,mBAAO,oBAAoB,4BAA0B,OAAO,CAAC;;AAG/D,cAAI,uBAAuB,IAAI,GAAG;AAChC,mBAAO,oBAAoB,IAAI,UAAU,iDAAiD,CAAC;;AAG7F,iBAAO,oBAAoB,MAAM,MAAM;;QAWzC,QAAK;AACH,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,mBAAO,oBAAoB,4BAA0B,OAAO,CAAC;;AAG/D,cAAI,uBAAuB,IAAI,GAAG;AAChC,mBAAO,oBAAoB,IAAI,UAAU,iDAAiD,CAAC;;AAG7F,cAAI,oCAAoC,IAAI,GAAG;AAC7C,mBAAO,oBAAoB,IAAI,UAAU,wCAAwC,CAAC;;AAGpF,iBAAO,oBAAoB,IAAI;;QAWjC,YAAS;AACP,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,kBAAM,4BAA0B,WAAW;;AAG7C,iBAAO,mCAAmC,IAAI;;;AAIlD,aAAO,iBAAiB,eAAe,WAAW;QAChD,OAAO,EAAE,YAAY,KAAI;QACzB,OAAO,EAAE,YAAY,KAAI;QACzB,WAAW,EAAE,YAAY,KAAI;QAC7B,QAAQ,EAAE,YAAY,KAAI;OAC3B;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,eAAe,WAAW,eAAO,aAAa;UAClE,OAAO;UACP,cAAc;SACf;;AAwBH,kDAA+C,QAAyB;AACtE,eAAO,IAAI,4BAA4B,MAAM;MAC/C;AAGA,oCAAiC,gBACA,gBACA,gBACA,gBACA,gBAAgB,GAChB,gBAAgD,MAAM,GAAC;AAGtF,cAAM,SAA4B,OAAO,OAAO,eAAe,SAAS;AACxE,iCAAyB,MAAM;AAE/B,cAAM,aAAiD,OAAO,OAAO,gCAAgC,SAAS;AAE9G,6CAAqC,QAAQ,YAAY,gBAAgB,gBAAgB,gBACpD,gBAAgB,eAAe,aAAa;AACjF,eAAO;MACT;AAEA,wCAAqC,QAAyB;AAC5D,eAAO,SAAS;AAIhB,eAAO,eAAe;AAEtB,eAAO,UAAU;AAIjB,eAAO,4BAA4B;AAInC,eAAO,iBAAiB,IAAI,YAAW;AAIvC,eAAO,wBAAwB;AAI/B,eAAO,gBAAgB;AAIvB,eAAO,wBAAwB;AAG/B,eAAO,uBAAuB;AAG9B,eAAO,gBAAgB;MACzB;AAEA,gCAA0B,IAAU;AAClC,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,2BAA2B,GAAG;AACzE,iBAAO;;AAGT,eAAO,cAAa;MACtB;AAEA,sCAAgC,QAAsB;AAGpD,YAAI,OAAO,YAAY,QAAW;AAChC,iBAAO;;AAGT,eAAO;MACT;AAEA,mCAA6B,QAAwB,QAAW;;AAC9D,YAAI,OAAO,WAAW,YAAY,OAAO,WAAW,WAAW;AAC7D,iBAAO,oBAAoB,MAAS;;AAEtC,eAAO,0BAA0B,eAAe;AAChD,QAAA,MAAA,OAAO,0BAA0B,sBAAgB,QAAA,OAAA,SAAA,SAAA,GAAE,MAAK;AAKxD,cAAM,SAAQ,OAAO;AAErB,YAAI,WAAU,YAAY,WAAU,WAAW;AAC7C,iBAAO,oBAAoB,MAAS;;AAEtC,YAAI,OAAO,yBAAyB,QAAW;AAC7C,iBAAO,OAAO,qBAAqB;;AAKrC,YAAI,qBAAqB;AACzB,YAAI,WAAU,YAAY;AACxB,+BAAqB;AAErB,mBAAS;;AAGX,cAAM,UAAU,WAAsB,CAAC,UAAS,WAAM;AACpD,iBAAO,uBAAuB;YAC5B,UAAU;YACV,UAAU;YACV,SAAS;YACT,SAAS;YACT,qBAAqB;;SAExB;AACD,eAAO,qBAAsB,WAAW;AAExC,YAAI,CAAC,oBAAoB;AACvB,sCAA4B,QAAQ,MAAM;;AAG5C,eAAO;MACT;AAEA,mCAA6B,QAA2B;AACtD,cAAM,SAAQ,OAAO;AACrB,YAAI,WAAU,YAAY,WAAU,WAAW;AAC7C,iBAAO,oBAAoB,IAAI,UAC7B,kBAAkB,iEAAgE,CAAC;;AAMvF,cAAM,UAAU,WAAsB,CAAC,UAAS,WAAM;AACpD,gBAAM,eAA6B;YACjC,UAAU;YACV,SAAS;;AAGX,iBAAO,gBAAgB;SACxB;AAED,cAAM,SAAS,OAAO;AACtB,YAAI,WAAW,UAAa,OAAO,iBAAiB,WAAU,YAAY;AACxE,2CAAiC,MAAM;;AAGzC,6CAAqC,OAAO,yBAAyB;AAErE,eAAO;MACT;AAIA,6CAAuC,QAAsB;AAI3D,cAAM,UAAU,WAAsB,CAAC,UAAS,WAAM;AACpD,gBAAM,eAA6B;YACjC,UAAU;YACV,SAAS;;AAGX,iBAAO,eAAe,KAAK,YAAY;SACxC;AAED,eAAO;MACT;AAEA,+CAAyC,QAAwB,OAAU;AACzE,cAAM,SAAQ,OAAO;AAErB,YAAI,WAAU,YAAY;AACxB,sCAA4B,QAAQ,KAAK;AACzC;;AAIF,qCAA6B,MAAM;MACrC;AAEA,2CAAqC,QAAwB,QAAW;AAItE,cAAM,aAAa,OAAO;AAG1B,eAAO,SAAS;AAChB,eAAO,eAAe;AACtB,cAAM,SAAS,OAAO;AACtB,YAAI,WAAW,QAAW;AACxB,gEAAsD,QAAQ,MAAM;;AAGtE,YAAI,CAAC,yCAAyC,MAAM,KAAK,WAAW,UAAU;AAC5E,uCAA6B,MAAM;;MAEvC;AAEA,4CAAsC,QAAsB;AAG1D,eAAO,SAAS;AAChB,eAAO,0BAA0B,YAAW;AAE5C,cAAM,cAAc,OAAO;AAC3B,eAAO,eAAe,QAAQ,kBAAY;AACxC,uBAAa,QAAQ,WAAW;SACjC;AACD,eAAO,iBAAiB,IAAI,YAAW;AAEvC,YAAI,OAAO,yBAAyB,QAAW;AAC7C,4DAAkD,MAAM;AACxD;;AAGF,cAAM,eAAe,OAAO;AAC5B,eAAO,uBAAuB;AAE9B,YAAI,aAAa,qBAAqB;AACpC,uBAAa,QAAQ,WAAW;AAChC,4DAAkD,MAAM;AACxD;;AAGF,cAAM,UAAU,OAAO,0BAA0B,YAAY,aAAa,OAAO;AACjF,oBACE,SACA,MAAA;AACE,uBAAa,SAAQ;AACrB,4DAAkD,MAAM;WAE1D,CAAC,WAAW;AACV,uBAAa,QAAQ,MAAM;AAC3B,4DAAkD,MAAM;SACzD;MACL;AAEA,iDAA2C,QAAsB;AAE/D,eAAO,sBAAuB,SAAS,MAAS;AAChD,eAAO,wBAAwB;MACjC;AAEA,0DAAoD,QAAwB,OAAU;AAEpF,eAAO,sBAAuB,QAAQ,KAAK;AAC3C,eAAO,wBAAwB;AAI/B,wCAAgC,QAAQ,KAAK;MAC/C;AAEA,iDAA2C,QAAsB;AAE/D,eAAO,sBAAuB,SAAS,MAAS;AAChD,eAAO,wBAAwB;AAE/B,cAAM,SAAQ,OAAO;AAIrB,YAAI,WAAU,YAAY;AAExB,iBAAO,eAAe;AACtB,cAAI,OAAO,yBAAyB,QAAW;AAC7C,mBAAO,qBAAqB,SAAQ;AACpC,mBAAO,uBAAuB;;;AAIlC,eAAO,SAAS;AAEhB,cAAM,SAAS,OAAO;AACtB,YAAI,WAAW,QAAW;AACxB,4CAAkC,MAAM;;MAK5C;AAEA,0DAAoD,QAAwB,OAAU;AAEpF,eAAO,sBAAuB,QAAQ,KAAK;AAC3C,eAAO,wBAAwB;AAK/B,YAAI,OAAO,yBAAyB,QAAW;AAC7C,iBAAO,qBAAqB,QAAQ,KAAK;AACzC,iBAAO,uBAAuB;;AAEhC,wCAAgC,QAAQ,KAAK;MAC/C;AAGA,mDAA6C,QAAsB;AACjE,YAAI,OAAO,kBAAkB,UAAa,OAAO,0BAA0B,QAAW;AACpF,iBAAO;;AAGT,eAAO;MACT;AAEA,wDAAkD,QAAsB;AACtE,YAAI,OAAO,0BAA0B,UAAa,OAAO,0BAA0B,QAAW;AAC5F,iBAAO;;AAGT,eAAO;MACT;AAEA,sDAAgD,QAAsB;AAGpE,eAAO,wBAAwB,OAAO;AACtC,eAAO,gBAAgB;MACzB;AAEA,2DAAqD,QAAsB;AAGzE,eAAO,wBAAwB,OAAO,eAAe,MAAK;MAC5D;AAEA,iEAA2D,QAAsB;AAE/E,YAAI,OAAO,kBAAkB,QAAW;AAGtC,iBAAO,cAAc,QAAQ,OAAO,YAAY;AAChD,iBAAO,gBAAgB;;AAEzB,cAAM,SAAS,OAAO;AACtB,YAAI,WAAW,QAAW;AACxB,2CAAiC,QAAQ,OAAO,YAAY;;MAEhE;AAEA,gDAA0C,QAAwB,cAAqB;AAIrF,cAAM,SAAS,OAAO;AACtB,YAAI,WAAW,UAAa,iBAAiB,OAAO,eAAe;AACjE,cAAI,cAAc;AAChB,2CAA+B,MAAM;iBAChC;AAGL,6CAAiC,MAAM;;;AAI3C,eAAO,gBAAgB;MACzB;YAOa,4BAA2B;QAoBtC,YAAY,QAAyB;AACnC,iCAAuB,QAAQ,GAAG,6BAA6B;AAC/D,+BAAqB,QAAQ,iBAAiB;AAE9C,cAAI,uBAAuB,MAAM,GAAG;AAClC,kBAAM,IAAI,UAAU,6EAA6E;;AAGnG,eAAK,uBAAuB;AAC5B,iBAAO,UAAU;AAEjB,gBAAM,SAAQ,OAAO;AAErB,cAAI,WAAU,YAAY;AACxB,gBAAI,CAAC,oCAAoC,MAAM,KAAK,OAAO,eAAe;AACxE,kDAAoC,IAAI;mBACnC;AACL,4DAA8C,IAAI;;AAGpD,iDAAqC,IAAI;qBAChC,WAAU,YAAY;AAC/B,0DAA8C,MAAM,OAAO,YAAY;AACvE,iDAAqC,IAAI;qBAChC,WAAU,UAAU;AAC7B,0DAA8C,IAAI;AAClD,2DAA+C,IAAI;iBAC9C;AAGL,kBAAM,cAAc,OAAO;AAC3B,0DAA8C,MAAM,WAAW;AAC/D,2DAA+C,MAAM,WAAW;;;QAQpE,IAAI,SAAM;AACR,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,iCAAiC,QAAQ,CAAC;;AAGvE,iBAAO,KAAK;;QAWd,IAAI,cAAW;AACb,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,kBAAM,iCAAiC,aAAa;;AAGtD,cAAI,KAAK,yBAAyB,QAAW;AAC3C,kBAAM,2BAA2B,aAAa;;AAGhD,iBAAO,0CAA0C,IAAI;;QAWvD,IAAI,QAAK;AACP,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,iCAAiC,OAAO,CAAC;;AAGtE,iBAAO,KAAK;;QAMd,MAAM,SAAc,QAAS;AAC3B,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,iCAAiC,OAAO,CAAC;;AAGtE,cAAI,KAAK,yBAAyB,QAAW;AAC3C,mBAAO,oBAAoB,2BAA2B,OAAO,CAAC;;AAGhE,iBAAO,iCAAiC,MAAM,MAAM;;QAMtD,QAAK;AACH,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,iCAAiC,OAAO,CAAC;;AAGtE,gBAAM,SAAS,KAAK;AAEpB,cAAI,WAAW,QAAW;AACxB,mBAAO,oBAAoB,2BAA2B,OAAO,CAAC;;AAGhE,cAAI,oCAAoC,MAAM,GAAG;AAC/C,mBAAO,oBAAoB,IAAI,UAAU,wCAAwC,CAAC;;AAGpF,iBAAO,iCAAiC,IAAI;;QAa9C,cAAW;AACT,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,kBAAM,iCAAiC,aAAa;;AAGtD,gBAAM,SAAS,KAAK;AAEpB,cAAI,WAAW,QAAW;AACxB;;AAKF,6CAAmC,IAAI;;QAazC,MAAM,QAAW,QAAU;AACzB,cAAI,CAAC,8BAA8B,IAAI,GAAG;AACxC,mBAAO,oBAAoB,iCAAiC,OAAO,CAAC;;AAGtE,cAAI,KAAK,yBAAyB,QAAW;AAC3C,mBAAO,oBAAoB,2BAA2B,UAAU,CAAC;;AAGnE,iBAAO,iCAAiC,MAAM,KAAK;;;AAIvD,aAAO,iBAAiB,4BAA4B,WAAW;QAC7D,OAAO,EAAE,YAAY,KAAI;QACzB,OAAO,EAAE,YAAY,KAAI;QACzB,aAAa,EAAE,YAAY,KAAI;QAC/B,OAAO,EAAE,YAAY,KAAI;QACzB,QAAQ,EAAE,YAAY,KAAI;QAC1B,aAAa,EAAE,YAAY,KAAI;QAC/B,OAAO,EAAE,YAAY,KAAI;OAC1B;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,4BAA4B,WAAW,eAAO,aAAa;UAC/E,OAAO;UACP,cAAc;SACf;;AAKH,6CAAgD,IAAM;AACpD,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,sBAAsB,GAAG;AACpE,iBAAO;;AAGT,eAAO,cAAa;MACtB;AAIA,gDAA0C,QAAqC,QAAW;AACxF,cAAM,SAAS,OAAO;AAItB,eAAO,oBAAoB,QAAQ,MAAM;MAC3C;AAEA,gDAA0C,QAAmC;AAC3E,cAAM,SAAS,OAAO;AAItB,eAAO,oBAAoB,MAAM;MACnC;AAEA,oEAA8D,QAAmC;AAC/F,cAAM,SAAS,OAAO;AAItB,cAAM,SAAQ,OAAO;AACrB,YAAI,oCAAoC,MAAM,KAAK,WAAU,UAAU;AACrE,iBAAO,oBAAoB,MAAS;;AAGtC,YAAI,WAAU,WAAW;AACvB,iBAAO,oBAAoB,OAAO,YAAY;;AAKhD,eAAO,iCAAiC,MAAM;MAChD;AAEA,sEAAgE,QAAqC,OAAU;AAC7G,YAAI,OAAO,wBAAwB,WAAW;AAC5C,2CAAiC,QAAQ,KAAK;eACzC;AACL,oDAA0C,QAAQ,KAAK;;MAE3D;AAEA,qEAA+D,QAAqC,OAAU;AAC5G,YAAI,OAAO,uBAAuB,WAAW;AAC3C,0CAAgC,QAAQ,KAAK;eACxC;AACL,mDAAyC,QAAQ,KAAK;;MAE1D;AAEA,yDAAmD,QAAmC;AACpF,cAAM,SAAS,OAAO;AACtB,cAAM,SAAQ,OAAO;AAErB,YAAI,WAAU,aAAa,WAAU,YAAY;AAC/C,iBAAO;;AAGT,YAAI,WAAU,UAAU;AACtB,iBAAO;;AAGT,eAAO,8CAA8C,OAAO,yBAAyB;MACvF;AAEA,kDAA4C,QAAmC;AAC7E,cAAM,SAAS,OAAO;AAItB,cAAM,gBAAgB,IAAI,UACxB,kFAAkF;AAEpF,8DAAsD,QAAQ,aAAa;AAI3E,+DAAuD,QAAQ,aAAa;AAE5E,eAAO,UAAU;AACjB,eAAO,uBAAuB;MAChC;AAEA,gDAA6C,QAAwC,OAAQ;AAC3F,cAAM,SAAS,OAAO;AAItB,cAAM,aAAa,OAAO;AAE1B,cAAM,YAAY,4CAA4C,YAAY,KAAK;AAE/E,YAAI,WAAW,OAAO,sBAAsB;AAC1C,iBAAO,oBAAoB,2BAA2B,UAAU,CAAC;;AAGnE,cAAM,SAAQ,OAAO;AACrB,YAAI,WAAU,WAAW;AACvB,iBAAO,oBAAoB,OAAO,YAAY;;AAEhD,YAAI,oCAAoC,MAAM,KAAK,WAAU,UAAU;AACrE,iBAAO,oBAAoB,IAAI,UAAU,0DAA0D,CAAC;;AAEtG,YAAI,WAAU,YAAY;AACxB,iBAAO,oBAAoB,OAAO,YAAY;;AAKhD,cAAM,UAAU,8BAA8B,MAAM;AAEpD,6CAAqC,YAAY,OAAO,SAAS;AAEjE,eAAO;MACT;AAEA,YAAM,gBAA+B,CAAA;YASxB,gCAA+B;QAwB1C,cAAA;AACE,gBAAM,IAAI,UAAU,qBAAqB;;QAU3C,IAAI,cAAW;AACb,cAAI,CAAC,kCAAkC,IAAI,GAAG;AAC5C,kBAAM,uCAAqC,aAAa;;AAE1D,iBAAO,KAAK;;QAMd,IAAI,SAAM;AACR,cAAI,CAAC,kCAAkC,IAAI,GAAG;AAC5C,kBAAM,uCAAqC,QAAQ;;AAErD,cAAI,KAAK,qBAAqB,QAAW;AAIvC,kBAAM,IAAI,UAAU,mEAAmE;;AAEzF,iBAAO,KAAK,iBAAiB;;QAU/B,MAAM,KAAS,QAAS;AACtB,cAAI,CAAC,kCAAkC,IAAI,GAAG;AAC5C,kBAAM,uCAAqC,OAAO;;AAEpD,gBAAM,SAAQ,KAAK,0BAA0B;AAC7C,cAAI,WAAU,YAAY;AAGxB;;AAGF,+CAAqC,MAAM,EAAC;;QAI9C,CAAC,YAAY,QAAW;AACtB,gBAAM,SAAS,KAAK,gBAAgB,MAAM;AAC1C,yDAA+C,IAAI;AACnD,iBAAO;;QAIT,CAAC,cAAW;AACV,qBAAW,IAAI;;;AAInB,aAAO,iBAAiB,gCAAgC,WAAW;QACjE,aAAa,EAAE,YAAY,KAAI;QAC/B,QAAQ,EAAE,YAAY,KAAI;QAC1B,OAAO,EAAE,YAAY,KAAI;OAC1B;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,gCAAgC,WAAW,eAAO,aAAa;UACnF,OAAO;UACP,cAAc;SACf;;AAKH,iDAA2C,IAAM;AAC/C,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,2BAA2B,GAAG;AACzE,iBAAO;;AAGT,eAAO,cAAa;MACtB;AAEA,oDAAiD,QACA,YACA,gBACA,gBACA,gBACA,gBACA,eACA,eAA6C;AAI5F,mBAAW,4BAA4B;AACvC,eAAO,4BAA4B;AAGnC,mBAAW,SAAS;AACpB,mBAAW,kBAAkB;AAC7B,mBAAW,UAAU;AAErB,mBAAW,eAAe;AAC1B,mBAAW,mBAAmB,sBAAqB;AACnD,mBAAW,WAAW;AAEtB,mBAAW,yBAAyB;AACpC,mBAAW,eAAe;AAE1B,mBAAW,kBAAkB;AAC7B,mBAAW,kBAAkB;AAC7B,mBAAW,kBAAkB;AAE7B,cAAM,eAAe,+CAA+C,UAAU;AAC9E,yCAAiC,QAAQ,YAAY;AAErD,cAAM,cAAc,eAAc;AAClC,cAAM,eAAe,oBAAoB,WAAW;AACpD,oBACE,cACA,MAAA;AAEE,qBAAW,WAAW;AACtB,8DAAoD,UAAU;WAEhE,QAAC;AAEC,qBAAW,WAAW;AACtB,0CAAgC,QAAQ,EAAC;SAC1C;MAEL;AAEA,sEAAmE,QACA,gBACA,eACA,eAA6C;AAC9G,cAAM,aAAa,OAAO,OAAO,gCAAgC,SAAS;AAE1E,YAAI,iBAAiD,MAAM;AAC3D,YAAI,iBAA8C,MAAM,oBAAoB,MAAS;AACrF,YAAI,iBAAsC,MAAM,oBAAoB,MAAS;AAC7E,YAAI,iBAAiD,MAAM,oBAAoB,MAAS;AAExF,YAAI,eAAe,UAAU,QAAW;AACtC,2BAAiB,MAAM,eAAe,MAAO,UAAU;;AAEzD,YAAI,eAAe,UAAU,QAAW;AACtC,2BAAiB,WAAS,eAAe,MAAO,OAAO,UAAU;;AAEnE,YAAI,eAAe,UAAU,QAAW;AACtC,2BAAiB,MAAM,eAAe,MAAM;;AAE9C,YAAI,eAAe,UAAU,QAAW;AACtC,2BAAiB,YAAU,eAAe,MAAO,MAAM;;AAGzD,6CACE,QAAQ,YAAY,gBAAgB,gBAAgB,gBAAgB,gBAAgB,eAAe,aAAa;MAEpH;AAGA,8DAAwD,YAAgD;AACtG,mBAAW,kBAAkB;AAC7B,mBAAW,kBAAkB;AAC7B,mBAAW,kBAAkB;AAC7B,mBAAW,yBAAyB;MACtC;AAEA,oDAAiD,YAA8C;AAC7F,6BAAqB,YAAY,eAAe,CAAC;AACjD,4DAAoD,UAAU;MAChE;AAEA,2DAAwD,YACA,OAAQ;AAC9D,YAAI;AACF,iBAAO,WAAW,uBAAuB,KAAK;iBACvC,YAAP;AACA,uDAA6C,YAAY,UAAU;AACnE,iBAAO;;MAEX;AAEA,6DAAuD,YAAgD;AACrG,eAAO,WAAW,eAAe,WAAW;MAC9C;AAEA,oDAAiD,YACA,OACA,WAAiB;AAChE,YAAI;AACF,+BAAqB,YAAY,OAAO,SAAS;iBAC1C,UAAP;AACA,uDAA6C,YAAY,QAAQ;AACjE;;AAGF,cAAM,SAAS,WAAW;AAC1B,YAAI,CAAC,oCAAoC,MAAM,KAAK,OAAO,WAAW,YAAY;AAChF,gBAAM,eAAe,+CAA+C,UAAU;AAC9E,2CAAiC,QAAQ,YAAY;;AAGvD,4DAAoD,UAAU;MAChE;AAIA,mEAAgE,YAA8C;AAC5G,cAAM,SAAS,WAAW;AAE1B,YAAI,CAAC,WAAW,UAAU;AACxB;;AAGF,YAAI,OAAO,0BAA0B,QAAW;AAC9C;;AAGF,cAAM,SAAQ,OAAO;AAErB,YAAI,WAAU,YAAY;AACxB,uCAA6B,MAAM;AACnC;;AAGF,YAAI,WAAW,OAAO,WAAW,GAAG;AAClC;;AAGF,cAAM,QAAQ,eAAe,UAAU;AACvC,YAAI,UAAU,eAAe;AAC3B,sDAA4C,UAAU;eACjD;AACL,sDAA4C,YAAY,KAAK;;MAEjE;AAEA,4DAAsD,YAAkD,OAAU;AAChH,YAAI,WAAW,0BAA0B,WAAW,YAAY;AAC9D,+CAAqC,YAAY,KAAK;;MAE1D;AAEA,2DAAqD,YAAgD;AACnG,cAAM,SAAS,WAAW;AAE1B,+CAAuC,MAAM;AAE7C,qBAAa,UAAU;AAGvB,cAAM,mBAAmB,WAAW,gBAAe;AACnD,uDAA+C,UAAU;AACzD,oBACE,kBACA,MAAA;AACE,4CAAkC,MAAM;WAE1C,YAAM;AACJ,qDAA2C,QAAQ,MAAM;SAC1D;MAEL;AAEA,2DAAwD,YAAgD,OAAQ;AAC9G,cAAM,SAAS,WAAW;AAE1B,oDAA4C,MAAM;AAElD,cAAM,mBAAmB,WAAW,gBAAgB,KAAK;AACzD,oBACE,kBACA,MAAA;AACE,4CAAkC,MAAM;AAExC,gBAAM,SAAQ,OAAO;AAGrB,uBAAa,UAAU;AAEvB,cAAI,CAAC,oCAAoC,MAAM,KAAK,WAAU,YAAY;AACxE,kBAAM,eAAe,+CAA+C,UAAU;AAC9E,6CAAiC,QAAQ,YAAY;;AAGvD,8DAAoD,UAAU;WAEhE,YAAM;AACJ,cAAI,OAAO,WAAW,YAAY;AAChC,2DAA+C,UAAU;;AAE3D,qDAA2C,QAAQ,MAAM;SAC1D;MAEL;AAEA,8DAAwD,YAAgD;AACtG,cAAM,cAAc,8CAA8C,UAAU;AAC5E,eAAO,eAAe;MACxB;AAIA,oDAA8C,YAAkD,OAAU;AACxG,cAAM,SAAS,WAAW;AAI1B,uDAA+C,UAAU;AACzD,oCAA4B,QAAQ,KAAK;MAC3C;AAIA,2CAAmC,OAAY;AAC7C,eAAO,IAAI,UAAU,4BAA4B,4CAA2C;MAC9F;AAIA,sDAA8C,OAAY;AACxD,eAAO,IAAI,UACT,6CAA6C,6DAA4D;MAC7G;AAKA,gDAA0C,OAAY;AACpD,eAAO,IAAI,UACT,yCAAyC,yDAAwD;MACrG;AAEA,0CAAoC,OAAY;AAC9C,eAAO,IAAI,UAAU,YAAY,QAAO,mCAAmC;MAC7E;AAEA,oDAA8C,QAAmC;AAC/E,eAAO,iBAAiB,WAAW,CAAC,UAAS,WAAM;AACjD,iBAAO,yBAAyB;AAChC,iBAAO,wBAAwB;AAC/B,iBAAO,sBAAsB;SAC9B;MACH;AAEA,8DAAwD,QAAqC,QAAW;AACtG,6CAAqC,MAAM;AAC3C,yCAAiC,QAAQ,MAAM;MACjD;AAEA,8DAAwD,QAAmC;AACzF,6CAAqC,MAAM;AAC3C,0CAAkC,MAAM;MAC1C;AAEA,gDAA0C,QAAqC,QAAW;AACxF,YAAI,OAAO,0BAA0B,QAAW;AAC9C;;AAIF,kCAA0B,OAAO,cAAc;AAC/C,eAAO,sBAAsB,MAAM;AACnC,eAAO,yBAAyB;AAChC,eAAO,wBAAwB;AAC/B,eAAO,sBAAsB;MAC/B;AAEA,yDAAmD,QAAqC,QAAW;AAKjG,uDAA+C,QAAQ,MAAM;MAC/D;AAEA,iDAA2C,QAAmC;AAC5E,YAAI,OAAO,2BAA2B,QAAW;AAC/C;;AAIF,eAAO,uBAAuB,MAAS;AACvC,eAAO,yBAAyB;AAChC,eAAO,wBAAwB;AAC/B,eAAO,sBAAsB;MAC/B;AAEA,mDAA6C,QAAmC;AAC9E,eAAO,gBAAgB,WAAW,CAAC,UAAS,WAAM;AAChD,iBAAO,wBAAwB;AAC/B,iBAAO,uBAAuB;SAC/B;AACD,eAAO,qBAAqB;MAC9B;AAEA,6DAAuD,QAAqC,QAAW;AACrG,4CAAoC,MAAM;AAC1C,wCAAgC,QAAQ,MAAM;MAChD;AAEA,6DAAuD,QAAmC;AACxF,4CAAoC,MAAM;AAC1C,yCAAiC,MAAM;MACzC;AAEA,+CAAyC,QAAqC,QAAW;AACvF,YAAI,OAAO,yBAAyB,QAAW;AAC7C;;AAGF,kCAA0B,OAAO,aAAa;AAC9C,eAAO,qBAAqB,MAAM;AAClC,eAAO,wBAAwB;AAC/B,eAAO,uBAAuB;AAC9B,eAAO,qBAAqB;MAC9B;AAEA,8CAAwC,QAAmC;AAIzE,4CAAoC,MAAM;MAC5C;AAEA,wDAAkD,QAAqC,QAAW;AAIhG,sDAA8C,QAAQ,MAAM;MAC9D;AAEA,gDAA0C,QAAmC;AAC3E,YAAI,OAAO,0BAA0B,QAAW;AAC9C;;AAGF,eAAO,sBAAsB,MAAS;AACtC,eAAO,wBAAwB;AAC/B,eAAO,uBAAuB;AAC9B,eAAO,qBAAqB;MAC9B;ACh4CO,YAAM,qBACX,OAAO,iBAAiB,cAAc,eAAe;ACWvD,yCAAmC,MAAa;AAC9C,YAAI,CAAE,QAAO,SAAS,cAAc,OAAO,SAAS,WAAW;AAC7D,iBAAO;;AAET,YAAI;AACF,cAAK,KAAgC;AACrC,iBAAO;iBACP,IAAA;AACA,iBAAO;;MAEX;AAEA,4CAAmC;AAEjC,cAAM,OAAO,uBAA0C,SAAkB,OAAa;AACpF,eAAK,UAAU,WAAW;AAC1B,eAAK,OAAO,SAAQ;AACpB,cAAI,MAAM,mBAAmB;AAC3B,kBAAM,kBAAkB,MAAM,KAAK,WAAW;;;AAGlD,aAAK,YAAY,OAAO,OAAO,MAAM,SAAS;AAC9C,eAAO,eAAe,KAAK,WAAW,eAAe,EAAE,OAAO,MAAM,UAAU,MAAM,cAAc,KAAI,CAAE;AACxG,eAAO;MACT;AAGA,YAAM,iBACJ,0BAA0B,kBAAkB,IAAI,qBAAqB,2BAA0B;oCCbzD,QACA,MACA,cACA,cACA,eACA,QAA+B;AAUrE,cAAM,SAAS,mCAAsC,MAAM;AAC3D,cAAM,SAAS,mCAAsC,IAAI;AAEzD,eAAO,aAAa;AAEpB,YAAI,eAAe;AAGnB,YAAI,eAAe,oBAA0B,MAAS;AAEtD,eAAO,WAAW,CAAC,UAAS,WAAM;AAChC,cAAI;AACJ,cAAI,WAAW,QAAW;AACxB,6BAAiB,MAAA;AACf,oBAAM,QAAQ,IAAI,eAAa,WAAW,YAAY;AACtD,oBAAM,UAAsC,CAAA;AAC5C,kBAAI,CAAC,cAAc;AACjB,wBAAQ,KAAK,MAAA;AACX,sBAAI,KAAK,WAAW,YAAY;AAC9B,2BAAO,oBAAoB,MAAM,KAAK;;AAExC,yBAAO,oBAAoB,MAAS;iBACrC;;AAEH,kBAAI,CAAC,eAAe;AAClB,wBAAQ,KAAK,MAAA;AACX,sBAAI,OAAO,WAAW,YAAY;AAChC,2BAAO,qBAAqB,QAAQ,KAAK;;AAE3C,yBAAO,oBAAoB,MAAS;iBACrC;;AAEH,iCAAmB,MAAM,QAAQ,IAAI,QAAQ,IAAI,YAAU,OAAM,CAAE,CAAC,GAAG,MAAM,KAAK;;AAGpF,gBAAI,OAAO,SAAS;AAClB,6BAAc;AACd;;AAGF,mBAAO,iBAAiB,SAAS,cAAc;;AAMjD,8BAAiB;AACf,mBAAO,WAAiB,CAAC,aAAa,eAAU;AAC9C,4BAAc,MAAa;AACzB,oBAAI,MAAM;AACR,8BAAW;uBACN;AAGL,qCAAmB,SAAQ,GAAI,MAAM,UAAU;;;AAInD,mBAAK,KAAK;aACX;;AAGH,8BAAiB;AACf,gBAAI,cAAc;AAChB,qBAAO,oBAAoB,IAAI;;AAGjC,mBAAO,mBAAmB,OAAO,eAAe,MAAA;AAC9C,qBAAO,WAAoB,CAAC,aAAa,eAAU;AACjD,gDACE,QACA;kBACE,aAAa,WAAK;AAChB,mCAAe,mBAAmB,iCAAiC,QAAQ,KAAK,GAAG,QAAW,KAAI;AAClG,gCAAY,KAAK;;kBAEnB,aAAa,MAAM,YAAY,IAAI;kBACnC,aAAa;iBACd;eAEJ;aACF;;AAIH,6BAAmB,QAAQ,OAAO,gBAAgB,iBAAW;AAC3D,gBAAI,CAAC,cAAc;AACjB,iCAAmB,MAAM,oBAAoB,MAAM,WAAW,GAAG,MAAM,WAAW;mBAC7E;AACL,uBAAS,MAAM,WAAW;;WAE7B;AAGD,6BAAmB,MAAM,OAAO,gBAAgB,iBAAW;AACzD,gBAAI,CAAC,eAAe;AAClB,iCAAmB,MAAM,qBAAqB,QAAQ,WAAW,GAAG,MAAM,WAAW;mBAChF;AACL,uBAAS,MAAM,WAAW;;WAE7B;AAGD,4BAAkB,QAAQ,OAAO,gBAAgB,MAAA;AAC/C,gBAAI,CAAC,cAAc;AACjB,iCAAmB,MAAM,qDAAqD,MAAM,CAAC;mBAChF;AACL,uBAAQ;;WAEX;AAGD,cAAI,oCAAoC,IAAI,KAAK,KAAK,WAAW,UAAU;AACzE,kBAAM,aAAa,IAAI,UAAU,6EAA6E;AAE9G,gBAAI,CAAC,eAAe;AAClB,iCAAmB,MAAM,qBAAqB,QAAQ,UAAU,GAAG,MAAM,UAAU;mBAC9E;AACL,uBAAS,MAAM,UAAU;;;AAI7B,oCAA0B,SAAQ,CAAE;AAEpC,2CAA8B;AAG5B,kBAAM,kBAAkB;AACxB,mBAAO,mBACL,cACA,MAAM,oBAAoB,eAAe,sBAAqB,IAAK,MAAS;;AAIhF,sCAA4B,QACA,SACA,QAA6B;AACvD,gBAAI,OAAO,WAAW,WAAW;AAC/B,qBAAO,OAAO,YAAY;mBACrB;AACL,4BAAc,SAAS,MAAM;;;AAIjC,qCAA2B,QAAyC,SAAwB,QAAkB;AAC5G,gBAAI,OAAO,WAAW,UAAU;AAC9B,qBAAM;mBACD;AACL,8BAAgB,SAAS,MAAM;;;AAInC,sCAA4B,QAAgC,iBAA2B,eAAmB;AACxG,gBAAI,cAAc;AAChB;;AAEF,2BAAe;AAEf,gBAAI,KAAK,WAAW,cAAc,CAAC,oCAAoC,IAAI,GAAG;AAC5E,8BAAgB,sBAAqB,GAAI,SAAS;mBAC7C;AACL,wBAAS;;AAGX,iCAAkB;AAChB,0BACE,OAAM,GACN,MAAM,SAAS,iBAAiB,aAAa,GAC7C,cAAY,SAAS,MAAM,QAAQ,CAAC;;;AAK1C,4BAAkB,SAAmB,OAAW;AAC9C,gBAAI,cAAc;AAChB;;AAEF,2BAAe;AAEf,gBAAI,KAAK,WAAW,cAAc,CAAC,oCAAoC,IAAI,GAAG;AAC5E,8BAAgB,sBAAqB,GAAI,MAAM,SAAS,SAAS,KAAK,CAAC;mBAClE;AACL,uBAAS,SAAS,KAAK;;;AAI3B,4BAAkB,SAAmB,OAAW;AAC9C,+CAAmC,MAAM;AACzC,+CAAmC,MAAM;AAEzC,gBAAI,WAAW,QAAW;AACxB,qBAAO,oBAAoB,SAAS,cAAc;;AAEpD,gBAAI,SAAS;AACX,qBAAO,KAAK;mBACP;AACL,uBAAQ,MAAS;;;SAGtB;MACH;YC9Na,gCAA+B;QAwB1C,cAAA;AACE,gBAAM,IAAI,UAAU,qBAAqB;;QAO3C,IAAI,cAAW;AACb,cAAI,CAAC,kCAAkC,IAAI,GAAG;AAC5C,kBAAM,uCAAqC,aAAa;;AAG1D,iBAAO,8CAA8C,IAAI;;QAO3D,QAAK;AACH,cAAI,CAAC,kCAAkC,IAAI,GAAG;AAC5C,kBAAM,uCAAqC,OAAO;;AAGpD,cAAI,CAAC,iDAAiD,IAAI,GAAG;AAC3D,kBAAM,IAAI,UAAU,iDAAiD;;AAGvE,+CAAqC,IAAI;;QAO3C,QAAQ,QAAW,QAAU;AAC3B,cAAI,CAAC,kCAAkC,IAAI,GAAG;AAC5C,kBAAM,uCAAqC,SAAS;;AAGtD,cAAI,CAAC,iDAAiD,IAAI,GAAG;AAC3D,kBAAM,IAAI,UAAU,mDAAmD;;AAGzE,iBAAO,uCAAuC,MAAM,KAAK;;QAM3D,MAAM,KAAS,QAAS;AACtB,cAAI,CAAC,kCAAkC,IAAI,GAAG;AAC5C,kBAAM,uCAAqC,OAAO;;AAGpD,+CAAqC,MAAM,EAAC;;QAI9C,CAAC,aAAa,QAAW;AACvB,qBAAW,IAAI;AACf,gBAAM,SAAS,KAAK,iBAAiB,MAAM;AAC3C,yDAA+C,IAAI;AACnD,iBAAO;;QAIT,CAAC,WAAW,aAA2B;AACrC,gBAAM,SAAS,KAAK;AAEpB,cAAI,KAAK,OAAO,SAAS,GAAG;AAC1B,kBAAM,QAAQ,aAAa,IAAI;AAE/B,gBAAI,KAAK,mBAAmB,KAAK,OAAO,WAAW,GAAG;AACpD,6DAA+C,IAAI;AACnD,kCAAoB,MAAM;mBACrB;AACL,8DAAgD,IAAI;;AAGtD,wBAAY,YAAY,KAAK;iBACxB;AACL,yCAA6B,QAAQ,WAAW;AAChD,4DAAgD,IAAI;;;;AAK1D,aAAO,iBAAiB,gCAAgC,WAAW;QACjE,OAAO,EAAE,YAAY,KAAI;QACzB,SAAS,EAAE,YAAY,KAAI;QAC3B,OAAO,EAAE,YAAY,KAAI;QACzB,aAAa,EAAE,YAAY,KAAI;OAChC;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,gCAAgC,WAAW,eAAO,aAAa;UACnF,OAAO;UACP,cAAc;SACf;;AAKH,iDAAoD,IAAM;AACxD,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,2BAA2B,GAAG;AACzE,iBAAO;;AAGT,eAAO,cAAa;MACtB;AAEA,+DAAyD,YAAgD;AACvG,cAAM,aAAa,8CAA8C,UAAU;AAC3E,YAAI,CAAC,YAAY;AACf;;AAGF,YAAI,WAAW,UAAU;AACvB,qBAAW,aAAa;AACxB;;AAKF,mBAAW,WAAW;AAEtB,cAAM,cAAc,WAAW,eAAc;AAC7C,oBACE,aACA,MAAA;AACE,qBAAW,WAAW;AAEtB,cAAI,WAAW,YAAY;AACzB,uBAAW,aAAa;AACxB,4DAAgD,UAAU;;WAG9D,QAAC;AACC,+CAAqC,YAAY,EAAC;SACnD;MAEL;AAEA,6DAAuD,YAAgD;AACrG,cAAM,SAAS,WAAW;AAE1B,YAAI,CAAC,iDAAiD,UAAU,GAAG;AACjE,iBAAO;;AAGT,YAAI,CAAC,WAAW,UAAU;AACxB,iBAAO;;AAGT,YAAI,uBAAuB,MAAM,KAAK,iCAAiC,MAAM,IAAI,GAAG;AAClF,iBAAO;;AAGT,cAAM,cAAc,8CAA8C,UAAU;AAE5E,YAAI,cAAe,GAAG;AACpB,iBAAO;;AAGT,eAAO;MACT;AAEA,8DAAwD,YAAgD;AACtG,mBAAW,iBAAiB;AAC5B,mBAAW,mBAAmB;AAC9B,mBAAW,yBAAyB;MACtC;oDAIqD,YAAgD;AACnG,YAAI,CAAC,iDAAiD,UAAU,GAAG;AACjE;;AAGF,cAAM,SAAS,WAAW;AAE1B,mBAAW,kBAAkB;AAE7B,YAAI,WAAW,OAAO,WAAW,GAAG;AAClC,yDAA+C,UAAU;AACzD,8BAAoB,MAAM;;MAE9B;sDAGE,YACA,OAAQ;AAER,YAAI,CAAC,iDAAiD,UAAU,GAAG;AACjE;;AAGF,cAAM,SAAS,WAAW;AAE1B,YAAI,uBAAuB,MAAM,KAAK,iCAAiC,MAAM,IAAI,GAAG;AAClF,2CAAiC,QAAQ,OAAO,KAAK;eAChD;AACL,cAAI;AACJ,cAAI;AACF,wBAAY,WAAW,uBAAuB,KAAK;mBAC5C,YAAP;AACA,iDAAqC,YAAY,UAAU;AAC3D,kBAAM;;AAGR,cAAI;AACF,iCAAqB,YAAY,OAAO,SAAS;mBAC1C,UAAP;AACA,iDAAqC,YAAY,QAAQ;AACzD,kBAAM;;;AAIV,wDAAgD,UAAU;MAC5D;oDAEqD,YAAkD,IAAM;AAC3G,cAAM,SAAS,WAAW;AAE1B,YAAI,OAAO,WAAW,YAAY;AAChC;;AAGF,mBAAW,UAAU;AAErB,uDAA+C,UAAU;AACzD,4BAAoB,QAAQ,EAAC;MAC/B;6DAGE,YAAgD;AAEhD,cAAM,SAAQ,WAAW,0BAA0B;AAEnD,YAAI,WAAU,WAAW;AACvB,iBAAO;;AAET,YAAI,WAAU,UAAU;AACtB,iBAAO;;AAGT,eAAO,WAAW,eAAe,WAAW;MAC9C;8DAIE,YAAgD;AAEhD,YAAI,8CAA8C,UAAU,GAAG;AAC7D,iBAAO;;AAGT,eAAO;MACT;gEAGE,YAAgD;AAEhD,cAAM,SAAQ,WAAW,0BAA0B;AAEnD,YAAI,CAAC,WAAW,mBAAmB,WAAU,YAAY;AACvD,iBAAO;;AAGT,eAAO;MACT;oDAEwD,QACA,YACA,gBACA,eACA,iBACA,eACA,eAA6C;AAGnG,mBAAW,4BAA4B;AAEvC,mBAAW,SAAS;AACpB,mBAAW,kBAAkB;AAC7B,mBAAW,UAAU;AAErB,mBAAW,WAAW;AACtB,mBAAW,kBAAkB;AAC7B,mBAAW,aAAa;AACxB,mBAAW,WAAW;AAEtB,mBAAW,yBAAyB;AACpC,mBAAW,eAAe;AAE1B,mBAAW,iBAAiB;AAC5B,mBAAW,mBAAmB;AAE9B,eAAO,4BAA4B;AAEnC,cAAM,cAAc,eAAc;AAClC,oBACE,oBAAoB,WAAW,GAC/B,MAAA;AACE,qBAAW,WAAW;AAKtB,0DAAgD,UAAU;WAE5D,QAAC;AACC,+CAAqC,YAAY,EAAC;SACnD;MAEL;wEAGE,QACA,kBACA,eACA,eAA6C;AAE7C,cAAM,aAAiD,OAAO,OAAO,gCAAgC,SAAS;AAE9G,YAAI,iBAAiD,MAAM;AAC3D,YAAI,gBAAqC,MAAM,oBAAoB,MAAS;AAC5E,YAAI,kBAAkD,MAAM,oBAAoB,MAAS;AAEzF,YAAI,iBAAiB,UAAU,QAAW;AACxC,2BAAiB,MAAM,iBAAiB,MAAO,UAAU;;AAE3D,YAAI,iBAAiB,SAAS,QAAW;AACvC,0BAAgB,MAAM,iBAAiB,KAAM,UAAU;;AAEzD,YAAI,iBAAiB,WAAW,QAAW;AACzC,4BAAkB,YAAU,iBAAiB,OAAQ,MAAM;;AAG7D,6CACE,QAAQ,YAAY,gBAAgB,eAAe,iBAAiB,eAAe,aAAa;MAEpG;AAIA,sDAA8C,OAAY;AACxD,eAAO,IAAI,UACT,6CAA6C,6DAA4D;MAC7G;iCCtWqC,QACA,iBAAwB;AAG3D,YAAI,+BAA+B,OAAO,yBAAyB,GAAG;AACpE,iBAAO,sBAAsB,MAAuC;;AAGtE,eAAO,yBAAyB,MAAuB;MACzD;wCAE4C,QACA,iBAAwB;AAIlE,cAAM,SAAS,mCAAsC,MAAM;AAE3D,YAAI,UAAU;AACd,YAAI,YAAY;AAChB,YAAI,YAAY;AAChB,YAAI,YAAY;AAChB,YAAI;AACJ,YAAI;AACJ,YAAI;AACJ,YAAI;AAEJ,YAAI;AACJ,cAAM,gBAAgB,WAAsB,cAAO;AACjD,iCAAuB;SACxB;AAED,iCAAsB;AACpB,cAAI,SAAS;AACX,wBAAY;AACZ,mBAAO,oBAAoB,MAAS;;AAGtC,oBAAU;AAEV,gBAAM,cAA8B;YAClC,aAAa,WAAK;AAIhB,6BAAe,MAAA;AACb,4BAAY;AACZ,sBAAM,SAAS;AACf,sBAAM,SAAS;AAQf,oBAAI,CAAC,WAAW;AACd,yDACE,QAAQ,2BACR,MAAM;;AAGV,oBAAI,CAAC,WAAW;AACd,yDACE,QAAQ,2BACR,MAAM;;AAIV,0BAAU;AACV,oBAAI,WAAW;AACb,gCAAa;;eAEhB;;YAEH,aAAa,MAAA;AACX,wBAAU;AACV,kBAAI,CAAC,WAAW;AACd,qDAAqC,QAAQ,yBAA+D;;AAE9G,kBAAI,CAAC,WAAW;AACd,qDAAqC,QAAQ,yBAA+D;;AAG9G,kBAAI,CAAC,aAAa,CAAC,WAAW;AAC5B,qCAAqB,MAAS;;;YAGlC,aAAa,MAAA;AACX,wBAAU;;;AAGd,0CAAgC,QAAQ,WAAW;AAEnD,iBAAO,oBAAoB,MAAS;;AAGtC,kCAA0B,QAAW;AACnC,sBAAY;AACZ,oBAAU;AACV,cAAI,WAAW;AACb,kBAAM,kBAAkB,oBAAoB,CAAC,SAAS,OAAO,CAAC;AAC9D,kBAAM,eAAe,qBAAqB,QAAQ,eAAe;AACjE,iCAAqB,YAAY;;AAEnC,iBAAO;;AAGT,kCAA0B,QAAW;AACnC,sBAAY;AACZ,oBAAU;AACV,cAAI,WAAW;AACb,kBAAM,kBAAkB,oBAAoB,CAAC,SAAS,OAAO,CAAC;AAC9D,kBAAM,eAAe,qBAAqB,QAAQ,eAAe;AACjE,iCAAqB,YAAY;;AAEnC,iBAAO;;AAGT,kCAAuB;;AAIvB,kBAAU,qBAAqB,gBAAgB,eAAe,gBAAgB;AAC9E,kBAAU,qBAAqB,gBAAgB,eAAe,gBAAgB;AAE9E,sBAAc,OAAO,gBAAgB,CAAC,OAAM;AAC1C,+CAAqC,QAAQ,2BAAiE,EAAC;AAC/G,+CAAqC,QAAQ,2BAAiE,EAAC;AAC/G,cAAI,CAAC,aAAa,CAAC,WAAW;AAC5B,iCAAqB,MAAS;;SAEjC;AAED,eAAO,CAAC,SAAS,OAAO;MAC1B;qCAEsC,QAA0B;AAI9D,YAAI,SAA2C,mCAAmC,MAAM;AACxF,YAAI,UAAU;AACd,YAAI,sBAAsB;AAC1B,YAAI,sBAAsB;AAC1B,YAAI,YAAY;AAChB,YAAI,YAAY;AAChB,YAAI;AACJ,YAAI;AACJ,YAAI;AACJ,YAAI;AAEJ,YAAI;AACJ,cAAM,gBAAgB,WAAiB,cAAO;AAC5C,iCAAuB;SACxB;AAED,oCAA4B,YAA4C;AACtE,wBAAc,WAAW,gBAAgB,QAAC;AACxC,gBAAI,eAAe,QAAQ;AACzB;;AAEF,8CAAkC,QAAQ,2BAA2B,EAAC;AACtE,8CAAkC,QAAQ,2BAA2B,EAAC;AACtE,gBAAI,CAAC,aAAa,CAAC,WAAW;AAC5B,mCAAqB,MAAS;;WAEjC;;AAGH,yCAA8B;AAC5B,cAAI,2BAA2B,MAAM,GAAG;AAEtC,+CAAmC,MAAM;AAEzC,qBAAS,mCAAmC,MAAM;AAClD,+BAAmB,MAAM;;AAG3B,gBAAM,cAAuC;YAC3C,aAAa,WAAK;AAIhB,6BAAe,MAAA;AACb,sCAAsB;AACtB,sCAAsB;AAEtB,sBAAM,SAAS;AACf,oBAAI,SAAS;AACb,oBAAI,CAAC,aAAa,CAAC,WAAW;AAC5B,sBAAI;AACF,6BAAS,kBAAkB,KAAK;2BACzB,QAAP;AACA,sDAAkC,QAAQ,2BAA2B,MAAM;AAC3E,sDAAkC,QAAQ,2BAA2B,MAAM;AAC3E,yCAAqB,qBAAqB,QAAQ,MAAM,CAAC;AACzD;;;AAIJ,oBAAI,CAAC,WAAW;AACd,sDAAoC,QAAQ,2BAA2B,MAAM;;AAE/E,oBAAI,CAAC,WAAW;AACd,sDAAoC,QAAQ,2BAA2B,MAAM;;AAG/E,0BAAU;AACV,oBAAI,qBAAqB;AACvB,iCAAc;2BACL,qBAAqB;AAC9B,iCAAc;;eAEjB;;YAEH,aAAa,MAAA;AACX,wBAAU;AACV,kBAAI,CAAC,WAAW;AACd,kDAAkC,QAAQ,yBAAyB;;AAErE,kBAAI,CAAC,WAAW;AACd,kDAAkC,QAAQ,yBAAyB;;AAErE,kBAAI,QAAQ,0BAA0B,kBAAkB,SAAS,GAAG;AAClE,oDAAoC,QAAQ,2BAA2B,CAAC;;AAE1E,kBAAI,QAAQ,0BAA0B,kBAAkB,SAAS,GAAG;AAClE,oDAAoC,QAAQ,2BAA2B,CAAC;;AAE1E,kBAAI,CAAC,aAAa,CAAC,WAAW;AAC5B,qCAAqB,MAAS;;;YAGlC,aAAa,MAAA;AACX,wBAAU;;;AAGd,0CAAgC,QAAQ,WAAW;;AAGrD,oCAA4B,MAAuB,YAAmB;AACpE,cAAI,8BAA0C,MAAM,GAAG;AAErD,+CAAmC,MAAM;AAEzC,qBAAS,gCAAgC,MAAM;AAC/C,+BAAmB,MAAM;;AAG3B,gBAAM,aAAa,aAAa,UAAU;AAC1C,gBAAM,cAAc,aAAa,UAAU;AAE3C,gBAAM,kBAAoD;YACxD,aAAa,WAAK;AAIhB,6BAAe,MAAA;AACb,sCAAsB;AACtB,sCAAsB;AAEtB,sBAAM,eAAe,aAAa,YAAY;AAC9C,sBAAM,gBAAgB,aAAa,YAAY;AAE/C,oBAAI,CAAC,eAAe;AAClB,sBAAI;AACJ,sBAAI;AACF,kCAAc,kBAAkB,KAAK;2BAC9B,QAAP;AACA,sDAAkC,WAAW,2BAA2B,MAAM;AAC9E,sDAAkC,YAAY,2BAA2B,MAAM;AAC/E,yCAAqB,qBAAqB,QAAQ,MAAM,CAAC;AACzD;;AAEF,sBAAI,CAAC,cAAc;AACjB,mEAA+C,WAAW,2BAA2B,KAAK;;AAE5F,sDAAoC,YAAY,2BAA2B,WAAW;2BAC7E,CAAC,cAAc;AACxB,iEAA+C,WAAW,2BAA2B,KAAK;;AAG5F,0BAAU;AACV,oBAAI,qBAAqB;AACvB,iCAAc;2BACL,qBAAqB;AAC9B,iCAAc;;eAEjB;;YAEH,aAAa,WAAK;AAChB,wBAAU;AAEV,oBAAM,eAAe,aAAa,YAAY;AAC9C,oBAAM,gBAAgB,aAAa,YAAY;AAE/C,kBAAI,CAAC,cAAc;AACjB,kDAAkC,WAAW,yBAAyB;;AAExE,kBAAI,CAAC,eAAe;AAClB,kDAAkC,YAAY,yBAAyB;;AAGzE,kBAAI,UAAU,QAAW;AAGvB,oBAAI,CAAC,cAAc;AACjB,iEAA+C,WAAW,2BAA2B,KAAK;;AAE5F,oBAAI,CAAC,iBAAiB,YAAY,0BAA0B,kBAAkB,SAAS,GAAG;AACxF,sDAAoC,YAAY,2BAA2B,CAAC;;;AAIhF,kBAAI,CAAC,gBAAgB,CAAC,eAAe;AACnC,qCAAqB,MAAS;;;YAGlC,aAAa,MAAA;AACX,wBAAU;;;AAGd,uCAA6B,QAAQ,MAAM,eAAe;;AAG5D,kCAAuB;AACrB,cAAI,SAAS;AACX,kCAAsB;AACtB,mBAAO,oBAAoB,MAAS;;AAGtC,oBAAU;AAEV,gBAAM,cAAc,2CAA2C,QAAQ,yBAAyB;AAChG,cAAI,gBAAgB,MAAM;AACxB,kCAAqB;iBAChB;AACL,+BAAmB,YAAY,OAAQ,KAAK;;AAG9C,iBAAO,oBAAoB,MAAS;;AAGtC,kCAAuB;AACrB,cAAI,SAAS;AACX,kCAAsB;AACtB,mBAAO,oBAAoB,MAAS;;AAGtC,oBAAU;AAEV,gBAAM,cAAc,2CAA2C,QAAQ,yBAAyB;AAChG,cAAI,gBAAgB,MAAM;AACxB,kCAAqB;iBAChB;AACL,+BAAmB,YAAY,OAAQ,IAAI;;AAG7C,iBAAO,oBAAoB,MAAS;;AAGtC,kCAA0B,QAAW;AACnC,sBAAY;AACZ,oBAAU;AACV,cAAI,WAAW;AACb,kBAAM,kBAAkB,oBAAoB,CAAC,SAAS,OAAO,CAAC;AAC9D,kBAAM,eAAe,qBAAqB,QAAQ,eAAe;AACjE,iCAAqB,YAAY;;AAEnC,iBAAO;;AAGT,kCAA0B,QAAW;AACnC,sBAAY;AACZ,oBAAU;AACV,cAAI,WAAW;AACb,kBAAM,kBAAkB,oBAAoB,CAAC,SAAS,OAAO,CAAC;AAC9D,kBAAM,eAAe,qBAAqB,QAAQ,eAAe;AACjE,iCAAqB,YAAY;;AAEnC,iBAAO;;AAGT,kCAAuB;AACrB;;AAGF,kBAAU,yBAAyB,gBAAgB,gBAAgB,gBAAgB;AACnF,kBAAU,yBAAyB,gBAAgB,gBAAgB,gBAAgB;AAEnF,2BAAmB,MAAM;AAEzB,eAAO,CAAC,SAAS,OAAO;MAC1B;oDCtaE,QACA,SAAe;AAEf,yBAAiB,QAAQ,OAAO;AAChC,cAAM,WAAW;AACjB,cAAM,wBAAwB,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACxC,cAAM,SAAS,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACzB,cAAM,OAAO,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACvB,cAAM,QAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACxB,cAAM,OAAO,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACvB,eAAO;UACL,uBAAuB,0BAA0B,SAC/C,SACA,wCACE,uBACA,GAAG,iDAAiD;UAExD,QAAQ,WAAW,SACjB,SACA,sCAAsC,QAAQ,UAAW,GAAG,kCAAkC;UAChG,MAAM,SAAS,SACb,SACA,oCAAoC,MAAM,UAAW,GAAG,gCAAgC;UAC1F,OAAO,UAAU,SACf,SACA,qCAAqC,OAAO,UAAW,GAAG,iCAAiC;UAC7F,MAAM,SAAS,SAAY,SAAY,0BAA0B,MAAM,GAAG,gCAAgC;;MAE9G;AAEA,qDACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,WAAgB,YAAY,IAAI,UAAU,CAAC,MAAM,CAAC;MAC5D;AAEA,mDACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,eAA4C,YAAY,IAAI,UAAU,CAAC,UAAU,CAAC;MAC5F;AAEA,oDACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,eAA4C,YAAY,IAAI,UAAU,CAAC,UAAU,CAAC;MAC5F;AAEA,yCAAmC,MAAc,SAAe;AAC9D,eAAO,GAAG;AACV,YAAI,SAAS,SAAS;AACpB,gBAAM,IAAI,UAAU,GAAG,YAAY,+DAA+D;;AAEpG,eAAO;MACT;oCC1EqC,SACA,SAAe;AAClD,yBAAiB,SAAS,OAAO;AACjC,cAAM,OAAO,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS;AACtB,eAAO;UACL,MAAM,SAAS,SAAY,SAAY,gCAAgC,MAAM,GAAG,gCAAgC;;MAEpH;AAEA,+CAAyC,MAAc,SAAe;AACpE,eAAO,GAAG;AACV,YAAI,SAAS,QAAQ;AACnB,gBAAM,IAAI,UAAU,GAAG,YAAY,qEAAqE;;AAE1G,eAAO;MACT;sCCZuC,SACA,SAAe;AACpD,yBAAiB,SAAS,OAAO;AACjC,cAAM,gBAAgB,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS;AAC/B,eAAO,EAAE,eAAe,QAAQ,aAAa,EAAC;MAChD;kCCPmC,SACA,SAAe;AAChD,yBAAiB,SAAS,OAAO;AACjC,cAAM,eAAe,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS;AAC9B,cAAM,gBAAgB,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS;AAC/B,cAAM,eAAe,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS;AAC9B,cAAM,SAAS,YAAO,QAAP,YAAO,SAAA,SAAP,QAAS;AACxB,YAAI,WAAW,QAAW;AACxB,4BAAkB,QAAQ,GAAG,kCAAkC;;AAEjE,eAAO;UACL,cAAc,QAAQ,YAAY;UAClC,eAAe,QAAQ,aAAa;UACpC,cAAc,QAAQ,YAAY;UAClC;;MAEJ;AAEA,iCAA2B,QAAiB,SAAe;AACzD,YAAI,CAAC,eAAc,MAAM,GAAG;AAC1B,gBAAM,IAAI,UAAU,GAAG,gCAAgC;;MAE3D;2CCnBE,MACA,SAAe;AAEf,yBAAiB,MAAM,OAAO;AAE9B,cAAM,WAAW,SAAI,QAAJ,SAAI,SAAA,SAAJ,KAAM;AACvB,4BAAoB,UAAU,YAAY,sBAAsB;AAChE,6BAAqB,UAAU,GAAG,oCAAoC;AAEtE,cAAM,WAAW,SAAI,QAAJ,SAAI,SAAA,SAAJ,KAAM;AACvB,4BAAoB,UAAU,YAAY,sBAAsB;AAChE,6BAAqB,UAAU,GAAG,oCAAoC;AAEtE,eAAO,EAAE,UAAU,SAAQ;MAC7B;YCsDa,gBAAc;QAczB,YAAY,sBAAqF,CAAA,GACrF,cAAqD,CAAA,GAAE;AACjE,cAAI,wBAAwB,QAAW;AACrC,kCAAsB;iBACjB;AACL,yBAAa,qBAAqB,iBAAiB;;AAGrD,gBAAM,WAAW,uBAAuB,aAAa,kBAAkB;AACvE,gBAAM,mBAAmB,qCAAqC,qBAAqB,iBAAiB;AAEpG,mCAAyB,IAAI;AAE7B,cAAI,iBAAiB,SAAS,SAAS;AACrC,gBAAI,SAAS,SAAS,QAAW;AAC/B,oBAAM,IAAI,WAAW,4DAA4D;;AAEnF,kBAAM,gBAAgB,qBAAqB,UAAU,CAAC;AACtD,kEACE,MACA,kBACA,aAAa;iBAEV;AAEL,kBAAM,gBAAgB,qBAAqB,QAAQ;AACnD,kBAAM,gBAAgB,qBAAqB,UAAU,CAAC;AACtD,qEACE,MACA,kBACA,eACA,aAAa;;;QAQnB,IAAI,SAAM;AACR,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,kBAAM,4BAA0B,QAAQ;;AAG1C,iBAAO,uBAAuB,IAAI;;QASpC,OAAO,SAAc,QAAS;AAC5B,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,mBAAO,oBAAoB,4BAA0B,QAAQ,CAAC;;AAGhE,cAAI,uBAAuB,IAAI,GAAG;AAChC,mBAAO,oBAAoB,IAAI,UAAU,kDAAkD,CAAC;;AAG9F,iBAAO,qBAAqB,MAAM,MAAM;;QAsB1C,UACE,aAAgE,QAAS;AAEzE,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,kBAAM,4BAA0B,WAAW;;AAG7C,gBAAM,UAAU,qBAAqB,YAAY,iBAAiB;AAElE,cAAI,QAAQ,SAAS,QAAW;AAC9B,mBAAO,mCAAmC,IAAI;;AAIhD,iBAAO,gCAAgC,IAAqC;;QAc9E,YACE,cACA,aAAmD,CAAA,GAAE;AAErD,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,kBAAM,4BAA0B,aAAa;;AAE/C,iCAAuB,cAAc,GAAG,aAAa;AAErD,gBAAM,YAAY,4BAA4B,cAAc,iBAAiB;AAC7E,gBAAM,UAAU,mBAAmB,YAAY,kBAAkB;AAEjE,cAAI,uBAAuB,IAAI,GAAG;AAChC,kBAAM,IAAI,UAAU,gFAAgF;;AAEtG,cAAI,uBAAuB,UAAU,QAAQ,GAAG;AAC9C,kBAAM,IAAI,UAAU,gFAAgF;;AAGtG,gBAAM,UAAU,qBACd,MAAM,UAAU,UAAU,QAAQ,cAAc,QAAQ,cAAc,QAAQ,eAAe,QAAQ,MAAM;AAG7G,oCAA0B,OAAO;AAEjC,iBAAO,UAAU;;QAWnB,OAAO,aACA,aAAmD,CAAA,GAAE;AAC1D,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,mBAAO,oBAAoB,4BAA0B,QAAQ,CAAC;;AAGhE,cAAI,gBAAgB,QAAW;AAC7B,mBAAO,oBAAoB,sCAAsC;;AAEnE,cAAI,CAAC,iBAAiB,WAAW,GAAG;AAClC,mBAAO,oBACL,IAAI,UAAU,2EAA2E,CAAC;;AAI9F,cAAI;AACJ,cAAI;AACF,sBAAU,mBAAmB,YAAY,kBAAkB;mBACpD,IAAP;AACA,mBAAO,oBAAoB,EAAC;;AAG9B,cAAI,uBAAuB,IAAI,GAAG;AAChC,mBAAO,oBACL,IAAI,UAAU,2EAA2E,CAAC;;AAG9F,cAAI,uBAAuB,WAAW,GAAG;AACvC,mBAAO,oBACL,IAAI,UAAU,2EAA2E,CAAC;;AAI9F,iBAAO,qBACL,MAAM,aAAa,QAAQ,cAAc,QAAQ,cAAc,QAAQ,eAAe,QAAQ,MAAM;;QAexG,MAAG;AACD,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,kBAAM,4BAA0B,KAAK;;AAGvC,gBAAM,WAAW,kBAAkB,IAAW;AAC9C,iBAAO,oBAAoB,QAAQ;;QAerC,OAAO,aAA+D,QAAS;AAC7E,cAAI,CAAC,iBAAiB,IAAI,GAAG;AAC3B,kBAAM,4BAA0B,QAAQ;;AAG1C,gBAAM,UAAU,uBAAuB,YAAY,iBAAiB;AACpE,iBAAO,mCAAsC,MAAM,QAAQ,aAAa;;;AAS5E,aAAO,iBAAiB,gBAAe,WAAW;QAChD,QAAQ,EAAE,YAAY,KAAI;QAC1B,WAAW,EAAE,YAAY,KAAI;QAC7B,aAAa,EAAE,YAAY,KAAI;QAC/B,QAAQ,EAAE,YAAY,KAAI;QAC1B,KAAK,EAAE,YAAY,KAAI;QACvB,QAAQ,EAAE,YAAY,KAAI;QAC1B,QAAQ,EAAE,YAAY,KAAI;OAC3B;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,gBAAe,WAAW,eAAO,aAAa;UAClE,OAAO;UACP,cAAc;SACf;;AAEH,UAAI,OAAO,eAAO,kBAAkB,UAAU;AAC5C,eAAO,eAAe,gBAAe,WAAW,eAAO,eAAe;UACpE,OAAO,gBAAe,UAAU;UAChC,UAAU;UACV,cAAc;SACf;;oCAsBqC,gBACA,eACA,iBACA,gBAAgB,GAChB,gBAAgD,MAAM,GAAC;AAG7F,cAAM,SAA4B,OAAO,OAAO,gBAAe,SAAS;AACxE,iCAAyB,MAAM;AAE/B,cAAM,aAAiD,OAAO,OAAO,gCAAgC,SAAS;AAC9G,6CACE,QAAQ,YAAY,gBAAgB,eAAe,iBAAiB,eAAe,aAAa;AAGlG,eAAO;MACT;wCAIE,gBACA,eACA,iBAA+C;AAE/C,cAAM,SAA6B,OAAO,OAAO,gBAAe,SAAS;AACzE,iCAAyB,MAAM;AAE/B,cAAM,aAA2C,OAAO,OAAO,6BAA6B,SAAS;AACrG,0CAAkC,QAAQ,YAAY,gBAAgB,eAAe,iBAAiB,GAAG,MAAS;AAElH,eAAO;MACT;AAEA,wCAAkC,QAAsB;AACtD,eAAO,SAAS;AAChB,eAAO,UAAU;AACjB,eAAO,eAAe;AACtB,eAAO,aAAa;MACtB;gCAEiC,IAAU;AACzC,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,2BAA2B,GAAG;AACzE,iBAAO;;AAGT,eAAO,cAAa;MACtB;sCAQuC,QAAsB;AAG3D,YAAI,OAAO,YAAY,QAAW;AAChC,iBAAO;;AAGT,eAAO;MACT;oCAIwC,QAA2B,QAAW;AAC5E,eAAO,aAAa;AAEpB,YAAI,OAAO,WAAW,UAAU;AAC9B,iBAAO,oBAAoB,MAAS;;AAEtC,YAAI,OAAO,WAAW,WAAW;AAC/B,iBAAO,oBAAoB,OAAO,YAAY;;AAGhD,4BAAoB,MAAM;AAE1B,cAAM,SAAS,OAAO;AACtB,YAAI,WAAW,UAAa,2BAA2B,MAAM,GAAG;AAC9D,iBAAO,kBAAkB,QAAQ,qBAAe;AAC9C,4BAAgB,YAAY,MAAS;WACtC;AACD,iBAAO,oBAAoB,IAAI,YAAW;;AAG5C,cAAM,sBAAsB,OAAO,0BAA0B,aAAa,MAAM;AAChF,eAAO,qBAAqB,qBAAqB,KAAI;MACvD;mCAEuC,QAAyB;AAG9D,eAAO,SAAS;AAEhB,cAAM,SAAS,OAAO;AAEtB,YAAI,WAAW,QAAW;AACxB;;AAGF,0CAAkC,MAAM;AAExC,YAAI,8BAAiC,MAAM,GAAG;AAC5C,iBAAO,cAAc,QAAQ,iBAAW;AACtC,wBAAY,YAAW;WACxB;AACD,iBAAO,gBAAgB,IAAI,YAAW;;MAE1C;mCAEuC,QAA2B,IAAM;AAItE,eAAO,SAAS;AAChB,eAAO,eAAe;AAEtB,cAAM,SAAS,OAAO;AAEtB,YAAI,WAAW,QAAW;AACxB;;AAGF,yCAAiC,QAAQ,EAAC;AAE1C,YAAI,8BAAiC,MAAM,GAAG;AAC5C,iBAAO,cAAc,QAAQ,iBAAW;AACtC,wBAAY,YAAY,EAAC;WAC1B;AAED,iBAAO,gBAAgB,IAAI,YAAW;eACjC;AAGL,iBAAO,kBAAkB,QAAQ,qBAAe;AAC9C,4BAAgB,YAAY,EAAC;WAC9B;AAED,iBAAO,oBAAoB,IAAI,YAAW;;MAE9C;AAqBA,2CAAmC,OAAY;AAC7C,eAAO,IAAI,UAAU,4BAA4B,4CAA2C;MAC9F;0CCjhB2C,MACA,SAAe;AACxD,yBAAiB,MAAM,OAAO;AAC9B,cAAM,gBAAgB,SAAI,QAAJ,SAAI,SAAA,SAAJ,KAAM;AAC5B,4BAAoB,eAAe,iBAAiB,qBAAqB;AACzE,eAAO;UACL,eAAe,0BAA0B,aAAa;;MAE1D;ACLA,YAAM,yBAAyB,CAAC,UAAsB;AACpD,eAAO,MAAM;MACf;AACA,UAAI;AACF,eAAO,eAAe,wBAAwB,QAAQ;UACpD,OAAO;UACP,cAAc;SACf;eACD,IAAA;;YAUmB,0BAAyB;QAI5C,YAAY,SAA4B;AACtC,iCAAuB,SAAS,GAAG,2BAA2B;AAC9D,oBAAU,2BAA2B,SAAS,iBAAiB;AAC/D,eAAK,0CAA0C,QAAQ;;QAMzD,IAAI,gBAAa;AACf,cAAI,CAAC,4BAA4B,IAAI,GAAG;AACtC,kBAAM,8BAA8B,eAAe;;AAErD,iBAAO,KAAK;;QAMd,IAAI,OAAI;AACN,cAAI,CAAC,4BAA4B,IAAI,GAAG;AACtC,kBAAM,8BAA8B,MAAM;;AAE5C,iBAAO;;;AAIX,aAAO,iBAAiB,0BAA0B,WAAW;QAC3D,eAAe,EAAE,YAAY,KAAI;QACjC,MAAM,EAAE,YAAY,KAAI;OACzB;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,0BAA0B,WAAW,eAAO,aAAa;UAC7E,OAAO;UACP,cAAc;SACf;;AAKH,6CAAuC,OAAY;AACjD,eAAO,IAAI,UAAU,uCAAuC,uDAAsD;MACpH;2CAE4C,IAAM;AAChD,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,yCAAyC,GAAG;AACvF,iBAAO;;AAGT,eAAO,cAAa;MACtB;AC5EA,YAAM,oBAAoB,MAAA;AACxB,eAAO;MACT;AACA,UAAI;AACF,eAAO,eAAe,mBAAmB,QAAQ;UAC/C,OAAO;UACP,cAAc;SACf;eACD,IAAA;;YAUmB,qBAAoB;QAIvC,YAAY,SAA4B;AACtC,iCAAuB,SAAS,GAAG,sBAAsB;AACzD,oBAAU,2BAA2B,SAAS,iBAAiB;AAC/D,eAAK,qCAAqC,QAAQ;;QAMpD,IAAI,gBAAa;AACf,cAAI,CAAC,uBAAuB,IAAI,GAAG;AACjC,kBAAM,yBAAyB,eAAe;;AAEhD,iBAAO,KAAK;;QAOd,IAAI,OAAI;AACN,cAAI,CAAC,uBAAuB,IAAI,GAAG;AACjC,kBAAM,yBAAyB,MAAM;;AAEvC,iBAAO;;;AAIX,aAAO,iBAAiB,qBAAqB,WAAW;QACtD,eAAe,EAAE,YAAY,KAAI;QACjC,MAAM,EAAE,YAAY,KAAI;OACzB;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,qBAAqB,WAAW,eAAO,aAAa;UACxE,OAAO;UACP,cAAc;SACf;;AAKH,wCAAkC,OAAY;AAC5C,eAAO,IAAI,UAAU,kCAAkC,kDAAiD;MAC1G;sCAEuC,IAAM;AAC3C,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,oCAAoC,GAAG;AAClF,iBAAO;;AAGT,eAAO,cAAa;MACtB;kCCxEyC,UACA,SAAe;AACtD,yBAAiB,UAAU,OAAO;AAClC,cAAM,QAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACxB,cAAM,eAAe,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AAC/B,cAAM,QAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AACxB,cAAM,YAAY,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AAC5B,cAAM,eAAe,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU;AAC/B,eAAO;UACL,OAAO,UAAU,SACf,SACA,gCAAgC,OAAO,UAAW,GAAG,iCAAiC;UACxF;UACA,OAAO,UAAU,SACf,SACA,gCAAgC,OAAO,UAAW,GAAG,iCAAiC;UACxF,WAAW,cAAc,SACvB,SACA,oCAAoC,WAAW,UAAW,GAAG,qCAAqC;UACpG;;MAEJ;AAEA,+CACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,eAAoD,YAAY,IAAI,UAAU,CAAC,UAAU,CAAC;MACpG;AAEA,+CACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,eAAoD,YAAY,IAAI,UAAU,CAAC,UAAU,CAAC;MACpG;AAEA,mDACE,IACA,UACA,SAAe;AAEf,uBAAe,IAAI,OAAO;AAC1B,eAAO,CAAC,OAAU,eAAoD,YAAY,IAAI,UAAU,CAAC,OAAO,UAAU,CAAC;MACrH;YCvBa,gBAAe;QAmB1B,YAAY,iBAAuD,CAAA,GACvD,sBAA6D,CAAA,GAC7D,sBAA6D,CAAA,GAAE;AACzE,cAAI,mBAAmB,QAAW;AAChC,6BAAiB;;AAGnB,gBAAM,mBAAmB,uBAAuB,qBAAqB,kBAAkB;AACvF,gBAAM,mBAAmB,uBAAuB,qBAAqB,iBAAiB;AAEtF,gBAAM,cAAc,mBAAmB,gBAAgB,iBAAiB;AACxE,cAAI,YAAY,iBAAiB,QAAW;AAC1C,kBAAM,IAAI,WAAW,gCAAgC;;AAEvD,cAAI,YAAY,iBAAiB,QAAW;AAC1C,kBAAM,IAAI,WAAW,gCAAgC;;AAGvD,gBAAM,wBAAwB,qBAAqB,kBAAkB,CAAC;AACtE,gBAAM,wBAAwB,qBAAqB,gBAAgB;AACnE,gBAAM,wBAAwB,qBAAqB,kBAAkB,CAAC;AACtE,gBAAM,wBAAwB,qBAAqB,gBAAgB;AAEnE,cAAI;AACJ,gBAAM,eAAe,WAAiB,cAAO;AAC3C,mCAAuB;WACxB;AAED,oCACE,MAAM,cAAc,uBAAuB,uBAAuB,uBAAuB,qBAAqB;AAEhH,+DAAqD,MAAM,WAAW;AAEtE,cAAI,YAAY,UAAU,QAAW;AACnC,iCAAqB,YAAY,MAAM,KAAK,0BAA0B,CAAC;iBAClE;AACL,iCAAqB,MAAS;;;QAOlC,IAAI,WAAQ;AACV,cAAI,CAAC,kBAAkB,IAAI,GAAG;AAC5B,kBAAM,0BAA0B,UAAU;;AAG5C,iBAAO,KAAK;;QAMd,IAAI,WAAQ;AACV,cAAI,CAAC,kBAAkB,IAAI,GAAG;AAC5B,kBAAM,0BAA0B,UAAU;;AAG5C,iBAAO,KAAK;;;AAIhB,aAAO,iBAAiB,gBAAgB,WAAW;QACjD,UAAU,EAAE,YAAY,KAAI;QAC5B,UAAU,EAAE,YAAY,KAAI;OAC7B;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,gBAAgB,WAAW,eAAO,aAAa;UACnE,OAAO;UACP,cAAc;SACf;;AAyCH,yCAAyC,QACA,cACA,uBACA,uBACA,uBACA,uBAAqD;AAC5F,kCAAuB;AACrB,iBAAO;;AAGT,gCAAwB,OAAQ;AAC9B,iBAAO,yCAAyC,QAAQ,KAAK;;AAG/D,gCAAwB,QAAW;AACjC,iBAAO,yCAAyC,QAAQ,MAAM;;AAGhE,kCAAuB;AACrB,iBAAO,yCAAyC,MAAM;;AAGxD,eAAO,YAAY,qBAAqB,gBAAgB,gBAAgB,gBAAgB,gBAChD,uBAAuB,qBAAqB;AAEpF,iCAAsB;AACpB,iBAAO,0CAA0C,MAAM;;AAGzD,iCAAyB,QAAW;AAClC,sDAA4C,QAAQ,MAAM;AAC1D,iBAAO,oBAAoB,MAAS;;AAGtC,eAAO,YAAY,qBAAqB,gBAAgB,eAAe,iBAAiB,uBAChD,qBAAqB;AAG7D,eAAO,gBAAgB;AACvB,eAAO,6BAA6B;AACpC,eAAO,qCAAqC;AAC5C,uCAA+B,QAAQ,IAAI;AAE3C,eAAO,6BAA6B;MACtC;AAEA,iCAA2B,IAAU;AACnC,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,4BAA4B,GAAG;AAC1E,iBAAO;;AAGT,eAAO,cAAa;MACtB;AAGA,oCAA8B,QAAyB,IAAM;AAC3D,6CACE,OAAO,UAAU,2BACjB,EAAC;AAEH,oDAA4C,QAAQ,EAAC;MACvD;AAEA,2DAAqD,QAAyB,IAAM;AAClF,wDAAgD,OAAO,0BAA0B;AACjF,qDAA6C,OAAO,UAAU,2BAA2B,EAAC;AAC1F,YAAI,OAAO,eAAe;AAIxB,yCAA+B,QAAQ,KAAK;;MAEhD;AAEA,8CAAwC,QAAyB,cAAqB;AAIpF,YAAI,OAAO,+BAA+B,QAAW;AACnD,iBAAO,mCAAkC;;AAG3C,eAAO,6BAA6B,WAAW,cAAO;AACpD,iBAAO,qCAAqC;SAC7C;AAED,eAAO,gBAAgB;MACzB;YASa,iCAAgC;QAQ3C,cAAA;AACE,gBAAM,IAAI,UAAU,qBAAqB;;QAM3C,IAAI,cAAW;AACb,cAAI,CAAC,mCAAmC,IAAI,GAAG;AAC7C,kBAAM,qCAAqC,aAAa;;AAG1D,gBAAM,qBAAqB,KAAK,2BAA2B,UAAU;AACrE,iBAAO,8CAA8C,kBAAwD;;QAO/G,QAAQ,QAAW,QAAU;AAC3B,cAAI,CAAC,mCAAmC,IAAI,GAAG;AAC7C,kBAAM,qCAAqC,SAAS;;AAGtD,kDAAwC,MAAM,KAAK;;QAOrD,MAAM,SAAc,QAAS;AAC3B,cAAI,CAAC,mCAAmC,IAAI,GAAG;AAC7C,kBAAM,qCAAqC,OAAO;;AAGpD,gDAAsC,MAAM,MAAM;;QAOpD,YAAS;AACP,cAAI,CAAC,mCAAmC,IAAI,GAAG;AAC7C,kBAAM,qCAAqC,WAAW;;AAGxD,oDAA0C,IAAI;;;AAIlD,aAAO,iBAAiB,iCAAiC,WAAW;QAClE,SAAS,EAAE,YAAY,KAAI;QAC3B,OAAO,EAAE,YAAY,KAAI;QACzB,WAAW,EAAE,YAAY,KAAI;QAC7B,aAAa,EAAE,YAAY,KAAI;OAChC;AACD,UAAI,OAAO,eAAO,gBAAgB,UAAU;AAC1C,eAAO,eAAe,iCAAiC,WAAW,eAAO,aAAa;UACpF,OAAO;UACP,cAAc;SACf;;AAKH,kDAAqD,IAAM;AACzD,YAAI,CAAC,aAAa,EAAC,GAAG;AACpB,iBAAO;;AAGT,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,IAAG,4BAA4B,GAAG;AAC1E,iBAAO;;AAGT,eAAO,cAAa;MACtB;AAEA,qDAAqD,QACA,YACA,oBACA,gBAAmC;AAItF,mBAAW,6BAA6B;AACxC,eAAO,6BAA6B;AAEpC,mBAAW,sBAAsB;AACjC,mBAAW,kBAAkB;MAC/B;AAEA,oEAAoE,QACA,aAAuC;AACzG,cAAM,aAAkD,OAAO,OAAO,iCAAiC,SAAS;AAEhH,YAAI,qBAAqB,CAAC,UAAQ;AAChC,cAAI;AACF,oDAAwC,YAAY,KAAqB;AACzE,mBAAO,oBAAoB,MAAS;mBAC7B,kBAAP;AACA,mBAAO,oBAAoB,gBAAgB;;;AAI/C,YAAI,iBAAsC,MAAM,oBAAoB,MAAS;AAE7E,YAAI,YAAY,cAAc,QAAW;AACvC,+BAAqB,WAAS,YAAY,UAAW,OAAO,UAAU;;AAExE,YAAI,YAAY,UAAU,QAAW;AACnC,2BAAiB,MAAM,YAAY,MAAO,UAAU;;AAGtD,8CAAsC,QAAQ,YAAY,oBAAoB,cAAc;MAC9F;AAEA,+DAAyD,YAAiD;AACxG,mBAAW,sBAAsB;AACjC,mBAAW,kBAAkB;MAC/B;AAEA,uDAAoD,YAAiD,OAAQ;AAC3G,cAAM,SAAS,WAAW;AAC1B,cAAM,qBAAqB,OAAO,UAAU;AAC5C,YAAI,CAAC,iDAAiD,kBAAkB,GAAG;AACzE,gBAAM,IAAI,UAAU,sDAAsD;;AAM5E,YAAI;AACF,iDAAuC,oBAAoB,KAAK;iBACzD,IAAP;AAEA,sDAA4C,QAAQ,EAAC;AAErD,gBAAM,OAAO,UAAU;;AAGzB,cAAM,eAAe,+CAA+C,kBAAkB;AACtF,YAAI,iBAAiB,OAAO,eAAe;AAEzC,yCAA+B,QAAQ,IAAI;;MAE/C;AAEA,qDAA+C,YAAmD,IAAM;AACtG,6BAAqB,WAAW,4BAA4B,EAAC;MAC/D;AAEA,gEAAgE,YACA,OAAQ;AACtE,cAAM,mBAAmB,WAAW,oBAAoB,KAAK;AAC7D,eAAO,qBAAqB,kBAAkB,QAAW,QAAC;AACxD,+BAAqB,WAAW,4BAA4B,EAAC;AAC7D,gBAAM;SACP;MACH;AAEA,yDAAsD,YAA+C;AACnG,cAAM,SAAS,WAAW;AAC1B,cAAM,qBAAqB,OAAO,UAAU;AAE5C,6CAAqC,kBAAkB;AAEvD,cAAM,QAAQ,IAAI,UAAU,4BAA4B;AACxD,oDAA4C,QAAQ,KAAK;MAC3D;AAIA,wDAAwD,QAA+B,OAAQ;AAG7F,cAAM,aAAa,OAAO;AAE1B,YAAI,OAAO,eAAe;AACxB,gBAAM,4BAA4B,OAAO;AAEzC,iBAAO,qBAAqB,2BAA2B,MAAA;AACrD,kBAAM,WAAW,OAAO;AACxB,kBAAM,SAAQ,SAAS;AACvB,gBAAI,WAAU,YAAY;AACxB,oBAAM,SAAS;;AAGjB,mBAAO,iDAAuD,YAAY,KAAK;WAChF;;AAGH,eAAO,iDAAuD,YAAY,KAAK;MACjF;AAEA,wDAAkD,QAAyB,QAAW;AAGpF,6BAAqB,QAAQ,MAAM;AACnC,eAAO,oBAAoB,MAAS;MACtC;AAEA,wDAAwD,QAA6B;AAEnF,cAAM,WAAW,OAAO;AAExB,cAAM,aAAa,OAAO;AAC1B,cAAM,eAAe,WAAW,gBAAe;AAC/C,wDAAgD,UAAU;AAG1D,eAAO,qBAAqB,cAAc,MAAA;AACxC,cAAI,SAAS,WAAW,WAAW;AACjC,kBAAM,SAAS;;AAEjB,+CAAqC,SAAS,yBAA+D;WAC5G,QAAC;AACF,+BAAqB,QAAQ,EAAC;AAC9B,gBAAM,SAAS;SAChB;MACH;AAIA,yDAAmD,QAAuB;AAMxE,uCAA+B,QAAQ,KAAK;AAG5C,eAAO,OAAO;MAChB;AAIA,oDAA8C,OAAY;AACxD,eAAO,IAAI,UACT,8CAA8C,8DAA6D;MAC/G;AAIA,yCAAmC,OAAY;AAC7C,eAAO,IAAI,UACT,6BAA6B,6CAA4C;MAC7E;;;;;;;;;;;;;;;;;;;;AC7gBA;AAAA;AAEA,QAAM,aAAY;AAElB,QAAI,CAAC,WAAW,gBAAgB;AAI9B,UAAI;AACF,cAAM,WAAU,QAAQ;AACxB,cAAM,EAAE,gBAAgB;AACxB,YAAI;AACF,mBAAQ,cAAc,MAAM;AAAA,UAAC;AAC7B,iBAAO,OAAO,YAAY,QAAQ,kBAAkB;AACpD,mBAAQ,cAAc;AAAA,QACxB,SAAS,OAAP;AACA,mBAAQ,cAAc;AACtB,gBAAM;AAAA,QACR;AAAA,MACF,SAAS,OAAP;AAEA,eAAO,OAAO,YAAY,0BAAuD;AAAA,MACnF;AAAA,IACF;AAEA,QAAI;AAGF,YAAM,EAAE,gBAAS,QAAQ;AACzB,UAAI,SAAQ,CAAC,MAAK,UAAU,QAAQ;AAClC,cAAK,UAAU,SAAS,eAAe,QAAQ;AAC7C,cAAI,WAAW;AACf,gBAAM,OAAO;AAEb,iBAAO,IAAI,eAAe;AAAA,YACxB,MAAM;AAAA,YACN,MAAM,KAAM,MAAM;AAChB,oBAAM,QAAQ,KAAK,MAAM,UAAU,KAAK,IAAI,KAAK,MAAM,WAAW,UAAS,CAAC;AAC5E,oBAAM,SAAS,MAAM,MAAM,YAAY;AACvC,0BAAY,OAAO;AACnB,mBAAK,QAAQ,IAAI,WAAW,MAAM,CAAC;AAEnC,kBAAI,aAAa,KAAK,MAAM;AAC1B,qBAAK,MAAM;AAAA,cACb;AAAA,YACF;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF,SAAS,OAAP;AAAA,IAAe;AAAA;AAAA;;;ACtCjB,4BAA6B,OAAO,SAAQ,MAAM;AAChD,aAAW,QAAQ,OAAO;AACxB,QAAI,YAAY,MAAM;AACpB,aAA2D,KAAK,OAAO;AAAA,IACzE,WAAW,YAAY,OAAO,IAAI,GAAG;AACnC,UAAI,QAAO;AACT,YAAI,WAAW,KAAK;AACpB,cAAM,MAAM,KAAK,aAAa,KAAK;AACnC,eAAO,aAAa,KAAK;AACvB,gBAAM,OAAO,KAAK,IAAI,MAAM,UAAU,UAAS;AAC/C,gBAAM,QAAQ,KAAK,OAAO,MAAM,UAAU,WAAW,IAAI;AACzD,sBAAY,MAAM;AAClB,gBAAM,IAAI,WAAW,KAAK;AAAA,QAC5B;AAAA,MACF,OAAO;AACL,cAAM;AAAA,MACR;AAAA,IAEF,OAAO;AAEL,UAAI,WAAW,GAAG,IAA0B;AAC5C,aAAO,aAAa,EAAE,MAAM;AAC1B,cAAM,QAAQ,EAAE,MAAM,UAAU,KAAK,IAAI,EAAE,MAAM,WAAW,UAAS,CAAC;AACtE,cAAM,SAAS,MAAM,MAAM,YAAY;AACvC,oBAAY,OAAO;AACnB,cAAM,IAAI,WAAW,MAAM;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AACF;AAxCA,IAKA,iBAGM,YAkCA,QA8MO,OACN;AAzPP;AAAA;AAKA,sBAAO;AALP,AAQA,IAAM,aAAY;AAkClB,IAAM,SAAQ,MAAM,MAAK;AAAA,MAEvB,SAAS,CAAC;AAAA,MACV,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,WAAW;AAAA,MAUX,YAAa,YAAY,CAAC,GAAG,UAAU,CAAC,GAAG;AACzC,YAAI,OAAO,cAAc,YAAY,cAAc,MAAM;AACvD,gBAAM,IAAI,UAAU,mFAAqF;AAAA,QAC3G;AAEA,YAAI,OAAO,UAAU,OAAO,cAAc,YAAY;AACpD,gBAAM,IAAI,UAAU,kFAAoF;AAAA,QAC1G;AAEA,YAAI,OAAO,YAAY,YAAY,OAAO,YAAY,YAAY;AAChE,gBAAM,IAAI,UAAU,uEAAyE;AAAA,QAC/F;AAEA,YAAI,YAAY;AAAM,oBAAU,CAAC;AAEjC,cAAM,UAAU,IAAI,YAAY;AAChC,mBAAW,WAAW,WAAW;AAC/B,cAAI;AACJ,cAAI,YAAY,OAAO,OAAO,GAAG;AAC/B,mBAAO,IAAI,WAAW,QAAQ,OAAO,MAAM,QAAQ,YAAY,QAAQ,aAAa,QAAQ,UAAU,CAAC;AAAA,UACzG,WAAW,mBAAmB,aAAa;AACzC,mBAAO,IAAI,WAAW,QAAQ,MAAM,CAAC,CAAC;AAAA,UACxC,WAAW,mBAAmB,OAAM;AAClC,mBAAO;AAAA,UACT,OAAO;AACL,mBAAO,QAAQ,OAAO,GAAG,SAAS;AAAA,UACpC;AAEA,eAAK,SAAS,YAAY,OAAO,IAAI,IAAI,KAAK,aAAa,KAAK;AAChE,eAAK,OAAO,KAAK,IAAI;AAAA,QACvB;AAEA,aAAK,WAAW,GAAG,QAAQ,YAAY,SAAY,gBAAgB,QAAQ;AAC3E,cAAM,OAAO,QAAQ,SAAS,SAAY,KAAK,OAAO,QAAQ,IAAI;AAClE,aAAK,QAAQ,iBAAiB,KAAK,IAAI,IAAI,OAAO;AAAA,MACpD;AAAA,MAMA,IAAI,OAAQ;AACV,eAAO,KAAK;AAAA,MACd;AAAA,MAKA,IAAI,OAAQ;AACV,eAAO,KAAK;AAAA,MACd;AAAA,MASA,MAAM,OAAQ;AAGZ,cAAM,UAAU,IAAI,YAAY;AAChC,YAAI,MAAM;AACV,yBAAiB,QAAQ,YAAW,KAAK,QAAQ,KAAK,GAAG;AACvD,iBAAO,QAAQ,OAAO,MAAM,EAAE,QAAQ,KAAK,CAAC;AAAA,QAC9C;AAEA,eAAO,QAAQ,OAAO;AACtB,eAAO;AAAA,MACT;AAAA,MASA,MAAM,cAAe;AAMnB,cAAM,OAAO,IAAI,WAAW,KAAK,IAAI;AACrC,YAAI,SAAS;AACb,yBAAiB,SAAS,YAAW,KAAK,QAAQ,KAAK,GAAG;AACxD,eAAK,IAAI,OAAO,MAAM;AACtB,oBAAU,MAAM;AAAA,QAClB;AAEA,eAAO,KAAK;AAAA,MACd;AAAA,MAEA,SAAU;AACR,cAAM,KAAK,YAAW,KAAK,QAAQ,IAAI;AAEvC,eAAO,IAAI,WAAW,eAAe;AAAA,UAEnC,MAAM;AAAA,UACN,MAAM,KAAM,MAAM;AAChB,kBAAM,QAAQ,MAAM,GAAG,KAAK;AAC5B,kBAAM,OAAO,KAAK,MAAM,IAAI,KAAK,QAAQ,MAAM,KAAK;AAAA,UACtD;AAAA,UAEA,MAAM,SAAU;AACd,kBAAM,GAAG,OAAO;AAAA,UAClB;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MAWA,MAAO,QAAQ,GAAG,MAAM,KAAK,MAAM,OAAO,IAAI;AAC5C,cAAM,EAAE,SAAS;AAEjB,YAAI,gBAAgB,QAAQ,IAAI,KAAK,IAAI,OAAO,OAAO,CAAC,IAAI,KAAK,IAAI,OAAO,IAAI;AAChF,YAAI,cAAc,MAAM,IAAI,KAAK,IAAI,OAAO,KAAK,CAAC,IAAI,KAAK,IAAI,KAAK,IAAI;AAExE,cAAM,OAAO,KAAK,IAAI,cAAc,eAAe,CAAC;AACpD,cAAM,QAAQ,KAAK;AACnB,cAAM,YAAY,CAAC;AACnB,YAAI,QAAQ;AAEZ,mBAAW,QAAQ,OAAO;AAExB,cAAI,SAAS,MAAM;AACjB;AAAA,UACF;AAEA,gBAAM,QAAO,YAAY,OAAO,IAAI,IAAI,KAAK,aAAa,KAAK;AAC/D,cAAI,iBAAiB,SAAQ,eAAe;AAG1C,6BAAiB;AACjB,2BAAe;AAAA,UACjB,OAAO;AACL,gBAAI;AACJ,gBAAI,YAAY,OAAO,IAAI,GAAG;AAC5B,sBAAQ,KAAK,SAAS,eAAe,KAAK,IAAI,OAAM,WAAW,CAAC;AAChE,uBAAS,MAAM;AAAA,YACjB,OAAO;AACL,sBAAQ,KAAK,MAAM,eAAe,KAAK,IAAI,OAAM,WAAW,CAAC;AAC7D,uBAAS,MAAM;AAAA,YACjB;AACA,2BAAe;AACf,sBAAU,KAAK,KAAK;AACpB,4BAAgB;AAAA,UAClB;AAAA,QACF;AAEA,cAAM,OAAO,IAAI,MAAK,CAAC,GAAG,EAAE,MAAM,OAAO,IAAI,EAAE,YAAY,EAAE,CAAC;AAC9D,aAAK,QAAQ;AACb,aAAK,SAAS;AAEd,eAAO;AAAA,MACT;AAAA,MAEA,KAAK,OAAO,eAAgB;AAC1B,eAAO;AAAA,MACT;AAAA,MAEA,QAAQ,OAAO,aAAc,QAAQ;AACnC,eACE,UACA,OAAO,WAAW,YAClB,OAAO,OAAO,gBAAgB,cAE5B,QAAO,OAAO,WAAW,cACzB,OAAO,OAAO,gBAAgB,eAEhC,gBAAgB,KAAK,OAAO,OAAO,YAAY;AAAA,MAEnD;AAAA,IACF;AAEA,WAAO,iBAAiB,OAAM,WAAW;AAAA,MACvC,MAAM,EAAE,YAAY,KAAK;AAAA,MACzB,MAAM,EAAE,YAAY,KAAK;AAAA,MACzB,OAAO,EAAE,YAAY,KAAK;AAAA,IAC5B,CAAC;AAGM,IAAM,QAAO;AACpB,IAAO,sBAAQ;AAAA;AAAA;;;ACzPf,IAEM,QA6CO,OACN;AAhDP;AAAA;AAAA;AAEA,IAAM,SAAQ,MAAM,cAAa,oBAAK;AAAA,MACpC,gBAAgB;AAAA,MAChB,QAAQ;AAAA,MAOR,YAAa,UAAU,UAAU,UAAU,CAAC,GAAG;AAC7C,YAAI,UAAU,SAAS,GAAG;AACxB,gBAAM,IAAI,UAAU,8DAA8D,UAAU,iBAAiB;AAAA,QAC/G;AACA,cAAM,UAAU,OAAO;AAEvB,YAAI,YAAY;AAAM,oBAAU,CAAC;AAGjC,cAAM,eAAe,QAAQ,iBAAiB,SAAY,KAAK,IAAI,IAAI,OAAO,QAAQ,YAAY;AAClG,YAAI,CAAC,OAAO,MAAM,YAAY,GAAG;AAC/B,eAAK,gBAAgB;AAAA,QACvB;AAEA,aAAK,QAAQ,OAAO,QAAQ;AAAA,MAC9B;AAAA,MAEA,IAAI,OAAQ;AACV,eAAO,KAAK;AAAA,MACd;AAAA,MAEA,IAAI,eAAgB;AAClB,eAAO,KAAK;AAAA,MACd;AAAA,MAEA,KAAK,OAAO,eAAgB;AAC1B,eAAO;AAAA,MACT;AAAA,MAEA,QAAQ,OAAO,aAAc,QAAQ;AACnC,eAAO,CAAC,CAAC,UAAU,kBAAkB,uBACnC,WAAW,KAAK,OAAO,OAAO,YAAY;AAAA,MAC9C;AAAA,IACF;AAGO,IAAM,QAAO;AACpB,IAAO,gBAAQ;AAAA;AAAA;;;ACfR,yBAAyB,IAAE,IAAE,qBAAE;AACtC,MAAI,IAAE,GAAG,GAAE,IAAI,GAAE,IAAI,QAAQ,OAAO,EAAE,EAAE,MAAM,GAAG,EAAE,SAAS,IAAI,GAAG,GAAE,IAAE,CAAC,GAAE,IAAE,KAAK;AAAA;AACjF,KAAE,QAAQ,CAAC,GAAE,MAAI,OAAO,KAAG,WAC1B,EAAE,KAAK,IAAE,GAAE,CAAC,IAAE;AAAA;AAAA,EAAY,EAAE,QAAQ,uBAAuB,MAAM;AAAA,CAAO,IACxE,EAAE,KAAK,IAAE,GAAE,CAAC,IAAE,gBAAgB,GAAE,EAAE,MAAM,CAAC;AAAA,gBAAuB,EAAE,QAAM;AAAA;AAAA,GAAsC,GAAG,MAAM,CAAC;AACzH,IAAE,KAAK,KAAK,KAAK;AACjB,SAAO,IAAI,EAAE,GAAE,EAAC,MAAK,mCAAiC,EAAC,CAAC;AAAC;AAvCzD,IAKiB,IAAW,IAAc,IAC1C,IACA,IACA,IACA,IACA,IAKa;AAfb;AAAA;AAEA;AACA;AAHA,AAKA,IAAI,GALJ,AAKK,aAAY,IALjB,AAKmB,UAAS,IAL5B,AAK8B,aAAY,OAAG;AAA7C,IACA,KAAE,KAAK;AADP,IAEA,KAAE,uEAAuE,MAAM,GAAG;AAFlF,IAGA,KAAE,CAAC,GAAE,GAAE,MAAK,MAAG,IAAG,gBAAgB,KAAK,KAAK,EAAE,GAAE,IAAE,CAAE,KAAE,MAAI,SAAO,IAAE,KAAG,EAAE,OAAI,SAAO,EAAE,OAAK,QAAO,IAAG,EAAE,SAAO,KAAG,EAAE,OAAI,SAAO,IAAI,cAAE,CAAC,CAAC,GAAE,GAAE,CAAC,IAAE,CAAC,IAAE,CAAC,GAAE,IAAE,EAAE;AAHtJ,IAIA,KAAE,CAAC,GAAE,OAAK,MAAE,IAAE,EAAE,QAAQ,aAAY,MAAM,GAAG,QAAQ,OAAM,KAAK,EAAE,QAAQ,OAAM,KAAK,EAAE,QAAQ,MAAK,KAAK;AAJzG,IAKA,KAAE,CAAC,GAAG,GAAG,OAAI;AAAC,UAAG,EAAE,SAAO,IAAE;AAAC,cAAM,IAAI,UAAU,sBAAsB,qBAAqB,mCAAkC,EAAE,iBAAiB;AAAA,MAAC;AAAA,IAAC;AAK5I,IAAM,YAAW,MAAM,UAAS;AAAA,MACvC,KAAG,CAAC;AAAA,MACJ,eAAe,GAAE;AAAC,YAAG,EAAE;AAAO,gBAAM,IAAI,UAAU,+EAA+E;AAAA,MAAC;AAAA,MAClI,KAAK,MAAK;AAAC,eAAO;AAAA,MAAU;AAAA,MAC5B,CAAC,MAAI;AAAC,eAAO,KAAK,QAAQ;AAAA,MAAC;AAAA,MAC3B,QAAQ,IAAG,GAAG;AAAC,eAAO,KAAG,OAAO,MAAI,YAAU,EAAE,QAAK,cAAY,CAAC,GAAE,KAAK,QAAG,OAAO,EAAE,OAAI,UAAU;AAAA,MAAC;AAAA,MACpG,UAAU,GAAE;AAAC,WAAE,UAAS,WAAU,CAAC;AAAE,aAAK,GAAG,KAAK,GAAE,GAAG,CAAC,CAAC;AAAA,MAAC;AAAA,MAC1D,OAAO,GAAE;AAAC,WAAE,UAAS,WAAU,CAAC;AAAE,aAAG;AAAG,aAAK,KAAG,KAAK,GAAG,OAAO,CAAC,CAAC,OAAK,MAAI,CAAC;AAAA,MAAC;AAAA,MAC5E,IAAI,GAAE;AAAC,WAAE,OAAM,WAAU,CAAC;AAAE,aAAG;AAAG,iBAAQ,IAAE,KAAK,IAAG,IAAE,EAAE,QAAO,IAAE,GAAE,IAAE,GAAE;AAAI,cAAG,EAAE,GAAG,OAAK;AAAE,mBAAO,EAAE,GAAG;AAAG,eAAO;AAAA,MAAI;AAAA,MACpH,OAAO,GAAE,GAAE;AAAC,WAAE,UAAS,WAAU,CAAC;AAAE,YAAE,CAAC;AAAE,aAAG;AAAG,aAAK,GAAG,QAAQ,OAAG,EAAE,OAAK,KAAG,EAAE,KAAK,EAAE,EAAE,CAAC;AAAE,eAAO;AAAA,MAAC;AAAA,MAClG,IAAI,GAAE;AAAC,WAAE,OAAM,WAAU,CAAC;AAAE,aAAG;AAAG,eAAO,KAAK,GAAG,KAAK,OAAG,EAAE,OAAK,CAAC;AAAA,MAAC;AAAA,MAClE,QAAQ,GAAE,GAAE;AAAC,WAAE,WAAU,WAAU,CAAC;AAAE,iBAAQ,CAAC,GAAE,MAAK;AAAK,YAAE,KAAK,GAAE,GAAE,GAAE,IAAI;AAAA,MAAC;AAAA,MAC7E,OAAO,GAAE;AAAC,WAAE,OAAM,WAAU,CAAC;AAAE,YAAI,IAAE,CAAC,GAAE,IAAE;AAAG,YAAE,GAAE,GAAG,CAAC;AAAE,aAAK,GAAG,QAAQ,OAAG;AAAC,YAAE,OAAK,EAAE,KAAG,KAAI,KAAE,CAAC,EAAE,KAAK,CAAC,KAAG,EAAE,KAAK,CAAC;AAAA,QAAC,CAAC;AAAE,aAAG,EAAE,KAAK,CAAC;AAAE,aAAK,KAAG;AAAA,MAAC;AAAA,MAC3I,CAAC,UAAS;AAAC,eAAM,KAAK;AAAA,MAAE;AAAA,MACxB,CAAC,OAAM;AAAC,iBAAO,CAAC,MAAK;AAAK,gBAAM;AAAA,MAAC;AAAA,MACjC,CAAC,SAAQ;AAAC,iBAAO,CAAC,EAAC,MAAK;AAAK,gBAAM;AAAA,MAAC;AAAA,IAAC;AAAA;AAAA;;;AC9BrC,IAAa;AAAb;AAAA;AAAO,IAAM,kBAAN,cAA6B,MAAM;AAAA,MACzC,YAAY,SAAS,MAAM;AAC1B,cAAM,OAAO;AAEb,cAAM,kBAAkB,MAAM,KAAK,WAAW;AAE9C,aAAK,OAAO;AAAA,MACb;AAAA,MAEA,IAAI,OAAO;AACV,eAAO,KAAK,YAAY;AAAA,MACzB;AAAA,MAEA,KAAK,OAAO,eAAe;AAC1B,eAAO,KAAK,YAAY;AAAA,MACzB;AAAA,IACD;AAAA;AAAA;;;AChBA,IAUa;AAVb;AAAA;AACA;AASO,IAAM,cAAN,cAAyB,gBAAe;AAAA,MAM9C,YAAY,SAAS,MAAM,aAAa;AACvC,cAAM,SAAS,IAAI;AAEnB,YAAI,aAAa;AAEhB,eAAK,OAAO,KAAK,QAAQ,YAAY;AACrC,eAAK,iBAAiB,YAAY;AAAA,QACnC;AAAA,MACD;AAAA,IACD;AAAA;AAAA;;;ACzBA,IAMM,OAQO,wBAmBA,SAiBA,gBAiBA,sBAcA;AAjFb;AAAA;AAMA,IAAM,QAAO,OAAO;AAQb,IAAM,yBAAwB,YAAU;AAC9C,aACC,OAAO,WAAW,YAClB,OAAO,OAAO,WAAW,cACzB,OAAO,OAAO,WAAW,cACzB,OAAO,OAAO,QAAQ,cACtB,OAAO,OAAO,WAAW,cACzB,OAAO,OAAO,QAAQ,cACtB,OAAO,OAAO,QAAQ,cACtB,OAAO,OAAO,SAAS,cACvB,OAAO,WAAU;AAAA,IAEnB;AAOO,IAAM,UAAS,YAAU;AAC/B,aACC,UACA,OAAO,WAAW,YAClB,OAAO,OAAO,gBAAgB,cAC9B,OAAO,OAAO,SAAS,YACvB,OAAO,OAAO,WAAW,cACzB,OAAO,OAAO,gBAAgB,cAC9B,gBAAgB,KAAK,OAAO,MAAK;AAAA,IAEnC;AAOO,IAAM,iBAAgB,YAAU;AACtC,aACC,OAAO,WAAW,YACjB,QAAO,WAAU,iBACjB,OAAO,WAAU;AAAA,IAGpB;AAUO,IAAM,uBAAsB,CAAC,aAAa,aAAa;AAC7D,YAAM,OAAO,IAAI,IAAI,QAAQ,EAAE;AAC/B,YAAM,OAAO,IAAI,IAAI,WAAW,EAAE;AAElC,aAAO,SAAS,QAAQ,KAAK,SAAS,IAAI,MAAM;AAAA,IACjD;AASO,IAAM,kBAAiB,CAAC,aAAa,aAAa;AACxD,YAAM,OAAO,IAAI,IAAI,QAAQ,EAAE;AAC/B,YAAM,OAAO,IAAI,IAAI,WAAW,EAAE;AAElC,aAAO,SAAS;AAAA,IACjB;AAAA;AAAA;;;ACtFA;AAAA;AAEA,QAAI,CAAC,WAAW,cAAc;AAC5B,UAAI;AACF,cAAM,EAAE,mBAAmB,QAAQ,mBACnC,OAAO,IAAI,eAAe,EAAE,OAC5B,KAAK,IAAI,YAAY;AACrB,aAAK,YAAY,IAAI,CAAC,IAAI,EAAE,CAAC;AAAA,MAC/B,SAAS,KAAP;AACA,YAAI,YAAY,SAAS,kBACvB,YAAW,eAAe,IAAI;AAAA,MAElC;AAAA,IACF;AAEA,YAAO,UAAU,WAAW;AAAA;AAAA;;;ACf5B,qBACA,mBACA,2BAKQ,OAMF,eAOA,WAOA,WAMA,eAGA,WAQA,WAcA;AA1DN;AAAA;AAAA,sBAA2D;AAC3D,wBAAyB;AACzB,gCAAyB;AAEzB;AACA;AAEA,IAAM,GAPN,AAOQ,gBAAS;AAMjB,IAAM,gBAAe,CAAC,MAAM,SAAS,UAAS,8BAAS,IAAI,GAAG,MAAM,IAAI;AAOxE,IAAM,YAAW,CAAC,MAAM,SAAS,MAAK,IAAI,EAAE,KAAK,WAAQ,UAAS,OAAM,MAAM,IAAI,CAAC;AAOnF,IAAM,YAAW,CAAC,MAAM,SAAS,MAAK,IAAI,EAAE,KAAK,WAAQ,UAAS,OAAM,MAAM,IAAI,CAAC;AAMnF,IAAM,gBAAe,CAAC,MAAM,SAAS,UAAS,8BAAS,IAAI,GAAG,MAAM,IAAI;AAGxE,IAAM,YAAW,CAAC,OAAM,MAAM,OAAO,OAAO,IAAI,oBAAK,CAAC,IAAI,cAAa;AAAA,MACrE;AAAA,MACA,MAAM,MAAK;AAAA,MACX,cAAc,MAAK;AAAA,MACnB,OAAO;AAAA,IACT,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC;AAGb,IAAM,YAAW,CAAC,OAAM,MAAM,OAAO,OAAO,IAAI,cAAK,CAAC,IAAI,cAAa;AAAA,MACrE;AAAA,MACA,MAAM,MAAK;AAAA,MACX,cAAc,MAAK;AAAA,MACnB,OAAO;AAAA,IACT,CAAC,CAAC,GAAG,gCAAS,IAAI,GAAG,EAAE,MAAM,cAAc,MAAK,QAAQ,CAAC;AASzD,IAAM,gBAAN,MAAmB;AAAA,MACjB;AAAA,MACA;AAAA,MAEA,YAAa,SAAS;AACpB,aAAK,QAAQ,QAAQ;AACrB,aAAK,SAAS,QAAQ;AACtB,aAAK,OAAO,QAAQ;AACpB,aAAK,eAAe,QAAQ;AAAA,MAC9B;AAAA,MAMA,MAAO,OAAO,KAAK;AACjB,eAAO,IAAI,cAAa;AAAA,UACtB,MAAM,KAAK;AAAA,UACX,cAAc,KAAK;AAAA,UACnB,MAAM,MAAM;AAAA,UACZ,OAAO,KAAK,SAAS;AAAA,QACvB,CAAC;AAAA,MACH;AAAA,MAEA,OAAQ,SAAU;AAChB,cAAM,EAAE,YAAY,MAAM,MAAK,KAAK,KAAK;AACzC,YAAI,UAAU,KAAK,cAAc;AAC/B,gBAAM,IAAI,kCAAa,2IAA2I,kBAAkB;AAAA,QACtL;AACA,eAAQ,sCAAiB,KAAK,OAAO;AAAA,UACnC,OAAO,KAAK;AAAA,UACZ,KAAK,KAAK,SAAS,KAAK,OAAO;AAAA,QACjC,CAAC;AAAA,MACH;AAAA,MAEA,KAAK,OAAO,eAAgB;AAC1B,eAAO;AAAA,MACT;AAAA,IACF;AAAA;AAAA;;;AChGA;AAAA;AAAA;AAAA;AA+TA,oBAAmB,aAAa;AAE/B,QAAM,KAAI,YAAY,MAAM,4DAA4D;AACxF,MAAI,CAAC,IAAG;AACP;AAAA,EACD;AAEA,QAAM,QAAQ,GAAE,MAAM,GAAE,MAAM;AAC9B,MAAI,WAAW,MAAM,MAAM,MAAM,YAAY,IAAI,IAAI,CAAC;AACtD,aAAW,SAAS,QAAQ,QAAQ,GAAG;AACvC,aAAW,SAAS,QAAQ,eAAe,CAAC,IAAG,SAAS;AACvD,WAAO,OAAO,aAAa,IAAI;AAAA,EAChC,CAAC;AACD,SAAO;AACR;AAEA,2BAAiC,OAAM,IAAI;AAC1C,MAAI,CAAC,aAAa,KAAK,EAAE,GAAG;AAC3B,UAAM,IAAI,UAAU,iBAAiB;AAAA,EACtC;AAEA,QAAM,KAAI,GAAG,MAAM,iCAAiC;AAEpD,MAAI,CAAC,IAAG;AACP,UAAM,IAAI,UAAU,sDAAsD;AAAA,EAC3E;AAEA,QAAM,SAAS,IAAI,iBAAgB,GAAE,MAAM,GAAE,EAAE;AAE/C,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,QAAM,cAAc,CAAC;AACrB,QAAM,WAAW,IAAI,UAAS;AAE9B,QAAM,aAAa,UAAQ;AAC1B,kBAAc,QAAQ,OAAO,MAAM,EAAC,QAAQ,KAAI,CAAC;AAAA,EAClD;AAEA,QAAM,eAAe,UAAQ;AAC5B,gBAAY,KAAK,IAAI;AAAA,EACtB;AAEA,QAAM,uBAAuB,MAAM;AAClC,UAAM,OAAO,IAAI,cAAK,aAAa,UAAU,EAAC,MAAM,YAAW,CAAC;AAChE,aAAS,OAAO,WAAW,IAAI;AAAA,EAChC;AAEA,QAAM,wBAAwB,MAAM;AACnC,aAAS,OAAO,WAAW,UAAU;AAAA,EACtC;AAEA,QAAM,UAAU,IAAI,YAAY,OAAO;AACvC,UAAQ,OAAO;AAEf,SAAO,cAAc,WAAY;AAChC,WAAO,aAAa;AACpB,WAAO,YAAY;AAEnB,kBAAc;AACd,kBAAc;AACd,iBAAa;AACb,gBAAY;AACZ,kBAAc;AACd,eAAW;AACX,gBAAY,SAAS;AAAA,EACtB;AAEA,SAAO,gBAAgB,SAAU,MAAM;AACtC,mBAAe,QAAQ,OAAO,MAAM,EAAC,QAAQ,KAAI,CAAC;AAAA,EACnD;AAEA,SAAO,gBAAgB,SAAU,MAAM;AACtC,mBAAe,QAAQ,OAAO,MAAM,EAAC,QAAQ,KAAI,CAAC;AAAA,EACnD;AAEA,SAAO,cAAc,WAAY;AAChC,mBAAe,QAAQ,OAAO;AAC9B,kBAAc,YAAY,YAAY;AAEtC,QAAI,gBAAgB,uBAAuB;AAE1C,YAAM,KAAI,YAAY,MAAM,mDAAmD;AAE/E,UAAI,IAAG;AACN,oBAAY,GAAE,MAAM,GAAE,MAAM;AAAA,MAC7B;AAEA,iBAAW,WAAU,WAAW;AAEhC,UAAI,UAAU;AACb,eAAO,aAAa;AACpB,eAAO,YAAY;AAAA,MACpB;AAAA,IACD,WAAW,gBAAgB,gBAAgB;AAC1C,oBAAc;AAAA,IACf;AAEA,kBAAc;AACd,kBAAc;AAAA,EACf;AAEA,mBAAiB,SAAS,OAAM;AAC/B,WAAO,MAAM,KAAK;AAAA,EACnB;AAEA,SAAO,IAAI;AAEX,SAAO;AACR;AA/aA,IAGI,IACE,IAaF,IACE,IAKA,KACA,KACA,QACA,SACA,QACA,IACA,IAEA,QAEA,OAEA;AAnCN;AAAA;AAAA;AACA;AAEA,IAAI,KAAI;AACR,IAAM,KAAI;AAAA,MACT,gBAAgB;AAAA,MAChB,oBAAoB;AAAA,MACpB,cAAc;AAAA,MACd,oBAAoB;AAAA,MACpB,cAAc;AAAA,MACd,0BAA0B;AAAA,MAC1B,qBAAqB;AAAA,MACrB,iBAAiB;AAAA,MACjB,WAAW;AAAA,MACX,KAAK;AAAA,IACN;AAEA,IAAI,KAAI;AACR,IAAM,KAAI;AAAA,MACT,eAAe;AAAA,MACf,eAAe,MAAK;AAAA,IACrB;AAEA,IAAM,MAAK;AACX,IAAM,MAAK;AACX,IAAM,SAAQ;AACd,IAAM,UAAS;AACf,IAAM,SAAQ;AACd,IAAM,KAAI;AACV,IAAM,KAAI;AAEV,IAAM,SAAQ,OAAK,IAAI;AAEvB,IAAM,QAAO,MAAM;AAAA,IAAC;AAEpB,IAAM,mBAAN,MAAsB;AAAA,MAIrB,YAAY,UAAU;AACrB,aAAK,QAAQ;AACb,aAAK,QAAQ;AAEb,aAAK,cAAc;AACnB,aAAK,gBAAgB;AACrB,aAAK,eAAe;AACpB,aAAK,gBAAgB;AACrB,aAAK,cAAc;AACnB,aAAK,aAAa;AAClB,aAAK,YAAY;AAEjB,aAAK,gBAAgB,CAAC;AAEtB,mBAAW,WAAW;AACtB,cAAM,OAAO,IAAI,WAAW,SAAS,MAAM;AAC3C,iBAAS,KAAI,GAAG,KAAI,SAAS,QAAQ,MAAK;AACzC,eAAK,MAAK,SAAS,WAAW,EAAC;AAC/B,eAAK,cAAc,KAAK,OAAM;AAAA,QAC/B;AAEA,aAAK,WAAW;AAChB,aAAK,aAAa,IAAI,WAAW,KAAK,SAAS,SAAS,CAAC;AACzD,aAAK,QAAQ,GAAE;AAAA,MAChB;AAAA,MAKA,MAAM,MAAM;AACX,YAAI,KAAI;AACR,cAAM,UAAU,KAAK;AACrB,YAAI,gBAAgB,KAAK;AACzB,YAAI,EAAC,YAAY,UAAU,eAAe,OAAO,eAAO,UAAS;AACjE,cAAM,iBAAiB,KAAK,SAAS;AACrC,cAAM,cAAc,iBAAiB;AACrC,cAAM,eAAe,KAAK;AAC1B,YAAI;AACJ,YAAI;AAEJ,cAAM,OAAO,WAAQ;AACpB,eAAK,QAAO,UAAU;AAAA,QACvB;AAEA,cAAM,QAAQ,WAAQ;AACrB,iBAAO,KAAK,QAAO;AAAA,QACpB;AAEA,cAAM,WAAW,CAAC,gBAAgB,OAAO,KAAK,SAAS;AACtD,cAAI,UAAU,UAAa,UAAU,KAAK;AACzC,iBAAK,gBAAgB,QAAQ,KAAK,SAAS,OAAO,GAAG,CAAC;AAAA,UACvD;AAAA,QACD;AAEA,cAAM,eAAe,CAAC,OAAM,WAAU;AACrC,gBAAM,aAAa,QAAO;AAC1B,cAAI,CAAE,eAAc,OAAO;AAC1B;AAAA,UACD;AAEA,cAAI,QAAO;AACV,qBAAS,OAAM,KAAK,aAAa,IAAG,IAAI;AACxC,mBAAO,KAAK;AAAA,UACb,OAAO;AACN,qBAAS,OAAM,KAAK,aAAa,KAAK,QAAQ,IAAI;AAClD,iBAAK,cAAc;AAAA,UACpB;AAAA,QACD;AAEA,aAAK,KAAI,GAAG,KAAI,SAAS,MAAK;AAC7B,cAAI,KAAK;AAET,kBAAQ;AAAA,iBACF,GAAE;AACN,kBAAI,UAAU,SAAS,SAAS,GAAG;AAClC,oBAAI,MAAM,SAAQ;AACjB,2BAAS,GAAE;AAAA,gBACZ,WAAW,MAAM,KAAI;AACpB;AAAA,gBACD;AAEA;AACA;AAAA,cACD,WAAW,QAAQ,MAAM,SAAS,SAAS,GAAG;AAC7C,oBAAI,QAAQ,GAAE,iBAAiB,MAAM,SAAQ;AAC5C,2BAAQ,GAAE;AACV,0BAAQ;AAAA,gBACT,WAAW,CAAE,SAAQ,GAAE,kBAAkB,MAAM,KAAI;AAClD,0BAAQ;AACR,2BAAS,aAAa;AACtB,2BAAQ,GAAE;AAAA,gBACX,OAAO;AACN;AAAA,gBACD;AAEA;AAAA,cACD;AAEA,kBAAI,MAAM,SAAS,QAAQ,IAAI;AAC9B,wBAAQ;AAAA,cACT;AAEA,kBAAI,MAAM,SAAS,QAAQ,IAAI;AAC9B;AAAA,cACD;AAEA;AAAA,iBACI,GAAE;AACN,uBAAQ,GAAE;AACV,mBAAK,eAAe;AACpB,sBAAQ;AAAA,iBAEJ,GAAE;AACN,kBAAI,MAAM,KAAI;AACb,sBAAM,eAAe;AACrB,yBAAQ,GAAE;AACV;AAAA,cACD;AAEA;AACA,kBAAI,MAAM,SAAQ;AACjB;AAAA,cACD;AAEA,kBAAI,MAAM,QAAO;AAChB,oBAAI,UAAU,GAAG;AAEhB;AAAA,gBACD;AAEA,6BAAa,iBAAiB,IAAI;AAClC,yBAAQ,GAAE;AACV;AAAA,cACD;AAEA,mBAAK,OAAM,CAAC;AACZ,kBAAI,KAAK,MAAK,KAAK,IAAG;AACrB;AAAA,cACD;AAEA;AAAA,iBACI,GAAE;AACN,kBAAI,MAAM,QAAO;AAChB;AAAA,cACD;AAEA,mBAAK,eAAe;AACpB,uBAAQ,GAAE;AAAA,iBAEN,GAAE;AACN,kBAAI,MAAM,KAAI;AACb,6BAAa,iBAAiB,IAAI;AAClC,yBAAS,aAAa;AACtB,yBAAQ,GAAE;AAAA,cACX;AAEA;AAAA,iBACI,GAAE;AACN,kBAAI,MAAM,KAAI;AACb;AAAA,cACD;AAEA,uBAAQ,GAAE;AACV;AAAA,iBACI,GAAE;AACN,kBAAI,MAAM,KAAI;AACb;AAAA,cACD;AAEA,uBAAS,cAAc;AACvB,uBAAQ,GAAE;AACV;AAAA,iBACI,GAAE;AACN,uBAAQ,GAAE;AACV,mBAAK,YAAY;AAAA,iBAEb,GAAE;AACN,8BAAgB;AAEhB,kBAAI,UAAU,GAAG;AAEhB,sBAAK;AACL,uBAAO,KAAI,gBAAgB,CAAE,MAAK,OAAM,gBAAgB;AACvD,wBAAK;AAAA,gBACN;AAEA,sBAAK;AACL,oBAAI,KAAK;AAAA,cACV;AAEA,kBAAI,QAAQ,SAAS,QAAQ;AAC5B,oBAAI,SAAS,WAAW,GAAG;AAC1B,sBAAI,UAAU,GAAG;AAChB,iCAAa,cAAc,IAAI;AAAA,kBAChC;AAEA;AAAA,gBACD,OAAO;AACN,0BAAQ;AAAA,gBACT;AAAA,cACD,WAAW,UAAU,SAAS,QAAQ;AACrC;AACA,oBAAI,MAAM,KAAI;AAEb,2BAAS,GAAE;AAAA,gBACZ,WAAW,MAAM,SAAQ;AAExB,2BAAS,GAAE;AAAA,gBACZ,OAAO;AACN,0BAAQ;AAAA,gBACT;AAAA,cACD,WAAW,QAAQ,MAAM,SAAS,QAAQ;AACzC,oBAAI,QAAQ,GAAE,eAAe;AAC5B,0BAAQ;AACR,sBAAI,MAAM,KAAI;AAEb,6BAAS,CAAC,GAAE;AACZ,6BAAS,WAAW;AACpB,6BAAS,aAAa;AACtB,6BAAQ,GAAE;AACV;AAAA,kBACD;AAAA,gBACD,WAAW,QAAQ,GAAE,eAAe;AACnC,sBAAI,MAAM,SAAQ;AACjB,6BAAS,WAAW;AACpB,6BAAQ,GAAE;AACV,4BAAQ;AAAA,kBACT,OAAO;AACN,4BAAQ;AAAA,kBACT;AAAA,gBACD,OAAO;AACN,0BAAQ;AAAA,gBACT;AAAA,cACD;AAEA,kBAAI,QAAQ,GAAG;AAGd,2BAAW,QAAQ,KAAK;AAAA,cACzB,WAAW,gBAAgB,GAAG;AAG7B,sBAAM,cAAc,IAAI,WAAW,WAAW,QAAQ,WAAW,YAAY,WAAW,UAAU;AAClG,yBAAS,cAAc,GAAG,eAAe,WAAW;AACpD,gCAAgB;AAChB,qBAAK,YAAY;AAIjB;AAAA,cACD;AAEA;AAAA,iBACI,GAAE;AACN;AAAA;AAEA,oBAAM,IAAI,MAAM,6BAA6B,QAAO;AAAA;AAAA,QAEvD;AAEA,qBAAa,eAAe;AAC5B,qBAAa,eAAe;AAC5B,qBAAa,YAAY;AAGzB,aAAK,QAAQ;AACb,aAAK,QAAQ;AACb,aAAK,QAAQ;AAAA,MACd;AAAA,MAEA,MAAM;AACL,YAAK,KAAK,UAAU,GAAE,sBAAsB,KAAK,UAAU,KACzD,KAAK,UAAU,GAAE,aAAa,KAAK,UAAU,KAAK,SAAS,QAAS;AACrE,eAAK,UAAU;AAAA,QAChB,WAAW,KAAK,UAAU,GAAE,KAAK;AAChC,gBAAM,IAAI,MAAM,kDAAkD;AAAA,QACnE;AAAA,MACD;AAAA,IACD;AAAA;AAAA;;;AC5HA,4BAA2B,MAAM;AAChC,MAAI,KAAK,YAAW,WAAW;AAC9B,UAAM,IAAI,UAAU,0BAA0B,KAAK,KAAK;AAAA,EACzD;AAEA,OAAK,YAAW,YAAY;AAE5B,MAAI,KAAK,YAAW,OAAO;AAC1B,UAAM,KAAK,YAAW;AAAA,EACvB;AAEA,QAAM,EAAC,SAAQ;AAGf,MAAI,SAAS,MAAM;AAClB,WAAO,2BAAO,MAAM,CAAC;AAAA,EACtB;AAGA,MAAI,CAAE,iBAAgB,8BAAS;AAC9B,WAAO,2BAAO,MAAM,CAAC;AAAA,EACtB;AAIA,QAAM,QAAQ,CAAC;AACf,MAAI,aAAa;AAEjB,MAAI;AACH,qBAAiB,SAAS,MAAM;AAC/B,UAAI,KAAK,OAAO,KAAK,aAAa,MAAM,SAAS,KAAK,MAAM;AAC3D,cAAM,QAAQ,IAAI,YAAW,mBAAmB,KAAK,mBAAmB,KAAK,QAAQ,UAAU;AAC/F,aAAK,QAAQ,KAAK;AAClB,cAAM;AAAA,MACP;AAEA,oBAAc,MAAM;AACpB,YAAM,KAAK,KAAK;AAAA,IACjB;AAAA,EACD,SAAS,OAAP;AACD,UAAM,SAAS,iBAAiB,kBAAiB,QAAQ,IAAI,YAAW,+CAA+C,KAAK,QAAQ,MAAM,WAAW,UAAU,KAAK;AACpK,UAAM;AAAA,EACP;AAEA,MAAI,KAAK,kBAAkB,QAAQ,KAAK,eAAe,UAAU,MAAM;AACtE,QAAI;AACH,UAAI,MAAM,MAAM,OAAK,OAAO,MAAM,QAAQ,GAAG;AAC5C,eAAO,2BAAO,KAAK,MAAM,KAAK,EAAE,CAAC;AAAA,MAClC;AAEA,aAAO,2BAAO,OAAO,OAAO,UAAU;AAAA,IACvC,SAAS,OAAP;AACD,YAAM,IAAI,YAAW,kDAAkD,KAAK,QAAQ,MAAM,WAAW,UAAU,KAAK;AAAA,IACrH;AAAA,EACD,OAAO;AACN,UAAM,IAAI,YAAW,4DAA4D,KAAK,KAAK;AAAA,EAC5F;AACD;AA1PA,IAOA,qBACA,mBACA,qBASM,WACA,YAWe,OAqOR,QA0BP,6BAgBO,qBAqDA,gBAkCA;AApYb;AAAA;AAOA,0BAAkC;AAClC,wBAA0C;AAC1C,0BAAqB;AAErB;AACA;AAEA;AACA;AACA;AAEA,IAAM,YAAW,iCAAU,4BAAO,QAAQ;AAC1C,IAAM,aAAY,OAAO,gBAAgB;AAWzC,IAAqB,QAArB,MAA0B;AAAA,MACzB,YAAY,MAAM;AAAA,QACjB,OAAO;AAAA,UACJ,CAAC,GAAG;AACP,YAAI,WAAW;AAEf,YAAI,SAAS,MAAM;AAElB,iBAAO;AAAA,QACR,WAAW,uBAAsB,IAAI,GAAG;AAEvC,iBAAO,2BAAO,KAAK,KAAK,SAAS,CAAC;AAAA,QACnC,WAAW,QAAO,IAAI,GAAG;AAAA,QAEzB,WAAW,2BAAO,SAAS,IAAI,GAAG;AAAA,QAElC,WAAW,wBAAM,iBAAiB,IAAI,GAAG;AAExC,iBAAO,2BAAO,KAAK,IAAI;AAAA,QACxB,WAAW,YAAY,OAAO,IAAI,GAAG;AAEpC,iBAAO,2BAAO,KAAK,KAAK,QAAQ,KAAK,YAAY,KAAK,UAAU;AAAA,QACjE,WAAW,gBAAgB,6BAAQ;AAAA,QAEnC,WAAW,gBAAgB,WAAU;AAEpC,iBAAO,gBAAe,IAAI;AAC1B,qBAAW,KAAK,KAAK,MAAM,GAAG,EAAE;AAAA,QACjC,OAAO;AAGN,iBAAO,2BAAO,KAAK,OAAO,IAAI,CAAC;AAAA,QAChC;AAEA,YAAI,SAAS;AAEb,YAAI,2BAAO,SAAS,IAAI,GAAG;AAC1B,mBAAS,4BAAO,SAAS,KAAK,IAAI;AAAA,QACnC,WAAW,QAAO,IAAI,GAAG;AACxB,mBAAS,4BAAO,SAAS,KAAK,KAAK,OAAO,CAAC;AAAA,QAC5C;AAEA,aAAK,cAAa;AAAA,UACjB;AAAA,UACA;AAAA,UACA;AAAA,UACA,WAAW;AAAA,UACX,OAAO;AAAA,QACR;AACA,aAAK,OAAO;AAEZ,YAAI,gBAAgB,6BAAQ;AAC3B,eAAK,GAAG,SAAS,YAAU;AAC1B,kBAAM,QAAQ,kBAAkB,kBAC/B,SACA,IAAI,YAAW,+CAA+C,KAAK,QAAQ,OAAO,WAAW,UAAU,MAAM;AAC9G,iBAAK,YAAW,QAAQ;AAAA,UACzB,CAAC;AAAA,QACF;AAAA,MACD;AAAA,MAEA,IAAI,OAAO;AACV,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAEA,IAAI,WAAW;AACd,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAOA,MAAM,cAAc;AACnB,cAAM,EAAC,QAAQ,YAAY,eAAc,MAAM,aAAY,IAAI;AAC/D,eAAO,OAAO,MAAM,YAAY,aAAa,UAAU;AAAA,MACxD;AAAA,MAEA,MAAM,WAAW;AAChB,cAAM,KAAK,KAAK,QAAQ,IAAI,cAAc;AAE1C,YAAI,GAAG,WAAW,mCAAmC,GAAG;AACvD,gBAAM,WAAW,IAAI,UAAS;AAC9B,gBAAM,aAAa,IAAI,gBAAgB,MAAM,KAAK,KAAK,CAAC;AAExD,qBAAW,CAAC,OAAM,UAAU,YAAY;AACvC,qBAAS,OAAO,OAAM,KAAK;AAAA,UAC5B;AAEA,iBAAO;AAAA,QACR;AAEA,cAAM,EAAC,4BAAc,MAAM;AAC3B,eAAO,YAAW,KAAK,MAAM,EAAE;AAAA,MAChC;AAAA,MAOA,MAAM,OAAO;AACZ,cAAM,KAAM,KAAK,WAAW,KAAK,QAAQ,IAAI,cAAc,KAAO,KAAK,YAAW,QAAQ,KAAK,YAAW,KAAK,QAAS;AACxH,cAAM,MAAM,MAAM,KAAK,YAAY;AAEnC,eAAO,IAAI,oBAAK,CAAC,GAAG,GAAG;AAAA,UACtB,MAAM;AAAA,QACP,CAAC;AAAA,MACF;AAAA,MAOA,MAAM,OAAO;AACZ,cAAM,OAAO,MAAM,KAAK,KAAK;AAC7B,eAAO,KAAK,MAAM,IAAI;AAAA,MACvB;AAAA,MAOA,MAAM,OAAO;AACZ,cAAM,SAAS,MAAM,aAAY,IAAI;AACrC,eAAO,IAAI,YAAY,EAAE,OAAO,MAAM;AAAA,MACvC;AAAA,MAOA,SAAS;AACR,eAAO,aAAY,IAAI;AAAA,MACxB;AAAA,IACD;AAEA,UAAK,UAAU,SAAS,iCAAU,MAAK,UAAU,QAAQ,sEAA0E,mBAAmB;AAGtJ,WAAO,iBAAiB,MAAK,WAAW;AAAA,MACvC,MAAM,EAAC,YAAY,KAAI;AAAA,MACvB,UAAU,EAAC,YAAY,KAAI;AAAA,MAC3B,aAAa,EAAC,YAAY,KAAI;AAAA,MAC9B,MAAM,EAAC,YAAY,KAAI;AAAA,MACvB,MAAM,EAAC,YAAY,KAAI;AAAA,MACvB,MAAM,EAAC,YAAY,KAAI;AAAA,MACvB,MAAM,EAAC,KAAK,iCAAU,MAAM;AAAA,MAAC,GAC5B,0EACA,iEAAiE,EAAC;AAAA,IACpE,CAAC;AA2EM,IAAM,SAAQ,CAAC,UAAU,kBAAkB;AACjD,UAAI;AACJ,UAAI;AACJ,UAAI,EAAC,SAAQ,SAAS;AAGtB,UAAI,SAAS,UAAU;AACtB,cAAM,IAAI,MAAM,oCAAoC;AAAA,MACrD;AAIA,UAAK,gBAAgB,+BAAY,OAAO,KAAK,gBAAgB,YAAa;AAEzE,aAAK,IAAI,gCAAY,EAAC,cAAa,CAAC;AACpC,aAAK,IAAI,gCAAY,EAAC,cAAa,CAAC;AACpC,aAAK,KAAK,EAAE;AACZ,aAAK,KAAK,EAAE;AAEZ,iBAAS,YAAW,SAAS;AAC7B,eAAO;AAAA,MACR;AAEA,aAAO;AAAA,IACR;AAEA,IAAM,8BAA6B,iCAClC,UAAQ,KAAK,YAAY,GACzB,6FACA,sDACD;AAYO,IAAM,sBAAqB,CAAC,MAAM,YAAY;AAEpD,UAAI,SAAS,MAAM;AAClB,eAAO;AAAA,MACR;AAGA,UAAI,OAAO,SAAS,UAAU;AAC7B,eAAO;AAAA,MACR;AAGA,UAAI,uBAAsB,IAAI,GAAG;AAChC,eAAO;AAAA,MACR;AAGA,UAAI,QAAO,IAAI,GAAG;AACjB,eAAO,KAAK,QAAQ;AAAA,MACrB;AAGA,UAAI,2BAAO,SAAS,IAAI,KAAK,wBAAM,iBAAiB,IAAI,KAAK,YAAY,OAAO,IAAI,GAAG;AACtF,eAAO;AAAA,MACR;AAEA,UAAI,gBAAgB,WAAU;AAC7B,eAAO,iCAAiC,QAAQ,YAAW;AAAA,MAC5D;AAGA,UAAI,QAAQ,OAAO,KAAK,gBAAgB,YAAY;AACnD,eAAO,gCAAgC,4BAA2B,IAAI;AAAA,MACvE;AAGA,UAAI,gBAAgB,6BAAQ;AAC3B,eAAO;AAAA,MACR;AAGA,aAAO;AAAA,IACR;AAWO,IAAM,iBAAgB,aAAW;AACvC,YAAM,EAAC,SAAQ,QAAQ;AAGvB,UAAI,SAAS,MAAM;AAClB,eAAO;AAAA,MACR;AAGA,UAAI,QAAO,IAAI,GAAG;AACjB,eAAO,KAAK;AAAA,MACb;AAGA,UAAI,2BAAO,SAAS,IAAI,GAAG;AAC1B,eAAO,KAAK;AAAA,MACb;AAGA,UAAI,QAAQ,OAAO,KAAK,kBAAkB,YAAY;AACrD,eAAO,KAAK,kBAAkB,KAAK,eAAe,IAAI,KAAK,cAAc,IAAI;AAAA,MAC9E;AAGA,aAAO;AAAA,IACR;AASO,IAAM,iBAAgB,OAAO,MAAM,EAAC,WAAU;AACpD,UAAI,SAAS,MAAM;AAElB,aAAK,IAAI;AAAA,MACV,OAAO;AAEN,cAAM,UAAS,MAAM,IAAI;AAAA,MAC1B;AAAA,IACD;AAAA;AAAA;;;ACxJO,yBAAwB,UAAU,CAAC,GAAG;AAC5C,SAAO,IAAI,SACV,QAEE,OAAO,CAAC,QAAQ,OAAO,OAAO,UAAU;AACxC,QAAI,QAAQ,MAAM,GAAG;AACpB,aAAO,KAAK,MAAM,MAAM,OAAO,QAAQ,CAAC,CAAC;AAAA,IAC1C;AAEA,WAAO;AAAA,EACR,GAAG,CAAC,CAAC,EACJ,OAAO,CAAC,CAAC,OAAM,WAAW;AAC1B,QAAI;AACH,0BAAmB,KAAI;AACvB,2BAAoB,OAAM,OAAO,KAAK,CAAC;AACvC,aAAO;AAAA,IACR,QAAE;AACD,aAAO;AAAA,IACR;AAAA,EACD,CAAC,CAEH;AACD;AA1QA,IAMA,mBACA,mBAGM,qBAWA,sBAsBe;AA3CrB;AAAA;AAMA,wBAAoB;AACpB,wBAAiB;AAGjB,IAAM,sBAAqB,OAAO,0BAAK,uBAAuB,aAC7D,0BAAK,qBACL,WAAQ;AACP,UAAI,CAAC,0BAA0B,KAAK,KAAI,GAAG;AAC1C,cAAM,QAAQ,IAAI,UAAU,2CAA2C,QAAO;AAC9E,eAAO,eAAe,OAAO,QAAQ,EAAC,OAAO,yBAAwB,CAAC;AACtE,cAAM;AAAA,MACP;AAAA,IACD;AAGD,IAAM,uBAAsB,OAAO,0BAAK,wBAAwB,aAC/D,0BAAK,sBACL,CAAC,OAAM,UAAU;AAChB,UAAI,kCAAkC,KAAK,KAAK,GAAG;AAClD,cAAM,QAAQ,IAAI,UAAU,yCAAyC,SAAQ;AAC7E,eAAO,eAAe,OAAO,QAAQ,EAAC,OAAO,mBAAkB,CAAC;AAChE,cAAM;AAAA,MACP;AAAA,IACD;AAcD,IAAqB,WAArB,cAAqC,gBAAgB;AAAA,MAOpD,YAAY,MAAM;AAGjB,YAAI,SAAS,CAAC;AACd,YAAI,gBAAgB,UAAS;AAC5B,gBAAM,MAAM,KAAK,IAAI;AACrB,qBAAW,CAAC,OAAM,WAAW,OAAO,QAAQ,GAAG,GAAG;AACjD,mBAAO,KAAK,GAAG,OAAO,IAAI,WAAS,CAAC,OAAM,KAAK,CAAC,CAAC;AAAA,UAClD;AAAA,QACD,WAAW,QAAQ,MAAM;AAAA,QAEzB,WAAW,OAAO,SAAS,YAAY,CAAC,wBAAM,iBAAiB,IAAI,GAAG;AACrE,gBAAM,SAAS,KAAK,OAAO;AAE3B,cAAI,UAAU,MAAM;AAEnB,mBAAO,KAAK,GAAG,OAAO,QAAQ,IAAI,CAAC;AAAA,UACpC,OAAO;AACN,gBAAI,OAAO,WAAW,YAAY;AACjC,oBAAM,IAAI,UAAU,+BAA+B;AAAA,YACpD;AAIA,qBAAS,CAAC,GAAG,IAAI,EACf,IAAI,UAAQ;AACZ,kBACC,OAAO,SAAS,YAAY,wBAAM,iBAAiB,IAAI,GACtD;AACD,sBAAM,IAAI,UAAU,6CAA6C;AAAA,cAClE;AAEA,qBAAO,CAAC,GAAG,IAAI;AAAA,YAChB,CAAC,EAAE,IAAI,UAAQ;AACd,kBAAI,KAAK,WAAW,GAAG;AACtB,sBAAM,IAAI,UAAU,6CAA6C;AAAA,cAClE;AAEA,qBAAO,CAAC,GAAG,IAAI;AAAA,YAChB,CAAC;AAAA,UACH;AAAA,QACD,OAAO;AACN,gBAAM,IAAI,UAAU,sIAAyI;AAAA,QAC9J;AAGA,iBACC,OAAO,SAAS,IACf,OAAO,IAAI,CAAC,CAAC,OAAM,WAAW;AAC7B,8BAAmB,KAAI;AACvB,+BAAoB,OAAM,OAAO,KAAK,CAAC;AACvC,iBAAO,CAAC,OAAO,KAAI,EAAE,YAAY,GAAG,OAAO,KAAK,CAAC;AAAA,QAClD,CAAC,IACD;AAEF,cAAM,MAAM;AAIZ,eAAO,IAAI,MAAM,MAAM;AAAA,UACtB,IAAI,QAAQ,GAAG,UAAU;AACxB,oBAAQ;AAAA,mBACF;AAAA,mBACA;AACJ,uBAAO,CAAC,OAAM,UAAU;AACvB,sCAAmB,KAAI;AACvB,uCAAoB,OAAM,OAAO,KAAK,CAAC;AACvC,yBAAO,gBAAgB,UAAU,GAAG,KACnC,QACA,OAAO,KAAI,EAAE,YAAY,GACzB,OAAO,KAAK,CACb;AAAA,gBACD;AAAA,mBAEI;AAAA,mBACA;AAAA,mBACA;AACJ,uBAAO,WAAQ;AACd,sCAAmB,KAAI;AACvB,yBAAO,gBAAgB,UAAU,GAAG,KACnC,QACA,OAAO,KAAI,EAAE,YAAY,CAC1B;AAAA,gBACD;AAAA,mBAEI;AACJ,uBAAO,MAAM;AACZ,yBAAO,KAAK;AACZ,yBAAO,IAAI,IAAI,gBAAgB,UAAU,KAAK,KAAK,MAAM,CAAC,EAAE,KAAK;AAAA,gBAClE;AAAA;AAGA,uBAAO,QAAQ,IAAI,QAAQ,GAAG,QAAQ;AAAA;AAAA,UAEzC;AAAA,QACD,CAAC;AAAA,MAEF;AAAA,MAEA,KAAK,OAAO,eAAe;AAC1B,eAAO,KAAK,YAAY;AAAA,MACzB;AAAA,MAEA,WAAW;AACV,eAAO,OAAO,UAAU,SAAS,KAAK,IAAI;AAAA,MAC3C;AAAA,MAEA,IAAI,OAAM;AACT,cAAM,SAAS,KAAK,OAAO,KAAI;AAC/B,YAAI,OAAO,WAAW,GAAG;AACxB,iBAAO;AAAA,QACR;AAEA,YAAI,QAAQ,OAAO,KAAK,IAAI;AAC5B,YAAI,sBAAsB,KAAK,KAAI,GAAG;AACrC,kBAAQ,MAAM,YAAY;AAAA,QAC3B;AAEA,eAAO;AAAA,MACR;AAAA,MAEA,QAAQ,UAAU,UAAU,QAAW;AACtC,mBAAW,SAAQ,KAAK,KAAK,GAAG;AAC/B,kBAAQ,MAAM,UAAU,SAAS,CAAC,KAAK,IAAI,KAAI,GAAG,OAAM,IAAI,CAAC;AAAA,QAC9D;AAAA,MACD;AAAA,MAEA,CAAE,SAAS;AACV,mBAAW,SAAQ,KAAK,KAAK,GAAG;AAC/B,gBAAM,KAAK,IAAI,KAAI;AAAA,QACpB;AAAA,MACD;AAAA,MAKA,CAAE,UAAU;AACX,mBAAW,SAAQ,KAAK,KAAK,GAAG;AAC/B,gBAAM,CAAC,OAAM,KAAK,IAAI,KAAI,CAAC;AAAA,QAC5B;AAAA,MACD;AAAA,MAEA,CAAC,OAAO,YAAY;AACnB,eAAO,KAAK,QAAQ;AAAA,MACrB;AAAA,MAOA,MAAM;AACL,eAAO,CAAC,GAAG,KAAK,KAAK,CAAC,EAAE,OAAO,CAAC,QAAQ,QAAQ;AAC/C,iBAAO,OAAO,KAAK,OAAO,GAAG;AAC7B,iBAAO;AAAA,QACR,GAAG,CAAC,CAAC;AAAA,MACN;AAAA,MAKA,CAAC,OAAO,IAAI,4BAA4B,KAAK;AAC5C,eAAO,CAAC,GAAG,KAAK,KAAK,CAAC,EAAE,OAAO,CAAC,QAAQ,QAAQ;AAC/C,gBAAM,SAAS,KAAK,OAAO,GAAG;AAG9B,cAAI,QAAQ,QAAQ;AACnB,mBAAO,OAAO,OAAO;AAAA,UACtB,OAAO;AACN,mBAAO,OAAO,OAAO,SAAS,IAAI,SAAS,OAAO;AAAA,UACnD;AAEA,iBAAO;AAAA,QACR,GAAG,CAAC,CAAC;AAAA,MACN;AAAA,IACD;AAMA,WAAO,iBACN,SAAQ,WACR,CAAC,OAAO,WAAW,WAAW,QAAQ,EAAE,OAAO,CAAC,QAAQ,aAAa;AACpE,aAAO,YAAY,EAAC,YAAY,KAAI;AACpC,aAAO;AAAA,IACR,GAAG,CAAC,CAAC,CACN;AAAA;AAAA;;;AC7OA,IAAM,iBAQO;AARb;AAAA;AAAA,IAAM,kBAAiB,oBAAI,IAAI,CAAC,KAAK,KAAK,KAAK,KAAK,GAAG,CAAC;AAQjD,IAAM,cAAa,UAAQ;AACjC,aAAO,gBAAe,IAAI,IAAI;AAAA,IAC/B;AAAA;AAAA;;;ACVA,IAUM,YAWe;AArBrB;AAAA;AAMA;AACA;AACA;AAEA,IAAM,aAAY,OAAO,oBAAoB;AAW7C,IAAqB,YAArB,cAAsC,MAAK;AAAA,MAC1C,YAAY,OAAO,MAAM,UAAU,CAAC,GAAG;AACtC,cAAM,MAAM,OAAO;AAGnB,cAAM,SAAS,QAAQ,UAAU,OAAO,QAAQ,SAAS;AAEzD,cAAM,UAAU,IAAI,SAAQ,QAAQ,OAAO;AAE3C,YAAI,SAAS,QAAQ,CAAC,QAAQ,IAAI,cAAc,GAAG;AAClD,gBAAM,cAAc,oBAAmB,MAAM,IAAI;AACjD,cAAI,aAAa;AAChB,oBAAQ,OAAO,gBAAgB,WAAW;AAAA,UAC3C;AAAA,QACD;AAEA,aAAK,cAAa;AAAA,UACjB,MAAM;AAAA,UACN,KAAK,QAAQ;AAAA,UACb;AAAA,UACA,YAAY,QAAQ,cAAc;AAAA,UAClC;AAAA,UACA,SAAS,QAAQ;AAAA,UACjB,eAAe,QAAQ;AAAA,QACxB;AAAA,MACD;AAAA,MAEA,IAAI,OAAO;AACV,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAEA,IAAI,MAAM;AACT,eAAO,KAAK,YAAW,OAAO;AAAA,MAC/B;AAAA,MAEA,IAAI,SAAS;AACZ,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAKA,IAAI,KAAK;AACR,eAAO,KAAK,YAAW,UAAU,OAAO,KAAK,YAAW,SAAS;AAAA,MAClE;AAAA,MAEA,IAAI,aAAa;AAChB,eAAO,KAAK,YAAW,UAAU;AAAA,MAClC;AAAA,MAEA,IAAI,aAAa;AAChB,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAEA,IAAI,UAAU;AACb,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAEA,IAAI,gBAAgB;AACnB,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAOA,QAAQ;AACP,eAAO,IAAI,UAAS,OAAM,MAAM,KAAK,aAAa,GAAG;AAAA,UACpD,MAAM,KAAK;AAAA,UACX,KAAK,KAAK;AAAA,UACV,QAAQ,KAAK;AAAA,UACb,YAAY,KAAK;AAAA,UACjB,SAAS,KAAK;AAAA,UACd,IAAI,KAAK;AAAA,UACT,YAAY,KAAK;AAAA,UACjB,MAAM,KAAK;AAAA,UACX,eAAe,KAAK;AAAA,QACrB,CAAC;AAAA,MACF;AAAA,MAOA,OAAO,SAAS,KAAK,SAAS,KAAK;AAClC,YAAI,CAAC,YAAW,MAAM,GAAG;AACxB,gBAAM,IAAI,WAAW,iEAAiE;AAAA,QACvF;AAEA,eAAO,IAAI,UAAS,MAAM;AAAA,UACzB,SAAS;AAAA,YACR,UAAU,IAAI,IAAI,GAAG,EAAE,SAAS;AAAA,UACjC;AAAA,UACA;AAAA,QACD,CAAC;AAAA,MACF;AAAA,MAEA,OAAO,QAAQ;AACd,cAAM,WAAW,IAAI,UAAS,MAAM,EAAC,QAAQ,GAAG,YAAY,GAAE,CAAC;AAC/D,iBAAS,YAAW,OAAO;AAC3B,eAAO;AAAA,MACR;AAAA,MAEA,KAAK,OAAO,eAAe;AAC1B,eAAO;AAAA,MACR;AAAA,IACD;AAEA,WAAO,iBAAiB,UAAS,WAAW;AAAA,MAC3C,MAAM,EAAC,YAAY,KAAI;AAAA,MACvB,KAAK,EAAC,YAAY,KAAI;AAAA,MACtB,QAAQ,EAAC,YAAY,KAAI;AAAA,MACzB,IAAI,EAAC,YAAY,KAAI;AAAA,MACrB,YAAY,EAAC,YAAY,KAAI;AAAA,MAC7B,YAAY,EAAC,YAAY,KAAI;AAAA,MAC7B,SAAS,EAAC,YAAY,KAAI;AAAA,MAC1B,OAAO,EAAC,YAAY,KAAI;AAAA,IACzB,CAAC;AAAA;AAAA;;;AC5ID,IAAa;AAAb;AAAA;AAAO,IAAM,aAAY,eAAa;AACrC,UAAI,UAAU,QAAQ;AACrB,eAAO,UAAU;AAAA,MAClB;AAEA,YAAM,aAAa,UAAU,KAAK,SAAS;AAC3C,YAAM,OAAO,UAAU,QAAS,WAAU,KAAK,gBAAgB,MAAM,MAAM;AAC3E,aAAO,UAAU,KAAK,aAAa,KAAK,YAAY,MAAM,MAAM;AAAA,IACjE;AAAA;AAAA;;;ACSO,oCAAmC,KAAK,aAAa,OAAO;AAElE,MAAI,OAAO,MAAM;AAChB,WAAO;AAAA,EACR;AAEA,QAAM,IAAI,IAAI,GAAG;AAGjB,MAAI,uBAAuB,KAAK,IAAI,QAAQ,GAAG;AAC9C,WAAO;AAAA,EACR;AAGA,MAAI,WAAW;AAIf,MAAI,WAAW;AAIf,MAAI,OAAO;AAGX,MAAI,YAAY;AAGf,QAAI,WAAW;AAIf,QAAI,SAAS;AAAA,EACd;AAGA,SAAO;AACR;AA2BO,iCAAgC,gBAAgB;AACtD,MAAI,CAAC,gBAAe,IAAI,cAAc,GAAG;AACxC,UAAM,IAAI,UAAU,2BAA2B,gBAAgB;AAAA,EAChE;AAEA,SAAO;AACR;AAOO,yCAAwC,KAAK;AAQnD,MAAI,gBAAgB,KAAK,IAAI,QAAQ,GAAG;AACvC,WAAO;AAAA,EACR;AAGA,QAAM,SAAS,IAAI,KAAK,QAAQ,eAAe,EAAE;AACjD,QAAM,gBAAgB,2BAAK,MAAM;AAEjC,MAAI,kBAAkB,KAAK,SAAS,KAAK,MAAM,GAAG;AACjD,WAAO;AAAA,EACR;AAEA,MAAI,kBAAkB,KAAK,mCAAmC,KAAK,MAAM,GAAG;AAC3E,WAAO;AAAA,EACR;AAKA,MAAI,IAAI,SAAS,eAAe,IAAI,KAAK,SAAS,YAAY,GAAG;AAChE,WAAO;AAAA,EACR;AAGA,MAAI,IAAI,aAAa,SAAS;AAC7B,WAAO;AAAA,EACR;AASA,SAAO;AACR;AAOO,sCAAqC,KAAK;AAEhD,MAAI,yBAAyB,KAAK,GAAG,GAAG;AACvC,WAAO;AAAA,EACR;AAGA,MAAI,IAAI,aAAa,SAAS;AAC7B,WAAO;AAAA,EACR;AAKA,MAAI,uBAAuB,KAAK,IAAI,QAAQ,GAAG;AAC9C,WAAO;AAAA,EACR;AAGA,SAAO,gCAA+B,GAAG;AAC1C;AA0BO,oCAAmC,SAAS,EAAC,qBAAqB,2BAA0B,CAAC,GAAG;AAMtG,MAAI,QAAQ,aAAa,iBAAiB,QAAQ,mBAAmB,IAAI;AACxE,WAAO;AAAA,EACR;AAGA,QAAM,SAAS,QAAQ;AAMvB,MAAI,QAAQ,aAAa,gBAAgB;AACxC,WAAO;AAAA,EACR;AAGA,QAAM,iBAAiB,QAAQ;AAG/B,MAAI,cAAc,2BAA0B,cAAc;AAI1D,MAAI,iBAAiB,2BAA0B,gBAAgB,IAAI;AAInE,MAAI,YAAY,SAAS,EAAE,SAAS,MAAM;AACzC,kBAAc;AAAA,EACf;AAMA,MAAI,qBAAqB;AACxB,kBAAc,oBAAoB,WAAW;AAAA,EAC9C;AAEA,MAAI,wBAAwB;AAC3B,qBAAiB,uBAAuB,cAAc;AAAA,EACvD;AAGA,QAAM,aAAa,IAAI,IAAI,QAAQ,GAAG;AAEtC,UAAQ;AAAA,SACF;AACJ,aAAO;AAAA,SAEH;AACJ,aAAO;AAAA,SAEH;AACJ,aAAO;AAAA,SAEH;AAGJ,UAAI,6BAA4B,WAAW,KAAK,CAAC,6BAA4B,UAAU,GAAG;AACzF,eAAO;AAAA,MACR;AAGA,aAAO,eAAe,SAAS;AAAA,SAE3B;AAGJ,UAAI,YAAY,WAAW,WAAW,QAAQ;AAC7C,eAAO;AAAA,MACR;AAIA,UAAI,6BAA4B,WAAW,KAAK,CAAC,6BAA4B,UAAU,GAAG;AACzF,eAAO;AAAA,MACR;AAGA,aAAO;AAAA,SAEH;AAGJ,UAAI,YAAY,WAAW,WAAW,QAAQ;AAC7C,eAAO;AAAA,MACR;AAGA,aAAO;AAAA,SAEH;AAGJ,UAAI,YAAY,WAAW,WAAW,QAAQ;AAC7C,eAAO;AAAA,MACR;AAGA,aAAO;AAAA,SAEH;AAGJ,UAAI,6BAA4B,WAAW,KAAK,CAAC,6BAA4B,UAAU,GAAG;AACzF,eAAO;AAAA,MACR;AAGA,aAAO;AAAA;AAGP,YAAM,IAAI,UAAU,2BAA2B,QAAQ;AAAA;AAE1D;AAOO,wCAAuC,SAAS;AAGtD,QAAM,eAAgB,SAAQ,IAAI,iBAAiB,KAAK,IAAI,MAAM,QAAQ;AAG1E,MAAI,SAAS;AAMb,aAAW,SAAS,cAAc;AACjC,QAAI,SAAS,gBAAe,IAAI,KAAK,GAAG;AACvC,eAAS;AAAA,IACV;AAAA,EACD;AAGA,SAAO;AACR;AAnVA,sBA2Da,iBAeA;AA1Eb;AAAA;AAAA,uBAAmB;AA2DZ,IAAM,kBAAiB,oBAAI,IAAI;AAAA,MACrC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD,CAAC;AAKM,IAAM,2BAA0B;AAAA;AAAA;;;AC1EvC,IAQA,kBACA,mBASM,YAQA,YAOA,gBAae,UAmLR;AAjOb;AAAA;AAQA,uBAAkC;AAClC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AAIA,IAAM,aAAY,OAAO,mBAAmB;AAQ5C,IAAM,aAAY,YAAU;AAC3B,aACC,OAAO,WAAW,YAClB,OAAO,OAAO,gBAAe;AAAA,IAE/B;AAEA,IAAM,iBAAgB,iCAAU,MAAM;AAAA,IAAC,GACtC,gEACA,gEAAgE;AAWjE,IAAqB,WAArB,cAAqC,MAAK;AAAA,MACzC,YAAY,OAAO,OAAO,CAAC,GAAG;AAC7B,YAAI;AAGJ,YAAI,WAAU,KAAK,GAAG;AACrB,sBAAY,IAAI,IAAI,MAAM,GAAG;AAAA,QAC9B,OAAO;AACN,sBAAY,IAAI,IAAI,KAAK;AACzB,kBAAQ,CAAC;AAAA,QACV;AAEA,YAAI,UAAU,aAAa,MAAM,UAAU,aAAa,IAAI;AAC3D,gBAAM,IAAI,UAAU,GAAG,gDAAgD;AAAA,QACxE;AAEA,YAAI,SAAS,KAAK,UAAU,MAAM,UAAU;AAC5C,YAAI,wCAAwC,KAAK,MAAM,GAAG;AACzD,mBAAS,OAAO,YAAY;AAAA,QAC7B;AAEA,YAAI,CAAC,WAAU,IAAI,KAAK,UAAU,MAAM;AACvC,yBAAc;AAAA,QACf;AAGA,YAAK,MAAK,QAAQ,QAAS,WAAU,KAAK,KAAK,MAAM,SAAS,SAC5D,YAAW,SAAS,WAAW,SAAS;AACzC,gBAAM,IAAI,UAAU,+CAA+C;AAAA,QACpE;AAEA,cAAM,YAAY,KAAK,OACtB,KAAK,OACJ,WAAU,KAAK,KAAK,MAAM,SAAS,OACnC,OAAM,KAAK,IACX;AAEF,cAAM,WAAW;AAAA,UAChB,MAAM,KAAK,QAAQ,MAAM,QAAQ;AAAA,QAClC,CAAC;AAED,cAAM,UAAU,IAAI,SAAQ,KAAK,WAAW,MAAM,WAAW,CAAC,CAAC;AAE/D,YAAI,cAAc,QAAQ,CAAC,QAAQ,IAAI,cAAc,GAAG;AACvD,gBAAM,cAAc,oBAAmB,WAAW,IAAI;AACtD,cAAI,aAAa;AAChB,oBAAQ,IAAI,gBAAgB,WAAW;AAAA,UACxC;AAAA,QACD;AAEA,YAAI,SAAS,WAAU,KAAK,IAC3B,MAAM,SACN;AACD,YAAI,YAAY,MAAM;AACrB,mBAAS,KAAK;AAAA,QACf;AAGA,YAAI,UAAU,QAAQ,CAAC,eAAc,MAAM,GAAG;AAC7C,gBAAM,IAAI,UAAU,gEAAgE;AAAA,QACrF;AAIA,YAAI,WAAW,KAAK,YAAY,OAAO,MAAM,WAAW,KAAK;AAC7D,YAAI,aAAa,IAAI;AAEpB,qBAAW;AAAA,QACZ,WAAW,UAAU;AAEpB,gBAAM,iBAAiB,IAAI,IAAI,QAAQ;AAEvC,qBAAW,wBAAwB,KAAK,cAAc,IAAI,WAAW;AAAA,QACtE,OAAO;AACN,qBAAW;AAAA,QACZ;AAEA,aAAK,cAAa;AAAA,UACjB;AAAA,UACA,UAAU,KAAK,YAAY,MAAM,YAAY;AAAA,UAC7C;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AAGA,aAAK,SAAS,KAAK,WAAW,SAAa,MAAM,WAAW,SAAY,KAAK,MAAM,SAAU,KAAK;AAClG,aAAK,WAAW,KAAK,aAAa,SAAa,MAAM,aAAa,SAAY,OAAO,MAAM,WAAY,KAAK;AAC5G,aAAK,UAAU,KAAK,WAAW,MAAM,WAAW;AAChD,aAAK,QAAQ,KAAK,SAAS,MAAM;AACjC,aAAK,gBAAgB,KAAK,iBAAiB,MAAM,iBAAiB;AAClE,aAAK,qBAAqB,KAAK,sBAAsB,MAAM,sBAAsB;AAIjF,aAAK,iBAAiB,KAAK,kBAAkB,MAAM,kBAAkB;AAAA,MACtE;AAAA,MAGA,IAAI,SAAS;AACZ,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAGA,IAAI,MAAM;AACT,eAAO,6BAAU,KAAK,YAAW,SAAS;AAAA,MAC3C;AAAA,MAGA,IAAI,UAAU;AACb,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAEA,IAAI,WAAW;AACd,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAGA,IAAI,SAAS;AACZ,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAGA,IAAI,WAAW;AACd,YAAI,KAAK,YAAW,aAAa,eAAe;AAC/C,iBAAO;AAAA,QACR;AAEA,YAAI,KAAK,YAAW,aAAa,UAAU;AAC1C,iBAAO;AAAA,QACR;AAEA,YAAI,KAAK,YAAW,UAAU;AAC7B,iBAAO,KAAK,YAAW,SAAS,SAAS;AAAA,QAC1C;AAEA,eAAO;AAAA,MACR;AAAA,MAEA,IAAI,iBAAiB;AACpB,eAAO,KAAK,YAAW;AAAA,MACxB;AAAA,MAEA,IAAI,eAAe,gBAAgB;AAClC,aAAK,YAAW,iBAAiB,wBAAuB,cAAc;AAAA,MACvE;AAAA,MAOA,QAAQ;AACP,eAAO,IAAI,SAAQ,IAAI;AAAA,MACxB;AAAA,MAEA,KAAK,OAAO,eAAe;AAC1B,eAAO;AAAA,MACR;AAAA,IACD;AAEA,WAAO,iBAAiB,SAAQ,WAAW;AAAA,MAC1C,QAAQ,EAAC,YAAY,KAAI;AAAA,MACzB,KAAK,EAAC,YAAY,KAAI;AAAA,MACtB,SAAS,EAAC,YAAY,KAAI;AAAA,MAC1B,UAAU,EAAC,YAAY,KAAI;AAAA,MAC3B,OAAO,EAAC,YAAY,KAAI;AAAA,MACxB,QAAQ,EAAC,YAAY,KAAI;AAAA,MACzB,UAAU,EAAC,YAAY,KAAI;AAAA,MAC3B,gBAAgB,EAAC,YAAY,KAAI;AAAA,IAClC,CAAC;AAQM,IAAM,yBAAwB,aAAW;AAC/C,YAAM,EAAC,cAAa,QAAQ;AAC5B,YAAM,UAAU,IAAI,SAAQ,QAAQ,YAAW,OAAO;AAGtD,UAAI,CAAC,QAAQ,IAAI,QAAQ,GAAG;AAC3B,gBAAQ,IAAI,UAAU,KAAK;AAAA,MAC5B;AAGA,UAAI,qBAAqB;AACzB,UAAI,QAAQ,SAAS,QAAQ,gBAAgB,KAAK,QAAQ,MAAM,GAAG;AAClE,6BAAqB;AAAA,MACtB;AAEA,UAAI,QAAQ,SAAS,MAAM;AAC1B,cAAM,aAAa,eAAc,OAAO;AAExC,YAAI,OAAO,eAAe,YAAY,CAAC,OAAO,MAAM,UAAU,GAAG;AAChE,+BAAqB,OAAO,UAAU;AAAA,QACvC;AAAA,MACD;AAEA,UAAI,oBAAoB;AACvB,gBAAQ,IAAI,kBAAkB,kBAAkB;AAAA,MACjD;AAKA,UAAI,QAAQ,mBAAmB,IAAI;AAClC,gBAAQ,iBAAiB;AAAA,MAC1B;AAKA,UAAI,QAAQ,YAAY,QAAQ,aAAa,eAAe;AAC3D,gBAAQ,YAAW,WAAW,2BAA0B,OAAO;AAAA,MAChE,OAAO;AACN,gBAAQ,YAAW,WAAW;AAAA,MAC/B;AAKA,UAAI,QAAQ,YAAW,oBAAoB,KAAK;AAC/C,gBAAQ,IAAI,WAAW,QAAQ,QAAQ;AAAA,MACxC;AAGA,UAAI,CAAC,QAAQ,IAAI,YAAY,GAAG;AAC/B,gBAAQ,IAAI,cAAc,YAAY;AAAA,MACvC;AAGA,UAAI,QAAQ,YAAY,CAAC,QAAQ,IAAI,iBAAiB,GAAG;AACxD,gBAAQ,IAAI,mBAAmB,mBAAmB;AAAA,MACnD;AAEA,UAAI,EAAC,UAAS;AACd,UAAI,OAAO,UAAU,YAAY;AAChC,gBAAQ,MAAM,SAAS;AAAA,MACxB;AAEA,UAAI,CAAC,QAAQ,IAAI,YAAY,KAAK,CAAC,OAAO;AACzC,gBAAQ,IAAI,cAAc,OAAO;AAAA,MAClC;AAKA,YAAM,SAAS,WAAU,SAAS;AAIlC,YAAM,UAAU;AAAA,QAEf,MAAM,UAAU,WAAW;AAAA,QAE3B,QAAQ,QAAQ;AAAA,QAChB,SAAS,QAAQ,OAAO,IAAI,4BAA4B,GAAG;AAAA,QAC3D,oBAAoB,QAAQ;AAAA,QAC5B;AAAA,MACD;AAEA,aAAO;AAAA,QAEN;AAAA,QACA;AAAA,MACD;AAAA,IACD;AAAA;AAAA;;;AC5TA,IAKa;AALb;AAAA;AAAA;AAKO,IAAM,cAAN,cAAyB,gBAAe;AAAA,MAC9C,YAAY,SAAS,OAAO,WAAW;AACtC,cAAM,SAAS,IAAI;AAAA,MACpB;AAAA,IACD;AAAA;AAAA;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+CA,sBAAoC,KAAK,UAAU;AAClD,SAAO,IAAI,QAAQ,CAAC,UAAS,WAAW;AAEvC,UAAM,UAAU,IAAI,SAAQ,KAAK,QAAQ;AACzC,UAAM,EAAC,WAAW,YAAW,uBAAsB,OAAO;AAC1D,QAAI,CAAC,kBAAiB,IAAI,UAAU,QAAQ,GAAG;AAC9C,YAAM,IAAI,UAAU,0BAA0B,oBAAoB,UAAU,SAAS,QAAQ,MAAM,EAAE,sBAAsB;AAAA,IAC5H;AAEA,QAAI,UAAU,aAAa,SAAS;AACnC,YAAM,OAAO,cAAgB,QAAQ,GAAG;AACxC,YAAM,YAAW,IAAI,UAAS,MAAM,EAAC,SAAS,EAAC,gBAAgB,KAAK,SAAQ,EAAC,CAAC;AAC9E,eAAQ,SAAQ;AAChB;AAAA,IACD;AAGA,UAAM,OAAQ,WAAU,aAAa,WAAW,6BAAQ,2BAAM;AAC9D,UAAM,EAAC,WAAU;AACjB,QAAI,WAAW;AAEf,UAAM,QAAQ,MAAM;AACnB,YAAM,QAAQ,IAAI,YAAW,4BAA4B;AACzD,aAAO,KAAK;AACZ,UAAI,QAAQ,QAAQ,QAAQ,gBAAgB,4BAAO,UAAU;AAC5D,gBAAQ,KAAK,QAAQ,KAAK;AAAA,MAC3B;AAEA,UAAI,CAAC,YAAY,CAAC,SAAS,MAAM;AAChC;AAAA,MACD;AAEA,eAAS,KAAK,KAAK,SAAS,KAAK;AAAA,IAClC;AAEA,QAAI,UAAU,OAAO,SAAS;AAC7B,YAAM;AACN;AAAA,IACD;AAEA,UAAM,mBAAmB,MAAM;AAC9B,YAAM;AACN,eAAS;AAAA,IACV;AAGA,UAAM,WAAW,KAAK,UAAU,SAAS,GAAG,OAAO;AAEnD,QAAI,QAAQ;AACX,aAAO,iBAAiB,SAAS,gBAAgB;AAAA,IAClD;AAEA,UAAM,WAAW,MAAM;AACtB,eAAS,MAAM;AACf,UAAI,QAAQ;AACX,eAAO,oBAAoB,SAAS,gBAAgB;AAAA,MACrD;AAAA,IACD;AAEA,aAAS,GAAG,SAAS,WAAS;AAC7B,aAAO,IAAI,YAAW,cAAc,QAAQ,uBAAuB,MAAM,WAAW,UAAU,KAAK,CAAC;AACpG,eAAS;AAAA,IACV,CAAC;AAED,yCAAoC,UAAU,WAAS;AACtD,UAAI,YAAY,SAAS,MAAM;AAC9B,iBAAS,KAAK,QAAQ,KAAK;AAAA,MAC5B;AAAA,IACD,CAAC;AAGD,QAAI,QAAQ,UAAU,OAAO;AAG5B,eAAS,GAAG,UAAU,QAAK;AAC1B,YAAI;AACJ,WAAE,gBAAgB,OAAO,MAAM;AAC9B,iCAAuB,GAAE;AAAA,QAC1B,CAAC;AACD,WAAE,gBAAgB,SAAS,cAAY;AAEtC,cAAI,YAAY,uBAAuB,GAAE,gBAAgB,CAAC,UAAU;AACnE,kBAAM,QAAQ,IAAI,MAAM,iBAAiB;AACzC,kBAAM,OAAO;AACb,qBAAS,KAAK,KAAK,SAAS,KAAK;AAAA,UAClC;AAAA,QACD,CAAC;AAAA,MACF,CAAC;AAAA,IACF;AAEA,aAAS,GAAG,YAAY,eAAa;AACpC,eAAS,WAAW,CAAC;AACrB,YAAM,UAAU,gBAAe,UAAU,UAAU;AAGnD,UAAI,YAAW,UAAU,UAAU,GAAG;AAErC,cAAM,WAAW,QAAQ,IAAI,UAAU;AAGvC,YAAI,cAAc;AAClB,YAAI;AACH,wBAAc,aAAa,OAAO,OAAO,IAAI,IAAI,UAAU,QAAQ,GAAG;AAAA,QACvE,QAAE;AAID,cAAI,QAAQ,aAAa,UAAU;AAClC,mBAAO,IAAI,YAAW,wDAAwD,YAAY,kBAAkB,CAAC;AAC7G,qBAAS;AACT;AAAA,UACD;AAAA,QACD;AAGA,gBAAQ,QAAQ;AAAA,eACV;AACJ,mBAAO,IAAI,YAAW,0EAA0E,QAAQ,OAAO,aAAa,CAAC;AAC7H,qBAAS;AACT;AAAA,eACI;AAEJ;AAAA,eACI,UAAU;AAEd,gBAAI,gBAAgB,MAAM;AACzB;AAAA,YACD;AAGA,gBAAI,QAAQ,WAAW,QAAQ,QAAQ;AACtC,qBAAO,IAAI,YAAW,gCAAgC,QAAQ,OAAO,cAAc,CAAC;AACpF,uBAAS;AACT;AAAA,YACD;AAIA,kBAAM,iBAAiB;AAAA,cACtB,SAAS,IAAI,SAAQ,QAAQ,OAAO;AAAA,cACpC,QAAQ,QAAQ;AAAA,cAChB,SAAS,QAAQ,UAAU;AAAA,cAC3B,OAAO,QAAQ;AAAA,cACf,UAAU,QAAQ;AAAA,cAClB,QAAQ,QAAQ;AAAA,cAChB,MAAM,OAAM,OAAO;AAAA,cACnB,QAAQ,QAAQ;AAAA,cAChB,MAAM,QAAQ;AAAA,cACd,UAAU,QAAQ;AAAA,cAClB,gBAAgB,QAAQ;AAAA,YACzB;AAWA,gBAAI,CAAC,qBAAoB,QAAQ,KAAK,WAAW,KAAK,CAAC,gBAAe,QAAQ,KAAK,WAAW,GAAG;AAChG,yBAAW,SAAQ,CAAC,iBAAiB,oBAAoB,UAAU,SAAS,GAAG;AAC9E,+BAAe,QAAQ,OAAO,KAAI;AAAA,cACnC;AAAA,YACD;AAGA,gBAAI,UAAU,eAAe,OAAO,QAAQ,QAAQ,SAAS,gBAAgB,4BAAO,UAAU;AAC7F,qBAAO,IAAI,YAAW,4DAA4D,sBAAsB,CAAC;AACzG,uBAAS;AACT;AAAA,YACD;AAGA,gBAAI,UAAU,eAAe,OAAS,WAAU,eAAe,OAAO,UAAU,eAAe,QAAQ,QAAQ,WAAW,QAAS;AAClI,6BAAe,SAAS;AACxB,6BAAe,OAAO;AACtB,6BAAe,QAAQ,OAAO,gBAAgB;AAAA,YAC/C;AAGA,kBAAM,yBAAyB,+BAA8B,OAAO;AACpE,gBAAI,wBAAwB;AAC3B,6BAAe,iBAAiB;AAAA,YACjC;AAGA,qBAAQ,OAAM,IAAI,SAAQ,aAAa,cAAc,CAAC,CAAC;AACvD,qBAAS;AACT;AAAA,UACD;AAAA;AAGC,mBAAO,OAAO,IAAI,UAAU,oBAAoB,QAAQ,mDAAmD,CAAC;AAAA;AAAA,MAE/G;AAGA,UAAI,QAAQ;AACX,kBAAU,KAAK,OAAO,MAAM;AAC3B,iBAAO,oBAAoB,SAAS,gBAAgB;AAAA,QACrD,CAAC;AAAA,MACF;AAEA,UAAI,OAAO,kCAAK,WAAW,IAAI,gCAAY,GAAG,WAAS;AACtD,YAAI,OAAO;AACV,iBAAO,KAAK;AAAA,QACb;AAAA,MACD,CAAC;AAGD,UAAI,QAAQ,UAAU,UAAU;AAC/B,kBAAU,GAAG,WAAW,gBAAgB;AAAA,MACzC;AAEA,YAAM,kBAAkB;AAAA,QACvB,KAAK,QAAQ;AAAA,QACb,QAAQ,UAAU;AAAA,QAClB,YAAY,UAAU;AAAA,QACtB;AAAA,QACA,MAAM,QAAQ;AAAA,QACd,SAAS,QAAQ;AAAA,QACjB,eAAe,QAAQ;AAAA,MACxB;AAGA,YAAM,UAAU,QAAQ,IAAI,kBAAkB;AAU9C,UAAI,CAAC,QAAQ,YAAY,QAAQ,WAAW,UAAU,YAAY,QAAQ,UAAU,eAAe,OAAO,UAAU,eAAe,KAAK;AACvI,mBAAW,IAAI,UAAS,MAAM,eAAe;AAC7C,iBAAQ,QAAQ;AAChB;AAAA,MACD;AAOA,YAAM,cAAc;AAAA,QACnB,OAAO,0BAAK;AAAA,QACZ,aAAa,0BAAK;AAAA,MACnB;AAGA,UAAI,YAAY,UAAU,YAAY,UAAU;AAC/C,eAAO,kCAAK,MAAM,0BAAK,aAAa,WAAW,GAAG,WAAS;AAC1D,cAAI,OAAO;AACV,mBAAO,KAAK;AAAA,UACb;AAAA,QACD,CAAC;AACD,mBAAW,IAAI,UAAS,MAAM,eAAe;AAC7C,iBAAQ,QAAQ;AAChB;AAAA,MACD;AAGA,UAAI,YAAY,aAAa,YAAY,aAAa;AAGrD,cAAM,MAAM,kCAAK,WAAW,IAAI,gCAAY,GAAG,WAAS;AACvD,cAAI,OAAO;AACV,mBAAO,KAAK;AAAA,UACb;AAAA,QACD,CAAC;AACD,YAAI,KAAK,QAAQ,WAAS;AAEzB,cAAK,OAAM,KAAK,QAAU,GAAM;AAC/B,mBAAO,kCAAK,MAAM,0BAAK,cAAc,GAAG,WAAS;AAChD,kBAAI,OAAO;AACV,uBAAO,KAAK;AAAA,cACb;AAAA,YACD,CAAC;AAAA,UACF,OAAO;AACN,mBAAO,kCAAK,MAAM,0BAAK,iBAAiB,GAAG,WAAS;AACnD,kBAAI,OAAO;AACV,uBAAO,KAAK;AAAA,cACb;AAAA,YACD,CAAC;AAAA,UACF;AAEA,qBAAW,IAAI,UAAS,MAAM,eAAe;AAC7C,mBAAQ,QAAQ;AAAA,QACjB,CAAC;AACD,YAAI,KAAK,OAAO,MAAM;AAGrB,cAAI,CAAC,UAAU;AACd,uBAAW,IAAI,UAAS,MAAM,eAAe;AAC7C,qBAAQ,QAAQ;AAAA,UACjB;AAAA,QACD,CAAC;AACD;AAAA,MACD;AAGA,UAAI,YAAY,MAAM;AACrB,eAAO,kCAAK,MAAM,0BAAK,uBAAuB,GAAG,WAAS;AACzD,cAAI,OAAO;AACV,mBAAO,KAAK;AAAA,UACb;AAAA,QACD,CAAC;AACD,mBAAW,IAAI,UAAS,MAAM,eAAe;AAC7C,iBAAQ,QAAQ;AAChB;AAAA,MACD;AAGA,iBAAW,IAAI,UAAS,MAAM,eAAe;AAC7C,eAAQ,QAAQ;AAAA,IACjB,CAAC;AAGD,mBAAc,UAAU,OAAO,EAAE,MAAM,MAAM;AAAA,EAC9C,CAAC;AACF;AAEA,8CAA6C,SAAS,eAAe;AACpE,QAAM,aAAa,2BAAO,KAAK,WAAW;AAE1C,MAAI,oBAAoB;AACxB,MAAI,0BAA0B;AAC9B,MAAI;AAEJ,UAAQ,GAAG,YAAY,cAAY;AAClC,UAAM,EAAC,YAAW;AAClB,wBAAoB,QAAQ,yBAAyB,aAAa,CAAC,QAAQ;AAAA,EAC5E,CAAC;AAED,UAAQ,GAAG,UAAU,YAAU;AAC9B,UAAM,gBAAgB,MAAM;AAC3B,UAAI,qBAAqB,CAAC,yBAAyB;AAClD,cAAM,QAAQ,IAAI,MAAM,iBAAiB;AACzC,cAAM,OAAO;AACb,sBAAc,KAAK;AAAA,MACpB;AAAA,IACD;AAEA,UAAM,SAAS,SAAO;AACrB,gCAA0B,2BAAO,QAAQ,IAAI,MAAM,EAAE,GAAG,UAAU,MAAM;AAGxE,UAAI,CAAC,2BAA2B,eAAe;AAC9C,kCACC,2BAAO,QAAQ,cAAc,MAAM,EAAE,GAAG,WAAW,MAAM,GAAG,CAAC,CAAC,MAAM,KACpE,2BAAO,QAAQ,IAAI,MAAM,EAAE,GAAG,WAAW,MAAM,CAAC,CAAC,MAAM;AAAA,MAEzD;AAEA,sBAAgB;AAAA,IACjB;AAEA,WAAO,gBAAgB,SAAS,aAAa;AAC7C,WAAO,GAAG,QAAQ,MAAM;AAExB,YAAQ,GAAG,SAAS,MAAM;AACzB,aAAO,eAAe,SAAS,aAAa;AAC5C,aAAO,eAAe,QAAQ,MAAM;AAAA,IACrC,CAAC;AAAA,EACF,CAAC;AACF;AAhaA,IAQA,mBACA,oBACA,mBACA,qBACA,qBA0BM;AAtCN;AAAA;AAQA,wBAAiB;AACjB,yBAAkB;AAClB,wBAAiB;AACjB,0BAAoD;AACpD,0BAAqB;AAErB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA,IAAM,oBAAmB,oBAAI,IAAI,CAAC,SAAS,SAAS,QAAQ,CAAC;AAAA;AAAA;;;ACtC7D;AAAA;AAAA;AAAA;AAAA,IAEO;AAFP;AAAA;AAAA;AAEA,IAAO,sBAAQ;AAAA;AAAA;;;ACFf;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AACO,IAAM,KAAK,CAAC,MAAM,OAAO,OAAO,YAAY;AAC5C,IAAM,OAAO,CAAC,MAAM;;;ACF3B,IAAM,aAAa,CAAC,WAAS,OAAQ,SAAU,MAAM,GAAG,EAAE,MAAM,CAAC;AAE1D,IAAM,SAAS,CAAC,WAAS,OAAO;AACnC,QAAM,UAAS,WAAW,QAAQ;AAClC,SAAO,QAAO,KAAK,GAAG;AAC1B;;;ACLA,IAAM,SAAS;AAER,IAAM,MAAM,CAAC,MAAM,MAAM,IAAI,sBAAoB,UAAU;AAG9D,MAAI,SAAS;AACb,QAAM,YAAY,CAAC,QAAQ;AACvB,aAAU,IAAI,SAAS,MAAM,IAAK,IAAI,MAAM,MAAM,EAAE,OAAO,GAAE,CAAC,IAAI;AAClE,QAAI;AAAQ,aAAO,IAAI,QAAQ,GAAG,SAAS,UAAU,EAAE;AAAA;AAClD,aAAO;AAAA,EAChB;AACA,MAAI,KAAK,SAAS,MAAM;AAAG,WAAO,UAAU,IAAI;AAChD,MAAI,IAAI,SAAS,MAAM;AAAG,UAAM,UAAU,GAAG;AAE7C,MAAI,CAAC;AAAqB,UAAM,IAAI,MAAM,GAAG,EAAE,OAAO,OAAK,KAAK,IAAI,EAAE,KAAK,GAAG;AAE9E,MAAI,IAAI,IAAI,SAAS,OAAO;AAAK,UAAM,IAAI,MAAM,GAAG,EAAE;AAEtD,MAAI,YAAY,IAAI,MAAM,GAAG;AAC7B,MAAI,UAAU,WAAW,KAAK,UAAU,OAAO;AAAI,gBAAY,CAAC;AAEhE,QAAM,gBAAgB,UAAU,IAAI;AACpC,MAAI,eAAe;AACf,UAAM,aAAY,cAAc,MAAM,GAAG;AAC1C,QAAI,WAAU,UAAU,KAAM,WAAU,SAAS,KAAK,WAAU,SAAS,EAAE;AAAI,gBAAU,KAAK,aAAa;AAAA,EAC9G;AAEA,QAAM,YAAY,KAAK,MAAM,GAAG;AAChC,QAAM,aAAa,UAAU,OAAO,CAAC,KAAK,OAAM,CAAC,CAAC,GAAG;AAWrD,QAAM,kBAAkB,WAAW,OAAO,CAAC,KAAK,OAAM;AAClD,QAAI,QAAQ,MAAM;AACd,gBAAU,IAAI;AACd,aAAO;AAAA,IACX,WAAW,QAAQ;AAAK,aAAO;AAAA;AAC1B,aAAO;AAAA,EAChB,CAAC;AAGD,QAAM,UAAU,CAAC,GAAG,WAAW,GAAG,eAAe,EAAE,KAAK,GAAG;AAG3D,MAAI;AAAQ,WAAO,SAAS,QAAQ;AAAA;AAC/B,WAAO;AAChB;;;ACnDA,IAAM,SAAS,CAAC,SAAS;AACrB,MAAI;AACJ,MAAI;AAAE,UAAM,IAAI,IAAI,IAAI,EAAE;AAAA,EAAK,QAC/B;AAAQ,UAAM,AAAU,IAAI,MAAM,WAAW,SAAS,IAAI;AAAA,EAAE;AAC5D,SAAO;AACX;AAEO,IAAM,cAAc,OAAO,MAAM,UAAQ,CAAC,GAAG,qBAAqB;AACrE,MAAI,CAAC,QAAQ;AAAO,YAAQ,OAAO;AACnC,QAAM,MAAM,OAAO,IAAI;AAEvB,QAAM,WAAW,MAAM,YAAY,KAAK,SAAS,gBAAgB;AACjE,MAAI,CAAC;AAAU,UAAM,IAAI,MAAM,uBAAuB;AACtD,QAAM,OAAO,SAAS,KAAK,MAAM,GAAG,EAAE;AAEtC,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA,QAAQ,SAAS;AAAA,EACrB;AACJ;AAEO,IAAM,cAAc,OAAO,KAAK,UAAQ,CAAC,GAAG,qBAAqB;AAEpE,QAAM,WAAW,MAAM,WAAW,MAAM,KAAK,OAAO;AAEpD,SAAO,IAAI,QAAQ,OAAM,aAAW;AAEhC,QAAI,UAAU;AAEV,YAAM,OAAO,SAAS,QAAQ,IAAI,cAAc;AAGhD,UAAI,WAAW,gBAAgB;AAC3B,cAAM,SAAS,MAAM,SAAS,YAAY;AAC1C,iBAAQ,EAAC,QAAQ,KAAI,CAAC;AAAA,MAC1B,OAGK;AAED,cAAM,SAAS,SAAS,KAAK,UAAU;AAEvC,cAAM,QAAQ,SAAS,SAAS,QAAQ,IAAI,gBAAgB,GAAG,EAAE;AACjE,YAAI,gBAAgB;AACpB,YAAI,SAAS,CAAC;AAEd,cAAM,gBAAgB,OAAO,EAAE,MAAM,YAAY;AAE7C,cAAI,MAAM;AACN,kBAAM,SAAS,CAAC;AAChB,gBAAI,OAAO,SAAS;AAAU,qBAAO,OAAO;AAC5C,kBAAM,OAAO,IAAI,KAAK,QAAQ,MAAM;AACpC,kBAAM,KAAK,MAAM,KAAK,YAAY;AAClC,qBAAQ,EAAC,QAAQ,IAAI,WAAW,EAAE,GAAG,KAAI,CAAC;AAC1C;AAAA,UACJ;AAEA,2BAAiB,MAAM;AACvB,gBAAM,QAAQ;AACd,iBAAO,KAAK,KAAK;AAEjB,cAAI,4BAA4B;AAAU,6BAAiB,SAAS,QAAQ,IAAI,OAAO,GAAG,gBAAgB,OAAO,KAAK;AAGtH,iBAAO,OAAO,KAAK,EAAE,KAAK,aAAa;AAAA,QAC3C;AAEA,eAAO,KAAK,EAAE,KAAK,aAAa;AAAA,MACpC;AAAA,IAEJ,OAAO;AACH,cAAQ,KAAK,0BAA0B,QAAQ,OAAO;AACtD,eAAQ,MAAS;AAAA,IACrB;AAAA,EACJ,CAAC;AACL;;;AC3EA,IAAM,UAAU,CAAC;AAGV,IAAM,QAAQ,IAAI,QAAQ,OAAO,UAAS,WAAW;AACxD,MAAI;AACA,QAAG,OAAO,YAAY,UAAU;AAE5B,iBAAW,QAAS,OAAM,yDAAsB;AAChD,UAAI,OAAO,WAAW,UAAU;AAAY,mBAAW,QAAQ;AAE/D,YAAM,QAAQ,OAAM,uEAAsB;AAC1C,iBAAW,OAAO;AAElB,UAAI,OAAO,WAAW,SAAS;AAAY,mBAAW,OAAO;AAC7D,eAAQ,IAAI;AAAA,IAChB;AAAO,eAAQ,IAAI;AAAA,EAEvB,SAAS,KAAP;AACE,YAAQ,IAAI,GAAG;AACf,WAAO,GAAG;AAAA,EACd;AACJ,CAAC;AAID,IAAM,KAAK;AACJ,IAAM,gBAAgB,CAAC,MAAM,WAAS,sBAAsB,QAAQ,qBAAqB,KAAK,IAAI;AAGlG,IAAM,iBAAiB,OAAO,MAAM,MAAM,aAAW,CAAC,MAAM;AAC/D,QAAM,YAAY,KAAK,MAAM,GAAG,EAAE,MAAM,EAAE,EAAE;AAC5C,QAAM,SAAS,cAAc;AAC7B,MAAI,WAAW,SAAS,qBAAqB;AAC7C,QAAM,MAAM,cAAc,MAAM,QAAQ;AACxC,MAAI,WAAW,MAAO,UAAS,OAAO,KAAK,EAAE,QAAQ,EAAE,MAAM,OAAO,EAAE,KAAK,OAAO,MAAM,MAAM,CAAC,OAAM;AACjG,QAAI,GAAE,QAAQ,SAAS,kBAAkB;AAAG,YAAM,IAAI,MAAM,iBAAiB;AAAA;AACxE,YAAM;AAAA,EACb,CAAC;AAGD,QAAM,MAAM,CAAC;AAEf,WAAS,OAAO,UAAU;AAEtB,WAAO,eAAe,KAAK,KAAK;AAAA,MAC5B,KAAK,MAAM,SAAS;AAAA,MAEpB,YAAY;AAAA,IAChB,CAAC;AAAA,EACJ;AAEA,aAAW,QAAQ;AAEpB,SAAO;AACX;AAEO,IAAM,UAAoB;AAEjC,IAAM,UAAU,OAAO,QAAQ,MAAM,WAAW,MAAM,GAAG,EAAE,KAAK,SAAO,IAAI,KAAK,CAAC;AAEjF,IAAM,aAAc,OAAO,KAAK,OAAO,CAAC,MAAM;AAE1C,QAAM;AAAA,IACF;AAAA,IACA,WAAW,MAAI;AAAA,IAAC;AAAA,IAChB;AAAA,IACA;AAAA,MACA;AAEJ,QAAM,gBAAgB,KAAK,WAAW;AAGtC,QAAM;AAGN,MAAI,KAAK;AAAc,SAAK,aAAa,OAAO,CAAC;AAIjD,QAAM,YAAY,IAAI,MAAM,GAAG,EAAE,MAAM,EAAE,EAAE;AAC3C,QAAM,SAAS,cAAc;AAE5B,MAAI,UAAU,CAAC,sBACf,MAAO,UAAS,OAAO,KAAK,EAAE,QAAQ,EAAE,MAAM,OAAO,EAAE,KAAK,OAAO,MAClE,MAAM,MAAM;AAAA,EAAE,CAAC,IACd;AAEF,MAAI,MAAM;AACX,MAAI,CAAC,SAAQ;AAET,WAAO,eAAe,MAAM,QAAQ,GAAG;AAE3C,QAAI;AACA,gBAAS,MAAM,eAAe,MAAM,KAAK,aAAa;AAAA,IAC1D,SAGO,IAAP;AAEI,YAAM,OAAO,AAAU,IAAI,IAAI,GAAG;AAClC,UAAI,YAAY;AAGhB,YAAM,aAAa,CAAC;AACpB,UAAI;AACJ,SAAG;AACC,aAAI,GAAG,KAAK,IAAI;AAChB,YAAI,MAAK;AAAM,eAAI,GAAG,KAAK,IAAI;AAC/B,YAAI,IAAG;AACH,iBAAO,KAAK,QAAQ,GAAE,IAAI,EAAE;AAC5B,gBAAM,WAAW,CAAC,CAAC,GAAE,GAAG,MAAM,SAAS;AACvC,gBAAM,YAAY,GAAE,GAAG,QAAQ,WAAW,EAAE,EAAE,KAAK;AACnD,qBAAW,KAAK;AAAA,YACZ,MAAM,GAAE;AAAA,YACR;AAAA,YACA;AAAA,UACJ,CAAC;AAAA,QACL;AAAA,MACJ,SAAS;AAGT,eAAS,MAAK,YAAW;AACrB,cAAM,EAAC,WAAW,UAAU,SAAQ,WAAW;AAG/C,YAAI,cAAc,AAAU,IAAI,MAAM,SAAS;AAC/C,cAAM,oBAAoB,AAAU,IAAI,WAAW;AACnD,cAAM,2BAA2B,AAAU,IAAI,kBAAkB,QAAQ,QAAQ,IAAI,EAAE,CAAC;AAExF,YAAI,KAAK;AAAc,eAAK,aAAa,KAAK,4BAA4B,WAAW;AAGrF,YAAI,MAAM,cAAc;AACxB,YAAI,CAAC,KAAK;AACN,gBAAM,aAAY,YAAY,MAAM,GAAG,EAAE,MAAM,EAAE,EAAE;AACnD,gBAAM,OAAO,MAAM,YAAY,WAAW;AAC1C,cAAI,OAAO,IAAI,KAAK,CAAC,KAAK,MAAM,GAAG,EAAE,MAAM,KAAK,KAAK,CAAC;AACtD,gBAAM,OAAO,WAAU,SAAS,IAAI;AACpC,gBAAM,SAAS;AACf,gBAAM,UAAU,MAAM,KAAK,KAAK;AAChC,cAAI,eAAgB,OAAQ,MAAM,IAAI,QAAQ,OAAO,aAAY;AAC7D,kBAAM,WAAW,QAAQ;AAAA,cACrB,MAAM;AAAA,cACN,UAAU,CAAC,OAAM,UAAQ;AACrB,yBAAS,OAAM,KAAI;AACnB,oBAAI,SAAQ;AAAQ,2BAAQ,MAAK,IAAI;AAAA,cACzC;AAAA,cACA,YAAY;AAAA,cACZ;AAAA,YACJ,CAAC;AAAA,UACL,CAAC,IAAI;AAEL,gBAAM,eAAe,cAAc,aAAa,aAAa;AAAA,QACjE;AAEA,eAAO,UAAW,WAAY,UAAU,KAAK,mBAAmB,cAAc;AAAA,EAAmB;AAAA,MACrG;AAEA,gBAAS,MAAM,eAAe,MAAM,KAAK,aAAa;AAAA,IAC1D;AAAA,EACJ;AAEA,MAAI,MAAM,aAAa,QAAQ,MAAM,QAAQ,GAAG,IAAI;AACpD,WAAS,KAAK;AAAA,IACZ,MAAM;AAAA,IACN,MAAM,aAAa,gBAAgB,MAAM;AAAA,IACzC;AAAA,EACF,CAAC;AAED,SAAO;AAEP;AAEA,IAAO,qBAAQ;;;AC7Kf,IAAM,QAAQ,CAAC;AAEf,IAAM,OAAM,OAAO,SAAS,aAAW,IAAI,aAAc;AAErD,MAAI,OAAO,AAAK,OAAO,OAAO;AAC9B,QAAM,SAAU,CAAC,QAAQ,KAAK,SAAS,MAAM;AAG7C,QAAM,WAAW,AAAa,QAAQ,SAAS,UAAU;AACzD,QAAM,SAAS,OAAO,aAAa;AACnC,QAAM,WAAW,MAAM,WAAW,YAAY,CAAC;AAE/C,MAAI,CAAC,MAAM,WAAU;AAEjB,UAAM,YAAW,CAAC;AAClB,UAAM,YAAY,AAAa,mBAAQ,UAAU;AAAA,MAC7C,UAAU,IAAI,SAAS;AACnB,YAAI,QAAQ;AACR,oBAAS,KAAK,IAAI;AAClB,mBAAS,GAAG,IAAI;AAAA,QACpB;AAAA,MACJ;AAAA,MACA,YAAY;AAAA,IAChB,CAAC,EAAE,MAAM,QAAK;AACV,UAAI,GAAE,QAAQ,SAAS,iBAAiB;AAAG,cAAM,IAAI,MAAM,KAAK;AAAA;AAC3D,cAAM;AAAA,IACf,CAAC;AAED,UAAM,UAAU,WAAW;AAE3B,UAAM,MAAM,MAAM,MAAM;AAExB,QAAI;AAAQ,YAAM,YAAY,KAAK,WAAW,CAAC;AAAA;AAC1C,YAAM,YAAY;AAAA,EAC3B,WAAW;AAAQ,aAAS,QAAQ,UAAQ,SAAS,GAAG,IAAI,CAAC;AAE7D,SAAQ,SAAU,KAAK,MAAM,KAAK,UAAU,MAAM,SAAS,CAAC,IAAI,MAAM;AAC1E;AAEA,IAAO,cAAQ;;;AC1Cf;AAEA,IAAM,QAAQ,CAAC,OAAW,SAAkB,aAA2B;AAEnE,QAAM,SAA4B,CAAC;AACnC,QAAM,cAAc,SAAS,eAAe;AAC5C,QAAM,WAAW,OAAO,UAAU;AAClC,QAAM,WAAW,OAAO,UAAU;AAElC,MAAI;AACJ,MAAI,UAAU;AACV,UAAM,WAAY,CAAC,eAAe,gBAAgB;AAClD,QAAI,CAAC,YAAY,CAAC,QAAQ,SAAQ;AAE9B,UAAI,YAAY,KAAK;AACjB,gBAAQ,EAAC,SAAS,oDAAoD,MAAM,MAAK;AACjF,gBAAQ,KAAK,SAAS,0GAA0G;AAAA,MACpI,OAAO;AACF,gBAAQ,EAAC,SAAS,oCAAoC,MAAM,MAAK;AAClE,gBAAQ,KAAK,SAAS,8FAA8F;AAAA,MACxH;AAAA,IAEJ;AAAA,EAEJ,WAAW,CAAC,UAAU;AAClB,YAAQ,EAAC,SAAS,mDAAmD,MAAM,KAAI;AAC/E,YAAQ,KAAK,SAAS,oJAAoJ;AAAA,EAC9K;AAGA,MAAI,OAAO;AACP,UAAM,WAAW;AACjB,WAAO,KAAK,KAAK;AAAA,EACrB;AAEA,SAAO;AACX;;;ACjCO,IAAM,QAAQ,CAAC,QAAQ;AAC1B,SAAO,OAAO,QAAQ,YAAY,OAAO,OAAO,iBAAS,EAAE,KAAK,SAAO,IAAI,SAAS,IAAI,MAAM,GAAG,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC;AACpH;AAEO,IAAM,QAAQ,CAAC,MAAM,UAAU,YAAU,UAAU;AAEtD,QAAM,OAAO,OAAO,OAAO,CAAC,GAAG,IAAI;AACnC,MAAI,UAAS;AACT,QAAI,WAAW;AACX,YAAM,QAAQ,SAAS,OAAO;AAC9B,aAAO,SAAS;AAChB,UAAI,aAAa;AAAO,eAAO,MAAM;AAAA,IACzC;AAEA,UAAM,OAAO,OAAO,KAAK,IAAI;AAC7B,UAAM,UAAU,IAAI,IAAI,OAAO,KAAK,QAAQ,CAAC;AAE7C,SAAK,QAAQ,OAAK;AACd,cAAQ,OAAO,CAAC;AAChB,UAAI,OAAO,SAAS,OAAO,YAAY,CAAC,MAAM,QAAQ,SAAS,EAAE;AAAG,aAAK,KAAK,MAAM,KAAK,IAAI,SAAS,EAAE;AAAA,eAC/F,KAAK;AAAU,aAAK,KAAK,SAAS;AAAA,IAC/C,CAAC;AAED,YAAQ,QAAQ,OAAK;AACjB,WAAK,KAAK,SAAS;AAAA,IACvB,CAAC;AAAA,EACL;AAEA,SAAO;AACX;AAEO,IAAM,aAAa,CAAC,KAAK,eAAe;AAC3C,QAAM,SAAS,AAAK,OAAO,GAAG,EAAE,MAAM,EAAE,MAAM,SAAS,OAAO;AAC9D,QAAM,SAAS,UAAU,WAAW,OAAO,KAAK,MAAM,KAAK,UAAU,WAAW,IAAI,CAAC,IAAI,WAAW;AACpG,SAAO;AACX;AAEO,IAAI,SAAS,CAAC,UAAU,QAAQ,MAAI,UAAU,MAAM;AACvD,UAAQ,MAAM,kBAAkB,WAAW,gBAAgB,aAAa,iBAAiB,UAAU,SAAS,sEAAsE,eAAe,KAAK,IAAI,0BAA0B,4BAA4B,IAAI;AACpQ,MAAI;AAAG,WAAO,EAAE;AAClB;;;AC3CF,IAAM,UAAS;AAER,IAAM,OAAM,CAAC,MAAM,MAAM,IAAI,sBAAoB,UAAU;AAG9D,MAAI,SAAS;AACb,QAAM,YAAY,CAAC,QAAQ;AACvB,aAAU,IAAI,SAAS,OAAM,IAAK,IAAI,MAAM,OAAM,EAAE,OAAO,GAAE,CAAC,IAAI;AAClE,QAAI;AAAQ,aAAO,IAAI,QAAQ,GAAG,SAAS,WAAU,EAAE;AAAA;AAClD,aAAO;AAAA,EAChB;AACA,MAAI,KAAK,SAAS,OAAM;AAAG,WAAO,UAAU,IAAI;AAChD,MAAI,IAAI,SAAS,OAAM;AAAG,UAAM,UAAU,GAAG;AAE7C,MAAI,CAAC;AAAqB,UAAM,IAAI,MAAM,GAAG,EAAE,OAAO,OAAK,KAAK,IAAI,EAAE,KAAK,GAAG;AAE9E,MAAI,IAAI,IAAI,SAAS,OAAO;AAAK,UAAM,IAAI,MAAM,GAAG,EAAE;AAEtD,MAAI,YAAY,IAAI,MAAM,GAAG;AAC7B,MAAI,UAAU,WAAW,KAAK,UAAU,OAAO;AAAI,gBAAY,CAAC;AAEhE,QAAM,gBAAgB,UAAU,IAAI;AACpC,MAAI,eAAe;AACf,UAAM,aAAY,cAAc,MAAM,GAAG;AAC1C,QAAI,WAAU,UAAU,KAAM,WAAU,SAAS,KAAK,WAAU,SAAS,EAAE;AAAI,gBAAU,KAAK,aAAa;AAAA,EAC9G;AAEA,QAAM,YAAY,KAAK,MAAM,GAAG;AAChC,QAAM,aAAa,UAAU,OAAO,CAAC,KAAK,OAAM,CAAC,CAAC,GAAG;AAWrD,QAAM,kBAAkB,WAAW,OAAO,CAAC,KAAK,OAAM;AAClD,QAAI,QAAQ,MAAM;AACd,gBAAU,IAAI;AACd,aAAO;AAAA,IACX,WAAW,QAAQ;AAAK,aAAO;AAAA;AAC1B,aAAO;AAAA,EAChB,CAAC;AAGD,QAAM,UAAU,CAAC,GAAG,WAAW,GAAG,eAAe,EAAE,KAAK,GAAG;AAG3D,MAAI;AAAQ,WAAO,SAAS,QAAQ;AAAA;AAC/B,WAAO;AAChB;;;AC/CO,IAAM,SAAQ,IAAI,QAAQ,OAAO,UAAS,WAAW;AACxD,MAAI;AACA,QAAG,OAAO,YAAY,UAAU;AAE5B,iBAAW,QAAS,OAAM,2DAAsB;AAChD,UAAI,OAAO,WAAW,UAAU;AAAY,mBAAW,QAAQ;AAE/D,YAAM,QAAQ,OAAM,yEAAsB;AAC1C,iBAAW,OAAO;AAElB,UAAI,OAAO,WAAW,SAAS;AAAY,mBAAW,OAAO;AAC7D,eAAQ,IAAI;AAAA,IAChB;AAAO,eAAQ,IAAI;AAAA,EAEvB,SAAS,KAAP;AACE,YAAQ,IAAI,GAAG;AACf,WAAO,GAAG;AAAA,EACd;AACJ,CAAC;AAKM,IAAM,iBAAgB,CAAC,MAAM,WAAS,sBAAsB,QAAQ,qBAAqB,KAAK,IAAI;AAGlG,IAAM,kBAAiB,OAAO,MAAM,MAAM,aAAW,CAAC,MAAM;AAC/D,QAAM,YAAY,KAAK,MAAM,GAAG,EAAE,MAAM,EAAE,EAAE;AAC5C,QAAM,SAAS,cAAc;AAC7B,MAAI,WAAW,SAAS,qBAAqB;AAC7C,QAAM,MAAM,eAAc,MAAM,QAAQ;AACxC,MAAI,WAAW,MAAO,UAAS,OAAO,KAAK,EAAE,QAAQ,EAAE,MAAM,OAAO,EAAE,KAAK,OAAO,MAAM,MAAM,CAAC,OAAM;AACjG,QAAI,GAAE,QAAQ,SAAS,kBAAkB;AAAG,YAAM,IAAI,MAAM,iBAAiB;AAAA;AACxE,YAAM;AAAA,EACb,CAAC;AAGD,QAAM,MAAM,CAAC;AAEf,WAAS,OAAO,UAAU;AAEtB,WAAO,eAAe,KAAK,KAAK;AAAA,MAC5B,KAAK,MAAM,SAAS;AAAA,MAEpB,YAAY;AAAA,IAChB,CAAC;AAAA,EACJ;AAEA,aAAW,QAAQ;AAEpB,SAAO;AACX;AAEO,IAAM,WAAoB;;;AC1DjC,+BAA+B,SAAS,IAAI;AAC1C,MAAI,kBAAkB,CAAC,iBAAiB;AACtC,WAAO,aAAa,QAAQ,2EAA2E,QAAQ;AAAA,EACjH;AACA,MAAI,kBAAkB,CAAC,iBAAiB;AACtC,QAAI,aAAa,aAAa,QAAQ,IAAI,IAAI;AAC9C,QAAI,cAAc,GAAG;AACnB,mBAAa,aAAa,QAAQ,IAAI;AAAA,IACxC;AACA,QAAI,cAAc,GAAG;AACnB,mBAAa,aAAa,QAAQ,KAAK;AAAA,IACzC;AACA,WAAO,aAAa,MAAM,GAAG,aAAa,QAAQ,KAAK,UAAU,IAAI,CAAC;AAAA,EACxE;AACA,MAAI,cAAc,gBAAgB,MAAM;AACxC,MAAI,cAAc,gBAAgB,MAAM;AACxC,MAAI;AACJ,MAAI,YAAY,SAAS,UAAU,GAAG;AACpC,QAAI,UAAU,YAAY,MAAM,GAAG,EAAE,GAAG,MAAM,GAAG,EAAE;AACnD,cAAU,IAAI,SAAS,SAAS,WAAW;AAAA,EAC7C,OAAO;AACL,QAAI,YAAY,UAAU,GAAG,CAAC,MAAM,YAAY,UAAU,GAAG,CAAC,GAAG;AAC/D,UAAI,UAAU,YAAY,MAAM,GAAG,EAAE,GAAG,MAAM,GAAG,EAAE;AACnD,gBAAU,IAAI,SAAS,SAAS,YAAY,UAAU,YAAY,QAAQ,GAAG,IAAI,GAAG,YAAY,SAAS,CAAC,CAAC;AAAA,IAC7G,OAAO;AACL,UAAI;AACF,kBAAW,IAAG,MAAM,cAAc,cAAc,GAAG;AAAA,MACrD,QAAE;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AACA,IAAI,eAAe,MAAM;AAAA,EACvB,cAAc;AACZ,SAAK,cAAc,CAAC;AACpB,SAAK,OAAO,CAAC;AACb,SAAK,WAAW,CAAC;AACjB,SAAK,WAAW,CAAC,cAAc;AAC7B,aAAO,OAAO,KAAK,MAAM,SAAS;AAClC,iBAAW,QAAQ,OAAO,oBAAoB,SAAS,GAAG;AACxD,YAAI,KAAK,SAAS;AAChB,eAAK,SAAS,MAAM,QAAQ,CAAC,QAAQ,IAAI,SAAS,KAAK,KAAK,KAAK,CAAC;AAAA,MACtE;AACA,aAAO,KAAK;AAAA,IACd;AACA,SAAK,mBAAmB,CAAC,KAAK,aAAa;AACzC,UAAI,KAAK;AACP,YAAI,CAAC,KAAK,SAAS,MAAM;AACvB,eAAK,SAAS,OAAO,CAAC;AAAA,QACxB;AACA,YAAI,IAAI,KAAK,SAAS,KAAK;AAC3B,aAAK,SAAS,KAAK,KAAK,EAAE,KAAK,GAAG,SAAS,CAAC;AAC5C,eAAO,KAAK,SAAS,KAAK,SAAS;AAAA,MACrC;AACE,eAAO;AAAA,IACX;AACA,SAAK,qBAAqB,CAAC,KAAK,QAAQ;AACtC,UAAI,WAAW,KAAK,SAAS;AAC7B,UAAI,UAAU;AACZ,YAAI,CAAC;AACH,iBAAO,KAAK,SAAS;AAAA,aAClB;AACH,cAAI,MAAM;AACV,cAAI,MAAM,SAAS,KAAK,CAAC,GAAG,OAAM;AAChC,gBAAI,EAAE,QAAQ,KAAK;AACjB,oBAAM;AACN,qBAAO;AAAA,YACT;AAAA,UACF,CAAC;AACD,cAAI;AACF,qBAAS,OAAO,KAAK,CAAC;AACxB,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AACA,SAAK,uBAAuB,CAAC,KAAK,aAAa;AAC7C,UAAI;AACJ,UAAI,UAAU,CAAC,UAAU;AACvB,iBAAS,KAAK;AACd,aAAK,mBAAmB,KAAK,GAAG;AAAA,MAClC;AACA,YAAM,KAAK,iBAAiB,KAAK,OAAO;AAAA,IAC1C;AAAA,EACF;AACF;AACA,IAAI,QAAQ,IAAI,aAAa;AAC7B,uBAAuB,OAAO;AAC5B,MAAI,CAAC,KAAK;AACR,SAAK,SAAS,CAAC;AACjB,WAAS,KAAK,OAAO;AACnB,QAAI,MAAM,YAAY,MAAM;AAC1B;AAAA,SACG;AACH,WAAK,OAAO,KAAK,MAAM;AACvB,UAAI,KAAK;AACP,aAAK,KAAK,MAAM;AAAA;AAEhB,eAAO,eAAe,MAAM,GAAG;AAAA,UAC7B,KAAK,MAAM;AACT,iBAAK,OAAO;AAAA,UACd;AAAA,UACA,KAAK,CAAC,MAAM;AACV,iBAAK,OAAO,KAAK;AACjB,gBAAI,KAAK,MAAM,SAAS,KAAK;AAC3B,mBAAK,SAAS,EAAE,CAAC,KAAK,UAAU,KAAK,OAAO,CAAC;AAAA,UACjD;AAAA,UACA,YAAY;AAAA,UACZ,cAAc;AAAA,QAChB,CAAC;AAAA,IACL;AAAA,EACF;AACF;AACA,IAAI,YAAY,MAAM;AAAA,EACpB,YAAY,aAAa,CAAC,GAAG,QAAQ,OAAO;AAC1C,SAAK,QAAwB,oBAAI,IAAI;AACrC,SAAK,WAAW,CAAC;AACjB,SAAK,UAAU,GAAG,KAAK,OAAO;AAC9B,SAAK,QAAQ;AACb,SAAK,YAAY;AACjB,SAAK,cAAc;AACnB,SAAK,SAAS;AACd,SAAK,YAAY;AACjB,SAAK,UAAU;AACf,SAAK,WAAW;AAChB,SAAK,WAAW;AAChB,SAAK,UAAU;AACf,SAAK,WAAW;AAChB,SAAK,YAAY;AACjB,SAAK,gBAAgB;AACrB,SAAK,WAAW,IAAI,SAAS;AAC3B,aAAO;AAAA,IACT;AACA,SAAK,QAAQ,IAAI,SAAS;AACxB,UAAI,KAAK;AACP,gBAAQ,KAAK,KAAK,GAAG;AACvB,UAAI,SAAS,KAAK,SAAS,GAAG,IAAI;AAClC,UAAI,kBAAkB,SAAS;AAC7B,eAAO,KAAK,CAAC,QAAQ;AACnB,cAAI,QAAQ;AACV,iBAAK,SAAS,EAAE,CAAC,KAAK,MAAM,IAAI,CAAC;AACnC,cAAI,KAAK,WAAW;AAClB,oBAAQ,QAAQ,KAAK,GAAG;AACxB,gBAAI,WAAW;AACb,sBAAQ,IAAI,GAAG,KAAK,eAAe,MAAM;AAAA,UAC7C;AACA;AACA,iBAAO;AAAA,QACT,CAAC;AAAA,MACH,OAAO;AACL,YAAI,WAAW;AACb,eAAK,SAAS,EAAE,CAAC,KAAK,MAAM,OAAO,CAAC;AACtC,YAAI,KAAK,WAAW;AAClB,kBAAQ,QAAQ,KAAK,GAAG;AACxB,cAAI,WAAW;AACb,oBAAQ,IAAI,GAAG,KAAK,eAAe,MAAM;AAAA,QAC7C;AACA;AAAA,MACF;AACA,aAAO;AAAA,IACT;AACA,SAAK,cAAc,CAAC,aAAa;AAC/B,UAAI,OAAO,aAAa;AACtB,eAAO;AACT,WAAK,WAAW,SAAS,KAAK,IAAI;AAClC,aAAO;AAAA,IACT;AACA,SAAK,WAAW,IAAI,SAAS;AAC3B,aAAO,IAAI,QAAQ,CAAC,KAAK,QAAQ;AAC/B,YAAI,KAAK,IAAI,GAAG,IAAI,CAAC;AAAA,MACvB,CAAC;AAAA,IACH;AACA,SAAK,gBAAgB,CAAC,OAAO,CAAC,MAAM;AACpC,SAAK,YAAY,MAAM;AACrB,aAAO,CAAE,MAAK,YAAY,KAAK,WAAW,KAAK,UAAU,KAAK,YAAY,KAAK,UAAU,KAAK,SAAS,KAAK,SAAS,KAAK,aAAa,KAAK;AAAA,IAC9I;AACA,SAAK,MAAM,IAAI,SAAS;AACtB,UAAI,OAAO,KAAK,kBAAkB;AAChC,eAAO,KAAK,cAAc,MAAM,IAAI;AACtC,UAAI,KAAK,UAAU;AACjB,aAAK,WAAW;AAChB,aAAK,UAAU,KAAK,UAAU;AAC9B,YAAI,KAAK,WAAW,CAAC,KAAK,aAAa;AACrC,eAAK,aAAa,KAAK,WAAW,IAAI;AAAA,QACxC;AACA,YAAI,KAAK,QAAQ,OAAO,KAAK,SAAS,YAAY,CAAC,KAAK,WAAW;AACjE,eAAK,QAAQ,KAAK,QAAQ,IAAI;AAAA,QAChC;AACA,YAAI,KAAK,QAAQ,KAAK;AACpB;AAAA,MACJ;AACA,UAAI,KAAK,SAAS;AAChB,YAAI,MAAM,KAAK,MAAM,GAAG,IAAI;AAC5B,eAAO;AAAA,MACT;AACA,aAAO,IAAI,QAAQ,OAAO,aAAY;AACpC,YAAI,MAAM;AACR,cAAI,MAAM,CAAC,MAAM,OAAO,MAAM,UAAU;AACtC,mBAAO,IAAI,QAAQ,OAAO,OAAM;AAC9B;AACA,kBAAI,MAAM,MAAM,KAAK,MAAM,GAAG,KAAK;AACnC,kBAAI,KAAK,QAAQ;AACf,uBAAO,OAAO,KAAK,QAAQ;AACzB,sBAAI,KAAK,OAAO;AACd,+BAAW,YAAY;AACrB,yBAAE,MAAM,IAAI,MAAM,MAAM,GAAG,KAAK,CAAC;AAAA,oBACnC,GAAG,KAAK,KAAK;AACb;AAAA,kBACF,WAAW,KAAK,SAAS,QAAQ,uBAAuB;AACtD,0CAAsB,YAAY;AAChC,yBAAE,MAAM,IAAI,MAAM,MAAM,GAAG,KAAK,CAAC;AAAA,oBACnC,CAAC;AACD;AAAA,kBACF;AACE,0BAAM,MAAM,KAAK,MAAM,GAAG,KAAK;AACjC;AAAA,gBACF;AACA,oBAAI,SAAS,KAAK,QAAQ;AACxB,qBAAE,GAAG;AACL;AAAA,gBACF;AAAA,cACF,WAAW,KAAK,WAAW;AACzB,uBAAO,OAAO,KAAK,WAAW;AAC5B,sBAAI,KAAK,OAAO;AACd,+BAAW,YAAY;AACrB,yBAAE,MAAM,IAAI,MAAM,MAAM,GAAG,GAAG,CAAC;AAAA,oBACjC,GAAG,KAAK,KAAK;AACb;AAAA,kBACF,WAAW,KAAK,SAAS,QAAQ,uBAAuB;AACtD,0CAAsB,YAAY;AAChC,yBAAE,MAAM,IAAI,MAAM,MAAM,GAAG,GAAG,CAAC;AAAA,oBACjC,CAAC;AACD;AAAA,kBACF;AACE,0BAAM,MAAM,KAAK,MAAM,GAAG,GAAG;AAC/B;AAAA,gBACF;AACA,oBAAI,SAAS,KAAK,WAAW;AAC3B,qBAAE,GAAG;AACL;AAAA,gBACF;AAAA,cACF,OAAO;AACL,mBAAE,GAAG;AACL;AAAA,cACF;AAAA,YACF,CAAC;AAAA,UACH;AACA,cAAI,UAAU,YAAY;AACxB,gBAAI,MAAM,MAAM,IAAI,MAAM,QAAQ,GAAG,IAAI;AACzC,gBAAI,QAAQ,QAAQ;AAClB,kBAAI,KAAK,YAAY,KAAK,kBAAkB,WAAW;AACrD,oBAAI,MAAM,QAAQ,GAAG;AACnB,wBAAM,KAAK,UAAU,MAAM,GAAG,GAAG;AAAA;AAEjC,wBAAM,KAAK,UAAU,MAAM,GAAG;AAAA,cAClC;AACA,kBAAI,KAAK,YAAY,KAAK,SAAS;AACjC,oBAAI,MAAM,QAAQ,GAAG;AACnB,wBAAM,KAAK,YAAY,MAAM,GAAG,GAAG;AAAA;AAEnC,wBAAM,KAAK,YAAY,MAAM,GAAG;AAAA,cACpC;AACA,kBAAI,KAAK,QAAQ;AACf,qBAAK,UAAU,MAAM,GAAG;AAAA,cAC1B;AAAA,YACF;AACA,mBAAO;AAAA,UACT;AACA,cAAI,KAAK,OAAO;AACd,uBAAW,YAAY;AACrB,uBAAQ,MAAM,QAAQ,CAAC;AAAA,YACzB,GAAG,KAAK,KAAK;AAAA,UACf,WAAW,KAAK,SAAS,QAAQ,uBAAuB;AACtD,kCAAsB,YAAY;AAChC,uBAAQ,MAAM,QAAQ,CAAC;AAAA,YACzB,CAAC;AAAA,UACH,OAAO;AACL,qBAAQ,MAAM,QAAQ,CAAC;AAAA,UACzB;AAAA,QACF;AACE,mBAAQ,MAAM;AAAA,MAClB,CAAC;AAAA,IACH;AACA,SAAK,YAAY,OAAO,MAAM,SAAS;AACrC,UAAI,EAAE,YAAY,EAAE,QAAQ;AAC1B,YAAI,OAAO,EAAE,WAAW,UAAU;AAChC,cAAI,EAAE,SAAS,EAAE,OAAO,IAAI,EAAE,MAAM,GAAG;AACrC,cAAE,SAAS,EAAE;AACb,gBAAI,EAAE;AACJ,mBAAK,MAAM,IAAI,EAAE,OAAO,KAAK,EAAE,MAAM;AAAA,UACzC;AACE,cAAE,SAAS,KAAK,MAAM,IAAI,EAAE,MAAM;AAAA,QACtC;AACA,YAAI,EAAE,kBAAkB;AACtB,gBAAM,EAAE,OAAO,IAAI,GAAG,IAAI;AAAA,MAC9B;AAAA,IACF;AACA,SAAK,cAAc,OAAO,MAAM,SAAS;AACvC,UAAI,OAAO,EAAE,aAAa,UAAU;AAClC,mBAAW,OAAO,EAAE,UAAU;AAC5B,cAAI,OAAO,EAAE,SAAS,SAAS,UAAU;AACvC,gBAAI,EAAE,SAAS,EAAE,OAAO,IAAI,EAAE,SAAS,IAAI,GAAG;AAC5C,gBAAE,SAAS,OAAO,EAAE,MAAM,IAAI,EAAE,SAAS,IAAI;AAC7C,kBAAI,CAAC,EAAE,MAAM,IAAI,EAAE,SAAS,KAAK,GAAG;AAClC,kBAAE,MAAM,IAAI,EAAE,SAAS,KAAK,KAAK,EAAE,SAAS,IAAI;AAAA,YACpD;AACA,gBAAI,CAAC,EAAE,SAAS,QAAQ,EAAE,MAAM,IAAI,EAAE,SAAS,IAAI;AACjD,gBAAE,SAAS,OAAO,EAAE,MAAM,IAAI,EAAE,SAAS,IAAI;AAAA,UACjD,WAAW,OAAO,EAAE,SAAS,SAAS,eAAe,EAAE,SAAS,SAAS,MAAM;AAC7E,gBAAI,EAAE,SAAS,EAAE,OAAO,IAAI,GAAG,GAAG;AAChC,gBAAE,SAAS,OAAO,EAAE,MAAM,IAAI,GAAG;AACjC,kBAAI,CAAC,EAAE,MAAM,IAAI,EAAE,SAAS,KAAK,GAAG;AAClC,kBAAE,MAAM,IAAI,EAAE,SAAS,KAAK,KAAK,EAAE,SAAS,IAAI;AAAA,YACpD;AACA,gBAAI,CAAC,EAAE,SAAS,QAAQ,EAAE,MAAM,IAAI,GAAG;AACrC,gBAAE,SAAS,OAAO,EAAE,MAAM,IAAI,GAAG;AAAA,UACrC;AACA,cAAI,EAAE,SAAS,MAAM;AACnB,kBAAM,EAAE,SAAS,KAAK,IAAI,GAAG,IAAI;AAAA,QACrC;AAAA,MACF;AAAA,IACF;AACA,SAAK,YAAY,OAAO,GAAG,WAAW;AACpC,UAAI,EAAE,QAAQ;AACZ,YAAI,OAAO,OAAO,KAAK,EAAE,MAAM;AAC/B,cAAM,QAAQ,IAAI,KAAK,IAAI,OAAO,MAAM;AACtC,cAAI,OAAO,EAAE,OAAO,GAAG,OAAO;AAC5B,cAAE,OAAO,GAAG,KAAK,cAAc,EAAE,OAAO,GAAG,EAAE;AAC/C,cAAI,OAAO;AACX,cAAI,OAAO,EAAE,OAAO,GAAG,OAAO,YAAY;AACxC,mBAAO,EAAE,OAAO,GAAG,GAAG,MAAM;AAAA,UAC9B,OAAO;AACL,gBAAI,OAAO,WAAW,UAAU;AAC9B,kBAAI,cAAc,MAAM,MAAM,EAAE,OAAO,GAAG;AACxC,uBAAO;AAAA,YACX,WAAW,WAAW,EAAE,OAAO,GAAG;AAChC,qBAAO;AAAA,UACX;AACA,cAAI,MAAM;AACR,gBAAI,EAAE,OAAO,GAAG,KAAK,KAAK;AACxB,kBAAI,MAAM,QAAQ,MAAM;AACtB,sBAAM,EAAE,OAAO,GAAG,KAAK,IAAI,GAAG,MAAM;AAAA;AAEpC,sBAAM,EAAE,OAAO,GAAG,KAAK,IAAI,GAAG,MAAM;AAAA,YACxC,WAAW,OAAO,EAAE,OAAO,GAAG,SAAS,YAAY;AACjD,kBAAI,MAAM,QAAQ,MAAM;AACtB,sBAAM,EAAE,OAAO,GAAG,KAAK,GAAG,MAAM;AAAA;AAEhC,sBAAM,EAAE,OAAO,GAAG,KAAK,MAAM;AAAA,YACjC,WAAW,OAAO,EAAE,OAAO,GAAG,SAAS,UAAU;AAC/C,kBAAI,EAAE;AACJ,kBAAE,OAAO,GAAG,OAAO,EAAE,MAAM,MAAM,IAAI,EAAE,OAAO,GAAG,IAAI;AAAA;AAErD,kBAAE,OAAO,GAAG,OAAO,EAAE,MAAM,IAAI,EAAE,OAAO,GAAG,IAAI;AACjD,kBAAI,EAAE,OAAO,GAAG,KAAK,KAAK;AACxB,oBAAI,MAAM,QAAQ,MAAM;AACtB,wBAAM,EAAE,OAAO,GAAG,KAAK,IAAI,GAAG,MAAM;AAAA;AAEpC,wBAAM,EAAE,OAAO,GAAG,KAAK,IAAI,GAAG,MAAM;AAAA,cACxC;AAAA,YACF;AAAA,UACF;AACA,iBAAO;AAAA,QACT,CAAC,CAAC;AAAA,MACJ;AAAA,IACF;AACA,SAAK,eAAe,CAAC,YAAY,KAAK,WAAW,OAAO,CAAC,MAAM;AAC7D,WAAK,YAAY;AACjB,UAAI,CAAC;AACH,aAAK,YAAY,KAAK;AACxB,UAAI,KAAK,WAAW,CAAC,KAAK,eAAe,2BAA2B,QAAQ;AAC1E,aAAK,cAAc;AACnB,YAAI,OAAO,YAAY;AACrB,cAAI,KAAK,aAAa;AACpB,gBAAI,KAAK;AACP,sBAAQ,KAAK,KAAK,GAAG;AACvB,gBAAI,SAAS,KAAK,UAAU,KAAK,MAAM,GAAG,IAAI;AAC9C,gBAAI,kBAAkB,SAAS;AAC7B,uBAAS,MAAM;AAAA,YACjB;AACA,gBAAI,KAAK,WAAW;AAClB,sBAAQ,QAAQ,KAAK,GAAG;AACxB,kBAAI,WAAW;AACb,wBAAQ,IAAI,GAAG,KAAK,eAAe,MAAM;AAAA,YAC7C;AACA;AACA,gBAAI,WAAW,QAAQ;AACrB,kBAAI,KAAK;AACP,qBAAK,SAAS,EAAE,CAAC,KAAK,MAAM,OAAO,CAAC;AACtC,kBAAI,KAAK,YAAY,KAAK,QAAQ,KAAK;AACrC,oBAAI,MAAM,QAAQ,MAAM;AACtB,wBAAM,KAAK,UAAU,MAAM,GAAG,MAAM;AAAA;AAEpC,wBAAM,KAAK,UAAU,MAAM,MAAM;AAAA,cACrC;AACA,kBAAI,KAAK,YAAY,KAAK,SAAS;AACjC,oBAAI,MAAM,QAAQ,MAAM;AACtB,wBAAM,KAAK,YAAY,MAAM,GAAG,MAAM;AAAA;AAEtC,wBAAM,KAAK,YAAY,MAAM,MAAM;AAAA,cACvC;AACA,kBAAI,KAAK,QAAQ;AACf,qBAAK,UAAU,MAAM,MAAM;AAAA,cAC7B;AACA,mBAAK,SAAS,EAAE,CAAC,KAAK,MAAM,OAAO,CAAC;AAAA,YACtC;AACA,kCAAsB,IAAI;AAAA,UAC5B;AAAA,QACF;AACA,8BAAsB,IAAI;AAAA,MAC5B;AAAA,IACF;AACA,SAAK,UAAU,CAAC,OAAO,KAAK,QAAQ,OAAO,CAAC,GAAG,UAAU,KAAK,SAAS;AACrE,WAAK,SAAS;AACd,UAAI,CAAC;AACH,aAAK,SAAS,KAAK;AACrB,UAAI,OAAO,YAAY,YAAY,CAAC,KAAK,WAAW;AAClD,aAAK,YAAY;AACjB,YAAI,UAAU,YAAY;AACxB,cAAI,KAAK,WAAW;AAClB,gBAAI,KAAK;AACP,sBAAQ,KAAK,KAAK,GAAG;AACvB,gBAAI,SAAS,KAAK,OAAO,KAAK,MAAM,GAAG,IAAI;AAC3C,gBAAI,kBAAkB,SAAS;AAC7B,uBAAS,MAAM;AAAA,YACjB;AACA,gBAAI,KAAK,WAAW;AAClB,sBAAQ,QAAQ,KAAK,GAAG;AACxB,kBAAI,WAAW;AACb,wBAAQ,IAAI,GAAG,KAAK,eAAe,MAAM;AAAA,YAC7C;AACA;AACA,gBAAI,WAAW,QAAQ;AACrB,kBAAI,KAAK;AACP,qBAAK,SAAS,EAAE,CAAC,KAAK,MAAM,OAAO,CAAC;AACtC,kBAAI,KAAK,YAAY,KAAK,QAAQ,KAAK;AACrC,oBAAI,MAAM,QAAQ,MAAM;AACtB,wBAAM,KAAK,UAAU,MAAM,GAAG,MAAM;AAAA;AAEpC,wBAAM,KAAK,UAAU,MAAM,MAAM;AAAA,cACrC;AACA,kBAAI,KAAK,YAAY,KAAK,SAAS;AACjC,oBAAI,MAAM,QAAQ,MAAM;AACtB,wBAAM,KAAK,YAAY,MAAM,GAAG,MAAM;AAAA;AAEtC,wBAAM,KAAK,YAAY,MAAM,MAAM;AAAA,cACvC;AACA,kBAAI,KAAK,QAAQ;AACf,qBAAK,UAAU,MAAM,MAAM;AAAA,cAC7B;AACA,mBAAK,SAAS,EAAE,CAAC,KAAK,MAAM,OAAO,CAAC;AAAA,YACtC;AACA,uBAAW,YAAY;AACrB,oBAAM,QAAQ;AAAA,YAChB,GAAG,OAAO;AAAA,UACZ;AAAA,QACF;AACA,gBAAQ;AAAA,MACV;AAAA,IACF;AACA,SAAK,YAAY,CAAC,YAAW;AAC3B,WAAK,SAAS;AACd,UAAI,KAAK;AACP,aAAK,UAAU;AAAA,IACnB;AACA,SAAK,cAAc,CAAC,aAAa;AAC/B,WAAK,WAAW;AAChB,UAAI,KAAK;AACP,aAAK,UAAU;AAAA,IACnB;AACA,SAAK,MAAM,CAAC,IAAI,CAAC,MAAM;AACrB,UAAI,OAAO,MAAM;AACf,YAAI,EAAE,UAAU,EAAE;AACpB,UAAI,GAAG,gBAAgB;AACrB,YAAI,EAAE;AACR,UAAI,CAAE,cAAa;AACjB,YAAI,IAAI,UAAU,EAAE,QAAQ,GAAG,MAAM,KAAK,KAAK;AACjD,WAAK,MAAM,IAAI,EAAE,KAAK,CAAC;AACvB,UAAI,KAAK,OAAO;AACd,aAAK,MAAM,MAAM,IAAI,EAAE,KAAK,CAAC;AAC7B,aAAK,MAAM,SAAS,KAAK,MAAM,MAAM;AAAA,MACvC;AACA,aAAO;AAAA,IACT;AACA,SAAK,SAAS,CAAC,MAAM;AACnB,UAAI,OAAO,MAAM;AACf,YAAI,KAAK,MAAM,IAAI,CAAC;AACtB,UAAI,GAAG,KAAK;AACV,aAAK,MAAM,OAAO,EAAE,GAAG;AACvB,YAAI,KAAK,SAAS,EAAE;AAClB,iBAAO,KAAK,SAAS,EAAE;AACzB,YAAI,KAAK,OAAO;AACd,eAAK,MAAM,MAAM,OAAO,EAAE,GAAG;AAC7B,eAAK,MAAM,SAAS,KAAK,MAAM,MAAM;AAAA,QACvC;AACA,aAAK,MAAM,QAAQ,CAAC,OAAO;AACzB,cAAI,GAAG,MAAM,IAAI,GAAG,GAAG,GAAG;AACxB,eAAG,MAAM,OAAO,GAAG,GAAG;AACtB,gBAAI,GAAG,SAAS,GAAG;AACjB,qBAAO,GAAG,SAAS,GAAG;AACxB,gBAAI,GAAG,QAAQ,QAAQ,GAAG;AACxB,qBAAO,GAAG;AAAA,UACd;AAAA,QACF,CAAC;AACD,YAAI,EAAE;AACJ,YAAE,SAAS,CAAC;AAAA,MAChB;AACA,UAAI,OAAO,KAAK,WAAW,UAAU;AACnC,aAAK,MAAM,mBAAmB,KAAK,OAAO;AAAA,MAC5C;AAAA,IACF;AACA,SAAK,SAAS,CAAC,GAAG,aAAa,SAAS;AACtC,UAAI,OAAO,MAAM;AACf,YAAI,KAAK,MAAM,IAAI,CAAC;AACtB,UAAI,GAAG,OAAO;AACZ,mBAAW,YAAY,CAAC;AACxB,YAAI,EAAE;AACJ,YAAE,UAAU;AAAA,MAChB;AAAA,IACF;AACA,SAAK,YAAY,CAAC,UAAU,MAAM,KAAK,QAAQ;AAC7C,UAAI,OAAO,aAAa,UAAU;AAChC,YAAI,KAAK;AACP,qBAAW,KAAK,MAAM,IAAI,QAAQ;AAAA;AAElC,qBAAW,KAAK,MAAM,IAAI,QAAQ;AAAA,MACtC;AACA,UAAI,OAAO,aAAa,YAAY;AAClC,eAAO,KAAK,MAAM,iBAAiB,KAAK,QAAQ;AAAA,MAClD,WAAW;AACT,eAAO,KAAK,MAAM,iBAAiB,KAAK,CAAC,QAAQ;AAC/C,mBAAS,IAAI,GAAG;AAAA,QAClB,CAAC;AAAA,IACL;AACA,SAAK,cAAc,CAAC,KAAK,MAAM,KAAK,QAAQ;AAC1C,aAAO,KAAK,MAAM,mBAAmB,KAAK,GAAG;AAAA,IAC/C;AACA,SAAK,iBAAiB,CAAC,aAAa;AAClC,UAAI,CAAC,KAAK,UAAU;AAClB,eAAO;AAAA,MACT,OAAO;AACL,YAAI,OAAO,aAAa,UAAU;AAChC,cAAI,KAAK;AACP,uBAAW,KAAK,MAAM,IAAI,QAAQ;AAAA;AAElC,uBAAW,KAAK,MAAM,IAAI,QAAQ;AAAA,QACtC;AACA,YAAI,OAAO,aAAa,YAAY;AAClC,iBAAO,KAAK,MAAM,iBAAiB,KAAK,SAAS,QAAQ;AAAA,QAC3D,WAAW;AACT,iBAAO,KAAK,MAAM,iBAAiB,KAAK,SAAS,CAAC,WAAW;AAC3D,qBAAS,IAAI,MAAM;AAAA,UACrB,CAAC;AAAA,MACL;AAAA,IACF;AACA,SAAK,cAAc,CAAC,aAAa;AAC/B,UAAI,CAAC,KAAK;AACR,aAAK,WAAW,CAAC;AACnB,UAAI,OAAO,aAAa,UAAU;AAChC,eAAO,OAAO,KAAK,UAAU,QAAQ;AAAA,MACvC;AACA,WAAK,uBAAuB;AAC5B,UAAI,KAAK;AACP,aAAK,UAAU;AAAA,IACnB;AACA,SAAK,aAAa,IAAI,SAAS;AAC7B,UAAI,OAAO,KAAK,WAAW,UAAU;AACnC,YAAI,KAAK,SAAS,KAAK,OAAO,IAAI,KAAK,MAAM,GAAG;AAC9C,eAAK,SAAS,KAAK;AACnB,cAAI,KAAK;AACP,iBAAK,MAAM,IAAI,KAAK,OAAO,KAAK,KAAK,MAAM;AAAA,QAC/C;AACE,eAAK,SAAS,KAAK,MAAM,IAAI,KAAK,MAAM;AAAA,MAC5C;AACA,UAAI,OAAO,KAAK,QAAQ,aAAa;AACnC,eAAO,KAAK,OAAO,MAAM,GAAG,IAAI;AAAA,IACpC;AACA,SAAK,eAAe,IAAI,SAAS;AAC/B,UAAI;AACJ,UAAI,OAAO,KAAK,aAAa,UAAU;AACrC,mBAAW,OAAO,KAAK,UAAU;AAC/B,cAAI,KAAK,SAAS,MAAM;AACtB,iBAAK,SAAS,KAAK,MAAM,GAAG,IAAI;AAAA,QACpC;AAAA,MACF;AACA,aAAO;AAAA,IACT;AACA,SAAK,WAAW,CAAC,IAAI,MAAM,aAAa,SAAS;AAC/C,UAAI,YAAY;AAAA,QACd,KAAK,EAAE;AAAA,QACP,UAAU,EAAE;AAAA,QACZ,OAAO,EAAE;AAAA,QACT,UAAU,EAAE;AAAA,QACZ,QAAQ,EAAE;AAAA,QACV,SAAS,EAAE;AAAA,QACX,UAAU,EAAE;AAAA,QACZ,MAAM,EAAE;AAAA,QACR,SAAS,EAAE;AAAA,QACX,OAAO,EAAE;AAAA,QACT,OAAO,EAAE;AAAA,QACT,WAAW,EAAE;AAAA,QACb,QAAQ,EAAE;AAAA,QACV,QAAQ,EAAE;AAAA,QACV,UAAU,EAAE;AAAA,QACZ,UAAU,EAAE;AAAA,QACZ,WAAW,EAAE;AAAA,MACf;AACA,UAAI,CAAC,YAAY;AACf,YAAI,cAAc,CAAC;AACnB,mBAAW,OAAO,KAAK,UAAU;AAC/B,sBAAY,OAAO,KAAK;AAAA,QAC1B;AACA,eAAO,OAAO,OAAO,WAAW,WAAW;AAAA,MAC7C;AACE,eAAO;AAAA,UACL,KAAK,EAAE;AAAA,UACP,UAAU,EAAE;AAAA,UACZ,OAAO,EAAE;AAAA,UACT,UAAU,EAAE;AAAA,UACZ,QAAQ,EAAE;AAAA,UACV,SAAS,EAAE;AAAA,UACX,UAAU,EAAE;AAAA,UACZ,MAAM,EAAE;AAAA,UACR,SAAS,EAAE;AAAA,UACX,OAAO,EAAE;AAAA,UACT,OAAO,EAAE;AAAA,UACT,WAAW,EAAE;AAAA,UACb,QAAQ,EAAE;AAAA,UACV,QAAQ,EAAE;AAAA,UACV,UAAU,EAAE;AAAA,UACZ,UAAU,EAAE;AAAA,UACZ,WAAW,EAAE;AAAA,UACb,GAAG,KAAK;AAAA,QACV;AAAA,IACJ;AACA,SAAK,WAAW,CAAC,QAAQ,CAAC,MAAM;AAC9B,UAAI,MAAM,OAAO,OAAO,CAAC,GAAG,KAAK;AACjC,UAAI,IAAI,UAAU;AAChB,aAAK,YAAY,MAAM,QAAQ;AAC/B,eAAO,IAAI;AAAA,MACb;AACA,UAAI,IAAI,UAAU;AAChB,aAAK,YAAY,MAAM,QAAQ;AAC/B,eAAO,IAAI;AAAA,MACb;AACA,aAAO,OAAO,KAAK,KAAK;AACxB,WAAK,UAAU,KAAK,UAAU;AAAA,IAChC;AACA,SAAK,aAAa,CAAC,MAAM;AACvB,UAAI,GAAG;AACL,YAAI,OAAO,MAAM;AACf,cAAI,KAAK,MAAM,IAAI,CAAC;AAAA,MACxB;AACA,UAAI,GAAG,OAAO;AACZ,YAAI,UAAU,CAAC;AACf,cAAM,oBAAoB,CAAC,SAAS;AAClC,cAAI,OAAO,KAAK,aAAa,YAAY,CAAC,QAAQ,KAAK,MAAM;AAC3D,oBAAQ,KAAK,OAAO;AACpB,uBAAW,OAAO,KAAK,UAAU;AAC/B,kBAAI,KAAK,SAAS,KAAK;AACrB,qBAAK,SAAS,KAAK,SAAS;AAC9B,kBAAI,KAAK,SAAS,KAAK,KAAK;AAC1B,oBAAI,KAAK,MAAM,IAAI,KAAK,SAAS,KAAK,GAAG;AACvC,uBAAK,MAAM,OAAO,KAAK,SAAS,KAAK,GAAG;AAC1C,qBAAK,MAAM,QAAQ,CAAC,OAAO;AACzB,sBAAI,GAAG,MAAM,IAAI,KAAK,SAAS,KAAK,GAAG;AACrC,uBAAG,MAAM,OAAO,KAAK,SAAS,KAAK,GAAG;AACxC,sBAAI,GAAG,SAAS,gBAAgB;AAC9B,2BAAO,GAAG,SAAS;AAAA,gBACvB,CAAC;AACD,kCAAkB,KAAK,SAAS,IAAI;AAAA,cACtC;AAAA,YACF;AAAA,UACF;AAAA,QACF;AACA,YAAI,EAAE;AACJ,YAAE,SAAS;AACb,YAAI,EAAE,KAAK;AACT,eAAK,MAAM,OAAO,EAAE,GAAG;AACvB,cAAI,KAAK,SAAS,EAAE;AAClB,mBAAO,KAAK,SAAS,EAAE;AACzB,cAAI,KAAK,QAAQ,QAAQ,EAAE;AACzB,mBAAO,KAAK;AACd,cAAI,KAAK,EAAE,gBAAgB;AACzB,mBAAO,KAAK,EAAE;AAChB,eAAK,MAAM,QAAQ,CAAC,OAAO;AACzB,gBAAI,IAAI,KAAK;AACX,kBAAI,GAAG,MAAM,IAAI,GAAG,GAAG;AACrB,mBAAG,MAAM,OAAO,GAAG,GAAG;AACxB,kBAAI,GAAG,SAAS,GAAG,gBAAgB;AACjC,uBAAO,GAAG,SAAS,GAAG;AAAA,YAC1B;AAAA,UACF,CAAC;AACD,4BAAkB,CAAC;AACnB,cAAI,KAAK;AACP,iBAAK,MAAM,WAAW,GAAG,OAAO;AAAA,mBACzB,EAAE;AACT,cAAE,SAAS,CAAC;AAAA,QAChB;AAAA,MACF;AAAA,IACF;AACA,SAAK,4BAA4B,CAAC,GAAG,OAAO,UAAU,CAAC,MAAM;AAC3D,UAAI,MAAM,EAAE;AACZ,UAAI,CAAC;AACH,cAAM,EAAE;AACV,UAAI,CAAC,QAAQ,MAAM;AACjB,gBAAQ,OAAO;AACf,YAAI,EAAE,UAAU;AACd,cAAI,MAAM,OAAO,EAAE,UAAU;AAC3B,gBAAI,EAAE,SAAS,MAAM,gBAAgB,WAAW;AAC9C,kBAAI,CAAC,EAAE,MAAM,IAAI,MAAM,GAAG;AACxB,kBAAE,MAAM,IAAI,MAAM,KAAK,KAAK;AAC9B,gBAAE,SAAS,MAAM,OAAO;AACxB,kBAAI,CAAC,EAAE;AACL,kBAAE,WAAW;AAAA,YACjB;AAAA,UACF;AAAA,QACF;AACA,YAAI,EAAE,kBAAkB,WAAW;AACjC,cAAI,EAAE,MAAM,IAAI,MAAM,GAAG;AACvB,cAAE,OAAO,MAAM,IAAI,MAAM,KAAK,KAAK;AACrC,cAAI,EAAE,OAAO,UAAU;AACrB,iBAAK,0BAA0B,EAAE,QAAQ,OAAO,OAAO;AAAA,UACzD,WAAW,EAAE,OAAO;AAClB,cAAE,MAAM,QAAQ,CAAC,OAAO;AACtB,kBAAI,CAAC,QAAQ,GAAG,MAAM;AACpB,qBAAK,0BAA0B,IAAI,OAAO,OAAO;AAAA,cACnD;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF;AACA,YAAI,EAAE,OAAO;AACX,cAAI,EAAE,UAAU,EAAE,OAAO,SAAS,EAAE,MAAM,MAAM;AAC9C,cAAE,MAAM,MAAM,QAAQ,CAAC,OAAO;AAC5B,kBAAI,CAAC,QAAQ,GAAG,MAAM;AACpB,qBAAK,0BAA0B,IAAI,OAAO,OAAO;AAAA,cACnD;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,SAAK,yBAAyB,CAAC,IAAI,SAAS;AAC1C,UAAI,GAAG,UAAU;AACf,mBAAW,OAAO,EAAE,UAAU;AAC5B,cAAI,CAAE,GAAE,SAAS,gBAAgB,YAAY;AAC3C,gBAAI,OAAO,EAAE,SAAS,SAAS,UAAU;AACvC,kBAAI,CAAC,EAAE,SAAS,KAAK;AACnB,kBAAE,SAAS,KAAK,MAAM;AACxB,kBAAI,CAAC,EAAE,MAAM,IAAI,EAAE,SAAS,KAAK,GAAG,GAAG;AACrC,kBAAE,SAAS,OAAO,IAAI,UAAU,EAAE,SAAS,MAAM,GAAG,EAAE,KAAK;AAC3D,qBAAK,0BAA0B,GAAG,EAAE,SAAS,IAAI;AAAA,cACnD;AAAA,YACF,OAAO;AACL,kBAAI,OAAO,EAAE,SAAS,SAAS,eAAe,EAAE,SAAS,QAAQ,MAAM;AACrE,kBAAE,SAAS,OAAO,EAAE,MAAM,IAAI,GAAG;AACjC,oBAAI,CAAC,EAAE,SAAS;AACd,oBAAE,SAAS,OAAO,EAAE,MAAM,IAAI,GAAG;AAAA,cACrC,WAAW,OAAO,EAAE,SAAS,SAAS,UAAU;AAC9C,oBAAI,IAAI,EAAE,SAAS;AACnB,kBAAE,SAAS,OAAO,EAAE,MAAM,IAAI,CAAC;AAC/B,oBAAI,CAAC,EAAE,SAAS;AACd,oBAAE,SAAS,OAAO,EAAE,MAAM,IAAI,GAAG;AAAA,cACrC;AACA,kBAAI,EAAE,SAAS,gBAAgB,WAAW;AACxC,kBAAE,MAAM,IAAI,EAAE,SAAS,KAAK,KAAK,EAAE,SAAS,IAAI;AAChD,qBAAK,0BAA0B,GAAG,EAAE,SAAS,IAAI;AACjD,oBAAI,CAAE,GAAE,SAAS,KAAK,OAAO;AAC3B,oBAAE,EAAE,SAAS,KAAK,OAAO,EAAE,SAAS;AAAA,cACxC;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAO,EAAE;AAAA,IACX;AACA,SAAK,cAAc,CAAC,IAAI,SAAS;AAC/B,QAAE,YAAY;AAAA,IAChB;AACA,SAAK,gBAAgB,CAAC,IAAI,SAAS;AACjC,QAAE,cAAc;AAAA,IAClB;AACA,SAAK,WAAW,CAAC,IAAI,SAAS;AAC5B,QAAE,cAAc,CAAC;AACjB,QAAE,YAAY,CAAC;AAAA,IACjB;AACA,SAAK,gBAAgB,CAAC,MAAM;AAC1B,UAAI,OAAO,MAAM;AACf,YAAI,KAAK,MAAM,IAAI,CAAC;AACtB,UAAI,EAAE;AACJ,aAAK,MAAM,IAAI,EAAE,KAAK,CAAC;AACzB,UAAI;AACF,eAAO,KAAK,MAAM,iBAAiB,KAAK,KAAK,CAAC,QAAQ;AACpD,cAAI,MAAM,QAAQ,GAAG;AACnB,cAAE,IAAI,GAAG,GAAG;AAAA;AAEZ,cAAE,IAAI,GAAG;AAAA,QACb,CAAC;AAAA,IACL;AACA,SAAK,QAAQ,CAAC,IAAI,MAAM,gBAAgB,MAAM,eAAe,CAAC,MAAM;AAClE,UAAI,YAAY,IAAI,UAAU;AAC9B,UAAI,OAAO,MAAM;AACf,YAAI,KAAK,MAAM,IAAI,CAAC;AACtB,UAAI,aAAa,WAAW;AAC1B,qBAAa,KAAK,EAAE,GAAG;AACvB,YAAI,cAAc;AAAA,UAChB,KAAK,EAAE;AAAA,UACP,UAAU,EAAE,SAAS,SAAS;AAAA,QAChC;AACA,YAAI,EAAE;AACJ,sBAAY,SAAS,EAAE,OAAO;AAChC,YAAI,OAAO,EAAE,aAAa,UAAU;AAClC,qBAAW,OAAO,EAAE,UAAU;AAC5B,gBAAI,OAAO,EAAE,SAAS,SAAS;AAC7B,qBAAO,EAAE,SAAS;AACpB,gBAAI,aAAa,SAAS,EAAE,SAAS,KAAK,GAAG;AAC3C,qBAAO,EAAE,SAAS,KAAK;AAAA,qBAChB,CAAC,eAAe;AACvB,qBAAO,EAAE,SAAS,KAAK;AAAA,YACzB;AACE,qBAAO,EAAE,SAAS,KAAK,MAAM,EAAE,SAAS,MAAM,eAAe,YAAY;AAAA,UAC7E;AAAA,QACF;AACA,mBAAW,QAAQ,GAAG;AACpB,cAAI,SAAS,YAAY,SAAS;AAChC;AACF,cAAI,OAAO,UAAU,UAAU,aAAa;AAC1C,gBAAI,OAAO,EAAE,UAAU,YAAY;AACjC,0BAAY,QAAQ,EAAE,MAAM,SAAS;AAAA,YACvC,WAAW,OAAO,EAAE,UAAU,UAAU;AACtC,0BAAY,QAAQ,KAAK,0BAA0B,EAAE,KAAK;AAAA,YAC5D,OAAO;AACL,0BAAY,QAAQ,EAAE;AAAA,YACxB;AAAA,UACF;AAAA,QACF;AACA,eAAO,KAAK,UAAU,WAAW;AAAA,MACnC;AAAA,IACF;AACA,SAAK,cAAc,CAAC,UAAS;AAC3B,UAAI,SAAS,kBAAkB,KAAI;AACnC,UAAI;AACF,eAAO,KAAK,IAAI,MAAM;AAAA,IAC1B;AACA,SAAK,WAAW,CAAC,SAAS;AACxB,WAAK,MAAM,SAAS,IAAI;AAAA,IAC1B;AACA,SAAK,aAAa,CAAC,YAAY,SAAS;AACtC,WAAK,YAAY;AACjB,WAAK,MAAM,QAAQ,CAAC,MAAM;AACxB,YAAI;AACF,YAAE,YAAY;AAAA;AAEd,YAAE,YAAY;AAAA,MAClB,CAAC;AAAA,IACH;AACA,QAAI,OAAO,eAAe,YAAY;AACpC,mBAAa,EAAE,UAAU,WAAW;AAAA,IACtC;AACA,QAAI,OAAO,eAAe,UAAU;AAClC,UAAI,sBAAsB,aAAa,WAAW;AAChD,eAAO,OAAO,YAAY,WAAW,QAAQ;AAC/C,UAAI,sBAAsB,OAAO;AAC/B,YAAI,SAAS;AACb,qBAAa;AAAA,UACX;AAAA,UACA,UAAU,CAAC,UAAU;AACnB,gBAAI,OAAO,UAAU,UAAU;AAC7B,kBAAI,SAAS,CAAC;AACd,yBAAW,OAAO,OAAO;AACvB,oBAAI,OAAO,OAAO,SAAS,YAAY;AACrC,sBAAI,MAAM,QAAQ,MAAM,IAAI;AAC1B,2BAAO,OAAO,OAAO,KAAK,GAAG,MAAM,IAAI;AAAA;AAEvC,2BAAO,OAAO,OAAO,KAAK,MAAM,IAAI;AAAA,gBACxC,OAAO;AACL,yBAAO,OAAO,MAAM;AACpB,yBAAO,OAAO,OAAO;AAAA,gBACvB;AAAA,cACF;AACA,qBAAO;AAAA,YACT;AACA,mBAAO;AAAA,UACT;AAAA,QACF;AACA,YAAI,OAAO;AACT,qBAAW,WAAW,OAAO;AAC/B,YAAI,OAAO;AACT,qBAAW,WAAW,OAAO;AAC/B,YAAI,OAAO;AACT,qBAAW,UAAU,OAAO;AAC9B,YAAI,OAAO;AACT,qBAAW,WAAW,OAAO;AAC/B,YAAI,OAAO;AACT,qBAAW,SAAS,OAAO;AAC7B,YAAI,OAAO;AACT,qBAAW,YAAY,OAAO;AAChC,YAAI,OAAO;AACT,qBAAW,OAAO,OAAO;AAC3B,YAAI,OAAO;AACT,qBAAW,UAAU,OAAO;AAC9B,YAAI,OAAO;AACT,qBAAW,SAAS,OAAO;AAC7B,YAAI,OAAO;AACT,qBAAW,YAAY,OAAO;AAChC,YAAI,OAAO;AACT,qBAAW,QAAQ,OAAO;AAC5B,YAAI,OAAO;AACT,qBAAW,WAAW,OAAO;AAC/B,YAAI,OAAO,MAAM;AACf,cAAI,OAAO,KAAK;AACd,mBAAO,OAAO,YAAY,OAAO,KAAK,QAAQ;AAAA,QAClD;AACA,YAAI,OAAO;AACT,iBAAO,OAAO,YAAY,OAAO,QAAQ;AAC3C,YAAI,OAAO;AACT,qBAAW,MAAM,OAAO;AAC1B,aAAK,QAAQ,OAAO;AACpB,eAAO,OAAO;AACd,YAAI,OAAO;AACT,iBAAO,MAAM,QAAQ,CAAC,MAAM;AAC1B,gBAAI,CAAC,MAAM,MAAM,IAAI,EAAE,GAAG,GAAG;AAC3B,oBAAM,MAAM,IAAI,EAAE,KAAK,CAAC;AACxB,oBAAM;AAAA,YACR;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AACA,UAAI,OAAO,WAAW,UAAU;AAC9B,YAAI;AACF,mBAAS,MAAM,MAAM,IAAI,MAAM;AAAA;AAE/B,mBAAS;AAAA,MACb;AACA,UAAI,WAAW,OAAQ,UAAS,SAAS;AACvC,YAAI;AACJ,YAAI,OAAO,OAAO;AAChB,oBAAU,MAAM,MAAM,IAAI,WAAW,GAAG;AAAA,QAC1C;AACA,YAAI,CAAC,WAAW,QAAQ,OAAO;AAC7B,oBAAU,OAAO,MAAM,IAAI,WAAW,GAAG;AAAA,QAC3C;AACA,YAAI,SAAS;AACX,cAAI,KAAK,UAAU;AACjB,iBAAK,cAAc,OAAO;AAAA,UAC5B;AACA,cAAI,CAAC,KAAK;AACR,iBAAK,SAAS;AAChB,cAAI,QAAQ,QAAQ,SAAS;AAC7B,iBAAO,MAAM;AACb,iBAAO,MAAM;AACb,mBAAS,KAAK;AACZ,uBAAW,KAAK,MAAM;AAAA,QAC1B;AAAA,MACF;AACA,UAAI,YAAY,UAAU;AACxB,mBAAW,WAAW,KAAK,YAAY,WAAW,QAAQ;AAAA,MAC5D;AACA,UAAI,CAAC,WAAW,OAAO,OAAO;AAC5B,mBAAW,MAAM,OAAO,MAAM;AAAA,MAChC,WAAW,CAAC,WAAW,KAAK;AAC1B,mBAAW,MAAM,OAAO,KAAK,MAAM,KAAK,OAAO,IAAI,IAAI;AAAA,MACzD;AACA,UAAI,OAAO,OAAO,oBAAoB,IAAI;AAC1C,iBAAW,OAAO,YAAY;AAC5B,YAAI,CAAC,KAAK,SAAS,GAAG;AACpB,eAAK,SAAS,OAAO,WAAW;AAAA,MACpC;AACA,UAAI,WAAW;AACb,aAAK,SAAS,WAAW,OAAO,OAAO,CAAC,GAAG,WAAW,QAAQ;AAChE,UAAI,WAAW,KAAK;AAClB,gBAAQ,IAAI,gBAAgB,YAAY,MAAM,IAAI;AAAA,MACpD;AACA,aAAO,OAAO,MAAM,UAAU;AAC9B,UAAI,CAAC,KAAK,KAAK;AACb,YAAI,OAAO;AACT,eAAK,MAAM,OAAO,MAAM;AAAA,QAC1B,OAAO;AACL,eAAK,MAAM,OAAO,KAAK,MAAM,KAAK,OAAO,IAAI,IAAI;AAAA,QACnD;AAAA,MACF;AACA,UAAI,OAAO;AACT,aAAK,QAAQ;AACb,YAAI,MAAM,MAAM,IAAI,KAAK,GAAG,GAAG;AAC7B,eAAK,MAAM,GAAG,KAAK,MAAM,MAAM,SAAS;AAAA,QAC1C;AACA,cAAM,MAAM,IAAI,KAAK,KAAK,IAAI;AAC9B,cAAM;AACN,aAAK,QAAQ,MAAM;AAAA,MACrB;AACA,UAAI,KAAK,UAAU;AACjB,sBAAc,UAAU;AACxB,YAAI,OAAO,KAAK,aAAa,YAAY;AACvC,eAAK,MAAM,iBAAiB,KAAK,SAAS,KAAK,QAAQ;AAAA,QACzD;AAAA,MACF;AACA,UAAI,OAAO,WAAW,UAAU;AAC9B,aAAK,SAAS;AACd,YAAI,kBAAkB,aAAa,kBAAkB;AACnD,iBAAO,MAAM,IAAI,KAAK,KAAK,IAAI;AAAA,MACnC;AACA,UAAI,OAAO,WAAW,SAAS,UAAU;AACvC,mBAAW,OAAO,WAAW,MAAM;AACjC,cAAI,OAAO,WAAW,KAAK,SAAS,UAAU;AAC5C,gBAAK,EAAC,WAAW,KAAK,MAAM,KAAK;AAC/B,yBAAW,KAAK,KAAK,MAAM;AAAA,YAC7B;AAAA,UACF;AACA,cAAI,OAAO,IAAI,UAAU,WAAW,KAAK,MAAM,MAAM,KAAK;AAC1D,eAAK,MAAM,IAAI,KAAK,KAAK,IAAI;AAAA,QAC/B;AAAA,MACF;AACA,UAAI,KAAK;AACP,aAAK,uBAAuB,IAAI;AAClC,UAAI,KAAK,kBAAkB,aAAa,KAAK,kBAAkB;AAC7D,aAAK,0BAA0B,KAAK,QAAQ,IAAI;AAClD,UAAI,OAAO,KAAK,aAAa;AAC3B,aAAK,SAAS,IAAI;AACpB,UAAI,CAAC,KAAK;AACR,aAAK,WAAW;AAClB,UAAI,KAAK,aAAa,CAAC,KAAK;AAC1B,aAAK,UAAU;AAAA,IACnB;AACE,aAAO;AAAA,EACX;AACF;AACA,IAAI,QAAQ,MAAM;AAAA,EAChB,YAAY,MAAM,KAAK,OAAO;AAC5B,SAAK,SAAS;AACd,SAAK,QAAwB,oBAAI,IAAI;AACrC,SAAK,QAAQ,IAAI,aAAa;AAC9B,SAAK,UAAU,GAAG,KAAK,OAAO;AAC9B,SAAK,OAAO,CAAC;AACb,SAAK,gBAAgB;AACrB,SAAK,MAAM,CAAC,IAAI,CAAC,MAAM;AACrB,UAAI,GAAG,gBAAgB;AACrB,YAAI,EAAE;AACR,UAAI,SAAQ;AACZ,UAAI,CAAE,cAAa;AACjB,YAAI,IAAI,UAAU,QAAO,QAAQ,QAAO,MAAM,IAAI;AAAA,WAC/C;AACH,aAAK,SAAS,KAAK,MAAM;AACzB,YAAI,EAAE,KAAK;AACT,eAAK,KAAK,EAAE,OAAO;AACnB,eAAK,MAAM,IAAI,EAAE,KAAK,CAAC;AAAA,QACzB;AAAA,MACF;AACA,aAAO;AAAA,IACT;AACA,SAAK,UAAU,CAAC,QAAO,KAAK,SAAS;AACnC,UAAI,CAAC;AACH;AACF,iBAAW,QAAQ,OAAM;AACvB,cAAM,IAAI,KAAK,MAAM,IAAI,IAAI;AAC7B,YAAI,CAAC,GAAG;AACN,cAAI,OAAO,MAAK,UAAU,YAAY;AACpC,iBAAK,IAAI,EAAE,KAAK,MAAM,UAAU,MAAK,MAAM,CAAC;AAAA,UAC9C,WAAW,OAAO,MAAK,UAAU,YAAY,CAAC,MAAM,QAAQ,MAAK,KAAK,GAAG;AACvE,gBAAI,CAAC,MAAK,MAAM;AACd,oBAAK,MAAM,MAAM;AACnB,gBAAI,UAAU,KAAK,IAAI,MAAK,KAAK;AACjC,gBAAI,MAAK,MAAM,SAAS;AACtB,oBAAK,MAAM,QAAQ,QAAQ,CAAC,MAAM;AAChC,qBAAK,MAAM,IAAI,GAAG,OAAO;AAAA,cAC3B,CAAC;AAAA,YACH;AAAA,UACF,OAAO;AACL,iBAAK,IAAI,EAAE,KAAK,MAAM,UAAU,IAAI,SAAS;AAC3C,qBAAO,MAAK;AAAA,YACd,EAAE,CAAC;AAAA,UACL;AAAA,QACF,OAAO;AACL,cAAI,OAAO,MAAK,UAAU,YAAY;AACpC,cAAE,YAAY,MAAK,KAAK;AAAA,UAC1B,WAAW,OAAO,MAAK,UAAU,UAAU;AACzC,gBAAI,MAAK,iBAAiB,WAAW;AACnC,mBAAK,IAAI,MAAK,KAAK;AAAA,YACrB,WAAW,MAAK,iBAAiB,OAAO;AACtC,kBAAI,SAAS,MAAK;AAClB,kBAAI,aAAa,CAAC;AAClB,kBAAI,OAAO;AACT,2BAAW,WAAW,OAAO;AAC/B,kBAAI,OAAO;AACT,2BAAW,WAAW,OAAO;AAC/B,kBAAI,OAAO;AACT,2BAAW,UAAU,OAAO;AAC9B,kBAAI,OAAO;AACT,2BAAW,WAAW,OAAO;AAC/B,kBAAI,OAAO;AACT,2BAAW,SAAS,OAAO;AAC7B,kBAAI,OAAO;AACT,2BAAW,YAAY,OAAO;AAChC,kBAAI,OAAO;AACT,2BAAW,OAAO,OAAO;AAC3B,kBAAI,OAAO;AACT,2BAAW,UAAU,OAAO;AAC9B,kBAAI,OAAO;AACT,2BAAW,SAAS,OAAO;AAC7B,kBAAI,OAAO;AACT,2BAAW,YAAY,OAAO;AAChC,kBAAI,OAAO;AACT,2BAAW,QAAQ,OAAO;AAC5B,kBAAI,OAAO;AACT,2BAAW,MAAM,OAAO;AAC1B,kBAAI,OAAO;AACT,2BAAW,WAAW,OAAO;AAC/B,kBAAI,OAAO,MAAM;AACf,uBAAO,OAAO,YAAY,OAAO,KAAK,QAAQ;AAChD,yBAAW,QAAQ,OAAO;AAC1B,yBAAW,SAAS;AACpB,gBAAE,SAAS,UAAU;AAAA,YACvB,OAAO;AACL,gBAAE,SAAS,MAAK,KAAK;AAAA,YACvB;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,WAAK,MAAM,QAAQ,CAAC,SAAS;AAC3B,YAAI,OAAO,KAAK,aAAa,UAAU;AACrC,qBAAW,OAAO,KAAK,UAAU;AAC/B,gBAAI,OAAO,KAAK,SAAS,SAAS,UAAU;AAC1C,kBAAI,KAAK,MAAM,IAAI,KAAK,SAAS,IAAI,GAAG;AACtC,qBAAK,SAAS,OAAO,KAAK,MAAM,IAAI,KAAK,SAAS,IAAI;AAAA,cACxD;AAAA,YACF,WAAW,KAAK,SAAS,SAAS,QAAQ,OAAO,KAAK,SAAS,SAAS,aAAa;AACnF,kBAAI,KAAK,MAAM,IAAI,GAAG,GAAG;AACvB,qBAAK,SAAS,OAAO,KAAK,MAAM,IAAI,GAAG;AAAA,cACzC;AAAA,YACF;AACA,gBAAI,KAAK,SAAS,gBAAgB,WAAW;AAC3C,mBAAK,0BAA0B,MAAM,KAAK,SAAS,IAAI;AAAA,YACzD;AAAA,UACF;AAAA,QACF;AACA,YAAI,OAAO,KAAK,WAAW,UAAU;AACnC,cAAI,KAAK,MAAM,IAAI,KAAK,MAAM,GAAG;AAC/B,iBAAK,SAAS,KAAK,MAAM,IAAI,KAAK,MAAM;AACxC,iBAAK,MAAM,IAAI,KAAK,OAAO,KAAK,KAAK,MAAM;AAAA,UAC7C;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AACA,SAAK,MAAM,CAAC,SAAQ;AAClB,aAAO,KAAK,MAAM,IAAI,IAAG;AAAA,IAC3B;AACA,SAAK,MAAM,CAAC,MAAM;AAChB,aAAO,KAAK,MAAM,IAAI,EAAE,KAAK,CAAC;AAAA,IAChC;AACA,SAAK,MAAM,CAAC,MAAM,SAAS;AACzB,UAAI,OAAO,MAAM;AACf,YAAI,KAAK,MAAM,IAAI,CAAC;AACtB,UAAI,GAAG;AACL,eAAO,EAAE,IAAI,GAAG,IAAI;AAAA;AAEpB,eAAO;AAAA,IACX;AACA,SAAK,WAAW,CAAC,MAAM,SAAS;AAC9B,UAAI,OAAO,MAAM;AACf,YAAI,KAAK,MAAM,IAAI,CAAC;AACtB,UAAI,GAAG;AACL,eAAO,IAAI,QAAQ,CAAC,KAAK,QAAQ;AAC/B,cAAI,EAAE,IAAI,GAAG,IAAI,CAAC;AAAA,QACpB,CAAC;AAAA;AAED,eAAO,IAAI,QAAQ,CAAC,KAAK,QAAQ;AAC/B,cAAI,MAAM;AAAA,QACZ,CAAC;AAAA,IACL;AACA,SAAK,aAAa,CAAC,GAAG,YAAY;AAChC,UAAI,OAAO,MAAM;AACf,YAAI,KAAK,MAAM,IAAI,CAAC;AACtB,UAAI,GAAG,OAAO;AACZ,YAAI,CAAC;AACH,oBAAU,CAAC;AACb,cAAM,oBAAoB,CAAC,SAAS;AAClC,cAAI,KAAK,YAAY,CAAC,QAAQ,KAAK,MAAM;AACvC,oBAAQ,KAAK,OAAO;AACpB,gBAAI,MAAM,QAAQ,KAAK,QAAQ,GAAG;AAChC,mBAAK,SAAS,QAAQ,CAAC,MAAM;AAC3B,oBAAI,EAAE;AACJ,oBAAE,SAAS;AACb,oBAAI,EAAE,KAAK;AACT,sBAAI,KAAK,MAAM,IAAI,EAAE,GAAG;AACtB,yBAAK,MAAM,OAAO,EAAE,GAAG;AAAA,gBAC3B;AACA,qBAAK,MAAM,QAAQ,CAAC,OAAO;AACzB,sBAAI,GAAG,MAAM,IAAI,EAAE,GAAG;AACpB,uBAAG,MAAM,OAAO,EAAE,GAAG;AAAA,gBACzB,CAAC;AACD,kCAAkB,CAAC;AAAA,cACrB,CAAC;AAAA,YACH,WAAW,OAAO,KAAK,aAAa,UAAU;AAC5C,kBAAI,KAAK;AACP,qBAAK,SAAS;AAChB,kBAAI,KAAK,KAAK;AACZ,oBAAI,KAAK,MAAM,IAAI,KAAK,GAAG;AACzB,uBAAK,MAAM,OAAO,KAAK,GAAG;AAAA,cAC9B;AACA,mBAAK,MAAM,QAAQ,CAAC,OAAO;AACzB,oBAAI,GAAG,MAAM,IAAI,KAAK,GAAG;AACvB,qBAAG,MAAM,OAAO,KAAK,GAAG;AAAA,cAC5B,CAAC;AACD,gCAAkB,IAAI;AAAA,YACxB;AAAA,UACF;AAAA,QACF;AACA,YAAI,EAAE;AACJ,YAAE,SAAS;AACb,YAAI,EAAE,KAAK;AACT,eAAK,MAAM,OAAO,EAAE,GAAG;AACvB,eAAK,MAAM,QAAQ,CAAC,OAAO;AACzB,gBAAI,GAAG,MAAM,IAAI,GAAG,GAAG;AACrB,iBAAG,MAAM,OAAO,GAAG,GAAG;AAAA,UAC1B,CAAC;AACD,eAAK,SAAS,KAAK,MAAM;AACzB,4BAAkB,CAAC;AAAA,QACrB;AACA,YAAI,EAAE;AACJ,YAAE,SAAS,CAAC;AAAA,MAChB;AACA,aAAO;AAAA,IACT;AACA,SAAK,SAAS,CAAC,MAAM;AACnB,UAAI,OAAO,MAAM;AACf,YAAI,KAAK,MAAM,IAAI,CAAC;AACtB,UAAI,GAAG,OAAO;AACZ,YAAI,EAAE;AACJ,YAAE,SAAS;AACb,YAAI,GAAG,KAAK;AACV,cAAI,KAAK,MAAM,IAAI,EAAE,GAAG,GAAG;AACzB,iBAAK,MAAM,OAAO,EAAE,GAAG;AACvB,iBAAK,MAAM,QAAQ,CAAC,OAAO;AACzB,kBAAI,GAAG,MAAM,IAAI,GAAG,GAAG;AACrB,mBAAG,MAAM,OAAO,GAAG,GAAG;AAAA,YAC1B,CAAC;AAAA,UACH;AAAA,QACF;AACA,YAAI,EAAE;AACJ,YAAE,SAAS,CAAC;AAAA,MAChB;AACA,aAAO;AAAA,IACT;AACA,SAAK,SAAS,CAAC,GAAG,eAAe;AAC/B,iBAAW,YAAY,CAAC;AAAA,IAC1B;AACA,SAAK,aAAa,OAAO,MAAM,SAAS;AACtC,UAAI,GAAG,QAAQ;AACb,eAAO,MAAM,EAAE,WAAW,GAAG,IAAI;AAAA,MACnC;AAAA,IACF;AACA,SAAK,eAAe,OAAO,MAAM,SAAS;AACxC,UAAI,GAAG,UAAU;AACf,eAAO,MAAM,EAAE,aAAa,GAAG,IAAI;AAAA,MACrC;AAAA,IACF;AACA,SAAK,YAAY,CAAC,GAAG,aAAa;AAChC,UAAI,CAAC;AACH;AACF,UAAI,GAAG,aAAa,OAAO,aAAa,YAAY;AAClD,eAAO,EAAE,UAAU,QAAQ;AAAA,MAC7B,WAAW,oBAAoB,aAAa,OAAO,aAAa;AAC9D,eAAO,KAAK,cAAc,GAAG,QAAQ;AAAA,eAC9B,OAAO,KAAK,UAAU;AAC7B,eAAO,KAAK,MAAM,iBAAiB,GAAG,QAAQ;AAAA,MAChD;AAAA,IACF;AACA,SAAK,cAAc,CAAC,MAAK,QAAQ;AAC/B,aAAO,KAAK,MAAM,mBAAmB,MAAK,GAAG;AAAA,IAC/C;AACA,SAAK,iBAAiB,CAAC,aAAa;AAClC,UAAI,CAAC,KAAK,UAAU;AAClB,eAAO;AAAA,MACT,OAAO;AACL,YAAI,OAAO,aAAa,UAAU;AAChC,cAAI,KAAK;AACP,uBAAW,KAAK,MAAM,IAAI,QAAQ;AAAA;AAElC,uBAAW,KAAK,MAAM,IAAI,QAAQ;AAAA,QACtC;AACA,YAAI,OAAO,aAAa,YAAY;AAClC,iBAAO,KAAK,MAAM,iBAAiB,KAAK,SAAS,QAAQ;AAAA,QAC3D,WAAW;AACT,iBAAO,KAAK,MAAM,iBAAiB,KAAK,SAAS,CAAC,WAAW;AAC3D,qBAAS,IAAI,MAAM;AAAA,UACrB,CAAC;AAAA,MACL;AAAA,IACF;AACA,SAAK,gBAAgB,CAAC,WAAW,eAAe;AAC9C,UAAI;AACJ,UAAI,WAAW;AACb,eAAM,UAAU;AAAA,eACT,OAAO,cAAc;AAC5B,eAAM;AACR,UAAI,OAAO,eAAe;AACxB,qBAAa,KAAK,MAAM,IAAI,UAAU;AACxC,UAAI,aAAa,YAAY;AAC3B,YAAI,MAAM,KAAK,MAAM,iBAAiB,MAAK,CAAC,QAAQ;AAClD,cAAI,MAAM,QAAQ,GAAG;AACnB,uBAAW,IAAI,GAAG,GAAG;AAAA;AAErB,uBAAW,IAAI,GAAG;AAAA,QACtB,CAAC;AACD,eAAO;AAAA,MACT;AAAA,IACF;AACA,SAAK,WAAW,CAAC,MAAM;AACrB,UAAI,OAAO,MAAM,UAAU;AACzB,YAAI,KAAK,MAAM,IAAI,CAAC;AAAA,MACtB;AACA,UAAI,GAAG,UAAU;AACf,UAAE,SAAS;AAAA,MACb;AAAA,IACF;AACA,SAAK,QAAQ,CAAC,GAAG,gBAAgB,SAAS;AACxC,UAAI,GAAG;AACL,eAAO,EAAE,MAAM,GAAG,aAAa;AAAA,WAC5B;AACH,YAAI,UAAU;AACd,aAAK,MAAM,QAAQ,CAAC,OAAO;AACzB,qBAAW;AAAA,GAClB,GAAG,OAAO,GAAG,MAAM,IAAI,aAAa;AAAA,QAC/B,CAAC;AACD,eAAO;AAAA,MACT;AAAA,IACF;AACA,SAAK,cAAc,CAAC,UAAS;AAC3B,UAAI,SAAS,kBAAkB,KAAI;AACnC,UAAI;AACF,eAAO,KAAK,IAAI,MAAM;AAAA,IAC1B;AACA,SAAK,SAAS,CAAC,UAAU,YAAY,WAAU;AAC7C,aAAO,WAAW,UAAU,YAAY,QAAO,IAAI;AAAA,IACrD;AACA,SAAK,WAAW,CAAC,SAAS;AACxB,WAAK,MAAM,SAAS,IAAI;AAAA,IAC1B;AACA,SAAK,aAAa,CAAC,YAAY,SAAS;AACtC,WAAK,MAAM,QAAQ,CAAC,MAAM;AACxB,YAAI;AACF,YAAE,YAAY;AAAA;AAEd,YAAE,YAAY;AAAA,MAClB,CAAC;AAAA,IACH;AACA,SAAK,MAAM,MAAM,MAAM,QAAQ,KAAK,MAAM,KAAK,OAAO,IAAI,IAAI;AAC9D,QAAI,OAAO;AACT,UAAI,MAAM,UAAU;AAClB,aAAK,cAAc,KAAK;AAAA,MAC1B;AACE,eAAO,OAAO,MAAM,KAAK;AAC3B,WAAK,WAAW;AAAA,IAClB;AACA,QAAI,QAAQ,OAAO,KAAK,KAAK,IAAI,EAAE,SAAS;AAC1C,WAAK,QAAQ,IAAI;AAAA,EACrB;AACF;AACA,2BAA2B,QAAO,MAAM;AACtC,MAAI;AACF,QAAI,SAAS,OAAO,UAAS,WAAW,KAAK,MAAM,KAAI,IAAI;AAC3D,UAAM,WAAW,CAAC,QAAQ;AACxB,iBAAW,QAAQ,KAAK;AACtB,YAAI,OAAO,IAAI,UAAU,UAAU;AACjC,cAAI,aAAa,sBAAsB,IAAI,KAAK;AAChD,cAAI,OAAO,eAAe,YAAY;AACpC,gBAAI,QAAQ;AAAA,UACd;AAAA,QACF,WAAW,OAAO,IAAI,UAAU,UAAU;AACxC,mBAAS,IAAI,KAAK;AAAA,QACpB;AAAA,MACF;AACA,aAAO;AAAA,IACT;AACA,WAAO,SAAS,MAAM;AAAA,EACxB,SAAS,KAAP;AACA,YAAQ,MAAM,GAAG;AACjB,WAAO;AAAA,EACT;AACF;AACA,IAAI,4BAA4B,WAAW;AACzC,QAAM,OAAuB,oBAAI,IAAI;AACrC,QAAM,UAAU,CAAC;AACjB,QAAM,OAAO,CAAC,MAAM;AACpB,mBAAiB;AACf,SAAK,MAAM;AACX,YAAQ,SAAS;AACjB,SAAK,SAAS;AAAA,EAChB;AACA,yBAAuB,KAAK,OAAO;AACjC,QAAI,MAAM,QAAQ,SAAS;AAC3B,QAAI,OAAO,QAAQ;AACnB,QAAI,OAAO,SAAS,UAAU;AAC5B,UAAI,KAAK,SAAS,SAAS,QAAQ,GAAG;AACpC,aAAK,KAAK,GAAG;AACb,gBAAQ,KAAK,MAAM,MAAM;AAAA,MAC3B,OAAO;AACL,eAAO,SAAS,GAAG;AACjB,iBAAO,QAAQ;AACf,cAAI,OAAO,SAAS,UAAU;AAC5B,gBAAI,KAAK,SAAS,OAAO;AACvB,qBAAO;AACP,sBAAQ,SAAS;AACjB,mBAAK,SAAS;AACd,gBAAE;AACF,sBAAQ,OAAO;AACf,mBAAK,OAAO;AACZ;AAAA,YACF;AAAA,UACF;AACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,yBAAuB,KAAK,OAAO;AACjC,QAAI,SAAS,MAAM;AACjB,UAAI,OAAO,UAAU,UAAU;AAC7B,YAAI,KAAK;AACP,wBAAc,KAAK,KAAK;AAAA,QAC1B;AACA,YAAI,QAAQ,KAAK,IAAI,KAAK;AAC1B,YAAI,OAAO;AACT,iBAAO,yBAAyB;AAAA,QAClC,OAAO;AACL,eAAK,IAAI,OAAO,KAAK,KAAK,GAAG,CAAC;AAAA,QAChC;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACA,SAAO,oCAAoC,KAAK,OAAO;AACrD,QAAI;AACF,cAAQ,KAAK,GAAG;AAChB,aAAO,KAAK,UAAU,KAAK,eAAe,KAAK;AAAA,IACjD,UAAE;AACA,YAAM;AAAA,IACR;AAAA,EACF;AACF,EAAE;AACF,IAAI,KAAK,8BAA8B,QAAQ;AAC7C,OAAK,4BAA4B;AACnC;AACA,IAAI,gBAAgB,WAAW;AAC7B,QAAM,OAAuB,oBAAI,IAAI;AACrC,QAAM,UAAU,CAAC;AACjB,QAAM,OAAO,CAAC,MAAM;AACpB,mBAAiB;AACf,SAAK,MAAM;AACX,YAAQ,SAAS;AACjB,SAAK,SAAS;AAAA,EAChB;AACA,yBAAuB,KAAK,OAAO;AACjC,QAAI,MAAM,QAAQ,SAAS;AAC3B,QAAI,QAAQ,MAAM;AAChB,UAAI,OAAO,QAAQ;AACnB,UAAI,OAAO,SAAS,UAAU;AAC5B,YAAI,KAAK,SAAS,SAAS,QAAQ,GAAG;AACpC,eAAK,KAAK,GAAG;AACb,kBAAQ,KAAK,MAAM,MAAM;AAAA,QAC3B,OAAO;AACL,iBAAO,SAAS,GAAG;AACjB,mBAAO,QAAQ;AACf,gBAAI,OAAO,SAAS,UAAU;AAC5B,kBAAI,KAAK,SAAS,OAAO;AACvB,uBAAO;AACP,wBAAQ,SAAS;AACjB,qBAAK,SAAS;AACd,kBAAE;AACF,wBAAQ,OAAO;AACf,qBAAK,OAAO;AACZ;AAAA,cACF;AAAA,YACF;AACA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,uBAAqB,KAAK,OAAO;AAC/B,QAAI;AACJ,QAAI,SAAS,MAAM;AACjB,UAAI,OAAO,UAAU,UAAU;AAC7B,YAAI,IAAI,MAAM,YAAY;AAC1B,YAAI,OAAO,MAAM,UAAU;AACzB,wBAAc,KAAK,KAAK;AAAA,QAC1B;AACA,YAAI,QAAQ,KAAK,IAAI,KAAK;AAC1B,YAAI,OAAO;AACT,iBAAO,yBAAyB;AAAA,QAClC,OAAO;AACL,eAAK,IAAI,OAAO,KAAK,KAAK,GAAG,CAAC;AAAA,QAChC;AACA,YAAI,MAAM,SAAS;AACjB,cAAI,MAAM,SAAS,IAAI;AACrB,kBAAM,MAAM,MAAM,MAAM,SAAS,EAAE;AAAA,UACrC;AACE,kBAAM;AAAA,QACV,WAAW,EAAE,SAAS,KAAK,GAAG;AAC5B,gBAAM,MAAM,KAAK,KAAK;AAAA,QACxB,WAAW,MAAM,YAAY,MAAM,YAAY,MAAM,YAAY,MAAM,WAAW;AAChF,gBAAM,gBAAgB;AAAA,QACxB,WAAW,MAAM,UAAU;AACzB,cAAI,MAAM,CAAC;AACX,qBAAW,QAAQ,OAAO;AACxB,gBAAI,MAAM,SAAS,MAAM;AACvB,kBAAI,QAAQ,MAAM;AAAA,YACpB,WAAW,MAAM,QAAQ,MAAM,KAAK,GAAG;AACrC,kBAAI,MAAM,MAAM,SAAS;AACvB,oBAAI,QAAQ,MAAM,MAAM,MAAM,MAAM,MAAM,SAAS,EAAE;AAAA;AAErD,oBAAI,QAAQ,MAAM;AAAA,YACtB,WAAW,MAAM,MAAM,YAAY,SAAS,UAAU;AACpD,kBAAI,QAAQ,CAAC;AACb,yBAAW,KAAK,MAAM,OAAO;AAC3B,oBAAI,MAAM,QAAQ,MAAM,MAAM,EAAE,GAAG;AACjC,sBAAI,MAAM,MAAM,GAAG,SAAS;AAC1B,wBAAI,MAAM,KAAK,MAAM,MAAM,GAAG,MAAM,MAAM,MAAM,GAAG,SAAS,EAAE;AAAA;AAE9D,wBAAI,MAAM,KAAK,MAAM,MAAM;AAAA,gBAC/B,OAAO;AACL,sBAAI,MAAM,MAAM,MAAM,MAAM;AAC1B,wBAAI,MAAM,MAAM,MAAM,GAAG,YAAY;AACrC,wBAAI,IAAI,SAAS,KAAK,GAAG;AACvB,0BAAI,MAAM,KAAK,MAAM,KAAK,MAAM,MAAM,EAAE;AAAA,oBAC1C,WAAW,QAAQ,YAAY,QAAQ,YAAY,QAAQ,WAAW;AACpE,0BAAI,MAAM,KAAK,gBAAgB;AAAA,oBACjC,OAAO;AACL,0BAAI,MAAM,KAAK,MAAM,MAAM;AAAA,oBAC7B;AAAA,kBACF,OAAO;AACL,wBAAI,MAAM,KAAK,MAAM,MAAM;AAAA,kBAC7B;AAAA,gBACF;AAAA,cACF;AAAA,YACF,OAAO;AACL,kBAAI,MAAM,MAAM,MAAM,YAAY;AAClC,kBAAI,IAAI,SAAS,KAAK,GAAG;AACvB,oBAAI,QAAQ,MAAM,KAAK,MAAM,KAAK;AAAA,cACpC,WAAW,QAAQ,YAAY,QAAQ,YAAY,QAAQ,WAAW;AACpE,oBAAI,QAAQ,gBAAgB;AAAA,cAC9B,OAAO;AACL,oBAAI,QAAQ,MAAM;AAAA,cACpB;AAAA,YACF;AAAA,UACF;AACA,gBAAM;AAAA,QACR,OAAO;AACL,gBAAM;AAAA,QACR;AAAA,MACF,OAAO;AACL,cAAM;AAAA,MACR;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACA,SAAO,wBAAwB,KAAK,OAAO;AACzC,YAAQ,KAAK,GAAG;AAChB,QAAI,MAAM,KAAK,UAAU,KAAK,aAAa,KAAK;AAChD,UAAM;AACN,WAAO;AAAA,EACT;AACF,EAAE;AACF,IAAI,KAAK,kBAAkB,QAAQ;AACjC,OAAK,gBAAgB;AACvB;AACA,oBAAoB,UAAU,YAAY,OAAO,OAAO;AACtD,MAAI,OAAO,UAAU,UAAU;AAC7B,UAAM,WAAW;AACjB,WAAO,IAAI,UAAU,OAAO,YAAY,KAAK;AAAA,EAC/C;AACA,SAAO,IAAI,UAAU,EAAE,SAAS,GAAG,YAAY,KAAK;AACtD;AAGA,IAAI,aAAa,cAAc,YAAY;AAAA,EACzC,WAAW,SAAS,QAAQ,MAAM,OAAO;AACvC,WAAO,gCAAgC,KAAK,UAAU,KAAK;AAAA,EAC7D;AAAA,EACA,QAAQ,CAAC;AAAA,EACT,YAAY;AAAA,EACZ;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,kBAAkB;AAAA,EAClB;AAAA,EACA;AAAA,EACA,iBAAiB;AAAA,EACjB,gBAAgB,CAAC,SAAS,WAAW,aAAa,YAAY,YAAY,YAAY,UAAU;AAAA,EAChG,IAAI,qBAAqB;AACvB,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,gBAAgB;AAClB,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,cAAc,KAAK;AACrB,QAAI,OAAO,QAAQ,UAAU;AAC3B,WAAK,cAAc,KAAK,GAAG;AAAA,IAC7B,WAAW,MAAM,QAAQ,GAAG;AAC1B,WAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,WAAW,MAAM;AACf,WAAO,KAAK,KAAK,YAAY,IAAI;AAAA,EACnC;AAAA,EACA,OAAO,WAAW,MAAM,KAAK,KAAK,MAAM,MAAM,SAAS,QAAQ;AAC7D,qBAAiB,KAAK,KAAK,MAAM;AAAA,EACnC;AAAA,EACA,2BAA2B,CAAC,OAAM,KAAK,QAAQ;AAC7C,QAAI,UAAS,aAAa;AACxB,UAAI,YAAY;AAChB,UAAI,OAAO,cAAc;AACvB,oBAAY,uBAAuB,SAAS;AAC9C,UAAI,OAAO,cAAc,YAAY;AACnC,aAAK,YAAY;AACjB,aAAK,MAAM,KAAK,QAAQ,KAAK;AAC7B,aAAK,MAAM,mBAAmB,OAAO;AACrC,aAAK,MAAM,iBAAiB,SAAS,KAAK,SAAS;AACnD,YAAI,UAAU,IAAI,YAAY,WAAW,EAAE,QAAQ,EAAE,OAAO,KAAK,OAAO,MAAM,KAAK,EAAE,CAAC;AACtF,aAAK,MAAM,iBAAiB,SAAS,MAAM;AACzC,eAAK,cAAc,OAAO;AAAA,QAC5B,CAAC;AAAA,MACH;AAAA,IACF,WAAW,UAAS,YAAY;AAC9B,UAAI,WAAW;AACf,UAAI,OAAO,aAAa;AACtB,mBAAW,uBAAuB,QAAQ;AAC5C,UAAI,OAAO,aAAa,YAAY;AAClC,YAAI,KAAK,UAAU;AACjB,cAAI;AACF,mBAAO,oBAAoB,UAAU,KAAK,QAAQ;AAAA,UACpD,SAAS,KAAP;AAAA,UACF;AAAA,QACF;AACA,aAAK,WAAW,CAAC,OAAO;AACtB,eAAK,SAAS,KAAK,OAAO,IAAI;AAAA,QAChC;AACA,aAAK,WAAW;AAChB,eAAO,iBAAiB,UAAU,KAAK,QAAQ;AAAA,MACjD;AAAA,IACF,WAAW,UAAS,YAAY;AAC9B,UAAI,WAAW;AACf,UAAI,OAAO,aAAa;AACtB,mBAAW,uBAAuB,QAAQ;AAC5C,UAAI,OAAO,aAAa,YAAY;AAClC,aAAK,WAAW,MAAM;AACpB,cAAI,KAAK;AACP,mBAAO,oBAAoB,UAAU,KAAK,QAAQ;AACpD,eAAK,MAAM,mBAAmB,OAAO;AACrC,cAAI;AACF,qBAAS,KAAK,OAAO,IAAI;AAAA,QAC7B;AAAA,MACF;AAAA,IACF,WAAW,UAAS,YAAY;AAC9B,UAAI,WAAW;AACf,UAAI,OAAO,aAAa;AACtB,mBAAW,uBAAuB,QAAQ;AAC5C,UAAI,OAAO,aAAa,YAAY;AAClC,aAAK,WAAW;AAAA,MAClB;AAAA,IACF,WAAW,UAAS,mBAAmB;AACrC,UAAI,MAAM;AACV,UAAI,OAAO,KAAK,oBAAoB;AAClC,aAAK,mBAAmB,KAAK,eAAe;AAC9C,UAAI,OAAO,QAAQ;AACjB,cAAM,uBAAuB,GAAG;AAClC,UAAI,OAAO,QAAQ,YAAY;AAC7B,aAAK,kBAAkB,KAAK,MAAM,iBAAiB,SAAS,CAAC,MAAM;AACjE,eAAK,OAAO,CAAC;AACb,cAAI,MAAM,CAAC;AAAA,QACb,CAAC;AAAA,MACH,WAAW,OAAO;AAChB,aAAK,kBAAkB,KAAK,MAAM,iBAAiB,SAAS,KAAK,MAAM;AAAA,IAC3E,WAAW,UAAS,SAAS;AAC3B,UAAI,WAAW;AACf,UAAI,OAAO,aAAa;AACtB,mBAAW,KAAK,MAAM,QAAQ;AAChC,aAAO,OAAO,KAAK,OAAO,QAAQ;AAClC,WAAK,MAAM,SAAS,EAAE,OAAO,KAAK,MAAM,CAAC;AAAA,IAC3C,WAAW,UAAS,YAAY;AAC9B,UAAI,WAAW;AACf,WAAK,WAAW;AAChB,WAAK,OAAO,KAAK,KAAK;AACtB,UAAI,UAAU,IAAI,YAAY,WAAW,EAAE,QAAQ,EAAE,OAAO,KAAK,MAAM,EAAE,CAAC;AAC1E,WAAK,cAAc,OAAO;AAAA,IAC5B,OAAO;AACL,UAAI,SAAS;AACb,UAAI,MAAK,SAAS,OAAO,GAAG;AAC1B,gBAAO,MAAK,MAAM,GAAG;AACrB,cAAK,MAAM;AACX,gBAAO,MAAK,KAAK;AACjB,iBAAS,uBAAuB,GAAG;AAAA,MACrC,WAAW,OAAO,QAAQ,UAAU;AAClC,YAAI;AACF,mBAAS,KAAK,MAAM,GAAG;AAAA,QACzB,SAAS,KAAP;AACA,mBAAS;AAAA,QACX;AAAA,MACF;AACA,WAAK,SAAQ;AACb,UAAI,UAAS,WAAW,KAAK;AAC3B,aAAK,MAAM,SAAQ;AAAA,IACvB;AAAA,EACF;AAAA,EACA,oBAAoB;AAClB,QAAI,CAAC,KAAK;AACR,WAAK,QAAQ,CAAC;AAChB,QAAI,WAAW,KAAK,aAAa,OAAO;AACxC,QAAI,OAAO,aAAa;AACtB,iBAAW,KAAK,MAAM,QAAQ;AAChC,WAAO,OAAO,KAAK,OAAO,QAAQ;AAClC,SAAK,MAAM,SAAS,EAAE,OAAO,KAAK,MAAM,CAAC;AACzC,UAAM,KAAK,KAAK,UAAU,EAAE,QAAQ,CAAC,QAAQ;AAC3C,UAAI,QAAO,IAAI;AACf,UAAI,SAAS,IAAI;AACjB,UAAI,MAAK,SAAS,OAAO,KAAK,MAAK,SAAS,IAAI,GAAG;AACjD,YAAI,MAAK,SAAS,OAAO;AACvB,kBAAO,MAAK,MAAM,GAAG;AAAA,iBACd,MAAK,SAAS,IAAI;AACzB,kBAAO,MAAK,UAAU,GAAG,MAAK,QAAQ,GAAG,CAAC;AAC5C,cAAK,MAAM;AACX,gBAAO,MAAK,KAAK;AACjB,iBAAS,uBAAuB,IAAI,KAAK;AAAA,MAC3C,WAAW,OAAO,IAAI,UAAU,UAAU;AACxC,YAAI;AACF,mBAAS,KAAK,MAAM,IAAI,KAAK;AAAA,QAC/B,SAAS,KAAP;AACA,mBAAS,IAAI;AAAA,QACf;AAAA,MACF;AACA,UAAI,CAAC,KAAK,QAAO;AACf,eAAO,iBAAiB,MAAM,KAAK;AAAA,UACjC,OAAO;AAAA,UACP,UAAU;AAAA,UACV,MAAM;AACJ,mBAAO,KAAK;AAAA,UACd;AAAA,UACA,IAAI,KAAK;AACP,iBAAK,aAAa,OAAM,GAAG;AAAA,UAC7B;AAAA,QACF,CAAC;AAAA,MACH;AACA,WAAK,SAAQ;AACb,UAAI,UAAS;AACX,aAAK,MAAM,SAAQ;AACrB,WAAK,cAAc,KAAK,KAAI;AAAA,IAC9B,CAAC;AACD,QAAI,cAAc,IAAI,YAAY,WAAW,EAAE,QAAQ,EAAE,OAAO,KAAK,OAAO,MAAM,KAAK,EAAE,CAAC;AAC1F,QAAI,UAAU,IAAI,YAAY,WAAW,EAAE,QAAQ,EAAE,OAAO,KAAK,OAAO,MAAM,KAAK,EAAE,CAAC;AACtF,QAAI,UAAU,IAAI,YAAY,WAAW,EAAE,QAAQ,EAAE,OAAO,KAAK,OAAO,MAAM,KAAK,EAAE,CAAC;AACtF,QAAI,UAAU,IAAI,YAAY,WAAW,EAAE,QAAQ,EAAE,OAAO,KAAK,OAAO,MAAM,KAAK,EAAE,CAAC;AACtF,SAAK,OAAO,KAAK,KAAK;AACtB,SAAK,cAAc,OAAO;AAC1B,SAAK,MAAM,iBAAiB,SAAS,MAAM;AACzC,WAAK,cAAc,OAAO;AAAA,IAC5B,CAAC;AACD,QAAI,OAAO,KAAK,aAAa,YAAY;AACvC,UAAI,KAAK,UAAU;AACjB,YAAI;AACF,iBAAO,oBAAoB,UAAU,KAAK,QAAQ;AAAA,QACpD,SAAS,KAAP;AAAA,QACF;AAAA,MACF;AACA,WAAK,WAAW,CAAC,OAAO;AACtB,aAAK,SAAS,MAAM,KAAK,KAAK;AAC9B,aAAK,cAAc,WAAW;AAAA,MAChC;AACA,aAAO,iBAAiB,UAAU,KAAK,QAAQ;AAAA,IACjD;AACA,QAAI,OAAO,KAAK,aAAa,YAAY;AACvC,UAAI,WAAW,KAAK;AACpB,WAAK,WAAW,CAAC,QAAQ,KAAK,UAAU;AACtC,YAAI,KAAK;AACP,iBAAO,oBAAoB,UAAU,KAAK,QAAQ;AACpD,aAAK,MAAM,mBAAmB,OAAO;AACrC,aAAK,cAAc,OAAO;AAC1B,iBAAS,MAAM,KAAK;AAAA,MACtB;AAAA,IACF;AACA,QAAI,OAAO,KAAK,cAAc,YAAY;AACxC,WAAK,MAAM,KAAK,QAAQ,KAAK;AAC7B,WAAK,MAAM,iBAAiB,SAAS,KAAK,SAAS;AAAA,IACrD;AACA,QAAI,KAAK,iBAAiB;AACxB,UAAI,MAAM,KAAK;AACf,UAAI,OAAO,KAAK,oBAAoB;AAClC,aAAK,mBAAmB,KAAK,eAAe;AAC9C,UAAI,OAAO,QAAQ;AACjB,cAAM,uBAAuB,GAAG;AAClC,UAAI,OAAO,QAAQ,YAAY;AAC7B,aAAK,kBAAkB,KAAK,MAAM,iBAAiB,SAAS,CAAC,MAAM;AACjE,eAAK,OAAO,CAAC;AACb,cAAI,MAAM,CAAC;AAAA,QACb,CAAC;AAAA,MACH,WAAW,QAAQ;AACjB,aAAK,kBAAkB,KAAK,MAAM,iBAAiB,SAAS,KAAK,MAAM;AAAA,IAC3E;AAAA,EACF;AAAA,EACA,cAAc;AACZ,UAAM;AAAA,EACR;AAAA,EACA,SAAS,MAAM;AACb,SAAK,OAAO;AACZ,QAAI,OAAO,KAAK,aAAa;AAC3B,WAAK,SAAS,KAAK,KAAK;AAAA,EAC5B;AAAA,EACA,SAAS,CAAC,QAAQ,KAAK,UAAU;AAC/B,QAAI,OAAO,KAAK,aAAa;AAC3B,WAAK,iBAAiB,KAAK,SAAS,MAAM,KAAK;AAAA;AAE/C,WAAK,iBAAiB,KAAK;AAC7B,QAAI,KAAK;AACP,WAAK,iBAAiB,UAAU,KAAK,iBAAiB,KAAK;AAC7D,UAAM,KAAI,SAAS,cAAc,UAAU;AAC3C,QAAI,OAAO,KAAK,mBAAmB;AACjC,SAAE,YAAY,KAAK;AAAA,aACZ,KAAK,0BAA0B,aAAa;AACnD,UAAI,KAAK,eAAe,YAAY;AAClC,aAAK,eAAe,WAAW,YAAY,KAAK,cAAc;AAAA,MAChE;AACA,SAAE,YAAY,KAAK,cAAc;AAAA,IACnC;AACA,UAAM,WAAW,GAAE;AACnB,QAAI,KAAK,UAAU;AACjB,UAAI,KAAK,WAAW;AAClB,YAAI,KAAK;AACP,eAAK,WAAW,YAAY,KAAK,KAAK;AACxC,aAAK,WAAW,YAAY,KAAK,QAAQ;AAAA,MAC3C;AACE,aAAK,YAAY,KAAK,QAAQ;AAAA,IAClC;AACA,QAAI,KAAK,WAAW;AAClB,UAAI,CAAC,KAAK,gBAAgB;AACxB,aAAK,aAAa,EAAE,MAAM,OAAO,CAAC,EAAE,YAAY;AAChD,aAAK,iBAAiB;AAAA,MACxB;AACA,UAAI,KAAK,QAAQ;AACf,YAAI,QAAQ,SAAS,cAAc,OAAO;AAC1C,cAAM,cAAc,KAAK;AACzB,aAAK,WAAW,QAAQ,KAAK;AAC7B,aAAK,QAAQ;AAAA,MACf;AACA,WAAK,WAAW,QAAQ,QAAQ;AAChC,WAAK,WAAW,KAAK,WAAW,WAAW;AAAA,IAC7C,OAAO;AACL,WAAK,QAAQ,QAAQ;AACrB,WAAK,WAAW,KAAK,WAAW;AAAA,IAClC;AACA,QAAI,WAAW,IAAI,YAAY,YAAY,EAAE,QAAQ,EAAE,OAAO,KAAK,OAAO,MAAM,KAAK,EAAE,CAAC;AACxF,SAAK,cAAc,QAAQ;AAC3B,QAAI,KAAK;AACP,WAAK,SAAS,MAAM,KAAK;AAAA,EAC7B;AAAA,EACA,QAAQ;AAAA,IACN,aAAa,CAAC;AAAA,IACd,MAAM,CAAC;AAAA,IACP,UAAU,CAAC;AAAA,IACX,SAAS,WAAW;AAClB,aAAO,OAAO,KAAK,aAAa,SAAS;AACzC,UAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,SAAS,GAAG;AACzC,mBAAW,QAAQ,OAAO,oBAAoB,KAAK,QAAQ,GAAG;AAC5D,cAAI,KAAK,YAAY,OAAO;AAC1B,iBAAK,KAAK,QAAQ,KAAK,YAAY;AACnC,mBAAO,KAAK,YAAY;AACxB,iBAAK,SAAS,MAAM,QAAQ,CAAC,QAAQ;AACnC,kBAAI,UAAU,KAAK,KAAK,KAAK;AAAA,YAC/B,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AACA,aAAO,KAAK;AAAA,IACd;AAAA,IACA,iBAAiB,KAAK,YAAY,CAAC,QAAQ;AAAA,IAC3C,GAAG;AACD,UAAI,KAAK;AACP,YAAI,CAAC,KAAK,SAAS,MAAM;AACvB,eAAK,SAAS,OAAO,CAAC;AAAA,QACxB;AACA,YAAI,IAAI,KAAK,SAAS,KAAK;AAC3B,aAAK,SAAS,KAAK,KAAK,EAAE,KAAK,GAAG,UAAU,CAAC;AAC7C,eAAO,KAAK,SAAS,KAAK,SAAS;AAAA,MACrC;AACE,eAAO;AAAA,IACX;AAAA,IACA,mBAAmB,KAAK,KAAK;AAC3B,UAAI,WAAW,KAAK,SAAS;AAC7B,UAAI,UAAU;AACZ,YAAI,CAAC;AACH,iBAAO,KAAK,SAAS;AAAA,aAClB;AACH,cAAI,MAAM;AACV,cAAI,MAAM,SAAS,KAAK,CAAC,GAAG,OAAM;AAChC,gBAAI,EAAE,QAAQ,KAAK;AACjB,oBAAM;AACN,qBAAO;AAAA,YACT;AAAA,UACF,CAAC;AACD,cAAI;AACF,qBAAS,OAAO,KAAK,CAAC;AACxB,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAAA,IACA,qBAAqB,MAAM,QAAQ,YAAY,CAAC,UAAU;AAAA,IAC1D,GAAG;AACD,UAAI;AACJ,UAAI,UAAU,CAAC,UAAU;AACvB,kBAAU,KAAK;AACf,aAAK,mBAAmB,KAAK,GAAG;AAAA,MAClC;AACA,YAAM,KAAK,iBAAiB,KAAK,OAAO;AAAA,IAC1C;AAAA,EACF;AAAA,EACA,IAAI,QAAQ;AACV,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,MAAM,WAAW,CAAC,GAAG;AACvB,SAAK,aAAa,SAAS,QAAQ;AAAA,EACrC;AAAA,EACA,IAAI,WAAW;AACb,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,SAAS,UAAU;AACrB,SAAK,aAAa,YAAY,QAAQ;AAAA,EACxC;AAAA,EACA,IAAI,SAAS;AACX,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,SAAS;AACX,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,QAAQ;AACV,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,YAAY;AACd,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,UAAU,WAAW;AACvB,SAAK,aAAa,aAAa,SAAS;AAAA,EAC1C;AAAA,EACA,IAAI,SAAS;AACX,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,OAAO,aAAa;AACtB,SAAK,SAAS;AACd,QAAI,KAAK,cAAc,OAAO,GAAG;AAC/B,WAAK,cAAc,OAAO,EAAE,YAAY;AAAA,IAC1C,OAAO;AACL,WAAK,OAAO;AAAA,IACd;AAAA,EACF;AAAA,EACA,IAAI,kBAAkB;AACpB,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,gBAAgB,WAAW;AAC7B,SAAK,aAAa,mBAAmB,SAAS;AAAA,EAChD;AAAA,EACA,IAAI,WAAW;AACb,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,SAAS,UAAU;AACrB,SAAK,aAAa,YAAY,QAAQ;AAAA,EACxC;AAAA,EACA,IAAI,WAAW;AACb,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,SAAS,UAAU;AACrB,SAAK,aAAa,YAAY,QAAQ;AAAA,EACxC;AAAA,EACA,IAAI,WAAW;AACb,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,SAAS,UAAU;AACrB,SAAK,aAAa,aAAa,QAAQ;AAAA,EACzC;AACF;AACA,0BAA0B,KAAK,KAAK,SAAS,MAAM;AACjD,MAAI;AACF,QAAI,QAAQ;AACV,UAAI;AACF,eAAO,eAAe,OAAO,KAAK,KAAK,EAAE,SAAS,OAAO,CAAC;AAAA;AAE1D,eAAO,eAAe,OAAO,IAAI,KAAK,YAAY,IAAI,KAAK,KAAK,EAAE,SAAS,OAAO,CAAC;AAAA,IACvF,OAAO;AACL,UAAI;AACF,eAAO,eAAe,OAAO,KAAK,GAAG;AAAA;AAErC,eAAO,eAAe,OAAO,IAAI,KAAK,YAAY,IAAI,KAAK,GAAG;AAAA,IAClE;AAAA,EACF,SAAS,KAAP;AAAA,EACF;AACF;AACA,gCAAgC,QAAQ;AACtC,MAAI,kBAAkB,CAAC,iBAAiB;AACtC,WAAO,aAAa,QAAQ,2EAA2E,QAAQ;AAAA,EACjH;AACA,MAAI,kBAAkB,CAAC,iBAAiB;AACtC,QAAI,aAAa,aAAa,QAAQ,GAAG;AACzC,WAAO,aAAa,MAAM,GAAG,aAAa,QAAQ,KAAK,UAAU,IAAI,CAAC;AAAA,EACxE;AACA,MAAI,cAAc,gBAAgB,MAAM;AACxC,MAAI,cAAc,gBAAgB,MAAM;AACxC,MAAI;AACJ,MAAI;AACF,QAAI,YAAY,SAAS,UAAU,GAAG;AACpC,UAAI,UAAU,YAAY,MAAM,GAAG,EAAE,GAAG,MAAM,GAAG,EAAE;AACnD,gBAAU,IAAI,SAAS,SAAS,WAAW;AAAA,IAC7C,OAAO;AACL,UAAI,YAAY,UAAU,GAAG,CAAC,MAAM,YAAY,UAAU,GAAG,CAAC,GAAG;AAC/D,YAAI,UAAU,YAAY,MAAM,GAAG,EAAE,GAAG,MAAM,GAAG,EAAE;AACnD,kBAAU,IAAI,SAAS,SAAS,YAAY,UAAU,YAAY,QAAQ,GAAG,IAAI,GAAG,YAAY,SAAS,CAAC,CAAC;AAAA,MAC7G,OAAO;AACL,YAAI;AACF,oBAAW,IAAG,MAAM,cAAc,cAAc,GAAG;AAAA,QACrD,SAAS,KAAP;AACA,oBAAW,IAAG,MAAM,MAAM;AAAA,QAC5B;AAAA,MACF;AAAA,IACF;AAAA,EACF,SAAS,KAAP;AAAA,EACF;AACA,SAAO;AACT;AAGA,IAAI,UAAU,cAAc,MAAM;AAAA,EAChC,YAAY,UAAU,CAAC,GAAG;AACxB,UAAM,QAAQ,QAAQ,OAAO,QAAQ,OAAO,UAAU,KAAK,MAAM,KAAK,OAAO,IAAI,IAAI,KAAK,QAAQ,KAAK;AACvG,SAAK,SAAS,CAAC;AACf,SAAK,oBAAoB;AACzB,SAAK,YAAY;AACjB,SAAK,YAAY;AACjB,SAAK,eAAe,CAAC;AACrB,SAAK,iBAAiB,CAAC;AACvB,SAAK,OAAO,CAAC,aAAY;AACvB,UAAI;AACF,mBAAU,OAAO,OAAO,CAAC,GAAG,QAAO;AAAA;AAEnC,mBAAU,CAAC;AACb,UAAI,SAAQ;AACV,eAAO,OAAO,SAAQ,cAAc,KAAK,YAAY;AAAA;AAErD,iBAAQ,eAAe,KAAK;AAC9B,UAAI,SAAQ;AACV,eAAO,OAAO,SAAQ,gBAAgB,KAAK,cAAc;AAAA;AAEzD,iBAAQ,iBAAiB,KAAK;AAChC,UAAI,MAAM,QAAQ,SAAQ,MAAM,GAAG;AACjC,iBAAQ,OAAO,QAAQ,CAAC,OAAM;AAC5B,eAAK,KAAK,IAAG,SAAQ,kBAAkB,SAAQ,aAAa,SAAQ,cAAc,SAAQ,gBAAgB,SAAQ,WAAW;AAAA,QAC/H,CAAC;AAAA,MACH,WAAW,SAAQ,UAAW,QAAO,KAAK,KAAK,MAAM,EAAE,SAAS,KAAK,KAAK,sBAAsB,KAAK;AACnG,aAAK,KAAK,SAAQ,QAAQ,SAAQ,kBAAkB,SAAQ,aAAa,SAAQ,cAAc,SAAQ,gBAAgB,SAAQ,WAAW;AAAA,IAC9I;AACA,SAAK,OAAO,CAAC,QAAQ,mBAAmB,MAAM,cAAc,KAAK,cAAc,gBAAgB,cAAc,SAAS;AACpH,UAAI,CAAC,UAAU,CAAC,KAAK,qBAAsB,QAAO,KAAK,KAAK,MAAM,EAAE,SAAS,KAAK,KAAK;AACrF;AACF,UAAI,KAAK;AACP,aAAK,YAAY;AACnB,UAAI;AACF,uBAAe,OAAO,OAAO,KAAK,cAAc,YAAY;AAAA;AAE5D,uBAAe,KAAK;AACtB,UAAI;AACJ,UAAI,YAAY,CAAC;AACjB,UAAI,QAAQ;AACV,YAAI,CAAE,mBAAkB,UAAU,QAAQ,QAAQ,CAAC,OAAO,SAAS;AACjE,cAAI,OAAO,QAAQ;AACjB,gBAAI,MAAM;AACV,qBAAS,CAAC;AACV,mBAAO,oBAAoB,OAAO,MAAM,EAAE,QAAQ,CAAC,SAAS;AAC1D,kBAAI;AACF,uBAAO,IAAI,OAAO,cAAc,QAAQ,OAAO,OAAO;AAAA;AAEtD,uBAAO,QAAQ,OAAO,OAAO;AAAA,YACjC,CAAC;AAAA,UACH,WAAW,OAAO,WAAW,YAAY;AACvC,sBAAU,IAAI,OAAO,EAAE,mBAAmB,KAAK,kBAAkB,CAAC;AAClE,oBAAQ,KAAK;AACb,gBAAI;AACF,sBAAQ,QAAQ,KAAK;AACvB,qBAAS,QAAQ;AACjB,gBAAI,QAAQ,gBAAgB,CAAC,KAAK;AAChC,mBAAK,eAAe,QAAQ;AAAA,qBACrB,QAAQ,gBAAgB,KAAK;AACpC,qBAAO,OAAO,KAAK,cAAc,QAAQ,YAAY;AACvD,gBAAI,QAAQ,kBAAkB,CAAC,KAAK;AAClC,mBAAK,iBAAiB,QAAQ;AAAA,qBACvB,QAAQ,kBAAkB,KAAK;AACtC,qBAAO,OAAO,KAAK,gBAAgB,QAAQ,cAAc;AAAA,UAC7D;AAAA,QACF,WAAW,kBAAkB,SAAS,OAAO,kBAAkB,SAAS,OAAO,SAAS;AACtF,oBAAU;AACV,mBAAS,CAAC;AACV,cAAI;AACF,oBAAQ,QAAQ,KAAK;AACvB,cAAI,kBAAkB;AACpB,gBAAI,QAAO,QAAQ;AACnB,gBAAI,CAAC,OAAM;AACT,sBAAO,QAAQ;AACf,sBAAQ,OAAO;AAAA,YACjB;AACA,gBAAI,CAAC,OAAM;AACT,sBAAO,QAAQ,KAAK,MAAM,KAAK,OAAO,IAAI,IAAI;AAC9C,sBAAQ,OAAO;AACf,sBAAQ,MAAM;AAAA,YAChB;AAAA,UACF;AACA,cAAI,QAAQ,gBAAgB,CAAC,KAAK;AAChC,iBAAK,eAAe,QAAQ;AAAA,mBACrB,QAAQ,gBAAgB,KAAK;AACpC,mBAAO,OAAO,KAAK,cAAc,QAAQ,YAAY;AACvD,cAAI,QAAQ,kBAAkB,CAAC,KAAK;AAClC,iBAAK,iBAAiB,QAAQ;AAAA,mBACvB,QAAQ,kBAAkB,KAAK;AACtC,mBAAO,OAAO,KAAK,gBAAgB,QAAQ,cAAc;AAC3D,kBAAQ,MAAM,QAAQ,CAAC,SAAS;AAC9B,mBAAO,KAAK,OAAO;AACnB,gBAAI,UAAU,CAAC;AACf,gBAAI,uBAAuB,CAAC,IAAI,QAAQ;AACtC,kBAAI,CAAC,QAAQ,GAAG,QAAQ,OAAO,oBAAoB,CAAC,QAAQ,KAAK,MAAM,cAAc,GAAG,MAAM;AAC5F,oBAAI,CAAC;AACH,0BAAQ,GAAG,OAAO;AAAA;AAElB,0BAAQ,IAAI,MAAM,cAAc,GAAG,OAAO;AAC5C,oBAAI,cAAc,SAAS,GAAG,kBAAkB,SAAS,GAAG,SAAS;AACnE,sBAAI;AACF,uBAAG,QAAQ,KAAK;AAClB,sBAAI,kBAAkB;AACpB,wBAAI,KAAK,GAAG;AACZ,wBAAI,CAAC,IAAI;AACP,2BAAK,GAAG;AACR,yBAAG,OAAO;AAAA,oBACZ;AACA,wBAAI,CAAC,IAAI;AACP,2BAAK,QAAQ,KAAK,MAAM,KAAK,OAAO,IAAI,IAAI;AAC5C,yBAAG,OAAO;AACV,yBAAG,MAAM;AAAA,oBACX;AAAA,kBACF;AACA,qBAAG,MAAM,QAAQ,CAAC,MAAM;AACtB,wBAAI,oBAAoB,CAAC,OAAO,GAAG,MAAM,cAAc,EAAE;AACvD,6BAAO,GAAG,MAAM,cAAc,EAAE,OAAO;AAAA,6BAChC,CAAC,OAAO,EAAE;AACjB,6BAAO,EAAE,OAAO;AAClB,yCAAqB,GAAG,EAAE;AAAA,kBAC5B,CAAC;AAAA,gBACH;AAAA,cACF;AAAA,YACF;AACA,iCAAqB,IAAI;AAAA,UAC3B,CAAC;AAAA,QACH,WAAW,OAAO,WAAW,UAAU;AACrC,cAAI,QAAO,OAAO,YAAY;AAC9B,cAAI,UAAS,UAAU;AACrB,oBAAO,OAAO,UAAU,SAAS,KAAK,MAAM;AAC5C,gBAAI;AACF,sBAAO,MAAK,MAAM,GAAG,EAAE;AACzB,gBAAI;AACF,sBAAO,MAAK,MAAM,GAAG,EAAE;AAAA,UAC3B;AACA,cAAI,SAAQ,UAAS,UAAU;AAC7B,gBAAI,UAAS;AACb,qBAAS,CAAC;AACV,mBAAO,oBAAoB,OAAM,EAAE,QAAQ,CAAC,UAAU;AACpD,kBAAI;AACF,uBAAO,QAAO,cAAc,SAAS,QAAO;AAAA;AAE5C,uBAAO,SAAS,QAAO;AAAA,YAC3B,CAAC;AAAA,UACH;AAAA,QACF;AACA,YAAK,oBAAmB,SAAS,SAAS,YAAY,QAAQ,QAAQ,kBAAkB;AACtF,mBAAS,OAAO,OAAO,CAAC,GAAG,MAAM;AACjC,qBAAW,QAAQ,QAAQ;AACzB,gBAAI,QAAQ,OAAO;AACnB,mBAAO,OAAO;AACd,mBAAO,QAAQ,OAAO,cAAc,QAAQ;AAAA,UAC9C;AAAA,QACF;AAAA,MACF;AACA,UAAI,KAAK,mBAAmB;AAC1B,YAAI,MAAM,OAAO,OAAO,CAAC,GAAG,KAAK,aAAa;AAC9C,YAAI,QAAQ;AACV,iBAAO,OAAO,KAAK,KAAK,MAAM;AAC9B,mBAAS,OAAO,OAAO,KAAK,MAAM;AAAA,QACpC;AACE,mBAAS,OAAO,OAAO,KAAK,KAAK,MAAM;AACzC,aAAK,oBAAoB;AAAA,MAC3B;AACA,UAAI,CAAC;AACH,iBAAS,KAAK;AAChB,UAAI,OAAO;AACX,iBAAW,OAAO,QAAQ;AACxB;AACA,YAAI,eAAe,CAAC,OAAO,aAAa;AACtC,cAAI,OAAO,UAAU,UAAU;AAC7B,gBAAI,CAAC,MAAM;AACT,oBAAM,MAAM;AACd,gBAAI,OAAO,OAAO,aAAa,UAAU;AACvC;AACE,2BAAW,OAAO,MAAM,UAAU;AAChC;AACA,sBAAI,OAAO,MAAM,SAAS,SAAS,UAAU;AAC3C,wBAAI,KAAK,MAAM,SAAS;AACxB,wBAAI,GAAG,OAAO,UAAU,GAAG;AACzB;AACF,wBAAI,gBAAgB;AAClB,iCAAW,MAAM,gBAAgB;AAC/B,6BAAK,eAAe,IAAI,IAAI,KAAK,OAAO,QAAQ,SAAS;AACzD,4BAAI,CAAC;AACH;AAAA,sBACJ;AAAA,oBACF;AACA,wBAAI,GAAG,MAAM,CAAC,GAAG,KAAK;AACpB,yBAAG,MAAM,GAAG;AAAA,oBACd;AACA,wBAAI;AACJ,wBAAI,GAAG,KAAK;AACV,0BAAI,UAAU,GAAG,MAAM;AACrB,4BAAI,UAAU,GAAG,GAAG,MAAM;AAC1B,kCAAU,WAAW;AACrB,2BAAG,MAAM;AACT,qCAAa,UAAU,UAAU,GAAG;AACpC,4BAAI;AAAA,sBACN,OAAO;AACL,kCAAU,GAAG,OAAO;AACpB,qCAAa,UAAU,GAAG,MAAM,GAAG;AACnC,4BAAI,GAAG;AAAA,sBACT;AAAA,oBACF,OAAO;AACL,0BAAI,UAAU,MAAM;AAClB,4BAAI,UAAU,GAAG,MAAM;AACvB,kCAAU,WAAW;AACrB,2BAAG,MAAM;AACT,qCAAa,UAAU,UAAU,GAAG;AACpC,4BAAI;AAAA,sBACN,OAAO;AACL,kCAAU,OAAO;AACjB,qCAAa,UAAU,MAAM,GAAG;AAChC,4BAAI;AAAA,sBACN;AAAA,oBACF;AACA,wBAAI,SAAS,QAAQ,kBAAkB;AACrC,gCAAU,QAAQ,OAAO,cAAc,KAAK;AAC5C,6BAAO,UAAU;AAAA,oBACnB;AACE,gCAAU,KAAK;AAAA,kBACnB;AAAA,gBACF;AAAA,YACJ;AAAA,UACF;AAAA,QACF;AACA,kBAAU,OAAO,OAAO;AACxB,qBAAa,OAAO,MAAM,GAAG;AAAA,MAC/B;AACA;AACE,mBAAW,SAAS,WAAW;AAC7B,cAAI,OAAO,UAAU,WAAW,UAAU;AACxC,gBAAI,KAAI,UAAU;AAClB,gBAAI,OAAO,OAAM,UAAU;AACzB,kBAAI,cAAc;AAChB,2BAAW,OAAO,cAAc;AAC9B,uBAAI,aAAa,KAAK,IAAG,OAAO,SAAS;AACzC,sBAAI,CAAC;AACH;AAAA,gBACJ;AAAA,cACF;AACA,kBAAI,GAAE,KAAK;AACT,oBAAI,OAAO,GAAE,OAAO,UAAU;AAAA,gBAC9B;AAAA,cACF;AACA,kBAAI,GAAE,MAAM;AAAA,cACZ;AACA,kBAAI,GAAE,QAAQ;AAAA,cACd;AACA,kBAAI,GAAE,KAAK;AAAA,cACX;AACA,kBAAI,GAAE,MAAM;AAAA,cACZ;AACA,kBAAI,GAAE,OAAO;AAAA,cACb;AACA,kBAAI,GAAE,SAAS;AAAA,cACf;AACA,kBAAI,GAAE,SAAS;AAAA,cACf;AACA,kBAAI,GAAE,OAAO;AAAA,cACb;AACA,kBAAI,GAAE,QAAQ,CAAC,GAAE,UAAU;AACzB,0BAAU,OAAO,WAAW,GAAE;AAAA,cAChC,WAAW,CAAC,GAAE,YAAY,OAAO,GAAE,OAAO,YAAY;AACpD,0BAAU,OAAO,WAAW,GAAE;AAAA,cAChC;AAAA,YACF;AAAA,UACF;AAAA,QACF;AACF,iBAAW,SAAS,QAAQ;AAC1B,YAAI,OAAO,OAAO,WAAW,UAAU;AACrC,cAAI,KAAK,OAAO,QAAQ;AACtB,gBAAI,OAAO,KAAK,OAAO,WAAW;AAChC,qBAAO,OAAO,KAAK,OAAO,QAAQ,OAAO,MAAM;AAAA;AAE/C,mBAAK,OAAO,SAAS,OAAO;AAAA,UAChC;AACE,iBAAK,OAAO,SAAS,OAAO;AAAA,QAChC,WAAW,KAAK,OAAO,QAAQ;AAC7B,cAAI,OAAO,KAAK,OAAO,WAAW;AAChC,mBAAO,OAAO,KAAK,OAAO,QAAQ,OAAO,MAAM;AAAA;AAE/C,iBAAK,OAAO,SAAS,OAAO;AAAA,QAChC;AACE,eAAK,OAAO,SAAS,OAAO;AAAA,MAChC;AACA,UAAI,SAAS;AACX,mBAAW,OAAO,KAAK,QAAQ;AAC7B,cAAI,KAAK,OAAO,gBAAgB,aAAa,KAAK,OAAO,KAAK,YAAY,KAAK,SAAS,WAAW,GAAG;AACpG,iBAAK,MAAM,IAAI,KAAK,KAAK,OAAO,IAAI;AACpC,iBAAK,SAAS,KAAK,MAAM;AAAA,UAC3B;AAAA,QACF;AAAA,MACF;AACE,aAAK,QAAQ,KAAK,MAAM;AAC1B,iBAAW,QAAQ,KAAK,QAAQ;AAC9B,YAAI,KAAK,OAAO,OAAO,SAAS;AAC9B,cAAI,UAAU,KAAK,OAAO,MAAM;AAChC,kBAAQ,QAAQ,CAAC,MAAM;AACrB,gBAAI,SAAS,QAAQ;AACnB,qBAAO,QAAQ,OAAO,cAAc,KAAK,KAAK,OAAO;AAAA;AAErD,qBAAO,KAAK,KAAK,OAAO;AAAA,UAC5B,CAAC;AAAA,QACH;AAAA,MACF;AACA,aAAO,KAAK;AAAA,IACd;AACA,SAAK,SAAS,CAAC,SAAS,KAAK,WAAW;AACtC,UAAI,CAAC;AACH;AACF,UAAI;AACJ,UAAI,CAAE,mBAAkB,YAAY,OAAO,WAAW,YAAY;AAChE,kBAAU,IAAI,QAAQ;AACtB,iBAAS,QAAQ;AAAA,MACnB,WAAW,kBAAkB,SAAS;AACpC,iBAAS,OAAO;AAAA,MAClB;AACA,iBAAW,MAAK,QAAQ;AACtB,eAAO,KAAK,OAAO;AACnB,YAAI,KAAK,MAAM,IAAI,EAAC;AAClB,eAAK,OAAO,EAAC;AAAA,MACjB;AACA,aAAO,KAAK;AAAA,IACd;AACA,SAAK,eAAe,CAAC,OAAO,QAAQ,SAAS;AAC3C,UAAI,KAAI,OAAO,YAAY;AAC3B,UAAI,MAAM,KAAK,MAAM,IAAI,KAAK;AAC9B,UAAI,CAAC,KAAK;AACR,cAAM,KAAK,OAAO;AAClB,YAAI,CAAC;AACH,gBAAM,KAAK,KAAK;AAAA,MACpB;AACA,UAAI,MAAM,KAAI;AACZ,YAAI,CAAE,KAAI,eAAc,WAAW;AACjC,cAAI;AACF,gBAAI,MAAK;AACX,iBAAO,IAAI;AAAA,QACb;AACE,iBAAO,IAAI,IAAG,IAAI;AAAA,MACtB;AACE,eAAO,KAAK,qBAAqB,EAAE,OAAO,MAAM,OAAO,CAAC;AAAA,IAC5D;AACA,SAAK,WAAW,IAAI,SAAS;AAC3B,UAAI,OAAO,KAAK,OAAO,UAAU;AAC/B,YAAI,KAAK,GAAG,QAAQ;AAClB,iBAAO,KAAK,aAAa,KAAK,GAAG,OAAO,KAAK,GAAG,QAAQ,KAAK,GAAG,IAAI;AAAA,QACtE,WAAW,KAAK,GAAG,OAAO;AACxB,iBAAO,KAAK,qBAAqB,KAAK,EAAE;AAAA,QAC1C,WAAW,KAAK,GAAG,MAAM;AACvB,iBAAO,KAAK,oBAAoB,KAAK,GAAG,MAAM,KAAK,GAAG,IAAI;AAAA,QAC5D,WAAW,KAAK,WAAW;AACzB,cAAI,KAAK,GAAG;AACV,iBAAK,SAAS,EAAE,CAAC,KAAK,GAAG,QAAQ,KAAK,GAAG,KAAK,CAAC;AACjD,cAAI,KAAK,GAAG;AACV,iBAAK,SAAS,EAAE,CAAC,KAAK,GAAG,OAAO,KAAK,GAAG,KAAK,CAAC;AAAA,QAClD;AACA,eAAO;AAAA,MACT;AACE,eAAO;AAAA,IACX;AACA,SAAK,UAAU,IAAI,SAAS;AAC1B,UAAI,KAAK,IAAI;AACX,YAAI,OAAO,KAAK,OAAO,UAAU;AAC/B,cAAI,SAAS,KAAK,GAAG,UAAU,GAAG,CAAC;AACnC,cAAI,OAAO,SAAS,GAAG,KAAK,OAAO,SAAS,GAAG,GAAG;AAChD,gBAAI,OAAO,SAAS,IAAI;AACtB,mBAAK,KAAK,KAAK,GAAG,QAAQ,OAAO,EAAE;AACrC,gBAAI,KAAK,GAAG,OAAO,KAAK;AACtB,mBAAK,KAAK,KAAK,GAAG,UAAU,GAAG,KAAK,GAAG,SAAS,CAAC;AAAA,YACnD;AACA;AACA,iBAAK,KAAK,KAAK,MAAM,KAAK,EAAE;AAAA,UAC9B;AAAA,QACF;AAAA,MACF;AACA,UAAI,OAAO,KAAK,OAAO,UAAU;AAC/B,YAAI,KAAK,GAAG,QAAQ;AAClB,iBAAO,KAAK,aAAa,KAAK,GAAG,OAAO,KAAK,GAAG,QAAQ,KAAK,GAAG,IAAI;AAAA,QACtE,WAAW,KAAK,GAAG,OAAO;AACxB,iBAAO,KAAK,qBAAqB,KAAK,EAAE;AAAA,QAC1C,WAAW,KAAK,GAAG,MAAM;AACvB,iBAAO,KAAK,oBAAoB,KAAK,GAAG,MAAM,KAAK,GAAG,IAAI;AAAA,QAC5D,WAAW,KAAK,WAAW;AACzB,cAAI,KAAK,GAAG;AACV,iBAAK,SAAS,EAAE,CAAC,KAAK,GAAG,QAAQ,KAAK,GAAG,KAAK,CAAC;AACjD,cAAI,KAAK,GAAG;AACV,iBAAK,SAAS,EAAE,CAAC,KAAK,GAAG,OAAO,KAAK,GAAG,KAAK,CAAC;AAAA,QAClD;AACA,eAAO;AAAA,MACT;AACE,eAAO;AAAA,IACX;AACA,SAAK,OAAO,CAAC,QAAQ,aAAa,UAAU,QAAQ,aAAa;AAC/D,UAAI,kBAAkB,WAAW;AAC/B,YAAI;AACF,iBAAO,OAAO,UAAU,CAAC,QAAQ;AAC/B,gBAAI,MAAM,SAAS,GAAG;AACtB,gBAAI,QAAQ;AACV,mBAAK,SAAS,EAAE,OAAO,aAAa,MAAM,KAAK,OAAO,CAAC;AAAA;AAEvD,mBAAK,SAAS,EAAE,OAAO,aAAa,MAAM,KAAK,OAAO,GAAG,QAAQ;AAAA,UACrE,CAAC;AAAA;AAED,iBAAO,KAAK,UAAU,QAAQ,CAAC,QAAQ;AACrC,iBAAK,SAAS,EAAE,OAAO,aAAa,MAAM,KAAK,OAAO,GAAG,QAAQ;AAAA,UACnE,CAAC;AAAA,MACL,WAAW,OAAO,WAAW;AAC3B,eAAO,KAAK,UAAU,QAAQ,CAAC,QAAQ;AACrC,eAAK,SAAS,EAAE,OAAO,aAAa,MAAM,KAAK,OAAO,GAAG,QAAQ;AAAA,QACnE,CAAC;AAAA,IACL;AACA,SAAK,WAAW,CAAC,QAAQ,aAAa,UAAU,QAAQ,aAAa;AACnE,UAAI,kBAAkB,WAAW;AAC/B,YAAI;AACF,iBAAO,OAAO,MAAM,qBAAqB,OAAO,KAAK,CAAC,QAAQ;AAC5D,gBAAI,MAAM,SAAS,GAAG;AACtB,gBAAI,QAAQ;AACV,mBAAK,SAAS,EAAE,OAAO,aAAa,MAAM,KAAK,OAAO,CAAC;AAAA;AAEvD,mBAAK,SAAS,EAAE,OAAO,aAAa,MAAM,KAAK,OAAO,GAAG,QAAQ;AAAA,UACrE,CAAC;AAAA;AAED,iBAAO,KAAK,MAAM,qBAAqB,OAAO,KAAK,CAAC,QAAQ;AAC1D,iBAAK,SAAS,EAAE,OAAO,aAAa,MAAM,KAAK,OAAO,GAAG,QAAQ;AAAA,UACnE,CAAC;AAAA,MACL,WAAW,OAAO,WAAW;AAC3B,eAAO,KAAK,MAAM,qBAAqB,QAAQ,CAAC,QAAQ;AACtD,eAAK,SAAS,EAAE,OAAO,aAAa,MAAM,KAAK,OAAO,GAAG,QAAQ;AAAA,QACnE,CAAC;AAAA,IACL;AACA,SAAK,YAAY,IAAI,SAAS;AAC5B,WAAK,MAAM,QAAQ,CAAC,MAAM;AACxB,UAAE,SAAS;AAAA,MACb,CAAC;AAAA,IACH;AACA,SAAK,oBAAoB,CAAC,QAAQ,QAAQ;AACxC,iBAAW,OAAO,KAAK;AACrB,YAAI,OAAO,IAAI,SAAS,YAAY,CAAC,MAAM,QAAQ,IAAI,IAAI,GAAG;AAC5D,cAAI,OAAO,OAAO,SAAS,YAAY,CAAC,MAAM,QAAQ,OAAO,IAAI;AAC/D,iBAAK,kBAAkB,OAAO,MAAM,IAAI,IAAI;AAAA;AAE5C,mBAAO,OAAO,KAAK,kBAAkB,CAAC,GAAG,IAAI,IAAI;AAAA,QACrD;AACE,iBAAO,OAAO,IAAI;AAAA,MACtB;AACA,aAAO;AAAA,IACT;AACA,SAAK,gBAAgB;AAAA,MACnB,KAAK;AAAA,QACH,KAAK,MAAM;AACT,iBAAO,KAAK,MAAM;AAAA,QACpB;AAAA,QACA,SAAS,CAAC,EAAE;AAAA,MACd;AAAA,MACA,MAAM,MAAM;AACV,gBAAQ,IAAI,MAAM;AAClB,eAAO;AAAA,MACT;AAAA,MACA,MAAM,IAAI,SAAS;AACjB,aAAK,SAAS,GAAG,IAAI;AACrB,eAAO;AAAA,MACT;AAAA,MACA,QAAQ,CAAC,WAAW;AAClB,YAAI,OAAO,WAAW,UAAU;AAC9B,iBAAO,OAAO,MAAM,MAAM;AAC1B,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT;AAAA,MACA,mBAAmB,CAAC,WAAW;AAC7B,YAAI,OAAO,WAAW,UAAU;AAC9B,eAAK,kBAAkB,MAAM,MAAM;AACnC,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT;AAAA,MACA,KAAK;AAAA,QACH,MAAM,IAAI,SAAS;AACjB,kBAAQ,IAAI,SAAS,GAAG,IAAI;AAAA,QAC9B;AAAA,QACA,SAAS,CAAC,MAAM;AAAA,MAClB;AAAA,MACA,OAAO,CAAC,YAAY;AAClB,YAAI,KAAK,IAAI,MAAM,OAAO;AAC1B,gBAAQ,MAAM,OAAO;AACrB,eAAO;AAAA,MACT;AAAA,MACA,OAAO,CAAC,QAAQ;AACd,YAAI,KAAK;AACP,iBAAO,KAAK,MAAM,KAAK;AAAA,QACzB;AACE,iBAAO,KAAK,MAAM;AAAA,MACtB;AAAA,MACA,YAAY,CAAC,QAAQ;AACnB,YAAI,KAAK;AACP,iBAAO,0BAA0B,KAAK,MAAM,KAAK,IAAI;AAAA,QACvD;AACE,iBAAO,0BAA0B,KAAK,MAAM,IAAI;AAAA,MACpD;AAAA,MACA,kBAAkB,KAAK;AAAA,MACvB,UAAU,KAAK;AAAA,MACf,SAAS,KAAK;AAAA,MACd,MAAM,KAAK;AAAA,MACX,QAAQ,KAAK;AAAA,MACb,MAAM,KAAK;AAAA,MACX,WAAW,KAAK;AAAA,MAChB,KAAK,KAAK;AAAA,MACV,WAAW,KAAK;AAAA,MAChB,eAAe,KAAK;AAAA,MACpB,aAAa,KAAK;AAAA,MAClB,UAAU,KAAK;AAAA,MACf,KAAK,KAAK;AAAA,MACV,KAAK,KAAK;AAAA,MACV,QAAQ,KAAK;AAAA,MACb,SAAS,KAAK;AAAA,MACd,UAAU,KAAK;AAAA,MACf,OAAO,KAAK;AAAA,MACZ,aAAa,KAAK;AAAA,MAClB,cAAc,KAAK;AAAA,MACnB,sBAAsB,KAAK;AAAA,MAC3B,qBAAqB,KAAK;AAAA,IAC5B;AACA,QAAI,QAAQ;AACV,WAAK,OAAO,QAAQ;AAAA;AAEpB,cAAQ,OAAO,KAAK;AACtB,QAAI,uBAAuB,SAAS;AAClC,WAAK,oBAAoB,QAAQ;AACjC,WAAK,SAAS,OAAO,OAAO,KAAK,eAAe,KAAK,MAAM;AAAA,IAC7D;AACA,QAAI,WAAW,OAAO,KAAK,KAAK,MAAM,EAAE,SAAS;AAC/C,WAAK,KAAK,OAAO;AAAA,EACrB;AAAA,EACA,qBAAqB,SAAS;AAC5B,QAAI;AACJ,QAAI,OAAO,YAAY,UAAU;AAC/B,UAAI,QAAQ;AACV,eAAO,QAAQ;AAAA,eACR,QAAQ;AACf,eAAO,QAAQ;AAAA,IACnB;AACA,QAAI,MAAM;AACR,UAAI,MAAM,QAAQ,QAAQ,IAAI;AAC5B,eAAO,KAAK,IAAI,MAAM,GAAG,QAAQ,IAAI;AAAA;AAErC,eAAO,KAAK,IAAI,MAAM,QAAQ,IAAI;AAAA,IACtC;AACE,aAAO;AAAA,EACX;AAAA,EACA,oBAAoB,OAAO,MAAM;AAC/B,QAAI,CAAC;AACH,aAAO;AACT,QAAI,MAAM,MAAM;AACd,WAAK,qBAAqB,IAAI;AAAA,IAChC,WAAW,MAAM,QAAQ,IAAI;AAC3B,aAAO,KAAK,IAAI,OAAO,GAAG,IAAI;AAAA;AAE9B,aAAO,KAAK,IAAI,OAAO,IAAI;AAAA,EAC/B;AAAA,EACA,aAAa,IAAG;AACd,WAAO,YAAY,OAAO,EAAC,KAAK,OAAO,UAAU,SAAS,KAAK,EAAC,MAAM;AAAA,EACxE;AAAA,EACA,iBAAiB,KAAK,OAAO,KAAK;AAChC,QAAI,KAAI,IAAI,SAAS,GAAG,KAAK;AAC7B,QAAI;AACJ,QAAI,KAAK;AACP,WAAI,IAAI,SAAS,MAAM,CAAC;AAAA,IAC1B;AACA,QAAI;AACJ,QAAI,GAAE,SAAS,KAAK,IAAG,SAAS;AAC9B,UAAI,IAAI,IAAI,YAAY,GAAE,SAAS,GAAE,MAAM;AAC7C,QAAI,GAAE,SAAS;AACb,QAAE,IAAI,EAAC;AACT,QAAI,MAAK,GAAE,SAAS;AAClB,QAAE,IAAI,IAAG,GAAE,MAAM;AACnB,WAAO;AAAA,EACT;AACF;AAGA,IAAI,aAAa,cAAc,QAAQ;AAAA,EACrC,YAAY,SAAS,YAAY,cAAc;AAC7C,UAAM,EAAE,OAAO,SAAS,OAAO,MAAM,SAAS,OAAO,QAAQ,OAAO,MAAM,KAAK,MAAM,KAAK,OAAO,IAAI,IAAI,IAAI,CAAC;AAC9G,SAAK,oBAAoB;AACzB,SAAK,YAAY;AACjB,SAAK,aAAa,SAAS;AAC3B,SAAK,eAAe;AAAA,MAClB,IAAI,CAAC,UAAU,aAAY;AACzB,YAAI,OAAO,eAAe,aAAa;AACrC,mBAAS,KAAK,mBAAmB,aAAa;AAAA,0GACkD;AAAA,QAClG;AACA,YAAI,KAAK,WAAW,WAAW;AAC/B,YAAI,OAAO,GAAG,OAAO,QAAQ;AAC7B,iBAAQ,WAAW;AAAA,MACrB;AAAA,MACA,KAAK,CAAC,UAAU,aAAY;AAC1B,YAAI,CAAC,SAAQ;AACX,mBAAQ,aAAa,KAAK;AAC5B,YAAI,OAAO,SAAQ,eAAe;AAChC,mBAAQ,aAAa,SAAS,eAAe,SAAQ,UAAU;AACjE,YAAI,OAAO,aAAa,aAAa;AACnC,mBAAS,KAAK,mBAAmB,aAAa;AAAA;AAAA,gHAEwD;AAAA,QACxG;AACA,iBAAQ,WAAW;AACnB,YAAI,WAAW,SAAQ;AACvB,iBAAQ,WAAW,CAAC,OAAO,SAAS;AAClC,gBAAM,QAAQ,SAAS,aAAa,UAAU,SAAQ,EAAE;AACxD,mBAAS,OAAO,IAAI;AAAA,QACtB;AAAA,MACF;AAAA,IACF;AACA,SAAK,eAAe;AAAA,MAClB,OAAO,CAAC,IAAG,OAAO,WAAW;AAC3B,YAAI,CAAE,eAAa,YAAY;AAC7B,cAAI,GAAE,SAAS,YAAY,MAAM,GAAE,OAAO,YAAY,IAAI;AACxD,gBAAI,GAAE,MAAM,WAAW,OAAO,GAAE,QAAQ,IAAI;AAC1C,iBAAE,aAAa,KAAK;AAAA,YACtB;AAAA,UACF,OAAO;AACL,gBAAI,GAAE,UAAU;AACd,kBAAI,CAAC,GAAE;AACL,mBAAE,MAAM;AACV,mBAAK,aAAa,IAAG,GAAE,yBAAyB;AAAA,YAClD,WAAW,GAAE,SAAS;AACpB,kBAAI,CAAC,GAAE;AACL,mBAAE,MAAM;AACV,mBAAK,mBAAmB,EAAC;AAAA,YAC3B,WAAW,GAAE,WAAW,GAAE,SAAS;AACjC,kBAAI,CAAC,GAAE;AACL,mBAAE,MAAM;AACV,mBAAK,WAAW,IAAG,GAAE,yBAAyB;AAAA,YAChD;AAAA,UACF;AAAA,QACF;AACA,eAAO;AAAA,MACT;AAAA,IACF;AACA,SAAK,iBAAiB;AAAA,MACpB,OAAO,CAAC,IAAI,UAAU,QAAQ,QAAQ,YAAY;AAChD,YAAK,QAAO,OAAO,OAAO,OAAQ,QAAO,YAAY,OAAO,WAAW,OAAO,WAAW,OAAO,YAAa,IAAG,YAAY,GAAG,WAAW,GAAG,WAAW,GAAG,YAAY,CAAC,GAAG,YAAY;AACrL,cAAI,OAAO;AACT,eAAG,aAAa,OAAO;AACzB,cAAI,OAAO;AACT,eAAG,aAAa,OAAO;AAAA,QAC3B;AACA,eAAO;AAAA,MACT;AAAA,IACF;AACA,SAAK,WAAW,CAAC;AACjB,SAAK,aAAa,CAAC;AACnB,SAAK,YAAY,CAAC;AAClB,SAAK,aAAa,CAAC,UAAS,4BAA4B,UAAU;AAChE,UAAI,MAAM,KAAK,cAAc,QAAO;AACpC,UAAI,CAAC,SAAQ;AACX,iBAAQ,UAAU;AACpB,UAAI,CAAC,SAAQ;AACX,iBAAQ,WAAW,SAAS,OAAO;AACjC,cAAI,OAAO,UAAU;AACnB,uBAAW,OAAO,OAAO;AACvB,kBAAI,KAAK,SAAS;AAChB,oBAAI,OAAO,KAAK,QAAQ,SAAS,cAAc,OAAO,MAAM,SAAS,YAAY;AAC/E,sBAAI,MAAM,QAAQ,MAAM,IAAI;AAC1B,yBAAK,QAAQ,KAAK,GAAG,MAAM,IAAI;AAAA;AAE/B,yBAAK,QAAQ,KAAK,MAAM,IAAI;AAAA,gBAChC,WAAW,QAAQ,SAAS;AAC1B,yBAAO,OAAO,KAAK,QAAQ,MAAM,MAAM,IAAI;AAAA,gBAC7C;AACE,uBAAK,QAAQ,OAAO,MAAM;AAAA,cAC9B;AAAA,YACF;AACF,iBAAO;AAAA,QACT;AACF,UAAI,OAAO,KAAK,iBAAiB,KAAK,QAAO;AAC7C,UAAI,OAAO,MAAM,KAAK,IAAI,iBAAiB,GAAG,CAAC;AAC/C,UAAI,2BAA2B;AAC7B,eAAO,KAAK,IAAI,CAAC,GAAG,OAAM,KAAK,WAAW,EAAE,SAAS,EAAE,CAAC,CAAC;AAAA,MAC3D;AACA,WAAK,SAAS,SAAQ,MAAM,EAAE,SAAS,KAAK,MAAM,YAAY,SAAQ,YAAY,KAAK;AACvF,UAAI,CAAC,KAAK;AACR,aAAK,WAAW,CAAC,UAAU;AACzB,cAAI,OAAO;AACX,cAAI,SAAQ;AACV,qBAAQ,SAAS,KAAK,KAAK,SAAS,SAAQ,IAAI,MAAM,KAAK,KAAK,SAAS,SAAQ,GAAG;AAAA,QACxF;AACF,UAAI,SAAQ,UAAU;AACpB,YAAI,WAAW,SAAQ;AACvB,iBAAQ,WAAW,CAAC,OAAO;AACzB,mBAAS,KAAK,KAAK,SAAS,SAAQ,IAAI,MAAM,IAAI,KAAK,KAAK,SAAS,SAAQ,GAAG;AAAA,QAClF;AACA,eAAO,iBAAiB,UAAU,SAAQ,QAAQ;AAAA,MACpD;AACA,aAAO,KAAK,SAAS,SAAQ;AAAA,IAC/B;AACA,SAAK,gBAAgB,CAAC,aAAY;AAChC,UAAI;AACJ,UAAI,SAAQ,SAAS;AACnB,YAAI,OAAO,SAAQ,YAAY,UAAU;AACvC,gBAAM,SAAS,cAAc,SAAQ,OAAO;AAC5C,cAAI,CAAC;AACH,kBAAM,SAAS,eAAe,SAAQ,OAAO;AAAA,QACjD;AACE,gBAAM,SAAQ;AAAA,MAClB,WAAW,SAAQ;AACjB,cAAM,SAAS,cAAc,SAAQ,OAAO;AAAA,eACrC,SAAQ,MAAM,SAAS,eAAe,SAAQ,EAAE;AACvD,cAAM,SAAS,eAAe,SAAQ,EAAE;AAC1C,UAAI,CAAC;AACH,eAAO;AACT,WAAK,cAAc,UAAS,GAAG;AAC/B,aAAO;AAAA,IACT;AACA,SAAK,gBAAgB,CAAC,UAAS,YAAY;AACzC,UAAI,CAAC,SAAQ,MAAM,SAAQ;AACzB,iBAAQ,KAAK,SAAQ;AACvB,UAAI,CAAC,SAAQ,OAAO,SAAQ;AAC1B,iBAAQ,MAAM,SAAQ;AACxB,UAAI,CAAC,SAAQ;AACX,iBAAQ,KAAK,GAAG,SAAQ,WAAW,YAAY,KAAK,MAAM,KAAK,OAAO,IAAI,IAAI;AAChF,UAAI,IAAI,SAAQ;AAChB,aAAO,SAAQ;AACf,aAAO,eAAe,UAAS,cAAc;AAAA,QAC3C,KAAK,WAAW;AACd,iBAAO,QAAQ;AAAA,QACjB;AAAA,QACA,KAAK,CAAC,MAAM;AACV,cAAI,QAAQ,YAAY;AACtB,oBAAQ,WAAW,YAAY,OAAO;AAAA,UACxC;AACA,eAAK,kBAAkB,SAAS,IAAI,IAAI,KAAK,YAAY,UAAS,SAAQ,QAAQ;AAAA,QACpF;AAAA,QACA,YAAY;AAAA,QACZ,cAAc;AAAA,MAChB,CAAC;AACD,eAAQ,aAAa,IAAI,IAAI,KAAK;AAClC,cAAQ,KAAK,SAAQ;AACrB,UAAI,SAAQ;AACV,eAAO,OAAO,QAAQ,OAAO,SAAQ,KAAK;AAC5C,UAAI,SAAQ,YAAY;AACtB,iBAAS,OAAO,SAAQ,YAAY;AAClC,cAAI,OAAO,SAAQ,WAAW,SAAS;AACrC,oBAAQ,OAAO,IAAI,SAAS,SAAQ,WAAW,KAAK,GAAG,IAAI;AAAA;AAE3D,oBAAQ,OAAO,SAAQ,WAAW;AAAA,QACtC;AAAA,MACF;AACA,UAAI,CAAC,SAAQ,YAAY,aAAa,SAAQ,WAAW;AACvD,gBAAQ,YAAY,SAAQ;AAAA,MAC9B,WAAW,CAAC,SAAQ,YAAY,aAAa,SAAQ,WAAW;AAC9D,gBAAQ,YAAY,SAAQ;AAAA,MAC9B;AACA,aAAO;AAAA,IACT;AACA,SAAK,oBAAoB,CAAC,KAAK,aAAY,UAAS,aAAa;AAC/D,UAAI,CAAC,IAAI,YAAY;AACnB,mBAAW,MAAM;AACf,cAAI,OAAO,gBAAe;AACxB,0BAAa,SAAS,eAAe,WAAU;AACjD,cAAI,eAAc,OAAO,gBAAe,UAAU;AAChD,wBAAW,YAAY,GAAG;AAAA,UAC5B;AACA,cAAI;AACF,qBAAS,KAAK,IAAI,MAAM,KAAK,KAAK,SAAS,SAAQ,GAAG;AACxD,cAAI,IAAI,KAAK,aAAa,IAAI,KAAK,SAAS;AAC1C,gBAAI,KAAK,aAAa;AAAA,UACxB;AACA,cAAI,IAAI,KAAK,UAAU,OAAO,IAAI,KAAK,SAAS,YAAY,IAAI,KAAK,MAAM;AACzE,gBAAI,KAAK,QAAQ;AAAA,UACnB;AAAA,QACF,GAAG,IAAI;AAAA,MACT;AAAA,IACF;AACA,SAAK,mBAAmB,CAAC,SAAS,aAAY;AAC5C,UAAI;AACJ,UAAI,KAAK,MAAM,IAAI,SAAQ,EAAE,GAAG,SAAS,YAAY,OAAO,SAAQ,cAAc,KAAK,MAAM,IAAI,SAAQ,EAAE,GAAG,eAAe,SAAQ,YAAY;AAC/I,eAAO,KAAK,MAAM,IAAI,SAAQ,EAAE;AAAA,MAClC,OAAO;AACL,YAAI,WAAW,SAAQ,sBAAsB,cAAc,SAAQ,YAAY,KAAK,OAAO,SAAQ,eAAe,WAAW,SAAQ,aAAa;AAClJ,YAAI;AACJ,YAAI;AACF,mBAAS,KAAK,MAAM,IAAI,QAAQ;AAClC,eAAO,IAAI,UAAU,oBAAmB,QAAQ,WAAU,OAAO,OAAO,CAAC,GAAG,QAAO,GAAG,QAAQ,IAAI;AAAA,MACpG;AACA,aAAO,KAAK;AACZ,aAAO,eAAe,MAAM,cAAc;AAAA,QACxC,KAAK,WAAW;AACd,iBAAO,QAAQ;AAAA,QACjB;AAAA,QACA,KAAK,CAAC,MAAM;AACV,cAAI,QAAQ,YAAY;AACtB,oBAAQ,WAAW,YAAY,OAAO;AAAA,UACxC;AACA,eAAK,kBAAkB,SAAS,IAAI,IAAI,KAAK,YAAY,UAAS,SAAQ,QAAQ;AAAA,QACpF;AAAA,QACA,YAAY;AAAA,QACZ,cAAc;AAAA,MAChB,CAAC;AACD,aAAO,eAAe,MAAM,WAAW;AAAA,QACrC,KAAK,MAAM;AAAA,QACX,KAAK,CAAC,MAAM;AACV,oBAAU;AACV,eAAK,MAAM,QAAQ,CAAC,MAAM;AACxB,gBAAI,KAAK,QAAQ,YAAY,EAAE,OAAO;AACpC,gBAAE,aAAa;AAAA,UACnB,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AACD,WAAK,UAAU;AACf,cAAQ,OAAO;AACf,YAAM,iBAAiB,SAAQ,YAAY;AAC3C,eAAS,OAAO,gBAAgB;AAC9B,YAAI,OAAO,eAAe,SAAS;AACjC,yBAAe,OAAO,eAAe,KAAK,KAAK,IAAI;AAAA,iBAC5C,QAAQ,cAAc;AAC7B,mBAAS,QAAQ,eAAe,YAAY;AAC1C,gBAAI,OAAO,eAAe,WAAW,UAAU,YAAY;AACzD,6BAAe,WAAW,QAAQ,eAAe,WAAW,MAAM,KAAK,IAAI;AAAA,YAC7E;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT;AACA,SAAK,eAAe,CAAC,UAAS,4BAA4B,SAAS;AACjE,UAAI,SAAQ,UAAU;AACpB,YAAI,WAAW,SAAQ;AACvB,iBAAQ,WAAW,CAAC,YAAY;AAC9B,mBAAS,KAAK,QAAQ,MAAM,SAAS,QAAO;AAAA,QAC9C;AAAA,MACF;AACA,UAAI,SAAQ,UAAU;AACpB,YAAI,WAAW,SAAQ;AACvB,iBAAQ,WAAW,CAAC,YAAY;AAC9B,mBAAS,KAAK,QAAQ,MAAM,SAAS,QAAO;AAAA,QAC9C;AAAA,MACF;AACA,UAAI,SAAQ,UAAU;AACpB,YAAI,WAAW,SAAQ;AACvB,iBAAQ,WAAW,CAAC,YAAY;AAC9B,mBAAS,KAAK,QAAQ,MAAM,MAAM,QAAO;AAAA,QAC3C;AAAA,MACF;AACA,UAAI,OAAO,SAAQ,oBAAoB,YAAY;AACjD,YAAI,kBAAkB,SAAQ;AAC9B,iBAAQ,kBAAkB,CAAC,YAAY;AACrC,0BAAgB,KAAK,QAAQ,MAAM,SAAS,QAAO;AAAA,QACrD;AAAA,MACF;AACA,UAAI,SAAQ,eAAe,SAAQ,gBAAgB,MAAM;AACvD,aAAK,aAAa,SAAQ,aAAa,SAAQ,UAAU,QAAO;AAAA,MAClE;AACA,YAAM,sBAAsB,WAAW;AAAA,QACrC,cAAc;AACZ,gBAAM,GAAG,SAAS;AAClB,eAAK,QAAQ,SAAQ;AACrB,eAAK,SAAS,SAAQ;AACtB,eAAK,YAAY,SAAQ;AACzB,eAAK,WAAW,SAAQ;AACxB,eAAK,WAAW,SAAQ;AACxB,eAAK,WAAW,SAAQ;AACxB,eAAK,WAAW,SAAQ;AACxB,eAAK,kBAAkB,SAAQ;AAAA,QACjC;AAAA,MACF;AACA,UAAI,CAAC,SAAQ;AACX,iBAAQ,UAAU,iBAAiB,KAAK,OAAO,IAAI;AACrD,oBAAc,WAAW,SAAQ,OAAO;AACxC,UAAI,MAAM,SAAS,cAAc,SAAQ,OAAO;AAChD,UAAI,kBAAkB,KAAK,cAAc,UAAS,GAAG;AACrD,WAAK,UAAU,gBAAgB,MAAM;AACrC,UAAI,OAAO,MAAM,KAAK,IAAI,iBAAiB,GAAG,CAAC;AAC/C,UAAI,2BAA2B;AAC7B,eAAO,KAAK,IAAI,CAAC,MAAM,KAAK,WAAW,EAAE,SAAS,EAAE,CAAC,CAAC;AAAA,MACxD;AACA,UAAI,CAAC,SAAQ;AACX,iBAAQ,UAAU;AACpB,UAAI,CAAC,SAAQ;AACX,iBAAQ,WAAW,YAAY,OAAO;AACpC,cAAI,OAAO,UAAU;AACnB,uBAAW,OAAO,OAAO;AACvB,kBAAI,KAAK,SAAS;AAChB,oBAAI,OAAO,KAAK,QAAQ,SAAS,cAAc,OAAO,MAAM,SAAS,YAAY;AAC/E,sBAAI,MAAM,QAAQ,MAAM,IAAI;AAC1B,yBAAK,QAAQ,KAAK,GAAG,MAAM,IAAI;AAAA;AAE/B,yBAAK,QAAQ,KAAK,MAAM,IAAI;AAAA,gBAChC,WAAW,QAAQ,SAAS;AAC1B,yBAAO,OAAO,KAAK,QAAQ,MAAM,MAAM,IAAI;AAAA,gBAC7C;AACE,uBAAK,QAAQ,OAAO,MAAM;AAAA,cAC9B;AAAA,YACF;AACF,iBAAO;AAAA,QACT;AACF,UAAI,OAAO,KAAK,iBAAiB,KAAK,QAAO;AAC7C,UAAI,CAAC,KAAK;AACR,aAAK,WAAW,CAAC,UAAU;AACzB,cAAI,OAAO;AAAA,QACb;AACF,WAAK,WAAW,gBAAgB,MAAM;AAAA,QACpC,SAAS;AAAA,QACT,OAAO;AAAA,QACP;AAAA,QACA;AAAA,QACA,GAAG;AAAA,MACL;AACA,aAAO,KAAK,WAAW,gBAAgB;AAAA,IACzC;AACA,SAAK,qBAAqB,CAAC,aAAY;AACrC,UAAI,CAAC,SAAQ,QAAQ;AACnB,iBAAQ,WAAW;AACnB,YAAI,SAAQ;AACV,mBAAQ,YAAY,UAAU,SAAQ;AACxC,YAAI,SAAQ;AACV,mBAAQ,YAAY,WAAW,SAAQ;AACzC,iBAAQ,YAAY;AAAA,MACtB;AACE,iBAAQ,WAAW,SAAQ;AAC7B,UAAI,SAAQ,UAAU;AACpB,YAAI,WAAW,SAAQ;AACvB,iBAAQ,WAAW,CAAC,YAAY;AAC9B,mBAAS,KAAK,QAAQ,MAAM,SAAS,QAAO;AAAA,QAC9C;AAAA,MACF;AACA,UAAI,SAAQ,UAAU;AACpB,YAAI,WAAW,SAAQ;AACvB,iBAAQ,WAAW,CAAC,YAAY;AAC9B,mBAAS,KAAK,QAAQ,MAAM,SAAS,QAAO;AAAA,QAC9C;AAAA,MACF;AACA,UAAI,SAAQ,UAAU;AACpB,YAAI,WAAW,SAAQ;AACvB,iBAAQ,WAAW,CAAC,YAAY;AAC9B,mBAAS,KAAK,QAAQ,MAAM,SAAS,QAAO;AAAA,QAC9C;AAAA,MACF;AACA,UAAI,OAAO,SAAQ,oBAAoB,YAAY;AACjD,YAAI,kBAAkB,SAAQ;AAC9B,iBAAQ,kBAAkB,CAAC,YAAY;AACrC,0BAAgB,KAAK,QAAQ,MAAM,SAAS,QAAO;AAAA,QACrD;AAAA,MACF;AACA,YAAM,sBAAsB,WAAW;AAAA,QACrC,cAAc;AACZ,gBAAM,GAAG,SAAS;AAClB,eAAK,QAAQ,SAAQ;AACrB,eAAK,SAAS,SAAQ;AACtB,eAAK,WAAW,SAAQ;AACxB,eAAK,WAAW,SAAQ;AACxB,eAAK,WAAW,SAAQ;AACxB,eAAK,WAAW,SAAQ;AACxB,eAAK,kBAAkB,SAAQ;AAAA,QACjC;AAAA,MACF;AACA,UAAI,CAAC,SAAQ;AACX,iBAAQ,UAAU,iBAAiB,KAAK,OAAO,IAAI;AACrD,oBAAc,WAAW,SAAQ,OAAO;AACxC,UAAI,MAAM,SAAS,cAAc,SAAQ,OAAO;AAChD,YAAM,kBAAkB,KAAK,cAAc,UAAS,GAAG;AACvD,UAAI,YAAY,MAAM;AACpB,YAAI,KAAK,WAAW,gBAAgB,KAAK,WAAW;AAClD,eAAK,WAAW,gBAAgB,IAAI,KAAK,KAAK,WAAW,gBAAgB,IAAI,SAAS,KAAK,WAAW,gBAAgB,GAAG;AACzH,gCAAsB,SAAS;AAAA,QACjC;AAAA,MACF;AACA,WAAK,UAAU,gBAAgB,MAAM;AACrC,UAAI,CAAC,SAAQ;AACX,iBAAQ,UAAU;AACpB,UAAI,CAAC,SAAQ;AACX,iBAAQ,WAAW,YAAY,OAAO;AACpC,cAAI,OAAO,UAAU;AACnB,uBAAW,OAAO,OAAO;AACvB,kBAAI,KAAK,SAAS;AAChB,oBAAI,OAAO,KAAK,QAAQ,SAAS,cAAc,OAAO,MAAM,SAAS,YAAY;AAC/E,sBAAI,MAAM,QAAQ,MAAM,IAAI;AAC1B,yBAAK,QAAQ,KAAK,GAAG,MAAM,IAAI;AAAA;AAE/B,yBAAK,QAAQ,KAAK,MAAM,IAAI;AAAA,gBAChC,WAAW,QAAQ,SAAS;AAC1B,yBAAO,OAAO,KAAK,QAAQ,MAAM,MAAM,IAAI;AAAA,gBAC7C;AACE,uBAAK,QAAQ,OAAO,MAAM;AAAA,cAC9B;AAAA,YACF;AACF,iBAAO;AAAA,QACT;AACF,UAAI,OAAO,KAAK,iBAAiB,KAAK,QAAO;AAC7C,UAAI,CAAC,KAAK;AACR,aAAK,WAAW,CAAC,UAAU;AACzB,cAAI,OAAO;AAAA,QACb;AACF,UAAI,SAAS,IAAI,cAAc,QAAQ;AACvC,UAAI,gBAAgB;AAClB,eAAO,OAAO,OAAO,OAAO,gBAAgB,KAAK;AACnD,UAAI;AACJ,UAAI,OAAO,gBAAgB,YAAY;AACrC,kBAAU,SAAQ;AAAA,eACX,OAAO,gBAAgB,YAAY;AAC1C,kBAAU,OAAO,WAAW,gBAAgB,OAAO;AACrD,WAAK,WAAW,gBAAgB,MAAM;AAAA,QACpC,SAAS;AAAA,QACT,OAAO;AAAA,QACP,UAAU,gBAAgB;AAAA,QAC1B;AAAA,QACA;AAAA,QACA,GAAG;AAAA,MACL;AACA,WAAK,WAAW,gBAAgB,IAAI,UAAU;AAC9C,UAAI,SAAS;AACb,UAAI,UAAU;AACd,WAAK,SAAS;AACd,WAAK,UAAU;AACf,aAAO,KAAK,WAAW,gBAAgB;AAAA,IACzC;AACA,SAAK,YAAY,CAAC,YAAY;AAC5B,UAAI,OAAO,YAAY,UAAU;AAC/B,YAAI,QAAQ;AACV,kBAAQ,YAAY;AACtB,YAAI,QAAQ;AACV,oBAAU,QAAQ;AAAA,MACtB,WAAW,OAAO,YAAY,YAAY,KAAK,WAAW,UAAU;AAClE,YAAI,KAAK,WAAW,SAAS,KAAK;AAChC,eAAK,WAAW,SAAS,KAAK,SAAS;AACzC,YAAI,KAAK,WAAW,SAAS;AAC3B,eAAK,WAAW,SAAS,KAAK,QAAQ,CAAC,MAAM,KAAK,UAAU,CAAC,CAAC;AAChE,YAAI,OAAO,KAAK,WAAW,SAAS;AACpC,eAAO,KAAK,WAAW;AACvB,kBAAU;AAAA,MACZ,WAAW,OAAO,YAAY,YAAY,KAAK,SAAS,UAAU;AAChE,YAAI,KAAK,SAAS,SAAS;AACzB,eAAK,SAAS,SAAS,KAAK,QAAQ,CAAC,MAAM,KAAK,UAAU,CAAC,CAAC;AAC9D,YAAI,OAAO,KAAK,SAAS,SAAS;AAClC,YAAI,KAAK,SAAS,SAAS;AACzB,iBAAO,oBAAoB,UAAU,KAAK,SAAS,SAAS,QAAQ;AACtE,YAAI,KAAK,SAAS,SAAS;AACzB,eAAK,SAAS,SAAS,SAAS,MAAM,KAAK,SAAS,QAAQ;AAC9D,eAAO,KAAK,SAAS;AACrB,kBAAU;AAAA,MACZ;AACA,UAAI,SAAS;AACX,YAAI,KAAK,MAAM,IAAI,QAAQ,EAAE,GAAG;AAC9B,eAAK,WAAW,QAAQ,EAAE;AAAA,QAC5B;AACA,YAAI,mBAAmB;AACrB,kBAAQ,OAAO;AAAA,iBACR,SAAS,YAAY;AAC5B,kBAAQ,WAAW,YAAY,OAAO;AAAA,QACxC;AACA,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AACA,SAAK,gBAAgB;AAAA,MACnB,YAAY,KAAK;AAAA,MACjB,cAAc,KAAK;AAAA,MACnB,oBAAoB,KAAK;AAAA,MACzB,WAAW,KAAK;AAAA,IAClB;AACA,QAAI,SAAS;AACX,mBAAa,QAAQ;AACvB,QAAI,OAAO,eAAe;AACxB,mBAAa,SAAS,eAAe,UAAU;AACjD,QAAI,sBAAsB;AACxB,WAAK,aAAa;AACpB,QAAI,cAAc;AAChB,aAAO,OAAO,KAAK,cAAc,YAAY;AAAA,IAC/C;AACA,SAAK,KAAK,OAAO;AAAA,EACnB;AACF;AAGA,IAAI,SAAS,cAAc,QAAQ;AAAA,EACjC,YAAY,SAAS;AACnB,UAAM,OAAO;AACb,SAAK,OAAO;AACZ,SAAK,cAAc,CAAC;AACpB,SAAK,UAAU,CAAC;AAChB,SAAK,WAAW,CAAC;AACjB,SAAK,qBAAqB,CAAC;AAC3B,SAAK,QAAQ,CAAC;AACd,SAAK,UAAU,OAAO,MAAM,aAAa,QAAQ,cAAc;AAC7D,UAAI,CAAC,KAAK,KAAK;AACb,aAAK,MAAM,OAAO,KAAK,MAAM,KAAK,OAAO,IAAI,IAAI;AAAA,MACnD;AACA,UAAI,OAAO,OAAO,OAAO,CAAC,GAAG,IAAI;AACjC,UAAI,aAAa;AACf,mBAAW,OAAO,aAAa;AAC7B,cAAI,OAAO,YAAY,SAAS,UAAU;AACxC,gBAAI,CAAC,YAAY,KAAK,WAAW,KAAK;AACpC,oBAAM,IAAI,QAAQ,CAAC,KAAK,QAAQ;AAC9B,oBAAI,QAAQ,YAAY,IAAI;AAC5B,oBAAI,UAAU,MAAM;AAClB,sBAAI,CAAC,YAAY,KAAK,WAAW,KAAK;AACpC,wBAAI,YAAY,IAAI,IAAI,QAAQ,KAAK;AACnC,6BAAO,YAAY;AACnB,0BAAI,KAAK;AAAA,oBACX,OAAO;AACL,iCAAW,MAAM;AACf,gCAAQ;AAAA,sBACV,GAAG,GAAG;AAAA,oBACR;AAAA,kBACF,OAAO;AACL,wBAAI,IAAI;AAAA,kBACV;AAAA,gBACF;AACA,wBAAQ;AAAA,cACV,CAAC,EAAE,MAAM,CAAC,OAAO;AACf,wBAAQ,MAAM,0BAA0B,EAAE;AAAA,cAC5C,CAAC;AAAA,YACH;AAAA,UACF;AAAA,QACF;AACA,mBAAW,OAAO,aAAa;AAC7B,sBAAY,OAAO,KAAK,cAAc,YAAY,MAAM,KAAK,GAAG;AAAA,QAClE;AAAA,MACF;AACA,UAAI,QAAQ;AACV,mBAAW,KAAK,QAAQ;AACtB,eAAK,eAAe,OAAO,GAAG,SAAS,OAAO,IAAI,KAAK,KAAK,OAAO,GAAG,IAAI;AAAA,QAC5E;AAAA,MACF;AACA,UAAI,OAAO,CAAC,YAAY,MAAM;AAC5B,YAAI,aAAa,KAAK,cAAc,KAAK,KAAK,MAAM;AACpD,YAAI,YAAY;AACd,iBAAO,WAAW,KAAK,SAAS,GAAG,CAAC;AAAA,MACxC;AACA,UAAI,UAAU,CAAC,SAAS,WAAW,MAAM;AACvC,YAAI,aAAa,KAAK,cAAc,KAAK,KAAK,SAAS;AACvD,YAAI,YAAY;AACd,iBAAO,WAAW,QAAQ,SAAS,QAAQ,GAAG,CAAC;AAAA,MACnD;AACA,UAAI,OAAO,CAAC,OAAO,MAAM,WAAW,MAAM;AACxC,YAAI,aAAa,KAAK,cAAc,KAAK,KAAK,MAAM;AACpD,YAAI,YAAY;AACd,iBAAO,WAAW,KAAK,OAAO,MAAM,QAAQ,GAAG,CAAC;AAAA,MACpD;AACA,UAAI,MAAM,CAAC,OAAO,MAAM,WAAW,MAAM;AACvC,YAAI,aAAa,KAAK,cAAc,KAAK,KAAK,KAAK;AACnD,YAAI,YAAY;AACd,iBAAO,WAAW,IAAI,OAAO,MAAM,QAAQ,GAAG,CAAC;AAAA,MACnD;AACA,UAAI,YAAY,CAAC,OAAO,aAAa,MAAM;AACzC,YAAI,aAAa,KAAK,cAAc,KAAK,KAAK,WAAW;AACzD,YAAI,YAAY;AACd,iBAAO,WAAW,UAAU,OAAO,UAAU,GAAG,CAAC;AAAA,MACrD;AACA,UAAI,cAAc,CAAC,OAAO,QAAQ,MAAM;AACtC,YAAI,aAAa,KAAK,cAAc,KAAK,KAAK,aAAa;AAC3D,YAAI,YAAY;AACd,iBAAO,WAAW,YAAY,OAAO,KAAK,GAAG,CAAC;AAAA,MAClD;AACA,UAAI,YAAY,MAAM;AACpB,eAAO,KAAK,WAAW,IAAI;AAAA,MAC7B;AACA,WAAK,OAAO;AACZ,WAAK,UAAU;AACf,WAAK,OAAO;AACZ,WAAK,MAAM;AACX,WAAK,YAAY;AACjB,WAAK,cAAc;AACnB,WAAK,YAAY;AACjB,WAAK,MAAM,KAAK,OAAO;AACvB,UAAI,eAAe,CAAC,WAAW;AAC7B,YAAI,gBAAgB,CAAC;AACrB,YAAI,OAAO;AACX,eAAO,KAAK,WAAW,EAAE,IAAI,CAAC,GAAG,OAAM;AACrC,cAAI,YAAY,IAAI,KAAK;AACvB,0BAAc,GAAG,QAAO,YAAY,IAAI;AACxC,mBAAO;AAAA,UACT;AAAA,QACF,CAAC;AACD,YAAI,MAAM;AACR,eAAK,KAAK;AAAA,YACR,OAAO;AAAA,YACP,MAAM;AAAA,cACJ,EAAE,KAAK,KAAK,IAAI;AAAA,cAChB;AAAA,cACA;AAAA,cACA;AAAA,YACF;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AACA,aAAO;AAAA,IACT;AACA,SAAK,gBAAgB,CAAC,UAAU,cAAc;AAC5C,UAAI,KAAK,QAAQ,WAAW;AAC1B,YAAI,KAAK,OAAO;AACd,mBAAS,KAAI,GAAG,KAAI,KAAK,MAAM,QAAQ,MAAK;AAC1C,gBAAI,IAAI,KAAK,MAAM;AACnB,uBAAW,OAAO,KAAK,QAAQ,WAAW;AACxC,kBAAI,KAAK,QAAQ,UAAU,KAAK,SAAS;AACvC,oBAAI,OAAO,KAAK,QAAQ,UAAU,KAAK,YAAY,UAAU;AAC3D,sBAAI,KAAK,QAAQ,UAAU,KAAK,QAAQ,QAAQ,GAAG;AACjD,wBAAI,KAAK,QAAQ,UAAU,KAAK,kBAAkB,KAAK,QAAQ,UAAU,KAAK,SAAS,MAAM;AAC3F,0BAAI,CAAC,KAAK,mBAAmB,KAAK,QAAQ,UAAU,KAAK,QAAQ,OAAO;AACtE,6BAAK,iBAAiB,KAAK,QAAQ,UAAU,IAAI;AACjD;AAAA,sBACF;AAAA,oBACF;AACA,2BAAO,KAAK,QAAQ,UAAU;AAAA,kBAChC;AAAA,gBACF,WAAW,KAAK,QAAQ,UAAU,KAAK,YAAY,GAAG;AACpD,sBAAI,KAAK,QAAQ,UAAU,KAAK,kBAAkB,KAAK,QAAQ,UAAU,KAAK,SAAS,MAAM;AAC3F,wBAAI,CAAC,KAAK,mBAAmB,KAAK,QAAQ,UAAU,KAAK,QAAQ;AAC/D,2BAAK,iBAAiB,KAAK,QAAQ,UAAU,IAAI;AACnD;AAAA,kBACF;AACA,yBAAO,KAAK,QAAQ,UAAU;AAAA,gBAChC;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF,OAAO;AACL,qBAAW,KAAK,KAAK,QAAQ,WAAW;AACtC,gBAAI,KAAK,QAAQ,UAAU,GAAG,kBAAkB,KAAK,QAAQ,UAAU,GAAG,SAAS,MAAM;AACvF,kBAAI,CAAC,KAAK,mBAAmB,KAAK,QAAQ,UAAU,GAAG,QAAQ,OAAO;AACpE,qBAAK,iBAAiB,KAAK,QAAQ,UAAU,EAAE;AAC/C;AAAA,cACF;AAAA,YACF;AACA,gBAAI,aAAa,KAAK,QAAQ,UAAU,GAAG,YAAY;AACrD,qBAAO,KAAK,QAAQ,UAAU;AAAA,YAChC,OAAO;AACL,qBAAO,KAAK,QAAQ,UAAU;AAAA,YAChC;AAAA,UACF;AAAA,QACF;AAAA,MACF,WAAW,KAAK,OAAO;AACrB,iBAAS,KAAI,GAAG,KAAI,KAAK,MAAM,QAAQ,MAAK;AAC1C,cAAI,IAAI,KAAK,MAAM;AACnB,cAAI,KAAK,QAAQ,KAAK,WAAW;AAC/B,gBAAI,KAAK,QAAQ,GAAG,UAAU,kBAAkB,KAAK,QAAQ,GAAG,UAAU,SAAS,MAAM;AACvF,kBAAI,CAAC,KAAK,mBAAmB,KAAK,QAAQ,GAAG,UAAU,QAAQ,QAAQ,OAAO;AAC5E,qBAAK,iBAAiB,KAAK,QAAQ,GAAG,UAAU,OAAO;AACvD;AAAA,cACF;AAAA,YACF;AACA,gBAAI,aAAa,KAAK,QAAQ,GAAG,YAAY,YAAY;AACvD,qBAAO,KAAK,QAAQ,GAAG;AAAA,YACzB,OAAO;AACL,qBAAO,KAAK,QAAQ,GAAG;AAAA,YACzB;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,UAAI,OAAO,aAAa,YAAY,KAAK,YAAY,aAAa,KAAK,YAAY,UAAU,MAAM;AACjG,eAAO,KAAK,YAAY;AAAA,MAC1B;AAAA,IACF;AACA,SAAK,iBAAiB,CAAC,UAAU,WAAW,UAAU;AACpD,UAAI,KAAK,QAAQ,WAAW;AAC1B,YAAI,CAAC,SAAS,CAAC;AACb,iBAAO,KAAK,QAAQ;AACtB,YAAI,QAAQ,CAAC;AACb,mBAAW,OAAO,KAAK,QAAQ,WAAW;AACxC,cAAI,OAAO,KAAK,QAAQ,UAAU,SAAS,UAAU;AACnD,gBAAI,CAAC,KAAK,QAAQ,UAAU,KAAK,KAAK;AACpC,yBAAW,KAAK,KAAK,QAAQ,UAAU,MAAM;AAC3C,oBAAI,OAAO,KAAK,QAAQ,UAAU,KAAK,OAAO,UAAU;AACtD,sBAAI,OAAO;AACX,sBAAI,aAAa,CAAC,KAAK,QAAQ,UAAU,KAAK,GAAG;AAC/C,2BAAO;AACT,6BAAW,KAAK,OAAO;AACrB,wBAAI,OAAO,KAAK,QAAQ,UAAU,KAAK,GAAG,OAAO,YAAY,OAAO,MAAM,OAAO,UAAU;AACzF,iCAAW,MAAM,MAAM,IAAI;AACzB,4BAAI,MAAM,GAAG,QAAQ,KAAK,QAAQ,UAAU,KAAK,GAAG,GAAG,KAAK;AAC1D,iCAAO;AACP;AAAA,wBACF;AAAA,sBACF;AAAA,oBACF,WAAW,KAAK,QAAQ,UAAU,KAAK,GAAG,OAAO,MAAM,IAAI;AACzD,6BAAO;AAAA,oBACT,OAAO;AACL,6BAAO;AACP;AAAA,oBACF;AAAA,kBACF;AACA,sBAAI,MAAM;AACR,0BAAM,KAAK,QAAQ,UAAU,KAAK,GAAG,OAAO,KAAK,QAAQ,UAAU,KAAK;AAAA,kBAC1E;AAAA,gBACF;AAAA,cACF;AAAA,YACF,OAAO;AACL,kBAAI,OAAO;AACX,kBAAI,aAAa,CAAC,KAAK,QAAQ,UAAU,KAAK;AAC5C,uBAAO;AACT,yBAAW,KAAK,OAAO;AACrB,oBAAI,OAAO,KAAK,QAAQ,UAAU,KAAK,OAAO,YAAY,OAAO,MAAM,OAAO,UAAU;AACtF,6BAAW,MAAM,MAAM,IAAI;AACzB,wBAAI,MAAM,GAAG,QAAQ,KAAK,QAAQ,UAAU,KAAK,GAAG,KAAK;AACvD,6BAAO;AACP;AAAA,oBACF;AAAA,kBACF;AAAA,gBACF,WAAW,KAAK,QAAQ,UAAU,KAAK,OAAO,MAAM,IAAI;AACtD,yBAAO;AAAA,gBACT,OAAO;AACL,yBAAO;AACP;AAAA,gBACF;AAAA,cACF;AACA,kBAAI,MAAM;AACR,oBAAI,KAAK,cAAc,KAAK,QAAQ,UAAU,MAAM,SAAS;AAC3D,wBAAM,KAAK,QAAQ,UAAU,KAAK,OAAO,KAAK,QAAQ,UAAU;AAAA,cACpE;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,SAAK,gBAAgB,CAAC,UAAS,WAAW;AACxC,UAAI,WAAW,CAAC;AAChB,UAAI,OAAO,aAAY,UAAU;AAC/B,YAAI,KAAK,YAAY,WAAU;AAC7B,qBAAU,KAAK,YAAY;AAAA,QAC7B,OAAO;AACL,qBAAW,KAAK,KAAK,oBAAoB;AACvC,uBAAW,KAAK,KAAK,mBAAmB,IAAI;AAC1C,kBAAI,KAAK,mBAAmB,GAAG,GAAG,WAAU;AAC1C,2BAAU,EAAE,YAAY,KAAK,mBAAmB,GAAG,GAAG,UAAS;AAC/D,yBAAQ,UAAU;AAClB,yBAAS,iBAAiB;AAC1B,yBAAS,iBAAiB;AAC1B;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AACA,YAAI,OAAO,aAAY,YAAY,KAAK,MAAM,IAAI,QAAO;AACvD,qBAAU,EAAE,YAAY,KAAK,MAAM,IAAI,QAAO,EAAE;AAAA,MACpD;AACA,UAAI,CAAC,YAAW,OAAO,aAAY;AACjC,eAAO;AACT,UAAI;AACF,iBAAS,SAAS;AACpB,UAAI,SAAQ,sBAAsB,WAAW;AAC3C,iBAAS,aAAa,SAAQ;AAC9B,YAAI,OAAO,SAAS;AACpB,iBAAS,OAAO,OAAO,YAAY;AACjC,cAAI,QAAQ,QAAQ;AAClB,gBAAI,MAAM,QAAQ,QAAQ,IAAI,GAAG;AAC/B,qBAAO,KAAK,QAAQ,UAAU,GAAG,QAAQ,IAAI;AAAA,YAC/C;AACE,qBAAO,KAAK,QAAQ,UAAU,QAAQ,IAAI;AAAA,UAC9C,OAAO;AACL,gBAAI,MAAM,QAAQ,QAAQ,IAAI,GAAG;AAC/B,qBAAO,KAAK,IAAI,GAAG,QAAQ,IAAI;AAAA,YACjC;AACE,qBAAO,KAAK,IAAI,QAAQ,IAAI;AAAA,UAChC;AAAA,QACF;AACA,iBAAS,UAAU,OAAO,SAAS,WAAW;AAC5C,cAAI,QAAQ;AACV,gBAAI,MAAM,QAAQ,QAAQ,IAAI,GAAG;AAC/B,qBAAO,KAAK,UAAU,GAAG,QAAQ,IAAI;AAAA,YACvC;AACE,qBAAO,KAAK,UAAU,QAAQ,IAAI;AAAA,UACtC,OAAO;AACL,gBAAI,MAAM,QAAQ,QAAQ,IAAI,GAAG;AAC/B,qBAAO,KAAK,IAAI,GAAG,QAAQ,IAAI;AAAA,YACjC;AACE,qBAAO,KAAK,IAAI,QAAQ,IAAI;AAAA,UAChC;AAAA,QACF;AACA,iBAAS,OAAO,OAAO,OAAO,MAAM,WAAW;AAC7C,cAAI,SAAS,KAAK,IAAI,KAAK,GAAG;AAC5B,gBAAI,IAAI,KAAK,IAAI,KAAK;AACtB,gBAAI,QAAQ;AACV,kBAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,uBAAO,EAAE,UAAU,GAAG,IAAI;AAAA,cAC5B;AACE,uBAAO,EAAE,UAAU,IAAI;AAAA,YAC3B,OAAO;AACL,kBAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,uBAAO,EAAE,IAAI,GAAG,IAAI;AAAA,cACtB;AACE,uBAAO,EAAE,IAAI,IAAI;AAAA,YACrB;AAAA,UACF,OAAO;AACL,gBAAI,QAAQ;AACV,kBAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,uBAAO,KAAK,UAAU,GAAG,IAAI;AAAA,cAC/B;AACE,uBAAO,KAAK,UAAU,IAAI;AAAA,YAC9B,OAAO;AACL,kBAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,uBAAO,KAAK,IAAI,GAAG,IAAI;AAAA,cACzB;AACE,uBAAO,KAAK,IAAI,IAAI;AAAA,YACxB;AAAA,UACF;AAAA,QACF;AACA,iBAAS,MAAM,SAAS;AACxB,iBAAS,YAAY,OAAO,OAAO,aAAa;AAC9C,iBAAO,KAAK,UAAU,UAAU,KAAK;AAAA,QACvC;AACA,iBAAS,cAAc,OAAO,OAAO,QAAQ;AAC3C,iBAAO,KAAK,YAAY,KAAK,KAAK;AAAA,QACpC;AACA,iBAAS,YAAY,MAAM;AACzB,eAAK,MAAM,OAAO,IAAI;AACtB,iBAAO;AAAA,QACT;AACA,iBAAS,UAAU,SAAQ;AAC3B,YAAI,SAAS,SAAS;AACpB,cAAI;AACJ,cAAI,KAAK;AACP,0BAAc,KAAK;AACrB,eAAK,WAAW,CAAC,MAAM;AACrB,gBAAI,SAAS;AACX,uBAAS,QAAQ,UAAU,CAAC;AAC9B,gBAAI;AACF,0BAAY,CAAC;AAAA,UACjB;AAAA,QACF;AAAA,MACF,WAAW,SAAQ,sBAAsB,OAAO;AAC9C,YAAI,SAAQ,WAAW,MAAM,IAAI,MAAM;AACrC,mBAAS,UAAU,SAAQ;AAC7B,YAAI,QAAQ,SAAS;AACrB,iBAAS,OAAO,OAAO,YAAY;AACjC,cAAI,MAAM,QAAQ,QAAQ,IAAI;AAC5B,kBAAM,IAAI,QAAQ,OAAO,GAAG,QAAQ,IAAI;AAAA;AAExC,kBAAM,IAAI,QAAQ,OAAO,QAAQ,IAAI;AAAA,QACzC;AACA,iBAAS,UAAU,OAAO,SAAS,WAAW;AAC5C,cAAI,CAAC,QAAQ;AACX,mBAAO;AACT,cAAI,QAAQ;AACV,gBAAI,MAAM,QAAQ,QAAQ,IAAI,GAAG;AAC/B,qBAAO,MAAM,MAAM,IAAI,QAAQ,KAAK,EAAE,UAAU,GAAG,QAAQ,IAAI;AAAA,YACjE;AACE,qBAAO,MAAM,MAAM,IAAI,QAAQ,KAAK,EAAE,UAAU,QAAQ,IAAI;AAAA,UAChE,OAAO;AACL,gBAAI,MAAM,QAAQ,QAAQ,IAAI,GAAG;AAC/B,qBAAO,MAAM,IAAI,QAAQ,OAAO,GAAG,QAAQ,IAAI;AAAA,YACjD;AACE,qBAAO,MAAM,IAAI,QAAQ,OAAO,QAAQ,IAAI;AAAA,UAChD;AAAA,QACF;AACA,iBAAS,OAAO,OAAO,OAAO,MAAM,WAAW;AAC7C,cAAI,SAAS,MAAM,IAAI,KAAK,GAAG;AAC7B,gBAAI,IAAI,MAAM,IAAI,KAAK;AACvB,gBAAI,QAAQ;AACV,kBAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,uBAAO,EAAE,UAAU,GAAG,IAAI;AAAA,cAC5B;AACE,uBAAO,EAAE,UAAU,IAAI;AAAA,YAC3B,OAAO;AACL,kBAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,uBAAO,EAAE,IAAI,GAAG,IAAI;AAAA,cACtB;AACE,uBAAO,EAAE,IAAI,IAAI;AAAA,YACrB;AAAA,UACF;AAAA,QACF;AACA,iBAAS,MAAM,SAAS;AACxB,iBAAS,YAAY,OAAO,OAAO,aAAa;AAC9C,iBAAO,MAAM,UAAU,OAAO,QAAQ;AAAA,QACxC;AACA,iBAAS,cAAc,OAAO,OAAO,QAAQ;AAC3C,iBAAO,MAAM,YAAY,OAAO,GAAG;AAAA,QACrC;AACA,iBAAS,YAAY,CAAC,MAAM;AAC1B,gBAAM,OAAO,CAAC;AACd,iBAAO;AAAA,QACT;AAAA,MACF,WAAW,CAAE,UAAQ,OAAO,KAAK,YAAY,SAAQ,OAAO;AAC1D,YAAI,IAAI,SAAQ;AAChB,YAAI,OAAO,MAAM,UAAU;AACzB,cAAI,KAAK,YAAY;AACnB,gBAAI,KAAK,YAAY;AAAA,mBACd,SAAQ,SAAS;AACxB,gBAAI,OAAO,SAAQ,YAAY,UAAU;AACvC,uBAAQ,UAAU,KAAK,SAAS,SAAQ;AAAA,YAC1C;AACA,gBAAI,OAAO,SAAQ,YAAY,UAAU;AACvC,kBAAI,SAAQ,QAAQ,aAAa;AAC/B,2BAAW,OAAO,SAAQ,QAAQ,aAAa;AAC7C,sBAAI,SAAQ,QAAQ,YAAY,KAAK,IAAI;AACvC,wBAAI,SAAQ,QAAQ,YAAY,KAAK;AACrC,6BAAS,iBAAiB;AAC1B,6BAAS,iBAAiB;AAC1B;AAAA,kBACF;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF,OAAO;AACL,uBAAW,KAAK,KAAK,oBAAoB;AACvC,yBAAW,KAAK,KAAK,mBAAmB,IAAI;AAC1C,oBAAI,KAAK,mBAAmB,GAAG,GAAG,IAAI;AACpC,sBAAI,KAAK,mBAAmB,GAAG,GAAG;AAClC,2BAAQ,UAAU;AAClB,2BAAS,iBAAiB;AAC1B,2BAAS,iBAAiB;AAC1B;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AACA,YAAI,OAAO,MAAM;AACf,iBAAO;AACT,iBAAS,MAAM,EAAE;AACjB,iBAAS,OAAO,EAAE;AAClB,iBAAS,UAAU,EAAE;AACrB,iBAAS,MAAM,EAAE;AACjB,iBAAS,OAAO,EAAE;AAClB,iBAAS,YAAY,EAAE;AACvB,iBAAS,cAAc,EAAE;AACzB,iBAAS,YAAY,EAAE;AACvB,iBAAS,UAAU,SAAQ;AAC3B,YAAI,SAAS,SAAS;AACpB,cAAI,CAAE,GAAE,WAAW,SAAS,QAAQ,SAAS,MAAM,EAAE,QAAQ,SAAS,IAAI;AACxE,gBAAI,aAAa,EAAE;AACnB,cAAE,UAAU,IAAI,SAAS;AACvB,kBAAI,SAAS;AACX,yBAAS,QAAQ,UAAU,GAAG,IAAI;AACpC,kBAAI,KAAK,MAAM,SAAS,WAAW,OAAO,KAAK,KAAK,QAAQ,SAAS,OAAO,EAAE,WAAW,GAAG;AAC1F,qBAAK,WAAW,SAAS,QAAQ,KAAK;AAAA,cACxC;AACA,kBAAI;AACF,2BAAW,GAAG,IAAI;AAAA,YACtB;AAAA,UACF;AAAA,QACF,OAAO;AACL,cAAI,aAAa,EAAE;AACnB,YAAE,UAAU,IAAI,SAAS;AACvB,iBAAK,iBAAiB,QAAQ;AAC9B,gBAAI,KAAK,MAAM,SAAS,WAAW,OAAO,KAAK,KAAK,QAAQ,SAAS,OAAO,EAAE,WAAW,GAAG;AAC1F,mBAAK,WAAW,SAAS,QAAQ,KAAK;AAAA,YACxC;AACA,gBAAI;AACF,yBAAW,GAAG,IAAI;AAAA,UACtB;AAAA,QACF;AACA,YAAI,SAAQ,SAAS;AACnB,cAAI,OAAO,SAAQ,YAAY;AAC7B,qBAAQ,UAAU,KAAK,SAAS,SAAQ;AAC1C,mBAAS,UAAU,SAAQ;AAAA,QAC7B,WAAW,EAAE;AACX,mBAAS,UAAU,EAAE;AAAA,MACzB;AACA,UAAI,CAAC,SAAS,UAAU,SAAQ,QAAQ;AACtC,iBAAS,SAAS,SAAQ;AAAA,MAC5B,WAAW,CAAC,SAAS,UAAU,SAAQ,SAAS;AAC9C,iBAAS,SAAS,OAAO,SAAQ,YAAY,WAAW,SAAQ,QAAQ,OAAO;AAAA,MACjF,WAAW,CAAC,SAAS,UAAW,UAAS,sBAAsB,aAAa,SAAS,sBAAsB,QAAQ;AACjH,iBAAS,SAAS;AAClB,YAAI,CAAC,KAAK,MAAM,QAAQ,OAAO;AAC7B,eAAK,MAAM,QAAQ,OAAO;AAAA,MAC9B;AACA,UAAI,CAAC,SAAS;AACZ,iBAAS,MAAM,aAAa,KAAK,MAAM,KAAK,OAAO,IAAI,IAAI;AAC7D,UAAI,SAAS,QAAQ;AACnB,YAAI,CAAC,KAAK,QAAQ,SAAS;AACzB,eAAK,QAAQ,SAAS,UAAU,CAAC;AACnC,aAAK,QAAQ,SAAS,QAAQ,SAAS,OAAO;AAAA,MAChD;AACA,UAAI,CAAC,KAAK,YAAY,SAAS;AAC7B,aAAK,YAAY,SAAS,OAAO;AACnC,aAAO;AAAA,IACT;AACA,SAAK,mBAAmB,CAAC,YAAY,YAAY,UAAU;AACzD,UAAI,OAAO,eAAe,YAAY,WAAW;AAC/C,qBAAa,WAAW;AAC1B,UAAI,OAAO,eAAe,UAAU;AAClC,YAAI,KAAK,YAAY,aAAa;AAChC,cAAI,aAAa,KAAK,YAAY;AAChC,iBAAK,YAAY,YAAY,UAAU;AACzC,iBAAO,KAAK,YAAY;AACxB,qBAAW,OAAO,KAAK,SAAS;AAC9B,gBAAI,KAAK,QAAQ,KAAK;AACpB,qBAAO,KAAK,QAAQ,KAAK;AAAA,iBACtB;AACH,yBAAW,KAAK,KAAK,QAAQ,MAAM;AACjC,oBAAI,KAAK,QAAQ,KAAK,KAAK,aAAa;AACtC,yBAAO,KAAK,QAAQ,KAAK;AAAA,gBAC3B;AAAA,cACF;AAAA,YACF;AAAA,UACF;AACA,iBAAO;AAAA,QACT,WAAW,KAAK,QAAQ,aAAa;AACnC,qBAAW,OAAO,KAAK,QAAQ,aAAa;AAC1C,iBAAK,iBAAiB,KAAK,QAAQ,YAAY,MAAM,SAAS;AAAA,UAChE;AACA,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AACA,SAAK,aAAa,CAAC,SAAS,aAAa,kBAAkB,aAAa,cAAc,QAAQ,UAAU;AACtG,WAAK,KAAK,SAAS,kBAAkB,aAAa,KAAK,cAAc,KAAK,cAAc;AACxF,WAAK,SAAS,QAAQ,QAAQ;AAC9B,UAAI,aAAa;AACf,YAAI,OAAO,gBAAgB;AACzB,eAAK,sBAAsB,SAAS,aAAa,MAAM;AAAA,aACpD;AACH,qBAAW,KAAK,aAAa;AAC3B,iBAAK,sBAAsB,SAAS,GAAG,MAAM;AAAA,UAC/C;AAAA,QACF;AAAA,MACF;AACA,UAAI;AACF,aAAK,aAAa;AACpB,UAAI;AACF,aAAK,QAAQ;AAAA,WACV;AACH,YAAI,CAAC,KAAK;AACR,eAAK,QAAQ,CAAC;AAChB,aAAK,MAAM,KAAK,QAAQ,IAAI;AAAA,MAC9B;AAAA,IACF;AACA,SAAK,wBAAwB,CAAC,SAAS,gBAAgB,WAAW;AAChE,UAAI,OAAO,YAAY,UAAU;AAC/B,kBAAU,KAAK,SAAS;AAAA,MAC1B;AACA,UAAI,kBAAkB,QAAQ,iBAAiB;AAC7C,YAAI,iBAAiB,CAAC;AACtB,YAAI,CAAC,KAAK,mBAAmB,QAAQ;AACnC,eAAK,mBAAmB,QAAQ,QAAQ,CAAC;AAC3C,aAAK,mBAAmB,QAAQ,MAAM,kBAAkB,QAAQ;AAChE,mBAAW,OAAO,QAAQ,iBAAiB;AACzC,cAAI,CAAC,KAAK,YAAY,MAAM;AAC1B,2BAAe,OAAO,KAAK,cAAc,EAAE,YAAY,QAAQ,gBAAgB,MAAM,QAAQ,GAAG,MAAM;AACtG,2BAAe,KAAK,iBAAiB;AAAA,UACvC;AAAA,QACF;AACA,eAAO;AAAA,MACT;AAAA,IACF;AACA,SAAK,iBAAiB,OAAO,SAAS,UAAS,WAAW,SAAS;AACjE,UAAI,OAAO,YAAY,UAAU;AAC/B,kBAAU,KAAK,SAAS;AAAA,MAC1B;AACA,UAAI,mBAAmB,SAAS;AAC9B,YAAI,aAAa,QAAQ,IAAI,QAAQ,UAAS,GAAG,IAAI;AACrD,YAAI,sBAAsB,SAAS;AACjC,iBAAO,WAAW,KAAK,OAAO,SAAS;AACrC,gBAAI,CAAC,KAAK,KAAK;AACb,oBAAM,IAAI,QAAQ,CAAC,KAAK,QAAQ;AAC9B,oBAAI,QAAQ,YAAY,IAAI;AAC5B,oBAAI,UAAU,MAAM;AAClB,sBAAI,CAAC,KAAK,KAAK;AACb,wBAAI,YAAY,IAAI,IAAI,QAAQ,KAAK;AACnC,0BAAI,KAAK;AAAA,oBACX,OAAO;AACL,iCAAW,MAAM;AACf,gCAAQ;AAAA,sBACV,GAAG,GAAG;AAAA,oBACR;AAAA,kBACF,OAAO;AACL,wBAAI,IAAI;AAAA,kBACV;AAAA,gBACF;AACA,wBAAQ;AAAA,cACV,CAAC,EAAE,MAAM,CAAC,OAAO;AACf,wBAAQ,MAAM,0BAA0B,EAAE;AAAA,cAC5C,CAAC;AAAA,YACH;AACA,gBAAI,KAAK;AACP,mBAAK,cAAc,EAAE,YAAY,MAAM,QAAQ,GAAG,MAAM;AAAA,UAC5D,CAAC;AAAA,QACH,WAAW,YAAY;AACrB,cAAI,CAAC,WAAW,KAAK;AACnB,kBAAM,IAAI,QAAQ,CAAC,KAAK,QAAQ;AAC9B,kBAAI,QAAQ,YAAY,IAAI;AAC5B,kBAAI,UAAU,MAAM;AAClB,oBAAI,CAAC,WAAW,KAAK;AACnB,sBAAI,YAAY,IAAI,IAAI,QAAQ,KAAK;AACnC,wBAAI,KAAK;AAAA,kBACX,OAAO;AACL,+BAAW,MAAM;AACf,8BAAQ;AAAA,oBACV,GAAG,GAAG;AAAA,kBACR;AAAA,gBACF,OAAO;AACL,sBAAI,IAAI;AAAA,gBACV;AAAA,cACF;AACA,sBAAQ;AAAA,YACV,CAAC,EAAE,MAAM,CAAC,OAAO;AACf,sBAAQ,MAAM,0BAA0B,EAAE;AAAA,YAC5C,CAAC;AAAA,UACH;AACA,cAAI,WAAW;AACb,mBAAO,KAAK,cAAc,EAAE,YAAY,QAAQ,GAAG,MAAM;AAAA,QAC7D;AAAA,MACF;AAAA,IACF;AACA,SAAK,YAAY,CAAC,eAAe;AAC/B,UAAI,OAAO,eAAe;AACxB,qBAAa,KAAK,YAAY;AAChC,aAAO,WAAW,UAAU;AAAA,IAC9B;AACA,SAAK,6BAA6B,CAAC,OAAO,OAAO,UAAU,aAAa,SAAS;AAC/E,UAAI,OAAO,UAAU,UAAU;AAC7B,gBAAQ,KAAK,cAAc,OAAO,KAAK;AAAA,MACzC;AACA,UAAI,OAAO,UAAU;AACnB,eAAO,IAAI,QAAQ,CAAC,KAAK,QAAQ;AAC/B,gBAAM,IAAI,oBAAoB,CAAC,OAAO,UAAU,MAAM,KAAK,GAAG,IAAI,CAAC,EAAE,KAAK,CAAC,QAAQ;AACjF,iBAAK,UAAU,UAAU,CAAC,SAAS;AACjC,kBAAI,MAAM,eAAe,OAAO;AAC9B,oBAAI,CAAC;AACH,uBAAK,SAAS,EAAE,CAAC,WAAW,KAAK,KAAK,CAAC;AAAA,yBAChC,OAAO,aAAa,UAAU;AACrC,uBAAK,SAAS,EAAE,CAAC,WAAW,KAAK,KAAK,CAAC;AAAA,gBACzC;AACE,2BAAS,KAAK,IAAI;AAAA,cACtB;AAAA,YACF,CAAC;AACD,gBAAI,GAAG;AAAA,UACT,CAAC,EAAE,MAAM,GAAG;AAAA,QACd,CAAC;AAAA,IACL;AACA,SAAK,mBAAmB,CAAC,OAAO,aAAa,aAAa,SAAS;AACjE,UAAI;AACJ,UAAI,OAAO,aAAa,UAAU;AAChC,YAAI,KAAK,QAAQ,WAAW;AAC1B,kBAAQ;AAAA,QACV;AACA,mBAAW,KAAK,cAAc,UAAU,MAAM;AAAA,MAChD;AACA,UAAI,OAAO,gBAAgB,UAAU;AACnC,sBAAc,KAAK,cAAc,aAAa,WAAW;AAAA,MAC3D;AACA,UAAI,aAAa,aAAa,UAAU,MAAM;AAC5C,YAAI,MAAM,IAAI,QAAQ,CAAC,MAAM,QAAQ;AACnC,sBAAY,UAAU,OAAO,YAAY,KAAK,CAAC,SAAS;AACtD,gBAAI,CAAC,KAAK,YAAY,SAAS,QAAQ,OAAO;AAC5C,kBAAI,KAAK,QAAQ,QAAQ;AACvB,wBAAQ;AACR,uBAAO,KAAK,KAAK,QAAQ,MAAM,EAAE,QAAQ,CAAC,MAAM;AAC9C,sBAAI,KAAK,QAAQ,UAAU,GAAG,MAAM;AAClC,+BAAW,KAAK,QAAQ,UAAU;AAAA,kBACpC;AAAA,gBACF,CAAC;AAAA,cACH;AAAA,YACF;AACA,gBAAI,KAAK,YAAY,SAAS;AAC5B,uBAAS,KAAK,EAAE,YAAY,OAAO,MAAM,KAAK,CAAC;AAAA,UACnD,GAAG,GAAG,IAAI,EAAE,KAAK,CAAC,QAAQ;AACxB,iBAAK,GAAG;AAAA,UACV,CAAC;AAAA,QACH,CAAC;AACD,eAAO;AAAA,MACT;AAAA,IACF;AACA,SAAK,eAAe,MAAM;AACxB,iBAAW,SAAQ,KAAK,UAAU;AAChC,YAAI,WAAW,KAAK,SAAS;AAC3B,eAAK,SAAS,OAAM,QAAQ,KAAK;AACnC,aAAK,MAAM,QAAQ,CAAC,GAAG,QAAQ;AAC7B,cAAI,CAAC,KAAK,SAAS,OAAM,MAAM,IAAI,EAAE,GAAG,GAAG;AACzC,iBAAK,SAAS,OAAM,MAAM,IAAI,EAAE,KAAK,CAAC;AAAA,UACxC,OAAO;AACL,gBAAI,CAAC,KAAK,SAAS,OAAM,MAAM,IAAI,GAAG,KAAK,EAAE,YAAY,KAAK,SAAS,OAAM,MAAM,IAAI,EAAE,GAAG,EAAE;AAC5F,mBAAK,SAAS,OAAM,MAAM,IAAI,KAAK,CAAC;AAAA,UACxC;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AACA,SAAK,cAAc,CAAC,MAAM,SAAS;AACjC,UAAI,MAAM;AACR,YAAI,OAAO,SAAS,UAAU;AAC5B,iBAAO,KAAK,MAAM;AAClB,cAAI,CAAC;AACH,mBAAO;AAAA,QACX;AAAA,MACF;AACA,UAAI,MAAM;AACR,YAAI,OAAO,SAAS,UAAU;AAC5B,iBAAO,KAAK,MAAM,IAAI;AAAA,QACxB;AAAA,MACF;AACA,UAAI,OAAO,SAAS,UAAU;AAC5B,aAAK,kBAAkB,MAAM,IAAI;AACjC,eAAO;AAAA,MACT;AAAA,IACF;AACA,SAAK,SAAS;AAAA,MACZ,SAAS,KAAK;AAAA,MACd,YAAY,KAAK;AAAA,MACjB,eAAe,KAAK;AAAA,MACpB,eAAe,KAAK;AAAA,MACpB,kBAAkB,KAAK;AAAA,MACvB,YAAY,KAAK;AAAA,MACjB,uBAAuB,KAAK;AAAA,MAC5B,gBAAgB,KAAK;AAAA,MACrB,WAAW,KAAK;AAAA,MAChB,kBAAkB,KAAK;AAAA,MACvB,4BAA4B,KAAK;AAAA,MACjC,cAAc,KAAK;AAAA,IACrB;AACA,SAAK,KAAK,KAAK,MAAM;AACrB,QAAI,SAAS;AACX,UAAI,QAAQ;AACV,aAAK,QAAQ,QAAQ;AACvB,UAAI,QAAQ,UAAU;AACpB,mBAAW,OAAO,QAAQ,UAAU;AAClC,cAAI,MAAM,QAAQ,SAAS;AAC3B,cAAI,eAAe,SAAS;AAC1B,gBAAI,QAAQ,OAAO;AACnB,gBAAI,QAAQ,MAAM;AAClB,iBAAK,WAAW,IAAI,SAAS,IAAI,aAAa,QAAQ,kBAAkB,QAAQ,aAAa,QAAQ,YAAY;AAAA,UACnH,WAAW,OAAO,QAAQ,YAAY;AACpC,gBAAI,UAAU,IAAI,IAAI;AACtB,oBAAQ,OAAO;AACf,oBAAQ,MAAM;AACd,gBAAI;AACF,mBAAK,WAAW,SAAS,QAAQ,aAAa,QAAQ,kBAAkB,QAAQ,aAAa,QAAQ,YAAY;AAAA,UACrH,OAAO;AACL,gBAAI,OAAO,IAAI,YAAY,YAAY;AACrC,kBAAI,UAAU,IAAI,IAAI,QAAQ,EAAE,MAAM,IAAI,CAAC;AAC3C,sBAAQ,OAAO;AACf,sBAAQ,MAAM;AACd,kBAAI;AACF,qBAAK,WAAW,SAAS,QAAQ,QAAQ,kBAAkB,QAAQ,aAAa,QAAQ,YAAY;AACtG,kBAAI,UAAU;AAAA,YAChB,WAAW,IAAI,mBAAmB,SAAS;AACzC,kBAAI,QAAQ,OAAO;AACnB,kBAAI,QAAQ,MAAM;AAClB,mBAAK,WAAW,IAAI,SAAS,QAAQ,QAAQ,kBAAkB,QAAQ,aAAa,QAAQ,YAAY;AAAA,YAC1G;AACA,gBAAI,OAAO,IAAI,YAAY,UAAU;AACnC,kBAAI,IAAI,aAAa;AACnB,oBAAI,MAAM,QAAQ,IAAI,WAAW,GAAG;AAClC,sBAAI,YAAY,QAAQ,CAAC,MAAM;AAC7B,yBAAK,sBAAsB,IAAI,KAAK,SAAS,CAAC;AAAA,kBAChD,CAAC;AAAA,gBACH;AACE,uBAAK,sBAAsB,IAAI,SAAS,IAAI,WAAW;AAAA,cAC3D;AACA,kBAAI,IAAI,QAAQ;AACd,2BAAW,KAAK,IAAI,QAAQ;AAC1B,uBAAK,eAAe,IAAI,SAAS,IAAI,OAAO,IAAI,IAAI,OAAO,GAAG,QAAQ,IAAI,OAAO,GAAG,IAAI;AAAA,gBAC1F;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,WAAW,SAAS,WAAW;AAC7B,QAAI;AACF,WAAK,iBAAiB,SAAS,SAAS;AAC1C,QAAI,OAAO,YAAY;AACrB,gBAAU,KAAK,MAAM;AACvB,QAAI,OAAO,YAAY,YAAY,QAAQ,KAAK;AAC9C,aAAO,KAAK,MAAM,QAAQ;AAC1B,UAAI,QAAQ;AACV,gBAAQ,QAAQ,OAAO;AAAA,IAC3B;AACA,WAAO;AAAA,EACT;AACF;AAGA,IAAI,oBAAoB,CAAC,KAAK,SAAS;AACrC,QAAM,OAAO,KAAK;AAClB,MAAI;AACJ,QAAM,KAAK,KAAK,KAAK,CAAC,EAAE,QAAQ,CAAC,KAAK,OAAM,KAAK,GAAG,SAAS,KAAK,IAAI,GAAG,EAAE,KAAK;AAChF,QAAM,mBAAmB,KAAK;AAC9B,MAAI,OAAO,qBAAqB,YAAY;AAC1C,SAAK,WAAW,YAAY,SAAS;AACnC,UAAI,cAAc,CAAC;AACnB,UAAI,KAAI;AACR,WAAK,QAAQ,CAAC,GAAG,MAAM;AACrB,cAAM,OAAO,KAAK,IAAI,CAAC;AACvB,cAAM,QAAQ,GAAG;AACjB,cAAM,aAAa,KAAK,SAAS,QAAQ,MAAM,EAAC,IAAI,QAAQ;AAC5D,cAAM,SAAS,MAAM,QAAQ;AAC7B,YAAI,SAAS,eAAe,SAAS,aAAa,OAAO;AACzD,eAAO,SAAS;AAChB,YAAI,CAAC,KAAK;AACR,mBAAS,CAAC,MAAM;AAClB,oBAAY,KAAK,GAAG,MAAM;AAC1B;AAAA,MACF,CAAC;AACD,aAAO,iBAAiB,KAAK,QAAQ,MAAM,GAAG,WAAW;AAAA,IAC3D;AAAA,EACF,OAAO;AACL,YAAQ,MAAM,kCAAkC,KAAK,KAAK,MAAM,gBAAgB;AAChF,SAAK,WAAW,IAAI,UAAU;AAAA,EAChC;AACA,UAAQ,IAAI,MAAM,CAAC,GAAG,KAAK,IAAI;AAC/B,SAAO;AACT;AAGA,IAAI,iBAAiB;AACrB,wBAAwB,IAAI;AAC1B,MAAI,OAAO,GAAG,SAAS;AACvB,QAAM,UAAU,KAAK,QAAQ,GAAG;AAChC,QAAM,WAAW,KAAK,QAAQ,GAAG;AACjC,QAAM,kBAAkB,CAAC,KAAK,SAAS,MAAM;AAC3C,UAAM,KAAK,SAAS,IAAI,QAAQ,GAAG;AACnC,QAAI,KAAK,YAAY,KAAK,SAAS;AACjC,aAAO,gBAAgB,IAAI,MAAM,EAAE,GAAG,SAAS,EAAE;AAAA,IACnD;AACE,aAAO;AAAA,EACX;AACA,QAAM,eAAe,gBAAgB,IAAI;AACzC,MAAI;AACJ,MAAI,iBAAiB,MAAM,WAAW;AACpC,iBAAa,KAAK,MAAM,KAAK,QAAQ,GAAG,IAAI,GAAG,KAAK,QAAQ,GAAG,CAAC;AAAA;AAEhE,iBAAa,KAAK,MAAM,oDAAoD,IAAI;AAClF,MAAI,CAAC;AACH,WAAO;AACT,QAAM,UAAU,WAAW,MAAM,cAAc,EAAE,OAAO,CAAC,OAAM,CAAC,CAAC,EAAC;AAClE,QAAM,OAAuB,oBAAI,IAAI;AACrC,UAAQ,QAAQ,CAAC,MAAM;AACrB,QAAI,CAAC,OAAM,SAAS,EAAE,MAAM,GAAG;AAC/B,YAAO,MAAK,KAAK;AACjB,YAAO,MAAK,QAAQ,QAAQ,EAAE;AAC9B,UAAM,SAAS,MAAK,SAAS,KAAK;AAClC,YAAO,MAAK,QAAQ,OAAO,EAAE;AAC7B,QAAI;AACF,UAAI;AACF,aAAK,IAAI,OAAM;AAAA,UACb,OAAO,QAAS,IAAG,MAAM,IAAI,QAAQ,IAAI;AAAA,UACzC;AAAA,QACF,CAAC;AAAA,IACL,SAAS,IAAP;AACA,WAAK,IAAI,OAAM,CAAC,CAAC;AACjB,cAAQ,KAAK,YAAY,iCAAgC,GAAG,SAAS,GAAG,KAAK;AAAA,IAC/E;AAAA,EACF,CAAC;AACD,SAAO;AACT;AACA,IAAI,gBAAgB;AAGpB,IAAI,SAAS,aAAa;AAC1B,IAAI,WAAW,MAAM;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,SAAS,CAAC;AAAA,EACV,WAAW,CAAC;AAAA,EACZ,UAAU;AAAA,EACV,UAAU,CAAC;AAAA,EACX,SAAS;AAAA,EACT,YAAY;AAAA,EACZ,IAAI,UAAU;AACZ,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,WAAW;AACb,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,QAAQ;AACV,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,MAAM,GAAG;AACX,SAAK,SAAS;AAAA,EAChB;AAAA,EACA,YAAY,MAAM,UAAU,CAAC,GAAG;AAC9B,SAAK,WAAW;AAChB,SAAK,WAAW;AAChB,SAAK,UAAU,QAAQ,UAAU,QAAQ,UAAU,QAAQ,UAAU,IAAI,OAAO;AAAA,MAC9E,cAAc;AAAA,MACd,kBAAkB;AAAA,IACpB,CAAC;AACD,OAAG;AACD,WAAK,WAAW,KAAK,QAAQ,WAAW,KAAK;AAAA,IAC/C,SAAS,KAAK,mBAAmB;AACjC,UAAM,aAAa,OAAO,KAAK,YAAY;AAC3C,UAAM,aAAa,aAAa,KAAK;AACrC,QAAI,WAAW,CAAC,CAAC,KAAK;AACtB,QAAI,CAAC,cAAc,CAAC,UAAU;AAC5B,UAAI,UAAU,EAAE,OAAO,EAAE,OAAO,CAAC,EAAE,EAAE;AACrC,eAAS,eAAe;AACtB,gBAAQ,MAAM,MAAM,eAAe,EAAE,SAAS,KAAK,aAAa;AAClE,WAAK,WAAW;AAChB,iBAAW;AACX,WAAK,YAAY;AAAA,IACnB;AACA,QAAI,cAAc,YAAY;AAC5B,WAAK,QAAQ,KAAK,QAAQ,QAAQ,OAAO,sBAAsB,KAAK,OAAO;AAAA,IAC7E;AACA,QAAI,UAAU;AACZ,YAAM,WAAW,CAAC;AAClB,YAAM,QAAQ,KAAK,QAAQ,MAAM;AACjC,eAAS,OAAO,OAAO;AACrB,cAAM,QAAQ,MAAM;AACpB,YAAI,CAAE,kBAAiB,WAAW;AAChC,gBAAM,gBAAgB,OAAO,OAAO,CAAC,GAAG,OAAO,OAAO,OAAO,CAAC;AAC9D,gBAAM,SAAS,IAAI,SAAS,OAAO,OAAO,OAAO,eAAe,EAAE,IAAI,CAAC,CAAC;AACxE,eAAK,SAAS,OAAO;AACrB,mBAAS,KAAK,MAAM;AAAA,QACtB;AACE,eAAK,OAAO,OAAO,KAAK,SAAS,OAAO;AAAA,MAC5C;AACA,YAAM,UAAU,KAAK,SAAS;AAC9B,eAAS,QAAQ,CAAC,MAAM;AACtB,YAAI,MAAM,EAAE,SAAS;AACrB,YAAI;AACF,gBAAM,GAAG,WAAW;AACtB,aAAK,QAAQ,EAAE,SAAS,OAAO;AAC/B,YAAI,OAAO,QAAQ,aAAa;AAC9B,kBAAQ,SAAS,KAAK,CAAC;AAAA,MAC3B,CAAC;AAAA,IACH;AACA,WAAO,eAAe,MAAM,OAAO;AAAA,MACjC,KAAK,MAAM,KAAK,OAAO;AAAA,MACvB,YAAY;AAAA,IACd,CAAC;AAAA,EACH;AAAA,EACA,cAAc,MAAM;AAClB,QAAI,OAAO,CAAC;AACZ,aAAS,OAAO,KAAK,UAAU;AAC7B,UAAI,WAAW,KAAK,SAAS,KAAK;AAClC,UAAI,KAAK,OAAO,MAAM;AACpB,YAAI,KAAK,KAAK,OAAO,KAAK;AAC1B,cAAM,MAAM,GAAG,OAAO,GAAG,OAAO;AAChC,mBAAW,CAAC;AACZ,iBAAS,OAAO,IAAI;AAClB,mBAAS,OAAO,IAAI;AACtB,iBAAS,MAAM;AACf,WAAG,MAAM,WAAW,CAAC;AAAA,MACvB;AACA,WAAK,OAAO,KAAK,QAAQ,KAAK,QAAQ;AAAA,IACxC;AACA,QAAI,eAAe,CAAC;AACpB,QAAI,cAAc,CAAC;AACnB,QAAI,WAAU,CAAC,SAAS;AACtB,UAAI,YAAY,UAAU,QAAQ;AAChC,cAAM,YAAY,KAAK,MAAM,GAAG;AAChC,cAAM,QAAQ,UAAU,MAAM;AAC9B,cAAM,UAAU,UAAU,IAAI;AAC9B,YAAI,OAAO,KAAK;AAChB,YAAI,MAAM;AACR,oBAAU,QAAQ,CAAC,QAAQ,OAAO,KAAK,MAAM,IAAI,GAAG,CAAC;AACrD,gBAAM,WAAW,UAAU,KAAK,MAAM,IAAI,OAAO,IAAI;AACrD,sBAAY,QAAQ,EAAE,UAAU,MAAM,QAAQ;AAAA,QAChD;AACE,kBAAQ,MAAM,0BAA0B,oBAAoB;AAAA,MAChE;AACA,aAAO,YAAY;AAAA,IACrB;AACA,QAAI,WAAW,OAAO,QAAQ,SAAS;AACrC,eAAS,SAAS,QAAQ;AACxB,YAAI,EAAE,UAAU,MAAM,YAAY,SAAQ,KAAK;AAC/C,YAAI,UAAU;AACZ,gBAAM,SAAS,SAAS,QAAQ;AAChC,cAAI,MAAM,QAAQ,IAAI;AACpB,mBAAO,IAAI,GAAG,IAAI;AAAA;AAElB,mBAAO,IAAI,IAAI;AAAA,QACnB,OAAO;AACL,gBAAM,SAAS,KAAK,QAAQ;AAC5B,cAAI;AACJ,cAAI,OAAO,OAAO,aAAa,YAAY;AACzC,gBAAI,MAAM,QAAQ,IAAI;AACpB,oBAAM,MAAM,OAAO,SAAS,GAAG,IAAI;AAAA;AAEnC,oBAAM,MAAM,OAAO,SAAS,IAAI;AAAA,UACpC;AACE,kBAAM,OAAO,WAAW;AAC1B,cAAI,aAAa;AACf,qBAAS,aAAa,QAAQ,GAAG;AAAA,QACrC;AAAA,MACF;AAAA,IACF;AACA,UAAM,QAAQ,KAAK,QAAQ,MAAM;AACjC,aAAS,UAAU,OAAO;AACxB,UAAI,EAAE,aAAa,SAAQ,MAAM;AACjC,UAAI,UAAU;AACZ,YAAI,CAAC,SAAS;AACZ,mBAAS,WAAW,CAAC;AACvB,cAAM,WAAW,CAAC,SAAS;AACzB,mBAAS,MAAM,SAAS,IAAI;AAAA,QAC9B;AACA,YAAI,oBAAoB;AACtB,mBAAS,UAAU,QAAQ;AAAA;AAE3B,eAAK,QAAQ,MAAM,iBAAiB,SAAS,KAAK,QAAQ;AAAA,MAC9D;AACE,qBAAa,UAAU,MAAM;AAAA,IACjC;AACA,WAAO;AAAA,EACT;AAAA,EACA,YAAY,MAAM;AAChB,QAAI,KAAK,QAAQ,OAAO;AACtB,UAAI,OAAO,KAAK,YAAY;AAC5B,YAAM,QAAQ,KAAK,aAAa,KAAK;AACrC,WAAK,QAAQ,SAAS,IAAI,MAAM,MAAM,KAAK,SAAS,KAAK,KAAK,IAAI,IAAI,WAAW,EAAE,QAAQ,MAAM,MAAM,KAAK,SAAS,KAAK,OAAO,KAAK,YAAY,QAAQ,OAAO,GAAG,KAAK,SAAS,UAAU;AAC5L,WAAK,QAAQ,KAAK,KAAK,KAAK;AAC5B,eAAS,OAAO,KAAK,UAAU;AAC7B,cAAM,SAAQ,KAAK,OAAO;AAC1B,YAAI;AACF,iBAAM,QAAQ,KAAK;AAAA,MACvB;AAAA,IACF;AAAA,EACF;AAAA,EACA,QAAQ,OAAO,UAAU;AACvB,QAAI,KAAK,YAAY,OAAO;AAC1B,WAAK,UAAU;AACf,YAAM,gBAAgB,CAAC;AACvB,eAAS,OAAO,KAAK,SAAS;AAC5B,cAAM,IAAI,KAAK,QAAQ;AACvB,cAAM,EAAE,MAAM,CAAC,QAAO;AACpB,wBAAc,KAAK,GAAE;AAAA,QACvB,CAAC;AAAA,MACH;AACA,WAAK,UAAU;AACf,YAAM,KAAI,YAAY;AACpB,iBAAS,OAAM;AACb,gBAAM,IAAG;AACX,YAAI,KAAK;AACP,gBAAM,KAAK,IAAI;AAAA,MACnB;AACA,YAAM,QAAQ,KAAK,QAAQ;AAC3B,UAAI,OAAO;AACT,cAAM,QAAQ,MAAM;AACpB,YAAI,WAAW;AACf,YAAI,OAAO;AACT,sBAAY,MAAM,KAAK,MAAM,IAAI,MAAM,KAAK;AAC5C,qBAAW,KAAK,MAAM,IAAI,MAAM,MAAM;AAAA,QACxC,OAAO;AACL,gBAAM,QAAQ,MAAM,KAAK,KAAK,MAAM,MAAM,OAAO,CAAC;AAClD,sBAAY,MAAM;AAClB,qBAAW,MAAM,MAAM,EAAE,EAAE;AAAA,QAC7B;AACA,YAAI;AACF,mBAAS,UAAU,IAAI,SAAS;AAC9B,qBAAS,OAAO,SAAS,MAAM;AAC7B,mBAAK,UAAU,SAAS,MAAM,SAAS,MAAM,GAAG,IAAI;AAAA,UACxD,CAAC;AACH,YAAI;AACF,eAAK,SAAS,WAAW,kBAAkB,MAAM;AAC/C,kBAAM,UAAU,IAAI,GAAG,IAAI;AAAA,UAC7B;AAAA,MACJ;AACA,UAAI,OAAO,UAAU;AACnB,cAAM,EAAC;AAAA;AAEP,cAAM,GAAE;AAAA,IACZ;AAAA,EACF;AAAA,EACA,OAAO,MAAM;AACX,QAAI,KAAK,YAAY,MAAM;AACzB,eAAS,KAAK,KAAK;AACjB,aAAK,OAAO,GAAG,KAAK;AACtB,UAAI,KAAK;AACP,aAAK,MAAM,MAAM,QAAQ,CAAC,MAAM;AAC9B,eAAK,MAAM,WAAW,CAAC;AACvB,YAAE,SAAS;AACX,eAAK,MAAM,MAAM,WAAW,CAAC;AAAA,QAC/B,CAAC;AACH,WAAK,UAAU;AAAA,IACjB;AAAA,EACF;AAAA,EACA,UAAU,CAAC,KAAK,SAAS;AACvB,QAAI,OAAO,SAAS;AAClB,aAAO,EAAE,SAAS,KAAK;AACzB,QAAI,CAAE,cAAa,SAAS,gBAAgB;AAC1C,aAAO;AAAA,SACJ;AACH,UAAI;AACJ,UAAI,gBAAgB,UAAU;AAC5B,qBAAa,KAAK;AAClB,eAAO,KAAK;AAAA,MACd;AACA,YAAM,OAAO,cAAc,KAAK,OAAO,KAAqB,oBAAI,IAAI;AACpE,UAAI,KAAK,SAAS;AAChB,aAAK,IAAI,WAAW,CAAC,CAAC;AACxB,UAAI,YAAY,MAAM,KAAK,KAAK,QAAQ,CAAC;AACzC,YAAM,QAAQ,UAAU,GAAG;AAC3B,UAAI,KAAK,WAAW;AAClB,cAAM,UAAU,MAAM,QAAQ,KAAK,SAAS;AAC5C,YAAI,KAAI;AACR,iBAAS,OAAO,KAAK,WAAW;AAC9B,gBAAM,IAAI,KAAK,UAAU;AACzB,cAAI,SAAS;AACX,sBAAU,IAAG,QAAQ;AACrB,gBAAI,MAAK;AACP,mBAAK,SAAS;AAAA,UAClB,OAAO;AACL,iBAAK,IAAI,GAAG,EAAE,QAAQ;AACtB,gBAAI,UAAU;AACZ,mBAAK,SAAS;AAAA,UAClB;AACA;AAAA,QACF;AAAA,MACF;AACA,YAAM,OAAO;AAAA,QACX,WAAW;AAAA,QACX,UAAU,KAAK;AAAA,QACf;AAAA,QACA,SAAS,KAAK;AAAA,MAChB;AACA,UAAI,QAAQ,OAAO,oBAAoB,IAAI;AAC3C,YAAM,WAAW,CAAC,aAAa,WAAW,OAAO,UAAU;AAC3D,YAAM,QAAQ,CAAC,QAAQ;AACrB,YAAI,CAAC,SAAS,SAAS,GAAG;AACxB,eAAK,OAAO,KAAK;AAAA,MACrB,CAAC;AACD,UAAI,YAAY;AACd,iBAAS,OAAO,YAAY;AAC1B,cAAI,CAAC,SAAS,SAAS,GAAG;AACxB,iBAAK,OAAO,WAAW;AAAA,QAC3B;AAAA,MACF;AACA,WAAK,YAAY;AACjB,aAAO,kBAAkB,KAAK,IAAI;AAAA,IACpC;AAAA,EACF;AAAA,EACA,YAAY,OAAO,QAAQ,KAAK,UAAU,SAAS;AACjD,QAAI,iBAAiB,OAAO;AAC1B,UAAI,MAAM;AACR,eAAO,MAAM,KAAK,IAAI,GAAG,IAAI;AAAA,WAC1B;AACH,YAAI,KAAK,WAAW;AAClB,iBAAO,KAAK,YAAY,KAAK;AAAA,iBACtB,MAAM,MAAM,IAAI,KAAK,EAAE;AAC9B,iBAAO,MAAM,IAAI,GAAG,IAAI;AAAA;AAExB,iBAAO,KAAK,YAAY,OAAO,GAAG,IAAI;AAAA,MAC1C;AAAA,IACF;AACE,aAAO,MAAM,MAAM,IAAI,GAAG,IAAI;AAAA,EAClC;AAAA,EACA,cAAc,CAAC,UAAU,SAAS,MAAM,IAAI,MAAM,MAAM,OAAO,EAAE,KAAK,EAAE,OAAO,GAAG,IAAI;AAAA,EACtF,MAAM,UAAU,SAAS,KAAK,UAAU,KAAK,OAAO,GAAG,IAAI;AAC7D;AACA,IAAI,cAAc;;;AXjqIlB,IAAM,cAAc;AAEpB,IAAM,YAAY,KAAK,IAAI;AAX3B;AAaA,IAAM,OAAN,MAAW;AAAA,EAiCP,YACI,aACA,UAAmB,CAAC,GACpB,KACF;AAnCF,kBAAgB,CAAC;AACjB,oBAAkB,CAAC;AACnB,iBAA8B,CAAC;AAE/B,oBAAkC,CAAC;AACnC,iBAA0C;AAG1C;AAGA,+BAAS,CAAC;AACV,iCAAW,CAAC;AACZ,6BAAO;AACP,+BAAS,CAAC;AACV,8BAAQ;AACR,8BAAQ;AAER,kCAAY,CAAC,MAAM,SAAS,KAAK,MAAM,QAAQ;AAE/C,+BAAS,CAAC,OAAM;AACZ,YAAM,OAAO;AAAA,QACT,SAAS,GAAE;AAAA,QACX,MAAM,GAAE;AAAA,QACR,MAAM,GAAE;AAAA,MACZ;AAEA,YAAM,MAAO,GAAE,SAAS,YAAa,KAAK,WAAW,KAAK;AAC1D,UAAI,KAAK,IAAI;AAAA,IACjB;AAaA,eAAM,UAAU,SAAS;AACrB,YAAM,OAAO,KAAK;AAElB,aAAO,MAAM,YAAI,KAAK,IAAI,KAAK,IAAI,mBAAK,UAAS,EAAE,MAAM,CAAC,OAAM,mBAAK,QAAL,WAAY;AAAA,QACxE,SAAS,GAAE;AAAA,QACX,MAAM;AAAA,MACV,EAAE;AAAA,IACN;AAIA,gBAAO,OAAO,MAAM,MAAM,SAAS,IAAU,SAAU,YAAa;AAEhE,UAAI,KAAK,SAAS;AACd,iBAAS,cAAc,KAAK,SAAS;AAEjC,gBAAM,aAAa,KAAK,IAAI,OAAO,QAAQ;AAE3C,mBAAS,OAAO,KAAK,QAAQ,aAAa;AACtC,kBAAM,UAAU,KAAK,QAAQ,YAAY;AAEzC,gBAAI,OAAO,YAAY,YAAY,CAAC,MAAM,QAAQ,OAAO,GAAG;AAExD,oBAAM,QAAQ,QAAQ;AACtB,kBAAI;AACJ,kBAAI;AAAI,iCAAiB,mBAAK,QAAO,MAAM;AAE3C,kBAAI,CAAC,gBAAgB;AAGjB,sBAAM,WAAW,OAAO,OAAO,CAAC,GAAG,OAAO;AAC1C,oBAAI,QAAQ;AAAS,2BAAS,aAAa;AAAA;AACtC,2BAAS,aAAa;AAE3B,iCAAkB,MAAM,KAAK,QAAQ,EAAE,CAAC,MAAM,QAAQ,GAAG,MAAM,UAAU;AAAA,kBACrE,OAAO;AAAA,gBACX,GAAG,SAAS,OAAO;AAEnB,oBAAI,IAAI;AACJ,sBAAI,CAAC,mBAAK,QAAO;AAAK,uCAAK,QAAO,MAAM,CAAC;AACzC,qCAAK,QAAO,IAAI,OAAO;AAAA,gBAC3B;AAAA,cACJ;AAGA,kBAAI,YAAY;AACZ,sBAAM,SAAS,eAAe;AAE9B,oBAAI,QAAQ;AACR,sBAAI,YAAY,OAAO,OAAO;AAE9B,sBAAI,aAAa,aAAa,OAAO,KAAK,SAAS,EAAE,WAAW;AAAG,gCAAY,UAAU;AACzF,sBAAI;AAAY,+BAAW,OAAO;AAAA,gBACtC,OAAO;AACH,qCAAK,QAAL,WAAY,EAAE,SAAS,qBAAqB,QAAQ;AAAA,gBACxD;AAAA,cACJ;AAAA,YAEJ,WAAW;AAAY,yBAAW,OAAO;AAAA,UAC7C;AAGA,cAAI,KAAK,IAAI,SAAS,CAAC,YAAY;AAC/B,+BAAK,QAAL,WAAY;AAAA,cACR,SAAS,kBAAkB;AAAA,cAC3B,MAAM;AAAA,YACV;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAIA,mBAAU,OAAO,QAAQ,MAAM,SAAS,QAAa,CAAC,GAAG,UAAoB,CAAC,GAAG,YAAY;AACzF,YAAM,QAAQ,MAAM;AACpB,YAAM,QAAQ,MAAM;AAEpB;AAEA,YAAM,KAAK,OAAO,QAAQ;AAE1B,UAAI,EAAE,QAAQ;AAEd,YAAM,WAAW,KAAK,YAAY,mBAAK;AAGvC,YAAM,kBAAkB,CAAC;AAIzB,eAAS,SAAQ,QAAQ;AAErB,YAAI,cAAc,gBAAgB,SAAQ,CAAC,GAAG,OAAO;AAErD,cAAM,OAAO,OAAO;AACpB,cAAM,QAAQ,QAAQ,OAAO,SAAS,YAAY,CAAC,MAAM,QAAQ,IAAI;AAErE,YAAI,OAAO;AACP,gBAAM,KAAK,KAAK,MAAM,MAAM,SAAS,IAAI,aAAa,OAAO;AAC7D,cAAI,QAAQ,KAAK,OAAO;AACxB,cAAI,AAAM,MAAM,KAAK,KAAM,SAAS,SAAS,CAAC,OAAQ;AAClD,iBAAK,MAAM;AAGX,gBAAI,YAA2B;AAC/B,gBAAI,gBAAgB,QAAQ;AAC5B,gBAAI;AACJ,gBAAI;AACA,kBAAI,IAAI,KAAK;AACb,kBAAI,CAAC,QAAQ,mBAAmB,QAAQ,kBAAkB,UAAU;AAChE,gCAAgB;AAChB,4BAAY,WAAW;AAAA,cAC3B;AAAO,2BAAW,GAAG,MAAM,MAAM,KAAK,EAAE,MAAM,CAAC,EAAE,KAAK,GAAG;AAAA,YAC7D,QAAE;AACE,kBAAI;AAAO,2BAAW,WAAW,AAAa,SAAQ,OAAO,QAAQ,IAAI,AAAa,SAAQ,KAAK;AAAA,YACvG;AAEA,gBAAI,OAAO,QAAQ,iBAAiB,mBAAK;AAGzC,gBAAI,OAAO;AAEP,kBAAI,KAAK,OAAM;AAGX,oBAAI,UAAS,KAAK,MAAM;AACxB,4BAAY,QAAQ,SAAO;AACvB,sBAAI,KAAK;AACL,wBAAI,CAAC,QAAO;AAAM,8BAAO,OAAO,CAAC;AACjC,8BAAS,QAAO;AAAA,kBACpB;AAAA,gBACJ,CAAC;AAGD,oBAAI,CAAC,KAAK,MAAM,YAAY;AAAO,uBAAK,MAAM,YAAY,SAAQ,CAAC;AACnE,oBAAI,UAAU,KAAK,MAAM,YAAY;AACrC,oBAAI,CAAC,QAAQ;AAAW,0BAAQ,YAAY,EAAE,cAAc,GAAG,QAAQ,CAAC,GAAG,OAAO,CAAC,EAAE;AACrF,wBAAQ,UAAU;AAClB,wBAAQ,UAAU,OAAO,KAAK,OAAO;AACrC,wBAAQ,UAAU,MAAM,KAAK,KAAK,IAAI,IAAI,SAAS;AAEnD,oBAAI;AAAQ,0BAAO,YAAY,CAAC;AAAA,cACpC;AAIA,kBAAI,aAAa,SAAS,UAAU;AAChC,oBAAI,MAAM,MAAM,KAAK,IAAI,UAAU,MAAS;AAC5C,oBAAI;AAAK,uBAAK,MAAM;AACpB,oBAAI,CAAC,KAAK,OAAO,CAAC,KAAK;AAAO,kBAAM,OAAO,OAAO,UAAU,OAAM,MAAM;AAAA,cAC5E,OAGK;AACD,oBAAI,mBAAK,cAAa;AAElB,sBAAI;AAEJ,wBAAM,AAAM,WAAW,UAAU,mBAAK,YAAW;AAEjD,sBAAI,KAAK;AAGL,wBACI,IAAI,WACD,SAAS,SAAS,OAAO;AAC9B,2BAAK,MAAM;AAAA,yBAER;AACD,yCAAK,QAAL,WAAY;AAAA,wBACR,MAAM;AAAA,wBACN,SAAS,SAAS,aAAY;AAAA,wBAC9B,MAAM;AAAA,sBACV;AACA,2BAAK,MAAM,EAAE,SAAS,IAAI;AAAA,oBAC9B;AAEA,gCAAY;AAAA,kBAChB,WACS;AAAO,oBAAM,OAAO,OAAO,UAAU,OAAM,MAAM;AAAA,gBAE9D,OAAO;AACH,qCAAK,QAAL,WAAY;AAAA,oBACR,SAAS;AAAA,oBACT,MAAM;AAAA,kBACV;AAAA,gBACJ;AAAA,cACJ;AAAA,YACJ;AAGA,gBAAI,CAAC;AAAW,0BAAa,QAAS,AAAa,SAAQ,OAAO,KAAK,IAAI,IAAI;AAE/E,gBAAI,OAAO;AACX,gBAAI,KAAK,OAAO;AACZ,qBAAO;AACP,kBAAI,CAAC,KAAK;AAAK,qBAAK,MAAM,CAAC;AAC3B,mBAAK,IAAI,QAAQ,KAAK;AACtB,qBAAO,KAAK;AAAA,YAChB;AAIA,gBAAI,KAAK,OAAO,KAAK,IAAI,OAAO;AAC5B,oBAAM,KAAK,KAAK,KAAK,KAAK;AAAA,gBACtB;AAAA,gBACA,YAAY,QAAQ;AAAA,gBACpB;AAAA,gBACA;AAAA,gBACA,iBAAiB,QAAQ;AAAA,cAC7B,GAAG,QAAW,aAAa,OAAO;AAAA,YACtC;AAAO,0BAAY,KAAK,QAAQ;AAAA,UAEpC;AAGA,mBAAS,OAAO,MAAM;AAElB,gBACI,CAAC,SACE,QAAQ,SACR,KAAK,KAAK;AAEb,oBAAM,WAAW,KAAK,IAAI;AAC1B,kBAAI,CAAC,YAAY,AAAU,GAAG,SAAS,QAAQ,GAAG;AAG9C,oBAAI,KAAK,IAAI,MAAM;AACf,wBAAM,YAAY,OAAO,SAAS;AAC9B,wBAAI;AACA,0BAAI,WAAW,MAAM,AAAa,gBAAe,IAAI;AAGrD,0BAAI,SAAS,WAAW,OAAO,KAAK,QAAQ,EAAE,WAAW;AAAG,mCAAW,SAAS;AAChF,6BAAO;AAAA,oBACX,SAAS,IAAP;AACE,8BAAQ,MAAM,sDAAsD;AACpE,yCAAK,QAAL,WAAY;AAAA,wBACR,SAAS,GAAE;AAAA,wBACX,MAAM;AAAA,sBACV;AAAA,oBACJ;AAAA,kBACJ;AAEA,wBAAM,MAAM,MAAM,UAAU,KAAK,IAAI,IAAI;AACzC,sBAAI,KAAK;AACL,2BAAO,KAAK,IAAI;AAChB,wBAAI,OAAO,QAAQ;AAAU,2BAAK,MAAM,EAAE,SAAS,OAAO,OAAO,KAAK,KAAK,GAAG,EAAE;AAAA;AAC3E,2BAAK,MAAM;AAAA,kBACpB,OAAO;AACH,uCAAK,QAAL,WAAY;AAAA,sBACR,SAAS;AAAA,sBACT,MAAM,KAAK;AAAA,oBACf;AAAA,kBACJ;AAAA,gBACJ,OAGK;AAED,wBAAM,oBAAoB,CAAC,WAAW,YAAY,UAAU;AAC5D,2BAAS,QAAO,KAAK,KAAK;AACtB,wBAAI;AACA,0BAAI,kBAAkB,SAAS,IAAG,KAAK,OAAO,KAAK,IAAI,UAAS;AAAU,6BAAK,IAAI,QAAQ,IAAG,MAAM,IAAI,KAAK,IAAI,QAAO;AAAA,oBAC5H,SAAS,IAAP;AACE,yCAAK,QAAL,WAAY;AAAA,wBACR,SAAS,SAAS;AAAA,wBAClB,MAAM,KAAK,IAAI;AAAA,sBACnB;AAAA,oBACJ;AAAA,kBACJ;AAAA,gBACJ;AAAA,cACJ,OAGK;AACD,wBAAQ,KAAK,cAAc,yEAAyE;AACpG,mCAAK,QAAL,WAAY;AAAA,kBACR,SAAS,gBAAgB;AAAA,kBACzB,MAAM;AAAA,gBACV;AAAA,cACJ;AAAA,YACJ,WAIS,KAAK,MAAM;AAChB,kBAAI,OAAO,KAAK,SAAS,YAAY,CAAC,MAAM,QAAQ,KAAK,IAAI,GAAG;AAC5D,sBAAM,WAAW,OAAO,OAAO,CAAC,GAAG,OAAO;AAC1C,yBAAS,aAAa,QAAQ,WAAW,UAAS;AAClD,sBAAM,KAAK,QAAQ,KAAK,MAAM,MAAM,UAAU,EAAE,OAAO,KAAK,KAAK,GAAG,aAAa,OAAO;AAAA,cAC5F;AAAA,YACJ;AAAA,UACJ;AAAA,QAEJ;AAAA,MACJ;AASA,eAAS,SAAQ,OAAO;AAEpB,cAAM,OAAO,MAAM;AAGnB,YAEI,MAAM,OACN,OAAO,MAAM,QAAQ,UACvB;AAGE,cAAI,KAAK,IAAI;AAAO,kBAAM,KAAK,KAAK,MAAM,MAAM,SAAS,IAAI,gBAAgB,MAAK;AAAA,mBAGzE,OAAO;AAGZ,gBAAI,CAAE,cAAa,KAAK,MAAM;AAC1B,iCAAK,QAAL,WAAY;AAAA,gBACR,SAAS;AAAA,gBACT,MAAM;AAAA,cACV;AAAA,YACJ;AAAA,UAEJ;AAEA,gBAAM,SAAQ,AAAM,MAAM,KAAK,KAAK,MAAM,QAAQ,UAAU;AAG5D,cAAI,MAAM,OAAM,KAAK;AAAO,kBAAM,OAAM,IAAI,QAAQ,KAAK,MAAM,KAAK,UAAU,MAAM,OAAM,KAAK,CAAC;AAAA,QACpG;AAAA,MACJ;AAEA,aAAO;AAAA,IACX;AAIA,gBAAO,OACH,cAAmC,mBAAK,SACxC,UAAmB,mBAAK,WACxB,MAAc,IACd,UAAU,CAAC,GACX,UAAU,MACT;AAGD,UAAI,QAAQ;AAAO,aAAK,QAAQ,EAAC,MAAM,CAAC,GAAG,aAAa,CAAC,EAAC;AAAA;AACrD,aAAK,QAAQ;AAIlB,YAAM,mBAAmB,QAAQ;AACjC,YAAM,kBAAkB,CAAC,mBAAK,UAAS,OAAO,qBAAqB;AAEnE,UAAI,CAAC,mBAAK;AAAQ,2BAAK,QAAS;AAChC,UAAI,CAAC,mBAAK;AAAU,2BAAK,UAAW;AACpC,UAAI,CAAC,mBAAK;AAAa,2BAAK,aAAc,QAAQ;AAElD,UAAI,CAAC,kBAAkB;AACnB,YAAI,CAAC;AAAK,gBAAM,mBAAK;AAGrB,YAAI;AACA,cAAI,IAAI,OAAO,WAAW;AAC1B,kBAAQ,aAAa;AAAA,QACzB,QAAE;AAAA,QAAQ;AAAA,MAEd,WACS,qBAAqB;AAAM,cAAM,mBAAK;AAG/C,UAAI;AAAiB,cAAM,mBAAK,OAAQ;AAExC,YAAM,gBAAgB,OAAO,OAAO,CAAC,GAAG,OAAO;AAE/C,YAAM,gBAAgB,cAAc,SAAS;AAC7C,YAAM,WAAW,OAAO,gBAAgB;AAExC,UAAI,MAAM,QAAQ;AAGlB,UAAI,OAAO,gBAAgB,UAAU;AACjC,iBAAS,OAAO,OAAO,CAAC,GAAG,WAAW;AACtC,YAAI,OAAO,qBAAqB;AAAU,gBAAM,WAAW,AAAa,SAAQ,gBAAgB;AAChG,eAAO;AAAA,MACX,WAAW,OAAQ,UAAW;AAC1B,YAAI,CAAC;AAAK,gBAAM,AAAa,SAAQ,aAAa,QAAQ,cAAc,EAAE;AAC1E,eAAO;AAAA,MACX;AACK,gBAAQ,MAAM,0BAA0B;AAE7C,UAAI,CAAC;AAAkB,2BAAK,OAAQ;AAGpC,aAAO,cAAc,iBAAiB,mBAAK;AAG3C,WAAK,OAAO,KAAK,GAAG,AAAM,MAAM,aAAa,eAAe,MAAM,CAAC;AAMnE,cAAQ;AAAA,aACC;AAGD,cAAI,CAAC,eAAe;AAChB,gBAAI,mBAAK,cAAa;AAClB,oBAAM,UAAU,AAAa,SAAQ,aAAa,GAAG;AACrD,oBAAM,MAAM,AAAM,WAAW,SAAS,mBAAK,YAAW;AACtD,kBAAI;AAAK,yBAAS,OAAO,OAAO,KAAK,WAAW,CAAC,IAAI,MAAM;AAAA,YAE/D;AAAA,UACJ;AAAA;AAGA,cAAI,CAAC,QAAQ;AACT,uBAAW,MAAM,AAAa,SAAQ,GAAG;AACzC,qBAAS,MAAM,KAAK,IAAI,UAAU,MAAS;AAC3C,gBAAI,CAAC,eAAe;AAChB,oBAAM,SAAS,AAAa,SAAQ,aAAa,UAAU,IAAI;AAC/D,oBAAM,MAAM,MAAM,KAAK,IAAI,QAAQ,MAAS;AAC5C,kBAAI;AAAK,yBAAS,OAAO,OAAO,KAAK,MAAM;AAAA,YAC/C;AAAA,UACJ;AAAA;AAGR,UAAI,CAAC;AAAkB,2BAAK,OAAQ;AAAA,eAC3B,mBAAK,WAAU,eAAe,CAAC,mBAAK;AAAO,2BAAK,OAAQ;AAGjE,UAAI,KAAK,OAAM;AACX,YAAI,SAAS,KAAK,MAAM;AACxB,gBAAQ,QAAQ,SAAO,SAAS,OAAO,IAAI;AAC3C,eAAO,YAAY,CAAC;AACpB,gBAAQ,KAAK,QAAQ;AAErB,YAAI,UAAU;AACV,cAAI,CAAC,KAAK,MAAM,YAAY;AAAW,iBAAK,MAAM,YAAY,YAAY,EAAE,cAAc,GAAG,QAAQ,CAAC,GAAG,OAAO,CAAC,EAAE;AACnH,gBAAM,MAAM,KAAK,MAAM;AACvB,cAAI,UAAU;AACd,cAAI,UAAU,OAAO,KAAK,OAAO;AACjC,cAAI,UAAU,MAAM,KAAK,KAAK,IAAI,IAAI,SAAS;AAAA,QACnD;AAAA,MACJ;AAEA,UAAI,KAAK,OAAO,WAAW,GAAG;AAG1B,cAAM,QAAQ,OAAO,MAAM;AAE3B,cAAM,KAAK,QAAQ,OAAO;AAAA,UACtB;AAAA,UACA;AAAA,UACA;AAAA,QACJ,GAAG,eAAe,OAAO,OAAO,SAAS,OAAO;AAIhD,cAAM,QAAQ,CAAC,QAAQ,aAAa;AAChC,gBAAM,SAAQ,OAAO,MAAM;AAC3B,mBAAS,OAAO,QAAO;AACnB,kBAAM,MAAM,SAAS,OAAM,MAAM;AAAA,cAC7B;AAAA,cACA;AAAA,cACA,SAAS;AAAA,YACb,CAAC;AAED,gBAAI;AAAK,qBAAM,OAAO;AAAA,UAC1B;AAAA,QACJ;AAGA,cAAM,cAAc,CAAC,WAAW;AAC5B,gBAAM,QAAQ,CAAC,MAAM,SAAS;AAG1B,kBAAM,QAAQ,KAAK,OAAO,MAAM;AAChC,qBAAS,UAAU,OAAO;AAEtB,oBAAM,YAAY,CAAC,GAAG,QAAQ,EAAE,OAAO,QAAQ,QAAQ,EAAE;AAEzD,kBAAI,YAAY,KAAK,OAAO,MAAM;AAClC,qBAAO,MAAM,GAAG,EAAE,QAAQ,CAAC,QAAQ,YAAY,UAAU,WAAW,GAAG,CAAC;AAExE,kBAAI,CAAC,WAAW;AACZ,mCAAK,QAAL,WAAY;AAAA,kBACR,SAAS,SAAS;AAAA,kBAClB,MAAM;AAAA,gBACV;AAAA,cACJ;AAEA,uBAAS,SAAS,MAAM,SAAS;AAC7B,oBAAI,WAAW;AACf,sBAAM,MAAM,GAAG,EAAE,QAAQ,CAAC,QAAQ,WAAW,UAAU,UAAU,GAAG,CAAC;AACrE,oBAAI,CAAC,UAAU;AACX,qCAAK,QAAL,WAAY;AAAA,oBACR,SAAS,SAAS;AAAA,oBAClB,MAAM;AAAA,kBACV;AAAA,gBACJ;AAAA,cACJ;AAAA,YACJ;AAAA,UAEJ,CAAC;AAAA,QACL;AAGA,YAAI,qBAAqB,QAAW;AAChC,cAAI,cAAc,WAAW,UAAU;AAGnC,iBAAK,SAAS,IAAI,YAAS,QAAQ;AAAA,cAC/B,UAAU,cAAc;AAAA,cACxB,YAAY,cAAc;AAAA,YAC9B,CAAC;AAGD,iBAAK,WAAW,OAAO,OAAO,CAAC,GAAG,KAAK,OAAO,OAAO;AACrD,gBAAI,YAAY,CAAC,WAAW;AACxB,kBAAI,QAAQ,OAAO;AACf,oBAAI,QAAQ,OAAO,OAAO,CAAC,GAAG,OAAO,KAAK;AAC1C,oBAAI,SAAQ,MAAM,QAAQ,OAAO,OAAO,CAAC,GAAG,MAAM,KAAK;AACvD,oBAAI,QAAO;AACP,2BAAS,KAAK,QAAO;AACjB,2BAAM,KAAK,OAAO,OAAO,CAAC,GAAG,OAAM,GAAG,OAAO;AAC7C,8BAAU,OAAM,EAAE;AAAA,kBACtB;AAAA,gBACJ;AACA,uBAAO,QAAQ;AAAA,cACnB;AAAA,YACJ;AACA,sBAAU,KAAK,QAAQ;AAEvB,mBAAO,KAAK;AAAA,UAChB;AAAO,iBAAK,WAAW;AAEvB,sBAAY,MAAM;AAAA,QACtB;AAEA,eAAO;AAAA,MACX;AAAA,IACJ;AAEA,iBAAQ,YAAY;AAChB,UAAI,KAAK;AAAQ,eAAO,MAAM,KAAK,OAAO,MAAM;AAAA,IACpD;AAEA,gBAAO,YAAY;AACf,UAAI,KAAK;AAAQ,eAAO,MAAM,KAAK,OAAO,KAAK;AAAA,IACnD;AApjBI,uBAAK,QAAS;AACd,uBAAK,UAAW;AAChB,uBAAK,MAAO;AAAA,EAChB;AAojBJ;AAplBI;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AA2kBJ,IAAO,eAAQ;",
  "names": []
}
